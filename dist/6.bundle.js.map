{"version":3,"sources":["webpack://POLY/./modules/three/examples/jsm/loaders/obj2/OBJLoader2Parser.js","webpack://POLY/./modules/three/examples/jsm/loaders/obj2/shared/MeshReceiver.js","webpack://POLY/./modules/three/examples/jsm/loaders/obj2/shared/MaterialHandler.js","webpack://POLY/./modules/three/examples/jsm/loaders/OBJLoader2.js"],"names":["OBJLoader2Parser","this","logging","enabled","debug","scope","callbacks","onProgress","text","_onProgress","onAssetAvailable","payload","_onAssetAvailable","onError","errorMessage","_onError","onLoad","object3d","message","_onLoad","contentRef","legacyMode","materials","materialPerSmoothingGroup","useOAsMesh","useIndices","disregardNormals","vertices","colors","normals","uvs","rawMesh","objectName","groupName","activeMtlName","mtllibName","faceType","subGroups","subGroupInUse","smoothingGroup","splitMaterials","normalized","real","counts","doubleIndicesCount","faceCount","mtlCount","smoothingGroupCount","inputObjectCount","outputObjectCount","globalCounts","faces","lineByte","currentByte","totalBytes","prototype","constructor","_resetRawMesh","_pushSmoothingGroup","setMaterialPerSmoothingGroup","setUseOAsMesh","setUseIndices","setDisregardNormals","setMaterials","Object","assign","setCallbackOnAssetAvailable","Function","setCallbackOnProgress","setCallbackOnError","setCallbackOnLoad","console","log","error","setLogging","_configure","matKeys","keys","printedConfig","length","join","name","info","execute","arrayBuffer","time","arrayBufferView","Uint8Array","byteLength","buffer","Array","code","word","bufferPointer","slashesCount","i","_processLine","String","fromCharCode","_finalizeParsing","timeEnd","executeLegacy","char","bufferLength","lineDesignation","reconstructString","content","start","stop","line","trim","push","parseFloat","_checkFaceType","_buildFace","undefined","_processCompletedMesh","mtlName","_checkSubGroup","smoothingGroupInt","parseInt","isNaN","smoothCheck","index","materialName","indexMappingsCount","indexMappings","indices","faceIndexV","faceIndexU","faceIndexN","updateSubGroupInUse","faceIndexVi","indexPointerV","indexPointerC","faceIndexUi","indexPointerU","faceIndexNi","indexPointerN","mappingName","indicesPointer","_createRawMeshReport","_finalizeRawMesh","meshOutputGroup","meshOutputGroupTemp","absoluteVertexCount","absoluteIndexMappingsCount","absoluteIndexCount","absoluteColorCount","absoluteNormalCount","absoluteUvCount","result","haveMesh","_buildMesh","progressBytesPercent","toFixed","meshOutputGroups","vertexFA","Float32Array","selectedMaterialIndex","materialGroup","materialOrg","material","materialNameOrg","indexUA","Uint32Array","colorFA","normalFA","uvFA","haveVertexColors","materialNames","createMultiMaterial","materialIndex","materialIndexMapping","materialGroups","vertexFAOffset","indexUAOffset","colorFAOffset","normalFAOffset","uvFAOffset","materialGroupOffset","materialGroupLength","oodIndex","hasOwnProperty","materialCloneInstructions","materialProperties","vertexColors","flatShading","cmd","type","matCheck","count","set","materialIndexLine","createdReport","progress","numericalValue","params","meshName","multiMaterial","buffers","geometryType","parserFinalReport","MeshReceiver","materialHandler","onMeshAlter","_setCallbacks","buildMeshes","meshPayload","key","bufferGeometry","BufferGeometry","setAttribute","BufferAttribute","setIndex","computeVertexNormals","skinIndex","Uint16Array","skinWeight","multiMaterials","getMaterial","addGroup","mesh","callbackOnMeshAlterResult","meshes","useOrgMesh","detail","isDisregardMesh","providesAlteredMeshes","computeBoundingSphere","Mesh","LineSegments","Points","progressMessage","meshNames","LoadedMeshUserOverride","disregardMesh","alteredMesh","addMesh","MaterialHandler","onLoadMaterials","createDefaultMaterials","overrideExisting","defaultMaterial","MeshStandardMaterial","color","defaultVertexColorMaterial","defaultLineMaterial","LineBasicMaterial","defaultPointMaterial","PointsMaterial","size","runtimeMaterials","addMaterials","addPayloadMaterials","materialPayload","newMaterials","clone","serializedMaterials","materialJson","loader","MaterialLoader","parse","existingMaterial","add","getMaterials","getMaterialsJSON","materialsJSON","toJSON","clearMaterials","OBJLoader2","manager","Loader","call","parser","modelName","instanceNo","baseObject3d","Object3D","meshReceiver","OBJLOADER2_VERSION","create","setModelName","setBaseObject3d","setCallbackOnMeshAlter","setCallbackOnLoadMaterials","load","url","onFileLoadProgress","event","currentTarget","statusText","responseURL","urlFull","URL","window","location","href","filename","urlParts","split","path","slice","numericalValueRef","lengthComputable","loaded","total","output","fileLoader","FileLoader","setPath","resourcePath","setResponseType","ArrayBuffer"],"mappings":"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","file":"6.bundle.js","sourcesContent":["/**\n * @author Kai Salmen / https://kaisalmen.de\n * Development repository: https://github.com/kaisalmen/WWOBJLoader\n */\n\n/**\n * Parse OBJ data either from ArrayBuffer or string\n */\nconst OBJLoader2Parser = function () {\n\n\tthis.logging = {\n\t\tenabled: false,\n\t\tdebug: false\n\t};\n\n\tlet scope = this;\n\tthis.callbacks = {\n\t\tonProgress: function ( text ) {\n\n\t\t\tscope._onProgress( text );\n\n\t\t},\n\t\tonAssetAvailable: function ( payload ) {\n\n\t\t\tscope._onAssetAvailable( payload );\n\n\t\t},\n\t\tonError: function ( errorMessage ) {\n\n\t\t\tscope._onError( errorMessage );\n\n\t\t},\n\t\tonLoad: function ( object3d, message ) {\n\n\t\t\tscope._onLoad( object3d, message );\n\n\t\t},\n\t};\n\tthis.contentRef = null;\n\tthis.legacyMode = false;\n\n\tthis.materials = {};\n\tthis.materialPerSmoothingGroup = false;\n\tthis.useOAsMesh = false;\n\tthis.useIndices = false;\n\tthis.disregardNormals = false;\n\n\tthis.vertices = [];\n\tthis.colors = [];\n\tthis.normals = [];\n\tthis.uvs = [];\n\n\tthis.rawMesh = {\n\t\tobjectName: '',\n\t\tgroupName: '',\n\t\tactiveMtlName: '',\n\t\tmtllibName: '',\n\n\t\t// reset with new mesh\n\t\tfaceType: - 1,\n\t\tsubGroups: [],\n\t\tsubGroupInUse: null,\n\t\tsmoothingGroup: {\n\t\t\tsplitMaterials: false,\n\t\t\tnormalized: - 1,\n\t\t\treal: - 1\n\t\t},\n\t\tcounts: {\n\t\t\tdoubleIndicesCount: 0,\n\t\t\tfaceCount: 0,\n\t\t\tmtlCount: 0,\n\t\t\tsmoothingGroupCount: 0\n\t\t}\n\t};\n\n\tthis.inputObjectCount = 1;\n\tthis.outputObjectCount = 1;\n\tthis.globalCounts = {\n\t\tvertices: 0,\n\t\tfaces: 0,\n\t\tdoubleIndicesCount: 0,\n\t\tlineByte: 0,\n\t\tcurrentByte: 0,\n\t\ttotalBytes: 0\n\t};\n\n};\n\nOBJLoader2Parser.prototype = {\n\n\tconstructor: OBJLoader2Parser,\n\n\t_resetRawMesh: function () {\n\n\t\t// faces are stored according combined index of group, material and smoothingGroup (0 or not)\n\t\tthis.rawMesh.subGroups = [];\n\t\tthis.rawMesh.subGroupInUse = null;\n\t\tthis.rawMesh.smoothingGroup.normalized = - 1;\n\t\tthis.rawMesh.smoothingGroup.real = - 1;\n\n\t\t// this default index is required as it is possible to define faces without 'g' or 'usemtl'\n\t\tthis._pushSmoothingGroup( 1 );\n\n\t\tthis.rawMesh.counts.doubleIndicesCount = 0;\n\t\tthis.rawMesh.counts.faceCount = 0;\n\t\tthis.rawMesh.counts.mtlCount = 0;\n\t\tthis.rawMesh.counts.smoothingGroupCount = 0;\n\n\t},\n\n\t/**\n\t * Tells whether a material shall be created per smoothing group.\n\t *\n\t * @param {boolean} materialPerSmoothingGroup=false\n\t * @return {OBJLoader2Parser}\n\t */\n\tsetMaterialPerSmoothingGroup: function ( materialPerSmoothingGroup ) {\n\n\t\tthis.materialPerSmoothingGroup = materialPerSmoothingGroup === true;\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Usually 'o' is meta-information and does not result in creation of new meshes, but mesh creation on occurrence of \"o\" can be enforced.\n\t *\n\t * @param {boolean} useOAsMesh=false\n\t * @return {OBJLoader2Parser}\n\t */\n\tsetUseOAsMesh: function ( useOAsMesh ) {\n\n\t\tthis.useOAsMesh = useOAsMesh === true;\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Instructs loaders to create indexed {@link BufferGeometry}.\n\t *\n\t * @param {boolean} useIndices=false\n\t * @return {OBJLoader2Parser}\n\t */\n\tsetUseIndices: function ( useIndices ) {\n\n\t\tthis.useIndices = useIndices === true;\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Tells whether normals should be completely disregarded and regenerated.\n\t *\n\t * @param {boolean} disregardNormals=false\n\t * @return {OBJLoader2Parser}\n\t */\n\tsetDisregardNormals: function ( disregardNormals ) {\n\n\t\tthis.disregardNormals = disregardNormals === true;\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Clears materials object and sets the new ones.\n\t *\n\t * @param {Object} materials Object with named materials\n\t */\n\tsetMaterials: function ( materials ) {\n\n \t\tthis.materials = Object.assign( {}, materials );\n\n\t},\n\n\t/**\n\t * Register a function that is called once an asset (mesh/material) becomes available.\n\t *\n\t * @param onAssetAvailable\n\t * @return {OBJLoader2Parser}\n\t */\n\tsetCallbackOnAssetAvailable: function ( onAssetAvailable ) {\n\n\t\tif ( onAssetAvailable !== null && onAssetAvailable !== undefined && onAssetAvailable instanceof Function ) {\n\n\t\t\tthis.callbacks.onAssetAvailable = onAssetAvailable;\n\n\t\t}\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Register a function that is used to report overall processing progress.\n\t *\n\t * @param {Function} onProgress\n\t * @return {OBJLoader2Parser}\n\t */\n\tsetCallbackOnProgress: function ( onProgress ) {\n\n\t\tif ( onProgress !== null && onProgress !== undefined && onProgress instanceof Function ) {\n\n\t\t\tthis.callbacks.onProgress = onProgress;\n\n\t\t}\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Register an error handler function that is called if errors occur. It can decide to just log or to throw an exception.\n\t *\n\t * @param {Function} onError\n\t * @return {OBJLoader2Parser}\n\t */\n\tsetCallbackOnError: function ( onError ) {\n\n\t\tif ( onError !== null && onError !== undefined && onError instanceof Function ) {\n\n\t\t\tthis.callbacks.onError = onError;\n\n\t\t}\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Register a function that is called when parsing was completed.\n\t *\n\t * @param {Function} onLoad\n\t * @return {OBJLoader2Parser}\n\t */\n\tsetCallbackOnLoad: function ( onLoad ) {\n\n\t\tif ( onLoad !== null && onLoad !== undefined && onLoad instanceof Function ) {\n\n\t\t\tthis.callbacks.onLoad = onLoad;\n\n\t\t}\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Announce parse progress feedback which is logged to the console.\n\t * @private\n\t *\n\t * @param {string} text Textual description of the event\n\t */\n\t_onProgress: function ( text ) {\n\n\t\tlet message = text ? text : '';\n\t\tif ( this.logging.enabled && this.logging.debug ) {\n\n\t\t\tconsole.log( message );\n\n\t\t}\n\n\t},\n\n\t/**\n\t * Announce error feedback which is logged as error message.\n\t * @private\n\t *\n\t * @param {String} errorMessage The event containing the error\n\t */\n\t_onError: function ( errorMessage ) {\n\n\t\tif ( this.logging.enabled && this.logging.debug ) {\n\n\t\t\tconsole.error( errorMessage );\n\n\t\t}\n\n\t},\n\n\t_onAssetAvailable: function ( payload ) {\n\n\t\tlet errorMessage = 'OBJLoader2Parser does not provide implementation for onAssetAvailable. Aborting...';\n\t\tthis.callbacks.onError( errorMessage );\n\t\tthrow errorMessage;\n\n\t},\n\n\t_onLoad: function ( object3d, message ) {\n\n\t\tconsole.log( \"You reached parser default onLoad callback: \" + message );\n\n\t},\n\n\t/**\n\t * Enable or disable logging in general (except warn and error), plus enable or disable debug logging.\n\t *\n\t * @param {boolean} enabled True or false.\n\t * @param {boolean} debug True or false.\n\t *\n\t * @return {OBJLoader2Parser}\n\t */\n\tsetLogging: function ( enabled, debug ) {\n\n\t\tthis.logging.enabled = enabled === true;\n\t\tthis.logging.debug = debug === true;\n\t\treturn this;\n\n\t},\n\n\t_configure: function () {\n\n\t\tthis._pushSmoothingGroup( 1 );\n\t\tif ( this.logging.enabled ) {\n\n\t\t\tlet matKeys = Object.keys( this.materials );\n\t\t\tlet matNames = ( matKeys.length > 0 ) ? '\\n\\tmaterialNames:\\n\\t\\t- ' + matKeys.join( '\\n\\t\\t- ' ) : '\\n\\tmaterialNames: None';\n\t\t\tlet printedConfig = 'OBJLoader.Parser configuration:'\n\t\t\t\t+ matNames\n\t\t\t\t+ '\\n\\tmaterialPerSmoothingGroup: ' + this.materialPerSmoothingGroup\n\t\t\t\t+ '\\n\\tuseOAsMesh: ' + this.useOAsMesh\n\t\t\t\t+ '\\n\\tuseIndices: ' + this.useIndices\n\t\t\t\t+ '\\n\\tdisregardNormals: ' + this.disregardNormals;\n\t\t\tprintedConfig += '\\n\\tcallbacks.onProgress: ' + this.callbacks.onProgress.name;\n\t\t\tprintedConfig += '\\n\\tcallbacks.onAssetAvailable: ' + this.callbacks.onAssetAvailable.name;\n\t\t\tprintedConfig += '\\n\\tcallbacks.onError: ' + this.callbacks.onError.name;\n\t\t\tconsole.info( printedConfig );\n\n\t\t}\n\n\t},\n\n\t/**\n\t * Parse the provided arraybuffer\n\t *\n\t * @param {Uint8Array} arrayBuffer OBJ data as Uint8Array\n\t */\n\texecute: function ( arrayBuffer ) {\n\n\t\tif ( this.logging.enabled ) console.time( 'OBJLoader2Parser.execute' );\n\t\tthis._configure();\n\n\t\tlet arrayBufferView = new Uint8Array( arrayBuffer );\n\t\tthis.contentRef = arrayBufferView;\n\t\tlet length = arrayBufferView.byteLength;\n\t\tthis.globalCounts.totalBytes = length;\n\t\tlet buffer = new Array( 128 );\n\n\t\tfor ( let code, word = '', bufferPointer = 0, slashesCount = 0, i = 0; i < length; i ++ ) {\n\n\t\t\tcode = arrayBufferView[ i ];\n\t\t\tswitch ( code ) {\n\n\t\t\t\t// space\n\t\t\t\tcase 32:\n\t\t\t\t\tif ( word.length > 0 ) buffer[ bufferPointer ++ ] = word;\n\t\t\t\t\tword = '';\n\t\t\t\t\tbreak;\n\t\t\t\t// slash\n\t\t\t\tcase 47:\n\t\t\t\t\tif ( word.length > 0 ) buffer[ bufferPointer ++ ] = word;\n\t\t\t\t\tslashesCount ++;\n\t\t\t\t\tword = '';\n\t\t\t\t\tbreak;\n\n\t\t\t\t// LF\n\t\t\t\tcase 10:\n\t\t\t\t\tif ( word.length > 0 ) buffer[ bufferPointer ++ ] = word;\n\t\t\t\t\tword = '';\n\t\t\t\t\tthis.globalCounts.lineByte = this.globalCounts.currentByte;\n\t\t\t\t\tthis.globalCounts.currentByte = i;\n\t\t\t\t\tthis._processLine( buffer, bufferPointer, slashesCount );\n\t\t\t\t\tbufferPointer = 0;\n\t\t\t\t\tslashesCount = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\t// CR\n\t\t\t\tcase 13:\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tword += String.fromCharCode( code );\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\t\tthis._finalizeParsing();\n\t\tif ( this.logging.enabled ) console.timeEnd( 'OBJLoader2Parser.execute' );\n\n\t},\n\n\t/**\n\t * Parse the provided text\n\t *\n\t * @param {string} text OBJ data as string\n\t */\n\texecuteLegacy: function ( text ) {\n\n\t\tif ( this.logging.enabled ) console.time( 'OBJLoader2Parser.executeLegacy' );\n\t\tthis._configure();\n\t\tthis.legacyMode = true;\n\t\tthis.contentRef = text;\n\t\tlet length = text.length;\n\t\tthis.globalCounts.totalBytes = length;\n\t\tlet buffer = new Array( 128 );\n\n\t\tfor ( let char, word = '', bufferPointer = 0, slashesCount = 0, i = 0; i < length; i ++ ) {\n\n\t\t\tchar = text[ i ];\n\t\t\tswitch ( char ) {\n\n\t\t\t\tcase ' ':\n\t\t\t\t\tif ( word.length > 0 ) buffer[ bufferPointer ++ ] = word;\n\t\t\t\t\tword = '';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase '/':\n\t\t\t\t\tif ( word.length > 0 ) buffer[ bufferPointer ++ ] = word;\n\t\t\t\t\tslashesCount ++;\n\t\t\t\t\tword = '';\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase '\\n':\n\t\t\t\t\tif ( word.length > 0 ) buffer[ bufferPointer ++ ] = word;\n\t\t\t\t\tword = '';\n\t\t\t\t\tthis.globalCounts.lineByte = this.globalCounts.currentByte;\n\t\t\t\t\tthis.globalCounts.currentByte = i;\n\t\t\t\t\tthis._processLine( buffer, bufferPointer, slashesCount );\n\t\t\t\t\tbufferPointer = 0;\n\t\t\t\t\tslashesCount = 0;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase '\\r':\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tword += char;\n\n\t\t\t}\n\n\t\t}\n\t\tthis._finalizeParsing();\n\t\tif ( this.logging.enabled ) console.timeEnd( 'OBJLoader2Parser.executeLegacy' );\n\n\t},\n\n\t_processLine: function ( buffer, bufferPointer, slashesCount ) {\n\n\t\tif ( bufferPointer < 1 ) return;\n\n\t\tlet reconstructString = function ( content, legacyMode, start, stop ) {\n\n\t\t\tlet line = '';\n\t\t\tif ( stop > start ) {\n\n\t\t\t\tlet i;\n\t\t\t\tif ( legacyMode ) {\n\n\t\t\t\t\tfor ( i = start; i < stop; i ++ ) line += content[ i ];\n\n\t\t\t\t} else {\n\n\n\t\t\t\t\tfor ( i = start; i < stop; i ++ ) line += String.fromCharCode( content[ i ] );\n\n\t\t\t\t}\n\t\t\t\tline = line.trim();\n\n\t\t\t}\n\t\t\treturn line;\n\n\t\t};\n\n\t\tlet bufferLength, length, i, lineDesignation;\n\t\tlineDesignation = buffer[ 0 ];\n\t\tswitch ( lineDesignation ) {\n\n\t\t\tcase 'v':\n\t\t\t\tthis.vertices.push( parseFloat( buffer[ 1 ] ) );\n\t\t\t\tthis.vertices.push( parseFloat( buffer[ 2 ] ) );\n\t\t\t\tthis.vertices.push( parseFloat( buffer[ 3 ] ) );\n\t\t\t\tif ( bufferPointer > 4 ) {\n\n\t\t\t\t\tthis.colors.push( parseFloat( buffer[ 4 ] ) );\n\t\t\t\t\tthis.colors.push( parseFloat( buffer[ 5 ] ) );\n\t\t\t\t\tthis.colors.push( parseFloat( buffer[ 6 ] ) );\n\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'vt':\n\t\t\t\tthis.uvs.push( parseFloat( buffer[ 1 ] ) );\n\t\t\t\tthis.uvs.push( parseFloat( buffer[ 2 ] ) );\n\t\t\t\tbreak;\n\n\t\t\tcase 'vn':\n\t\t\t\tthis.normals.push( parseFloat( buffer[ 1 ] ) );\n\t\t\t\tthis.normals.push( parseFloat( buffer[ 2 ] ) );\n\t\t\t\tthis.normals.push( parseFloat( buffer[ 3 ] ) );\n\t\t\t\tbreak;\n\n\t\t\tcase 'f':\n\t\t\t\tbufferLength = bufferPointer - 1;\n\n\t\t\t\t// \"f vertex ...\"\n\t\t\t\tif ( slashesCount === 0 ) {\n\n\t\t\t\t\tthis._checkFaceType( 0 );\n\t\t\t\t\tfor ( i = 2, length = bufferLength; i < length; i ++ ) {\n\n\t\t\t\t\t\tthis._buildFace( buffer[ 1 ] );\n\t\t\t\t\t\tthis._buildFace( buffer[ i ] );\n\t\t\t\t\t\tthis._buildFace( buffer[ i + 1 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// \"f vertex/uv ...\"\n\n\t\t\t\t} else if ( bufferLength === slashesCount * 2 ) {\n\n\t\t\t\t\tthis._checkFaceType( 1 );\n\t\t\t\t\tfor ( i = 3, length = bufferLength - 2; i < length; i += 2 ) {\n\n\t\t\t\t\t\tthis._buildFace( buffer[ 1 ], buffer[ 2 ] );\n\t\t\t\t\t\tthis._buildFace( buffer[ i ], buffer[ i + 1 ] );\n\t\t\t\t\t\tthis._buildFace( buffer[ i + 2 ], buffer[ i + 3 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// \"f vertex/uv/normal ...\"\n\n\t\t\t\t} else if ( bufferLength * 2 === slashesCount * 3 ) {\n\n\t\t\t\t\tthis._checkFaceType( 2 );\n\t\t\t\t\tfor ( i = 4, length = bufferLength - 3; i < length; i += 3 ) {\n\n\t\t\t\t\t\tthis._buildFace( buffer[ 1 ], buffer[ 2 ], buffer[ 3 ] );\n\t\t\t\t\t\tthis._buildFace( buffer[ i ], buffer[ i + 1 ], buffer[ i + 2 ] );\n\t\t\t\t\t\tthis._buildFace( buffer[ i + 3 ], buffer[ i + 4 ], buffer[ i + 5 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// \"f vertex//normal ...\"\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._checkFaceType( 3 );\n\t\t\t\t\tfor ( i = 3, length = bufferLength - 2; i < length; i += 2 ) {\n\n\t\t\t\t\t\tthis._buildFace( buffer[ 1 ], undefined, buffer[ 2 ] );\n\t\t\t\t\t\tthis._buildFace( buffer[ i ], undefined, buffer[ i + 1 ] );\n\t\t\t\t\t\tthis._buildFace( buffer[ i + 2 ], undefined, buffer[ i + 3 ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 'l':\n\t\t\tcase 'p':\n\t\t\t\tbufferLength = bufferPointer - 1;\n\t\t\t\tif ( bufferLength === slashesCount * 2 ) {\n\n\t\t\t\t\tthis._checkFaceType( 4 );\n\t\t\t\t\tfor ( i = 1, length = bufferLength + 1; i < length; i += 2 ) this._buildFace( buffer[ i ], buffer[ i + 1 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthis._checkFaceType( ( lineDesignation === 'l' ) ? 5 : 6 );\n\t\t\t\t\tfor ( i = 1, length = bufferLength + 1; i < length; i ++ ) this._buildFace( buffer[ i ] );\n\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tcase 's':\n\t\t\t\tthis._pushSmoothingGroup( buffer[ 1 ] );\n\t\t\t\tbreak;\n\n\t\t\tcase 'g':\n\t\t\t\t// 'g' leads to creation of mesh if valid data (faces declaration was done before), otherwise only groupName gets set\n\t\t\t\tthis._processCompletedMesh();\n\t\t\t\tthis.rawMesh.groupName = reconstructString( this.contentRef, this.legacyMode, this.globalCounts.lineByte + 2, this.globalCounts.currentByte );\n\t\t\t\tbreak;\n\n\t\t\tcase 'o':\n\t\t\t\t// 'o' is meta-information and usually does not result in creation of new meshes, but can be enforced with \"useOAsMesh\"\n\t\t\t\tif ( this.useOAsMesh ) this._processCompletedMesh();\n\t\t\t\tthis.rawMesh.objectName = reconstructString( this.contentRef, this.legacyMode, this.globalCounts.lineByte + 2, this.globalCounts.currentByte );\n\t\t\t\tbreak;\n\n\t\t\tcase 'mtllib':\n\t\t\t\tthis.rawMesh.mtllibName = reconstructString( this.contentRef, this.legacyMode, this.globalCounts.lineByte + 7, this.globalCounts.currentByte );\n\t\t\t\tbreak;\n\n\t\t\tcase 'usemtl':\n\t\t\t\tlet mtlName = reconstructString( this.contentRef, this.legacyMode, this.globalCounts.lineByte + 7, this.globalCounts.currentByte );\n\t\t\t\tif ( mtlName !== '' && this.rawMesh.activeMtlName !== mtlName ) {\n\n\t\t\t\t\tthis.rawMesh.activeMtlName = mtlName;\n\t\t\t\t\tthis.rawMesh.counts.mtlCount ++;\n\t\t\t\t\tthis._checkSubGroup();\n\n\t\t\t\t}\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tbreak;\n\n\t\t}\n\n\t},\n\n\t_pushSmoothingGroup: function ( smoothingGroup ) {\n\n\t\tlet smoothingGroupInt = parseInt( smoothingGroup );\n\t\tif ( isNaN( smoothingGroupInt ) ) {\n\n\t\t\tsmoothingGroupInt = smoothingGroup === \"off\" ? 0 : 1;\n\n\t\t}\n\n\t\tlet smoothCheck = this.rawMesh.smoothingGroup.normalized;\n\t\tthis.rawMesh.smoothingGroup.normalized = this.rawMesh.smoothingGroup.splitMaterials ? smoothingGroupInt : ( smoothingGroupInt === 0 ) ? 0 : 1;\n\t\tthis.rawMesh.smoothingGroup.real = smoothingGroupInt;\n\n\t\tif ( smoothCheck !== smoothingGroupInt ) {\n\n\t\t\tthis.rawMesh.counts.smoothingGroupCount ++;\n\t\t\tthis._checkSubGroup();\n\n\t\t}\n\n\t},\n\n\t/**\n\t * Expanded faceTypes include all four face types, both line types and the point type\n\t * faceType = 0: \"f vertex ...\"\n\t * faceType = 1: \"f vertex/uv ...\"\n\t * faceType = 2: \"f vertex/uv/normal ...\"\n\t * faceType = 3: \"f vertex//normal ...\"\n\t * faceType = 4: \"l vertex/uv ...\" or \"l vertex ...\"\n\t * faceType = 5: \"l vertex ...\"\n\t * faceType = 6: \"p vertex ...\"\n\t */\n\t_checkFaceType: function ( faceType ) {\n\n\t\tif ( this.rawMesh.faceType !== faceType ) {\n\n\t\t\tthis._processCompletedMesh();\n\t\t\tthis.rawMesh.faceType = faceType;\n\t\t\tthis._checkSubGroup();\n\n\t\t}\n\n\t},\n\n\t_checkSubGroup: function () {\n\n\t\tlet index = this.rawMesh.activeMtlName + '|' + this.rawMesh.smoothingGroup.normalized;\n\t\tthis.rawMesh.subGroupInUse = this.rawMesh.subGroups[ index ];\n\n\t\tif ( this.rawMesh.subGroupInUse === undefined || this.rawMesh.subGroupInUse === null ) {\n\n\t\t\tthis.rawMesh.subGroupInUse = {\n\t\t\t\tindex: index,\n\t\t\t\tobjectName: this.rawMesh.objectName,\n\t\t\t\tgroupName: this.rawMesh.groupName,\n\t\t\t\tmaterialName: this.rawMesh.activeMtlName,\n\t\t\t\tsmoothingGroup: this.rawMesh.smoothingGroup.normalized,\n\t\t\t\tvertices: [],\n\t\t\t\tindexMappingsCount: 0,\n\t\t\t\tindexMappings: [],\n\t\t\t\tindices: [],\n\t\t\t\tcolors: [],\n\t\t\t\tuvs: [],\n\t\t\t\tnormals: []\n\t\t\t};\n\t\t\tthis.rawMesh.subGroups[ index ] = this.rawMesh.subGroupInUse;\n\n\t\t}\n\n\t},\n\n\t_buildFace: function ( faceIndexV, faceIndexU, faceIndexN ) {\n\n\t\tlet subGroupInUse = this.rawMesh.subGroupInUse;\n\t\tlet scope = this;\n\t\tlet updateSubGroupInUse = function () {\n\n\t\t\tlet faceIndexVi = parseInt( faceIndexV );\n\t\t\tlet indexPointerV = 3 * ( faceIndexVi > 0 ? faceIndexVi - 1 : faceIndexVi + scope.vertices.length / 3 );\n\t\t\tlet indexPointerC = scope.colors.length > 0 ? indexPointerV : null;\n\n\t\t\tlet vertices = subGroupInUse.vertices;\n\t\t\tvertices.push( scope.vertices[ indexPointerV ++ ] );\n\t\t\tvertices.push( scope.vertices[ indexPointerV ++ ] );\n\t\t\tvertices.push( scope.vertices[ indexPointerV ] );\n\n\t\t\tif ( indexPointerC !== null ) {\n\n\t\t\t\tlet colors = subGroupInUse.colors;\n\t\t\t\tcolors.push( scope.colors[ indexPointerC ++ ] );\n\t\t\t\tcolors.push( scope.colors[ indexPointerC ++ ] );\n\t\t\t\tcolors.push( scope.colors[ indexPointerC ] );\n\n\t\t\t}\n\t\t\tif ( faceIndexU ) {\n\n\t\t\t\tlet faceIndexUi = parseInt( faceIndexU );\n\t\t\t\tlet indexPointerU = 2 * ( faceIndexUi > 0 ? faceIndexUi - 1 : faceIndexUi + scope.uvs.length / 2 );\n\t\t\t\tlet uvs = subGroupInUse.uvs;\n\t\t\t\tuvs.push( scope.uvs[ indexPointerU ++ ] );\n\t\t\t\tuvs.push( scope.uvs[ indexPointerU ] );\n\n\t\t\t}\n\t\t\tif ( faceIndexN && ! scope.disregardNormals ) {\n\n\t\t\t\tlet faceIndexNi = parseInt( faceIndexN );\n\t\t\t\tlet indexPointerN = 3 * ( faceIndexNi > 0 ? faceIndexNi - 1 : faceIndexNi + scope.normals.length / 3 );\n\t\t\t\tlet normals = subGroupInUse.normals;\n\t\t\t\tnormals.push( scope.normals[ indexPointerN ++ ] );\n\t\t\t\tnormals.push( scope.normals[ indexPointerN ++ ] );\n\t\t\t\tnormals.push( scope.normals[ indexPointerN ] );\n\n\t\t\t}\n\n\t\t};\n\n\t\tif ( this.useIndices ) {\n\n\t\t\tif ( this.disregardNormals ) faceIndexN = undefined;\n\t\t\tlet mappingName = faceIndexV + ( faceIndexU ? '_' + faceIndexU : '_n' ) + ( faceIndexN ? '_' + faceIndexN : '_n' );\n\t\t\tlet indicesPointer = subGroupInUse.indexMappings[ mappingName ];\n\t\t\tif ( indicesPointer === undefined || indicesPointer === null ) {\n\n\t\t\t\tindicesPointer = this.rawMesh.subGroupInUse.vertices.length / 3;\n\t\t\t\tupdateSubGroupInUse();\n\t\t\t\tsubGroupInUse.indexMappings[ mappingName ] = indicesPointer;\n\t\t\t\tsubGroupInUse.indexMappingsCount ++;\n\n\t\t\t} else {\n\n\t\t\t\tthis.rawMesh.counts.doubleIndicesCount ++;\n\n\t\t\t}\n\t\t\tsubGroupInUse.indices.push( indicesPointer );\n\n\t\t} else {\n\n\t\t\tupdateSubGroupInUse();\n\n\t\t}\n\t\tthis.rawMesh.counts.faceCount ++;\n\n\t},\n\n\t_createRawMeshReport: function ( inputObjectCount ) {\n\n\t\treturn 'Input Object number: ' + inputObjectCount +\n\t\t\t'\\n\\tObject name: ' + this.rawMesh.objectName +\n\t\t\t'\\n\\tGroup name: ' + this.rawMesh.groupName +\n\t\t\t'\\n\\tMtllib name: ' + this.rawMesh.mtllibName +\n\t\t\t'\\n\\tVertex count: ' + this.vertices.length / 3 +\n\t\t\t'\\n\\tNormal count: ' + this.normals.length / 3 +\n\t\t\t'\\n\\tUV count: ' + this.uvs.length / 2 +\n\t\t\t'\\n\\tSmoothingGroup count: ' + this.rawMesh.counts.smoothingGroupCount +\n\t\t\t'\\n\\tMaterial count: ' + this.rawMesh.counts.mtlCount +\n\t\t\t'\\n\\tReal MeshOutputGroup count: ' + this.rawMesh.subGroups.length;\n\n\t},\n\n\t/**\n\t * Clear any empty subGroup and calculate absolute vertex, normal and uv counts\n\t */\n\t_finalizeRawMesh: function () {\n\n\t\tlet meshOutputGroupTemp = [];\n\t\tlet meshOutputGroup;\n\t\tlet absoluteVertexCount = 0;\n\t\tlet absoluteIndexMappingsCount = 0;\n\t\tlet absoluteIndexCount = 0;\n\t\tlet absoluteColorCount = 0;\n\t\tlet absoluteNormalCount = 0;\n\t\tlet absoluteUvCount = 0;\n\t\tlet indices;\n\t\tfor ( let name in this.rawMesh.subGroups ) {\n\n\t\t\tmeshOutputGroup = this.rawMesh.subGroups[ name ];\n\t\t\tif ( meshOutputGroup.vertices.length > 0 ) {\n\n\t\t\t\tindices = meshOutputGroup.indices;\n\t\t\t\tif ( indices.length > 0 && absoluteIndexMappingsCount > 0 ) {\n\n\t\t\t\t\tfor ( let i = 0; i < indices.length; i ++ ) {\n\n\t\t\t\t\t\tindices[ i ] = indices[ i ] + absoluteIndexMappingsCount;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tmeshOutputGroupTemp.push( meshOutputGroup );\n\t\t\t\tabsoluteVertexCount += meshOutputGroup.vertices.length;\n\t\t\t\tabsoluteIndexMappingsCount += meshOutputGroup.indexMappingsCount;\n\t\t\t\tabsoluteIndexCount += meshOutputGroup.indices.length;\n\t\t\t\tabsoluteColorCount += meshOutputGroup.colors.length;\n\t\t\t\tabsoluteUvCount += meshOutputGroup.uvs.length;\n\t\t\t\tabsoluteNormalCount += meshOutputGroup.normals.length;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// do not continue if no result\n\t\tlet result = null;\n\t\tif ( meshOutputGroupTemp.length > 0 ) {\n\n\t\t\tresult = {\n\t\t\t\tname: this.rawMesh.groupName !== '' ? this.rawMesh.groupName : this.rawMesh.objectName,\n\t\t\t\tsubGroups: meshOutputGroupTemp,\n\t\t\t\tabsoluteVertexCount: absoluteVertexCount,\n\t\t\t\tabsoluteIndexCount: absoluteIndexCount,\n\t\t\t\tabsoluteColorCount: absoluteColorCount,\n\t\t\t\tabsoluteNormalCount: absoluteNormalCount,\n\t\t\t\tabsoluteUvCount: absoluteUvCount,\n\t\t\t\tfaceCount: this.rawMesh.counts.faceCount,\n\t\t\t\tdoubleIndicesCount: this.rawMesh.counts.doubleIndicesCount\n\t\t\t};\n\n\t\t}\n\t\treturn result;\n\n\t},\n\n\t_processCompletedMesh: function () {\n\n\t\tlet result = this._finalizeRawMesh();\n\t\tlet haveMesh = result !== null;\n\t\tif ( haveMesh ) {\n\n\t\t\tif ( this.colors.length > 0 && this.colors.length !== this.vertices.length ) {\n\n\t\t\t\tthis.callbacks.onError( 'Vertex Colors were detected, but vertex count and color count do not match!' );\n\n\t\t\t}\n\t\t\tif ( this.logging.enabled && this.logging.debug ) console.debug( this._createRawMeshReport( this.inputObjectCount ) );\n\t\t\tthis.inputObjectCount ++;\n\n\t\t\tthis._buildMesh( result );\n\t\t\tlet progressBytesPercent = this.globalCounts.currentByte / this.globalCounts.totalBytes;\n\t\t\tthis._onProgress( 'Completed [o: ' + this.rawMesh.objectName + ' g:' + this.rawMesh.groupName + '' +\n\t\t\t\t'] Total progress: ' + ( progressBytesPercent * 100 ).toFixed( 2 ) + '%' );\n\t\t\tthis._resetRawMesh();\n\n\t\t}\n\t\treturn haveMesh;\n\n\t},\n\n\t/**\n\t * SubGroups are transformed to too intermediate format that is forwarded to the MeshReceiver.\n\t * It is ensured that SubGroups only contain objects with vertices (no need to check).\n\t *\n\t * @param result\n\t */\n\t_buildMesh: function ( result ) {\n\n\t\tlet meshOutputGroups = result.subGroups;\n\n\t\tlet vertexFA = new Float32Array( result.absoluteVertexCount );\n\t\tthis.globalCounts.vertices += result.absoluteVertexCount / 3;\n\t\tthis.globalCounts.faces += result.faceCount;\n\t\tthis.globalCounts.doubleIndicesCount += result.doubleIndicesCount;\n\t\tlet indexUA = ( result.absoluteIndexCount > 0 ) ? new Uint32Array( result.absoluteIndexCount ) : null;\n\t\tlet colorFA = ( result.absoluteColorCount > 0 ) ? new Float32Array( result.absoluteColorCount ) : null;\n\t\tlet normalFA = ( result.absoluteNormalCount > 0 ) ? new Float32Array( result.absoluteNormalCount ) : null;\n\t\tlet uvFA = ( result.absoluteUvCount > 0 ) ? new Float32Array( result.absoluteUvCount ) : null;\n\t\tlet haveVertexColors = colorFA !== null;\n\n\t\tlet meshOutputGroup;\n\t\tlet materialNames = [];\n\n\t\tlet createMultiMaterial = ( meshOutputGroups.length > 1 );\n\t\tlet materialIndex = 0;\n\t\tlet materialIndexMapping = [];\n\t\tlet selectedMaterialIndex;\n\t\tlet materialGroup;\n\t\tlet materialGroups = [];\n\n\t\tlet vertexFAOffset = 0;\n\t\tlet indexUAOffset = 0;\n\t\tlet colorFAOffset = 0;\n\t\tlet normalFAOffset = 0;\n\t\tlet uvFAOffset = 0;\n\t\tlet materialGroupOffset = 0;\n\t\tlet materialGroupLength = 0;\n\n\t\tlet materialOrg, material, materialName, materialNameOrg;\n\t\t// only one specific face type\n\t\tfor ( let oodIndex in meshOutputGroups ) {\n\n\t\t\tif ( ! meshOutputGroups.hasOwnProperty( oodIndex ) ) continue;\n\t\t\tmeshOutputGroup = meshOutputGroups[ oodIndex ];\n\n\t\t\tmaterialNameOrg = meshOutputGroup.materialName;\n\t\t\tif ( this.rawMesh.faceType < 4 ) {\n\n\t\t\t\tmaterialName = materialNameOrg + ( haveVertexColors ? '_vertexColor' : '' ) + ( meshOutputGroup.smoothingGroup === 0 ? '_flat' : '' );\n\n\n\t\t\t} else {\n\n\t\t\t\tmaterialName = this.rawMesh.faceType === 6 ? 'defaultPointMaterial' : 'defaultLineMaterial';\n\n\t\t\t}\n\t\t\tmaterialOrg = this.materials[ materialNameOrg ];\n\t\t\tmaterial = this.materials[ materialName ];\n\n\t\t\t// both original and derived names do not lead to an existing material => need to use a default material\n\t\t\tif ( ( materialOrg === undefined || materialOrg === null ) && ( material === undefined || material === null ) ) {\n\n\t\t\t\tmaterialName = haveVertexColors ? 'defaultVertexColorMaterial' : 'defaultMaterial';\n\t\t\t\tmaterial = this.materials[ materialName ];\n\t\t\t\tif ( this.logging.enabled ) {\n\n\t\t\t\t\tconsole.info( 'object_group \"' + meshOutputGroup.objectName + '_' +\n\t\t\t\t\t\tmeshOutputGroup.groupName + '\" was defined with unresolvable material \"' +\n\t\t\t\t\t\tmaterialNameOrg + '\"! Assigning \"' + materialName + '\".' );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tif ( material === undefined || material === null ) {\n\n\t\t\t\tlet materialCloneInstructions = {\n\t\t\t\t\tmaterialNameOrg: materialNameOrg,\n\t\t\t\t\tmaterialName: materialName,\n\t\t\t\t\tmaterialProperties: {\n\t\t\t\t\t\tvertexColors: haveVertexColors ? 2 : 0,\n\t\t\t\t\t\tflatShading: meshOutputGroup.smoothingGroup === 0\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tlet payload = {\n\t\t\t\t\tcmd: 'assetAvailable',\n\t\t\t\t\ttype: 'material',\n\t\t\t\t\tmaterials: {\n\t\t\t\t\t\tmaterialCloneInstructions: materialCloneInstructions\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\tthis.callbacks.onAssetAvailable( payload );\n\n\t\t\t\t// only set materials if they don't exist, yet\n\t\t\t\tlet matCheck = this.materials[ materialName ];\n\t\t\t\tif ( matCheck === undefined || matCheck === null ) {\n\n\t\t\t\t\tthis.materials[ materialName ] = materialCloneInstructions;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( createMultiMaterial ) {\n\n\t\t\t\t// re-use material if already used before. Reduces materials array size and eliminates duplicates\n\t\t\t\tselectedMaterialIndex = materialIndexMapping[ materialName ];\n\t\t\t\tif ( ! selectedMaterialIndex ) {\n\n\t\t\t\t\tselectedMaterialIndex = materialIndex;\n\t\t\t\t\tmaterialIndexMapping[ materialName ] = materialIndex;\n\t\t\t\t\tmaterialNames.push( materialName );\n\t\t\t\t\tmaterialIndex ++;\n\n\t\t\t\t}\n\t\t\t\tmaterialGroupLength = this.useIndices ? meshOutputGroup.indices.length : meshOutputGroup.vertices.length / 3;\n\t\t\t\tmaterialGroup = {\n\t\t\t\t\tstart: materialGroupOffset,\n\t\t\t\t\tcount: materialGroupLength,\n\t\t\t\t\tindex: selectedMaterialIndex\n\t\t\t\t};\n\t\t\t\tmaterialGroups.push( materialGroup );\n\t\t\t\tmaterialGroupOffset += materialGroupLength;\n\n\t\t\t} else {\n\n\t\t\t\tmaterialNames.push( materialName );\n\n\t\t\t}\n\n\t\t\tvertexFA.set( meshOutputGroup.vertices, vertexFAOffset );\n\t\t\tvertexFAOffset += meshOutputGroup.vertices.length;\n\n\t\t\tif ( indexUA ) {\n\n\t\t\t\tindexUA.set( meshOutputGroup.indices, indexUAOffset );\n\t\t\t\tindexUAOffset += meshOutputGroup.indices.length;\n\n\t\t\t}\n\n\t\t\tif ( colorFA ) {\n\n\t\t\t\tcolorFA.set( meshOutputGroup.colors, colorFAOffset );\n\t\t\t\tcolorFAOffset += meshOutputGroup.colors.length;\n\n\t\t\t}\n\n\t\t\tif ( normalFA ) {\n\n\t\t\t\tnormalFA.set( meshOutputGroup.normals, normalFAOffset );\n\t\t\t\tnormalFAOffset += meshOutputGroup.normals.length;\n\n\t\t\t}\n\t\t\tif ( uvFA ) {\n\n\t\t\t\tuvFA.set( meshOutputGroup.uvs, uvFAOffset );\n\t\t\t\tuvFAOffset += meshOutputGroup.uvs.length;\n\n\t\t\t}\n\n\t\t\tif ( this.logging.enabled && this.logging.debug ) {\n\n\t\t\t\tlet materialIndexLine = ( selectedMaterialIndex === undefined || selectedMaterialIndex === null ) ? '' : '\\n\\t\\tmaterialIndex: ' + selectedMaterialIndex;\n\t\t\t\tlet createdReport = '\\tOutput Object no.: ' + this.outputObjectCount +\n\t\t\t\t\t'\\n\\t\\tgroupName: ' + meshOutputGroup.groupName +\n\t\t\t\t\t'\\n\\t\\tIndex: ' + meshOutputGroup.index +\n\t\t\t\t\t'\\n\\t\\tfaceType: ' + this.rawMesh.faceType +\n\t\t\t\t\t'\\n\\t\\tmaterialName: ' + meshOutputGroup.materialName +\n\t\t\t\t\t'\\n\\t\\tsmoothingGroup: ' + meshOutputGroup.smoothingGroup +\n\t\t\t\t\tmaterialIndexLine +\n\t\t\t\t\t'\\n\\t\\tobjectName: ' + meshOutputGroup.objectName +\n\t\t\t\t\t'\\n\\t\\t#vertices: ' + meshOutputGroup.vertices.length / 3 +\n\t\t\t\t\t'\\n\\t\\t#indices: ' + meshOutputGroup.indices.length +\n\t\t\t\t\t'\\n\\t\\t#colors: ' + meshOutputGroup.colors.length / 3 +\n\t\t\t\t\t'\\n\\t\\t#uvs: ' + meshOutputGroup.uvs.length / 2 +\n\t\t\t\t\t'\\n\\t\\t#normals: ' + meshOutputGroup.normals.length / 3;\n\t\t\t\tconsole.debug( createdReport );\n\n\t\t\t}\n\n\t\t}\n\t\tthis.outputObjectCount ++;\n\t\tthis.callbacks.onAssetAvailable(\n\t\t\t{\n\t\t\t\tcmd: 'assetAvailable',\n\t\t\t\ttype: 'mesh',\n\t\t\t\tprogress: {\n\t\t\t\t\tnumericalValue: this.globalCounts.currentByte / this.globalCounts.totalBytes\n\t\t\t\t},\n\t\t\t\tparams: {\n\t\t\t\t\tmeshName: result.name\n\t\t\t\t},\n\t\t\t\tmaterials: {\n\t\t\t\t\tmultiMaterial: createMultiMaterial,\n\t\t\t\t\tmaterialNames: materialNames,\n\t\t\t\t\tmaterialGroups: materialGroups\n\t\t\t\t},\n\t\t\t\tbuffers: {\n\t\t\t\t\tvertices: vertexFA,\n\t\t\t\t\tindices: indexUA,\n\t\t\t\t\tcolors: colorFA,\n\t\t\t\t\tnormals: normalFA,\n\t\t\t\t\tuvs: uvFA\n\t\t\t\t},\n\t\t\t\t// 0: mesh, 1: line, 2: point\n\t\t\t\tgeometryType: this.rawMesh.faceType < 4 ? 0 : ( this.rawMesh.faceType === 6 ) ? 2 : 1\n\t\t\t},\n\t\t\t[ vertexFA.buffer ],\n\t\t\tindexUA !== null ? [ indexUA.buffer ] : null,\n\t\t\tcolorFA !== null ? [ colorFA.buffer ] : null,\n\t\t\tnormalFA !== null ? [ normalFA.buffer ] : null,\n\t\t\tuvFA !== null ? [ uvFA.buffer ] : null\n\t\t);\n\n\t},\n\n\t_finalizeParsing: function () {\n\n\t\tif ( this.logging.enabled ) console.info( 'Global output object count: ' + this.outputObjectCount );\n\t\tif ( this._processCompletedMesh() && this.logging.enabled ) {\n\n\t\t\tlet parserFinalReport = 'Overall counts: ' +\n\t\t\t\t'\\n\\tVertices: ' + this.globalCounts.vertices +\n\t\t\t\t'\\n\\tFaces: ' + this.globalCounts.faces +\n\t\t\t\t'\\n\\tMultiple definitions: ' + this.globalCounts.doubleIndicesCount;\n\t\t\tconsole.info( parserFinalReport );\n\n\t\t}\n\n\t}\n};\n\nexport { OBJLoader2Parser };\n","import {BufferAttribute} from 'three/src/core/BufferAttribute';\nimport {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {LineSegments} from 'three/src/objects/LineSegments';\nimport {Mesh} from 'three/src/objects/Mesh';\nimport {Points} from 'three/src/objects/Points';\n/**\n * @author Kai Salmen / https://kaisalmen.de\n * Development repository: https://github.com/kaisalmen/WWOBJLoader\n */\n\n\n\n/**\n *\n * @param {MaterialHandler} materialHandler\n * @constructor\n */\nconst MeshReceiver = function ( materialHandler ) {\n\n\tthis.logging = {\n\t\tenabled: false,\n\t\tdebug: false\n\t};\n\n\tthis.callbacks = {\n\t\tonProgress: null,\n\t\tonMeshAlter: null\n\t};\n\tthis.materialHandler = materialHandler;\n\n};\n\nMeshReceiver.prototype = {\n\n\tconstructor: MeshReceiver,\n\n\t/**\n\t * Enable or disable logging in general (except warn and error), plus enable or disable debug logging.\n\t *\n\t * @param {boolean} enabled True or false.\n\t * @param {boolean} debug True or false.\n\t */\n\tsetLogging:\tfunction ( enabled, debug ) {\n\n\t\tthis.logging.enabled = enabled === true;\n\t\tthis.logging.debug = debug === true;\n\n\t},\n\n\t/**\n\t *\n\t * @param {Function} onProgress\n\t * @param {Function} onMeshAlter\n\t * @private\n\t */\n\t_setCallbacks: function ( onProgress, onMeshAlter ) {\n\n\t\tif ( onProgress !== null && onProgress !== undefined && onProgress instanceof Function ) {\n\n\t\t\tthis.callbacks.onProgress = onProgress;\n\n\t\t}\n\t\tif ( onMeshAlter !== null && onMeshAlter !== undefined && onMeshAlter instanceof Function ) {\n\n\t\t\tthis.callbacks.onMeshAlter = onMeshAlter;\n\n\t\t}\n\n\t},\n\n\t/**\n\t * Builds one or multiple meshes from the data described in the payload (buffers, params, material info).\n\t *\n\t * @param {Object} meshPayload Raw mesh description (buffers, params, materials) used to build one to many meshes.\n\t * @returns {Mesh[]} mesh Array of {@link Mesh}\n\t */\n\tbuildMeshes: function ( meshPayload ) {\n\n\t\tlet meshName = meshPayload.params.meshName;\n\t\tlet buffers = meshPayload.buffers;\n\n\t\tlet bufferGeometry = new BufferGeometry();\n\t\tif ( buffers.vertices !== undefined && buffers.vertices !== null ) {\n\n\t\t\tbufferGeometry.setAttribute( 'position', new BufferAttribute( new Float32Array( buffers.vertices ), 3 ) );\n\n\t\t}\n\t\tif ( buffers.indices !== undefined && buffers.indices !== null ) {\n\n\t\t\tbufferGeometry.setIndex( new BufferAttribute( new Uint32Array( buffers.indices ), 1 ) );\n\n\t\t}\n\t\tif ( buffers.colors !== undefined && buffers.colors !== null ) {\n\n\t\t\tbufferGeometry.setAttribute( 'color', new BufferAttribute( new Float32Array( buffers.colors ), 3 ) );\n\n\t\t}\n\t\tif ( buffers.normals !== undefined && buffers.normals !== null ) {\n\n\t\t\tbufferGeometry.setAttribute( 'normal', new BufferAttribute( new Float32Array( buffers.normals ), 3 ) );\n\n\t\t} else {\n\n\t\t\tbufferGeometry.computeVertexNormals();\n\n\t\t}\n\t\tif ( buffers.uvs !== undefined && buffers.uvs !== null ) {\n\n\t\t\tbufferGeometry.setAttribute( 'uv', new BufferAttribute( new Float32Array( buffers.uvs ), 2 ) );\n\n\t\t}\n\t\tif ( buffers.skinIndex !== undefined && buffers.skinIndex !== null ) {\n\n\t\t\tbufferGeometry.setAttribute( 'skinIndex', new BufferAttribute( new Uint16Array( buffers.skinIndex ), 4 ) );\n\n\t\t}\n\t\tif ( buffers.skinWeight !== undefined && buffers.skinWeight !== null ) {\n\n\t\t\tbufferGeometry.setAttribute( 'skinWeight', new BufferAttribute( new Float32Array( buffers.skinWeight ), 4 ) );\n\n\t\t}\n\n\t\tlet material, materialName, key;\n\t\tlet materialNames = meshPayload.materials.materialNames;\n\t\tlet createMultiMaterial = meshPayload.materials.multiMaterial;\n\t\tlet multiMaterials = [];\n\t\tfor ( key in materialNames ) {\n\n\t\t\tmaterialName = materialNames[ key ];\n\t\t\tmaterial = this.materialHandler.getMaterial( materialName );\n\t\t\tif ( createMultiMaterial ) multiMaterials.push( material );\n\n\t\t}\n\t\tif ( createMultiMaterial ) {\n\n\t\t\tmaterial = multiMaterials;\n\t\t\tlet materialGroups = meshPayload.materials.materialGroups;\n\t\t\tlet materialGroup;\n\t\t\tfor ( key in materialGroups ) {\n\n\t\t\t\tmaterialGroup = materialGroups[ key ];\n\t\t\t\tbufferGeometry.addGroup( materialGroup.start, materialGroup.count, materialGroup.index );\n\n\t\t\t}\n\n\t\t}\n\n\t\tlet meshes = [];\n\t\tlet mesh;\n\t\tlet callbackOnMeshAlterResult;\n\t\tlet useOrgMesh = true;\n\t\tlet geometryType = meshPayload.geometryType === null ? 0 : meshPayload.geometryType;\n\n\t\tif ( this.callbacks.onMeshAlter ) {\n\n\t\t\tcallbackOnMeshAlterResult = this.callbacks.onMeshAlter(\n\t\t\t\t{\n\t\t\t\t\tdetail: {\n\t\t\t\t\t\tmeshName: meshName,\n\t\t\t\t\t\tbufferGeometry: bufferGeometry,\n\t\t\t\t\t\tmaterial: material,\n\t\t\t\t\t\tgeometryType: geometryType\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\n\t\t}\n\n\t\t// here LoadedMeshUserOverride is required to be provided by the callback used to alter the results\n\t\tif ( callbackOnMeshAlterResult ) {\n\n\t\t\tif ( callbackOnMeshAlterResult.isDisregardMesh() ) {\n\n\t\t\t\tuseOrgMesh = false;\n\n\t\t\t} else if ( callbackOnMeshAlterResult.providesAlteredMeshes() ) {\n\n\t\t\t\tfor ( let i in callbackOnMeshAlterResult.meshes ) {\n\n\t\t\t\t\tmeshes.push( callbackOnMeshAlterResult.meshes[ i ] );\n\n\t\t\t\t}\n\t\t\t\tuseOrgMesh = false;\n\n\t\t\t}\n\n\t\t}\n\t\tif ( useOrgMesh ) {\n\n\t\t\tif ( meshPayload.computeBoundingSphere ) bufferGeometry.computeBoundingSphere();\n\t\t\tif ( geometryType === 0 ) {\n\n\t\t\t\tmesh = new Mesh( bufferGeometry, material );\n\n\t\t\t} else if ( geometryType === 1 ) {\n\n\t\t\t\tmesh = new LineSegments( bufferGeometry, material );\n\n\t\t\t} else {\n\n\t\t\t\tmesh = new Points( bufferGeometry, material );\n\n\t\t\t}\n\t\t\tmesh.name = meshName;\n\t\t\tmeshes.push( mesh );\n\n\t\t}\n\n\t\tlet progressMessage = meshPayload.params.meshName;\n\t\tif ( meshes.length > 0 ) {\n\n\t\t\tlet meshNames = [];\n\t\t\tfor ( let i in meshes ) {\n\n\t\t\t\tmesh = meshes[ i ];\n\t\t\t\tmeshNames[ i ] = mesh.name;\n\n\t\t\t}\n\t\t\tprogressMessage += ': Adding mesh(es) (' + meshNames.length + ': ' + meshNames + ') from input mesh: ' + meshName;\n\t\t\tprogressMessage += ' (' + ( meshPayload.progress.numericalValue * 100 ).toFixed( 2 ) + '%)';\n\n\t\t} else {\n\n\t\t\tprogressMessage += ': Not adding mesh: ' + meshName;\n\t\t\tprogressMessage += ' (' + ( meshPayload.progress.numericalValue * 100 ).toFixed( 2 ) + '%)';\n\n\t\t}\n\t\tif ( this.callbacks.onProgress ) {\n\n\t\t\tthis.callbacks.onProgress( 'progress', progressMessage, meshPayload.progress.numericalValue );\n\n\t\t}\n\n\t\treturn meshes;\n\n\t}\n\n};\n\n/**\n * Object to return by callback onMeshAlter. Used to disregard a certain mesh or to return one to many meshes.\n * @class\n *\n * @param {boolean} disregardMesh=false Tell implementation to completely disregard this mesh\n * @param {boolean} disregardMesh=false Tell implementation that mesh(es) have been altered or added\n */\nconst LoadedMeshUserOverride = function ( disregardMesh, alteredMesh ) {\n\n\tthis.disregardMesh = disregardMesh === true;\n\tthis.alteredMesh = alteredMesh === true;\n\tthis.meshes = [];\n\n};\n\n\nLoadedMeshUserOverride.prototype = {\n\n\tconstructor: LoadedMeshUserOverride,\n\n\t/**\n\t * Add a mesh created within callback.\n\t *\n\t * @param {Mesh} mesh\n\t */\n\taddMesh: function ( mesh ) {\n\n\t\tthis.meshes.push( mesh );\n\t\tthis.alteredMesh = true;\n\n\t},\n\n\t/**\n\t * Answers if mesh shall be disregarded completely.\n\t *\n\t * @returns {boolean}\n\t */\n\tisDisregardMesh: function () {\n\n\t\treturn this.disregardMesh;\n\n\t},\n\n\t/**\n\t * Answers if new mesh(es) were created.\n\t *\n\t * @returns {boolean}\n\t */\n\tprovidesAlteredMeshes: function () {\n\n\t\treturn this.alteredMesh;\n\n\t}\n};\n\nexport {\n\tMeshReceiver,\n\tLoadedMeshUserOverride\n};\n","import {LineBasicMaterial} from 'three/src/materials/LineBasicMaterial';\nimport {MaterialLoader} from 'three/src/loaders/MaterialLoader';\nimport {MeshStandardMaterial} from 'three/src/materials/MeshStandardMaterial';\nimport {PointsMaterial} from 'three/src/materials/PointsMaterial';\n/**\n * @author Kai Salmen / https://kaisalmen.de\n * Development repository: https://github.com/kaisalmen/WWOBJLoader\n */\n\nconst MaterialHandler = function () {\n\tthis.logging = {\n\t\tenabled: false,\n\t\tdebug: false,\n\t};\n\n\tthis.callbacks = {\n\t\tonLoadMaterials: null,\n\t};\n\tthis.materials = {};\n};\n\nMaterialHandler.prototype = {\n\tconstructor: MaterialHandler,\n\n\t/**\n\t * Enable or disable logging in general (except warn and error), plus enable or disable debug logging.\n\t *\n\t * @param {boolean} enabled True or false.\n\t * @param {boolean} debug True or false.\n\t */\n\tsetLogging: function (enabled, debug) {\n\t\tthis.logging.enabled = enabled === true;\n\t\tthis.logging.debug = debug === true;\n\t},\n\n\t_setCallbacks: function (onLoadMaterials) {\n\t\tif (onLoadMaterials !== undefined && onLoadMaterials !== null && onLoadMaterials instanceof Function) {\n\t\t\tthis.callbacks.onLoadMaterials = onLoadMaterials;\n\t\t}\n\t},\n\n\t/**\n\t * Creates default materials and adds them to the materials object.\n\t *\n\t * @param overrideExisting boolean Override existing material\n\t */\n\tcreateDefaultMaterials: function (overrideExisting) {\n\t\tlet defaultMaterial = new MeshStandardMaterial({color: 0xdcf1ff});\n\t\tdefaultMaterial.name = 'defaultMaterial';\n\n\t\tlet defaultVertexColorMaterial = new MeshStandardMaterial({color: 0xdcf1ff});\n\t\tdefaultVertexColorMaterial.name = 'defaultVertexColorMaterial';\n\t\tdefaultVertexColorMaterial.vertexColors = true;\n\n\t\tlet defaultLineMaterial = new LineBasicMaterial();\n\t\tdefaultLineMaterial.name = 'defaultLineMaterial';\n\n\t\tlet defaultPointMaterial = new PointsMaterial({size: 0.1});\n\t\tdefaultPointMaterial.name = 'defaultPointMaterial';\n\n\t\tlet runtimeMaterials = {};\n\t\truntimeMaterials[defaultMaterial.name] = defaultMaterial;\n\t\truntimeMaterials[defaultVertexColorMaterial.name] = defaultVertexColorMaterial;\n\t\truntimeMaterials[defaultLineMaterial.name] = defaultLineMaterial;\n\t\truntimeMaterials[defaultPointMaterial.name] = defaultPointMaterial;\n\n\t\tthis.addMaterials(runtimeMaterials, overrideExisting);\n\t},\n\n\t/**\n\t * Updates the materials with contained material objects (sync) or from alteration instructions (async).\n\t *\n\t * @param {Object} materialPayload Material update instructions\n\t * @returns {Object} Map of {@link Material}\n\t */\n\taddPayloadMaterials: function (materialPayload) {\n\t\tlet material, materialName;\n\t\tlet materialCloneInstructions = materialPayload.materials.materialCloneInstructions;\n\t\tlet newMaterials = {};\n\n\t\tif (materialCloneInstructions !== undefined && materialCloneInstructions !== null) {\n\t\t\tlet materialNameOrg = materialCloneInstructions.materialNameOrg;\n\t\t\tmaterialNameOrg = materialNameOrg !== undefined && materialNameOrg !== null ? materialNameOrg : '';\n\t\t\tlet materialOrg = this.materials[materialNameOrg];\n\t\t\tif (materialOrg) {\n\t\t\t\tmaterial = materialOrg.clone();\n\n\t\t\t\tmaterialName = materialCloneInstructions.materialName;\n\t\t\t\tmaterial.name = materialName;\n\n\t\t\t\tObject.assign(material, materialCloneInstructions.materialProperties);\n\n\t\t\t\tthis.materials[materialName] = material;\n\t\t\t\tnewMaterials[materialName] = material;\n\t\t\t} else {\n\t\t\t\tif (this.logging.enabled) {\n\t\t\t\t\tconsole.info('Requested material \"' + materialNameOrg + '\" is not available!');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet materials = materialPayload.materials.serializedMaterials;\n\t\tif (materials !== undefined && materials !== null && Object.keys(materials).length > 0) {\n\t\t\tlet loader = new MaterialLoader();\n\t\t\tlet materialJson;\n\t\t\tfor (materialName in materials) {\n\t\t\t\tmaterialJson = materials[materialName];\n\t\t\t\tif (materialJson !== undefined && materialJson !== null) {\n\t\t\t\t\tmaterial = loader.parse(materialJson);\n\t\t\t\t\tif (this.logging.enabled) {\n\t\t\t\t\t\tconsole.info('De-serialized material with name \"' + materialName + '\" will be added.');\n\t\t\t\t\t}\n\t\t\t\t\tthis.materials[materialName] = material;\n\t\t\t\t\tnewMaterials[materialName] = material;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmaterials = materialPayload.materials.runtimeMaterials;\n\t\tnewMaterials = this.addMaterials(materials, true, newMaterials);\n\n\t\treturn newMaterials;\n\t},\n\n\t/**\n\t * Set materials loaded by any supplier of an Array of {@link Material}.\n\t *\n\t * @param materials Object with named {@link Material}\n\t * @param overrideExisting boolean Override existing material\n\t * @param newMaterials [Object] with named {@link Material}\n\t */\n\taddMaterials: function (materials, overrideExisting, newMaterials) {\n\t\tif (newMaterials === undefined || newMaterials === null) {\n\t\t\tnewMaterials = {};\n\t\t}\n\t\tif (materials !== undefined && materials !== null && Object.keys(materials).length > 0) {\n\t\t\tlet material;\n\t\t\tlet existingMaterial;\n\t\t\tlet add;\n\t\t\tfor (let materialName in materials) {\n\t\t\t\tmaterial = materials[materialName];\n\t\t\t\tadd = overrideExisting === true;\n\t\t\t\tif (!add) {\n\t\t\t\t\texistingMaterial = this.materials[materialName];\n\t\t\t\t\tadd = existingMaterial === null || existingMaterial === undefined;\n\t\t\t\t}\n\t\t\t\tif (add) {\n\t\t\t\t\tthis.materials[materialName] = material;\n\t\t\t\t\tnewMaterials[materialName] = material;\n\t\t\t\t}\n\t\t\t\tif (this.logging.enabled && this.logging.debug) {\n\t\t\t\t\tconsole.info('Material with name \"' + materialName + '\" was added.');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this.callbacks.onLoadMaterials) {\n\t\t\tthis.callbacks.onLoadMaterials(newMaterials);\n\t\t}\n\t\treturn newMaterials;\n\t},\n\n\t/**\n\t * Returns the mapping object of material name and corresponding material.\n\t *\n\t * @returns {Object} Map of {@link Material}\n\t */\n\tgetMaterials: function () {\n\t\treturn this.materials;\n\t},\n\n\t/**\n\t *\n\t * @param {String} materialName\n\t * @returns {Material}\n\t */\n\tgetMaterial: function (materialName) {\n\t\treturn this.materials[materialName];\n\t},\n\n\t/**\n\t * Returns the mapping object of material name and corresponding jsonified material.\n\t *\n\t * @returns {Object} Map of Materials in JSON representation\n\t */\n\tgetMaterialsJSON: function () {\n\t\tlet materialsJSON = {};\n\t\tlet material;\n\t\tfor (let materialName in this.materials) {\n\t\t\tmaterial = this.materials[materialName];\n\t\t\tmaterialsJSON[materialName] = material.toJSON();\n\t\t}\n\n\t\treturn materialsJSON;\n\t},\n\n\t/**\n\t * Removes all materials\n\t */\n\tclearMaterials: function () {\n\t\tthis.materials = {};\n\t},\n};\n\nexport {MaterialHandler};\n","import {FileLoader} from 'three/src/loaders/FileLoader';\nimport {Loader} from 'three/src/loaders/Loader';\nimport {Object3D} from 'three/src/core/Object3D';\n/**\n * @author Kai Salmen / https://kaisalmen.de\n * Development repository: https://github.com/kaisalmen/WWOBJLoader\n */\n\n\nimport { OBJLoader2Parser } from \"./obj2/OBJLoader2Parser.js\";\nimport { MeshReceiver } from \"./obj2/shared/MeshReceiver.js\";\nimport { MaterialHandler } from \"./obj2/shared/MaterialHandler.js\";\n\n/**\n * Creates a new OBJLoader2. Use it to load OBJ data from files or to parse OBJ data from arraybuffer or text.\n *\n * @param {LoadingManager} [manager] The loadingManager for the loader to use. Default is {@link LoadingManager}\n * @constructor\n */\nconst OBJLoader2 = function ( manager ) {\n\n\tLoader.call( this, manager );\n\n\tthis.parser = new OBJLoader2Parser();\n\n\tthis.modelName = '';\n\tthis.instanceNo = 0;\n\tthis.baseObject3d = new Object3D();\n\n\tthis.materialHandler = new MaterialHandler();\n\tthis.meshReceiver = new MeshReceiver( this.materialHandler );\n\n\t// as OBJLoader2 is no longer derived from OBJLoader2Parser, we need to override the default onAssetAvailable callback\n\tlet scope = this;\n\tlet defaultOnAssetAvailable = function ( payload ) {\n\n\t\tscope._onAssetAvailable( payload );\n\n\t};\n\tthis.parser.setCallbackOnAssetAvailable( defaultOnAssetAvailable );\n\n};\n\nOBJLoader2.OBJLOADER2_VERSION = '3.2.0';\nconsole.info( 'Using OBJLoader2 version: ' + OBJLoader2.OBJLOADER2_VERSION );\n\n\nOBJLoader2.prototype = Object.assign( Object.create( Loader.prototype ), {\n\n\tconstructor: OBJLoader2,\n\n\t/**\n\t * See {@link OBJLoader2Parser.setLogging}\n\t * @return {OBJLoader2}\n\t */\n\tsetLogging: function ( enabled, debug ) {\n\n\t\tthis.parser.setLogging( enabled, debug );\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * See {@link OBJLoader2Parser.setMaterialPerSmoothingGroup}\n\t * @return {OBJLoader2}\n\t */\n\tsetMaterialPerSmoothingGroup: function ( materialPerSmoothingGroup ) {\n\n\t\tthis.parser.setMaterialPerSmoothingGroup( materialPerSmoothingGroup );\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * See {@link OBJLoader2Parser.setUseOAsMesh}\n\t * @return {OBJLoader2}\n\t */\n\tsetUseOAsMesh: function ( useOAsMesh ) {\n\n\t\tthis.parser.setUseOAsMesh( useOAsMesh );\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * See {@link OBJLoader2Parser.setUseIndices}\n\t * @return {OBJLoader2}\n\t */\n\tsetUseIndices: function ( useIndices ) {\n\n\t\tthis.parser.setUseIndices( useIndices );\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * See {@link OBJLoader2Parser.setDisregardNormals}\n\t * @return {OBJLoader2}\n\t */\n\tsetDisregardNormals: function ( disregardNormals ) {\n\n\t\tthis.parser.setDisregardNormals( disregardNormals );\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Set the name of the model.\n\t *\n\t * @param {string} modelName\n\t * @return {OBJLoader2}\n\t */\n\tsetModelName: function ( modelName ) {\n\n\t\tthis.modelName = modelName ? modelName : this.modelName;\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Set the node where the loaded objects will be attached directly.\n\t *\n\t * @param {Object3D} baseObject3d Object already attached to scenegraph where new meshes will be attached to\n\t * @return {OBJLoader2}\n\t */\n\tsetBaseObject3d: function ( baseObject3d ) {\n\n\t\tthis.baseObject3d = ( baseObject3d === undefined || baseObject3d === null ) ? this.baseObject3d : baseObject3d;\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Add materials as associated array.\n\t *\n\t * @param {Object} materials Object with named {@link Material}\n\t * @param overrideExisting boolean Override existing material\n\t * @return {OBJLoader2}\n\t */\n\taddMaterials: function ( materials, overrideExisting ) {\n\n\t\tthis.materialHandler.addMaterials( materials, overrideExisting );\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * See {@link OBJLoader2Parser.setCallbackOnAssetAvailable}\n\t * @return {OBJLoader2}\n\t */\n\tsetCallbackOnAssetAvailable: function ( onAssetAvailable ) {\n\n\t\tthis.parser.setCallbackOnAssetAvailable( onAssetAvailable );\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * See {@link OBJLoader2Parser.setCallbackOnProgress}\n\t * @return {OBJLoader2}\n\t */\n\tsetCallbackOnProgress: function ( onProgress ) {\n\n\t\tthis.parser.setCallbackOnProgress( onProgress );\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * See {@link OBJLoader2Parser.setCallbackOnError}\n\t * @return {OBJLoader2}\n\t */\n\tsetCallbackOnError: function ( onError ) {\n\n\t\tthis.parser.setCallbackOnError( onError );\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * See {@link OBJLoader2Parser.setCallbackOnLoad}\n\t * @return {OBJLoader2}\n\t */\n\tsetCallbackOnLoad: function ( onLoad ) {\n\n\t\tthis.parser.setCallbackOnLoad( onLoad );\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Register a function that is called once a single mesh is available and it could be altered by the supplied function.\n\t *\n\t * @param {Function} [onMeshAlter]\n\t * @return {OBJLoader2}\n\t */\n\tsetCallbackOnMeshAlter: function ( onMeshAlter ) {\n\n\t\tthis.meshReceiver._setCallbacks( this.parser.callbacks.onProgress, onMeshAlter );\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Register a function that is called once all materials have been loaded and they could be altered by the supplied function.\n\t *\n\t * @param {Function} [onLoadMaterials]\n\t * @return {OBJLoader2}\n\t */\n\tsetCallbackOnLoadMaterials: function ( onLoadMaterials ) {\n\n\t\tthis.materialHandler._setCallbacks( onLoadMaterials );\n\t\treturn this;\n\n\t},\n\n\t/**\n\t * Use this convenient method to load a file at the given URL. By default the fileLoader uses an ArrayBuffer.\n\t *\n\t * @param {string}  url A string containing the path/URL of the file to be loaded.\n\t * @param {function} onLoad A function to be called after loading is successfully completed. The function receives loaded Object3D as an argument.\n\t * @param {function} [onFileLoadProgress] A function to be called while the loading is in progress. The argument will be the XMLHttpRequest instance, which contains total and Integer bytes.\n\t * @param {function} [onError] A function to be called if an error occurs during loading. The function receives the error as an argument.\n\t * @param {function} [onMeshAlter] Called after every single mesh is made available by the parser\n\t */\n\tload: function ( url, onLoad, onFileLoadProgress, onError, onMeshAlter ) {\n\n\t\tlet scope = this;\n\t\tif ( onLoad === null || onLoad === undefined || ! ( onLoad instanceof Function ) ) {\n\n\t\t\tlet errorMessage = 'onLoad is not a function! Aborting...';\n\t\t\tscope.parser.callbacks.onError( errorMessage );\n\t\t\tthrow errorMessage;\n\n\t\t} else {\n\n\t\t\tthis.parser.setCallbackOnLoad( onLoad );\n\n\t\t}\n\t\tif ( onError === null || onError === undefined || ! ( onError instanceof Function ) ) {\n\n\t\t\tonError = function ( event ) {\n\n\t\t\t\tlet errorMessage = event;\n\t\t\t\tif ( event.currentTarget && event.currentTarget.statusText !== null ) {\n\n\t\t\t\t\terrorMessage = 'Error occurred while downloading!\\nurl: ' + event.currentTarget.responseURL + '\\nstatus: ' + event.currentTarget.statusText;\n\n\t\t\t\t}\n\t\t\t\tscope.parser.callbacks.onError( errorMessage );\n\n\t\t\t};\n\n\t\t}\n\t\tif ( ! url ) {\n\n\t\t\tonError( 'An invalid url was provided. Unable to continue!' );\n\n\t\t}\n\t\tlet urlFull = new URL( url, window.location.href ).href;\n\t\tlet filename = urlFull;\n\t\tlet urlParts = urlFull.split( '/' );\n\t\tif ( urlParts.length > 2 ) {\n\n\t\t\tfilename = urlParts[ urlParts.length - 1 ];\n\t\t\tthis.path = urlParts.slice( 0, urlParts.length - 1 ).join( '/' ) + '/';\n\n\t\t}\n\t\tif ( onFileLoadProgress === null || onFileLoadProgress === undefined || ! ( onFileLoadProgress instanceof Function ) ) {\n\n\t\t\tlet numericalValueRef = 0;\n\t\t\tlet numericalValue = 0;\n\t\t\tonFileLoadProgress = function ( event ) {\n\n\t\t\t\tif ( ! event.lengthComputable ) return;\n\n\t\t\t\tnumericalValue = event.loaded / event.total;\n\t\t\t\tif ( numericalValue > numericalValueRef ) {\n\n\t\t\t\t\tnumericalValueRef = numericalValue;\n\t\t\t\t\tlet output = 'Download of \"' + url + '\": ' + ( numericalValue * 100 ).toFixed( 2 ) + '%';\n\t\t\t\t\tscope.parser.callbacks.onProgress( 'progressLoad', output, numericalValue );\n\n\t\t\t\t}\n\n\t\t\t};\n\n\t\t}\n\n\t\tthis.setCallbackOnMeshAlter( onMeshAlter );\n\t\tlet fileLoaderOnLoad = function ( content ) {\n\n\t\t\tscope.parser.callbacks.onLoad( scope.parse( content ), \"OBJLoader2#load: Parsing completed\" );\n\n\t\t};\n\t\tlet fileLoader = new FileLoader( this.manager );\n\t\tfileLoader.setPath( this.path || this.resourcePath );\n\t\tfileLoader.setResponseType( 'arraybuffer' );\n\t\tfileLoader.load( filename, fileLoaderOnLoad, onFileLoadProgress, onError );\n\n\t},\n\n\t/**\n\t * Parses OBJ data synchronously from arraybuffer or string and returns the {@link Object3D}.\n\t *\n\t * @param {arraybuffer|string} content OBJ data as Uint8Array or String\n\t * @return {Object3D}\n\t */\n\tparse: function ( content ) {\n\n\t\t// fast-fail in case of illegal data\n\t\tif ( content === null || content === undefined ) {\n\n\t\t\tthrow 'Provided content is not a valid ArrayBuffer or String. Unable to continue parsing';\n\n\t\t}\n\t\tif ( this.parser.logging.enabled ) {\n\n\t\t\tconsole.time( 'OBJLoader parse: ' + this.modelName );\n\n\t\t}\n\n\t\t// Create default materials beforehand, but do not override previously set materials (e.g. during init)\n\t\tthis.materialHandler.createDefaultMaterials( false );\n\n\t\t// code works directly on the material references, parser clear its materials before updating\n\t\tthis.parser.setMaterials( this.materialHandler.getMaterials() );\n\n\t\tif ( content instanceof ArrayBuffer || content instanceof Uint8Array ) {\n\n\t\t\tif ( this.parser.logging.enabled ) console.info( 'Parsing arrayBuffer...' );\n\t\t\tthis.parser.execute( content );\n\n\t\t} else if ( typeof ( content ) === 'string' || content instanceof String ) {\n\n\t\t\tif ( this.parser.logging.enabled ) console.info( 'Parsing text...' );\n\t\t\tthis.parser.executeLegacy( content );\n\n\t\t} else {\n\n\t\t\tthis.parser.callbacks.onError( 'Provided content was neither of type String nor Uint8Array! Aborting...' );\n\n\t\t}\n\t\tif ( this.parser.logging.enabled ) {\n\n\t\t\tconsole.timeEnd( 'OBJLoader parse: ' + this.modelName );\n\n\t\t}\n\t\treturn this.baseObject3d;\n\n\t},\n\n\t_onAssetAvailable: function ( payload ) {\n\n\t\tif ( payload.cmd !== 'assetAvailable' ) return;\n\n\t\tif ( payload.type === 'mesh' ) {\n\n\t\t\tlet meshes = this.meshReceiver.buildMeshes( payload );\n\t\t\tfor ( let mesh of meshes ) {\n\n\t\t\t\tthis.baseObject3d.add( mesh );\n\n\t\t\t}\n\n\t\t} else if ( payload.type === 'material' ) {\n\n\t\t\tthis.materialHandler.addPayloadMaterials( payload );\n\n\t\t}\n\n\t}\n\n} );\n\nexport { OBJLoader2 };\n"],"sourceRoot":""}