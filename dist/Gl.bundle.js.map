{"version":3,"sources":["webpack://POLY/./node_modules/three/src/loaders/Loader.js","webpack://POLY/./node_modules/three/src/textures/VideoTexture.js","webpack://POLY/./node_modules/three/src/loaders/Cache.js","webpack://POLY/./node_modules/three/src/loaders/ImageLoader.js","webpack://POLY/./node_modules/three/src/loaders/LoadingManager.js","webpack://POLY/./node_modules/three/src/loaders/TextureLoader.js","webpack://POLY/./src/engine/nodes/gl/Constant.ts","webpack://POLY/./src/engine/nodes/gl/_ConversionMisc.ts","webpack://POLY/./src/engine/nodes/gl/_ConversionToVec.ts","webpack://POLY/./src/engine/nodes/gl/_ConversionVecTo.ts","webpack://POLY/./src/engine/nodes/gl/_BaseAdaptive.ts","webpack://POLY/./src/engine/nodes/gl/_BaseMathFunction.ts","webpack://POLY/./src/engine/nodes/gl/_Math_Arg1.ts","webpack://POLY/./src/engine/nodes/gl/_Math_Arg2.ts","webpack://POLY/./src/engine/nodes/gl/_Math_Arg2Operation.ts","webpack://POLY/./src/engine/nodes/gl/_BaseMathFunctionArgBoolean2.ts","webpack://POLY/./src/engine/nodes/gl/_Math_Arg2Boolean.ts","webpack://POLY/./src/engine/nodes/gl/gl/quaternion.glsl","webpack://POLY/./src/engine/nodes/gl/Align.ts","webpack://POLY/./src/engine/nodes/gl/Complement.ts","webpack://POLY/./src/engine/nodes/gl/gl/complement.glsl","webpack://POLY/./src/engine/nodes/gl/Cross.ts","webpack://POLY/./src/engine/nodes/gl/_Math_Arg3.ts","webpack://POLY/./src/engine/nodes/gl/Cycle.ts","webpack://POLY/./src/engine/nodes/gl/gl/cycle.glsl","webpack://POLY/./src/engine/nodes/gl/Disk.ts","webpack://POLY/./src/engine/nodes/gl/gl/disk.glsl","webpack://POLY/./src/engine/nodes/gl/gl/easing/circular-in-out.glsl","webpack://POLY/./src/engine/nodes/gl/gl/easing/bounce-out.glsl","webpack://POLY/./src/engine/nodes/gl/Easing.ts","webpack://POLY/./src/engine/nodes/gl/gl/easing/exponential-in-out.glsl","webpack://POLY/./src/engine/nodes/gl/gl/easing/circular-in.glsl","webpack://POLY/./src/engine/nodes/gl/gl/easing/elastic-out.glsl","webpack://POLY/./src/engine/nodes/gl/gl/easing/cubic-in.glsl","webpack://POLY/./src/engine/nodes/gl/gl/easing/exponential-out.glsl","webpack://POLY/./src/engine/nodes/gl/gl/easing/quintic-out.glsl","webpack://POLY/./src/engine/nodes/gl/gl/easing/elastic-in-out.glsl","webpack://POLY/./src/engine/nodes/gl/gl/easing/linear.glsl","webpack://POLY/./src/engine/nodes/gl/gl/easing/circular-out.glsl","webpack://POLY/./src/engine/nodes/gl/gl/easing/back-in-out.glsl","webpack://POLY/./src/engine/nodes/gl/gl/easing/back-in.glsl","webpack://POLY/./src/engine/nodes/gl/gl/easing/sine-in.glsl","webpack://POLY/./src/engine/nodes/gl/gl/easing/back-out.glsl","webpack://POLY/./src/engine/nodes/gl/gl/easing/quartic-in-out.glsl","webpack://POLY/./src/engine/nodes/gl/gl/easing/quadratic-in.glsl","webpack://POLY/./src/engine/nodes/gl/gl/easing/cubic-in-out.glsl","webpack://POLY/./src/engine/nodes/gl/gl/easing/elastic-in.glsl","webpack://POLY/./src/engine/nodes/gl/gl/easing/quadratic-in-out.glsl","webpack://POLY/./src/engine/nodes/gl/gl/easing/exponential-in.glsl","webpack://POLY/./src/engine/nodes/gl/gl/easing/quintic-in-out.glsl","webpack://POLY/./src/engine/nodes/gl/gl/easing/sine-in-out.glsl","webpack://POLY/./src/engine/nodes/gl/gl/easing/cubic-out.glsl","webpack://POLY/./src/engine/nodes/gl/gl/easing/quadratic-out.glsl","webpack://POLY/./src/engine/nodes/gl/gl/easing/bounce-in-out.glsl","webpack://POLY/./src/engine/nodes/gl/gl/easing/quintic-in.glsl","webpack://POLY/./src/engine/nodes/gl/gl/easing/quartic-in.glsl","webpack://POLY/./src/engine/nodes/gl/gl/easing/quartic-out.glsl","webpack://POLY/./src/engine/nodes/gl/gl/easing/bounce-in.glsl","webpack://POLY/./src/engine/nodes/gl/gl/easing/sine-out.glsl","webpack://POLY/./src/engine/nodes/gl/gl/fit.glsl","webpack://POLY/./src/engine/nodes/gl/Fit.ts","webpack://POLY/./src/engine/nodes/gl/Fit01.ts","webpack://POLY/./src/engine/nodes/gl/HsvToRgb.ts","webpack://POLY/./src/engine/nodes/gl/gl/hsv2rgb.glsl","webpack://POLY/./src/engine/nodes/gl/InstanceTransform.ts","webpack://POLY/./src/engine/nodes/gl/Length.ts","webpack://POLY/./src/engine/nodes/gl/Luminance.ts","webpack://POLY/./src/engine/nodes/gl/Mix.ts","webpack://POLY/./src/engine/nodes/gl/MultAdd.ts","webpack://POLY/./src/engine/nodes/gl/Negate.ts","webpack://POLY/./src/engine/nodes/gl/gl/noise/common.glsl","webpack://POLY/./src/engine/nodes/gl/Noise.ts","webpack://POLY/./src/engine/nodes/gl/gl/noise/classicnoise2D.glsl","webpack://POLY/./src/engine/nodes/gl/gl/noise/classicnoise3D.glsl","webpack://POLY/./src/engine/nodes/gl/gl/noise/classicnoise4D.glsl","webpack://POLY/./src/engine/nodes/gl/gl/noise/noise2D.glsl","webpack://POLY/./src/engine/nodes/gl/gl/noise/noise3D.glsl","webpack://POLY/./src/engine/nodes/gl/gl/noise/noise4D.glsl","webpack://POLY/./src/engine/nodes/gl/Null.ts","webpack://POLY/./src/engine/nodes/gl/Output.ts","webpack://POLY/./src/engine/nodes/gl/Param.ts","webpack://POLY/./src/engine/nodes/gl/Refract.ts","webpack://POLY/./src/engine/nodes/gl/QuatMult.ts","webpack://POLY/./src/engine/nodes/gl/QuatFromAxisAngle.ts","webpack://POLY/./src/engine/nodes/gl/QuatToAngle.ts","webpack://POLY/./src/engine/nodes/gl/QuatToAxis.ts","webpack://POLY/./src/engine/nodes/gl/Ramp.ts","webpack://POLY/./src/engine/nodes/gl/Random.ts","webpack://POLY/./src/engine/nodes/gl/RgbToHsv.ts","webpack://POLY/./src/engine/nodes/gl/gl/rgb2hsv.glsl","webpack://POLY/./src/engine/nodes/gl/Rotate.ts","webpack://POLY/./src/engine/nodes/gl/Round.ts","webpack://POLY/./src/engine/nodes/gl/Texture.ts","webpack://POLY/./src/engine/nodes/gl/TwoWaySwitch.ts","webpack://POLY/./src/engine/nodes/gl/VectorAlign.ts","webpack://POLY/./src/engine/nodes/gl/VectorAngle.ts","webpack://POLY/./src/engine/poly/registers/Gl.ts"],"names":["Loader","manager","this","undefined","crossOrigin","path","resourcePath","Object","assign","prototype","load","parse","setCrossOrigin","setPath","setResourcePath","VideoTexture","video","mapping","wrapS","wrapT","magFilter","minFilter","format","type","anisotropy","call","generateMipmaps","create","constructor","isVideoTexture","update","image","readyState","HAVE_CURRENT_DATA","needsUpdate","Cache","enabled","files","add","key","file","get","remove","clear","ImageLoader","url","onLoad","onProgress","onError","resolveURL","scope","cached","itemStart","setTimeout","itemEnd","document","createElementNS","onImageLoad","removeEventListener","onImageError","event","itemError","addEventListener","substr","src","LoadingManager","isLoading","itemsLoaded","itemsTotal","urlModifier","handlers","onStart","setURLModifier","transform","addHandler","regex","loader","push","removeHandler","index","indexOf","splice","getHandler","i","l","length","global","lastIndex","test","DefaultLoadingManager","TextureLoader","texture","isJPEG","search","typed_visible_options","visible_if","ConstantGlParamsConfig","INTEGER","FLOAT","menu","entries","map","name","value","bool","BOOLEAN","BOOL","int","INT","float","vec2","VECTOR2","VEC2","vec3","VECTOR3","VEC3","vec4","VECTOR4","VEC4","ParamsConfig","ConstantGlNode","params_config","gl_connections_controller","_allow_inputs_created_from_params","initialize_node","set_output_name_function","OUTPUT_NAME","set_expected_input_types_function","set_expected_output_types_function","_current_connection_type","shaders_collection_controller","param","_current_param","connection_type","any","body_line","_current_var_name","add_body_lines","console","warn","pv","_params_by_type","Map","p","gl_var_name","ParamsConfigFloatToInt","io","outputs","set_named_output_connection_points","ConnectionPointType","variable_for_input","ThreeToGl","ParamsConfigIntToFloat","x","y","ParamsConfig2","float2","z","ParamsConfig3","float3","w","ParamsConfig4","float4","VecToGlFactory","options","components","param_type","c","add_param","body_lines","vec","used_output_names","forEach","var_name","components_v4","ParamType","OUTPUT_NAME_VEC3","OUTPUT_NAME_W","INPUT_NAME_VEC4","in_vec4","out_vec3","out_w","super","_expected_input_types","bind","_expected_output_types","set_input_name_function","_gl_input_name","first_input_connection_type","connections","first_input_connection","count","Math","max","input_connections","var_type","named_output_connection_points","joined_args","inputs","named_input_connection_points","connection","join","output_name","gl_method_name","add_definitions","gl_function_definitions","MathFunctionArg1Factory","method","gl_output_name","out","gl_input_name","in","_gl_output_name","AbsGlNode","AcosGlNode","AsinGlNode","AtanGlNode","CeilGlNode","CosGlNode","DegreesGlNode","ExpGlNode","Exp2GlNode","FloorGlNode","FractGlNode","InverseSqrtGlNode","LogGlNode","Log2GlNode","NormalizeGlNode","RadiansGlNode","SignGlNode","SinGlNode","SqrtGlNode","TanGlNode","MathFunctionArg2Factory","gl_input_names","default_in_type","allowed_in_types","out_type","functions","f","first_input_type","includes","first_connection","MaxGlNode","MinGlNode","ModGlNode","PowGlNode","StepGlNode","MathFunctionArg2OperationFactory","in_prefix","operation","variable","gl_operation","current_connections","expected_count","expected_input_types","AddGlNode","DivideGlNode","SubstractGlNode","input_types","input_index","empty_array","Array","second_connection","second_type","named_input","boolean_operation","MathFunctionArg2BooleanFactory","op","AndGlNode","OrGlNode","InputName","InputNames","DIR","UP","DefaultValues","MathFunctionArg3Factory","gl_input_default_values","default","position","center","radius","feather","vector2","EASE_NAMES","IMPORT_BY_EASE_NAME","linear","IMPORT_DEPENDENCIES_BY_EASE_NAME","METHOD_NAMES_BY_EASE_NAME","default_ease_type","input","spare_params_controller","set_inputless_param_names","ease_name","method_name","glsl_function_code","ease_functions","function_dependencies","concat","in_value","src_min","src_max","hsv","function_declaration_lines","vector3","rgb","VARS","normal","instance_position","instance_orientation","instance_scale","gl_output_name_position","gl_output_name_normal","_default_position","_default_normal","instancePosition","_default_instance_position","instanceOrientation","_default_input_instance_orientation","instanceScale","_default_input_instance_scale","result_position","result_normal","material_node","assembler_controller","assembler","globals_handler","read_attribute","mult","VALUE","PRE_ADD","MULT","POST_ADD","pre_add","post_add","gl_type","out_name","NOISE_NAME","NOISE_NAMES","CLASSIC_PERLIN_2D","CLASSIC_PERLIN_3D","CLASSIC_PERLIN_4D","NOISE_2D","NOISE_3D","NOISE_4D","IMPORT_BY_NOISE_NAME","INPUT_TYPES_BY_NOISE_NAME","OUTPUT_TYPE_BY_NOISE_NAME","METHOD_NAMES_BY_NOISE_NAME","OUTPUT_TYPE","OUTPUT_TYPES","NoChange","Float","Vec2","Vec3","Vec4","OUTPUT_TYPE_LABEL","CONNECTION_TYPE_BY_OUTPUT_TYPE","ALL_COMPONENTS","default_noise_type","default_output_type","amp","freq","noise_name","output_type","val","octaves","range","range_locked","amp_attenuation","freq_increase","separator","SEPARATOR","AMP","POSITION","FREQ","OFFSET","noise_function","noise_output_gl_type","fbm_function","output_gl_type","line","single_noise_line","lines_count_required","assembly_args","noise","component","offset_gl_type","offset_components_count","offset2","j","assembly_line","input_type","fbm_method_name","output_name_suffix","offset","right_hand","add_post_dirty_hook","_set_mat_to_recompile","add_output_params","set_node_lines_output","STRING","as_color","_on_create_set_name_if_none_bound","_on_create_set_name_if_none","lifecycle","add_on_create_hook","definitions","uniform_name","default_value","_param_configs_controller","ParamConfigsController","reset","create_and_push","COLOR","output_connection_point","set","AXIS","ANGLE","texture_name","_uniform_name","definition","SAMPLER_2D","input_val","RAMP","Ramp","DEFAULT_VALUE","seed","input_name","Mode","Modes","QUAT","LabelByMode","InputNamesByMode","MethodNameByMode","InputTypesByMode","vector","axis","signature","mode","input_connection","output_connection","_simple_line","simple_lines","param_name","File","DEFAULT_NODE_PATH","UV","uv","rgba","OPERATOR_PATH","CONDITION","IF_TRUE","IF_FALSE","second_or_third_connection","connection_type_from_connection","condition","if_true","if_false","start","end","up","poly","register_node","MATH","TRIGO","LOGIC","Attribute","GLOBALS","except","NodeContext","COP","Constant","GEOMETRY","CONVERSION","Globals","UTIL"],"mappings":"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","file":"Gl.bundle.js","sourcesContent":["import { DefaultLoadingManager } from './LoadingManager.js';\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nfunction Loader( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\tthis.crossOrigin = 'anonymous';\n\tthis.path = '';\n\tthis.resourcePath = '';\n\n}\n\nObject.assign( Loader.prototype, {\n\n\tload: function ( /* url, onLoad, onProgress, onError */ ) {},\n\n\tparse: function ( /* data */ ) {},\n\n\tsetCrossOrigin: function ( crossOrigin ) {\n\n\t\tthis.crossOrigin = crossOrigin;\n\t\treturn this;\n\n\t},\n\n\tsetPath: function ( path ) {\n\n\t\tthis.path = path;\n\t\treturn this;\n\n\t},\n\n\tsetResourcePath: function ( resourcePath ) {\n\n\t\tthis.resourcePath = resourcePath;\n\t\treturn this;\n\n\t}\n\n} );\n\nexport { Loader };\n","/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nimport { RGBFormat, LinearFilter } from '../constants.js';\nimport { Texture } from './Texture.js';\n\nfunction VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\tTexture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\tthis.format = format !== undefined ? format : RGBFormat;\n\n\tthis.minFilter = minFilter !== undefined ? minFilter : LinearFilter;\n\tthis.magFilter = magFilter !== undefined ? magFilter : LinearFilter;\n\n\tthis.generateMipmaps = false;\n\n}\n\nVideoTexture.prototype = Object.assign( Object.create( Texture.prototype ), {\n\n\tconstructor: VideoTexture,\n\n\tisVideoTexture: true,\n\n\tupdate: function () {\n\n\t\tvar video = this.image;\n\n\t\tif ( video.readyState >= video.HAVE_CURRENT_DATA ) {\n\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n} );\n\n\nexport { VideoTexture };\n","/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar Cache = {\n\n\tenabled: false,\n\n\tfiles: {},\n\n\tadd: function ( key, file ) {\n\n\t\tif ( this.enabled === false ) return;\n\n\t\t// console.log( 'THREE.Cache', 'Adding key:', key );\n\n\t\tthis.files[ key ] = file;\n\n\t},\n\n\tget: function ( key ) {\n\n\t\tif ( this.enabled === false ) return;\n\n\t\t// console.log( 'THREE.Cache', 'Checking key:', key );\n\n\t\treturn this.files[ key ];\n\n\t},\n\n\tremove: function ( key ) {\n\n\t\tdelete this.files[ key ];\n\n\t},\n\n\tclear: function () {\n\n\t\tthis.files = {};\n\n\t}\n\n};\n\n\nexport { Cache };\n","/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nimport { Cache } from './Cache.js';\nimport { Loader } from './Loader.js';\n\nfunction ImageLoader( manager ) {\n\n\tLoader.call( this, manager );\n\n}\n\nImageLoader.prototype = Object.assign( Object.create( Loader.prototype ), {\n\n\tconstructor: ImageLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\turl = this.manager.resolveURL( url );\n\n\t\tvar scope = this;\n\n\t\tvar cached = Cache.get( url );\n\n\t\tif ( cached !== undefined ) {\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\tsetTimeout( function () {\n\n\t\t\t\tif ( onLoad ) onLoad( cached );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, 0 );\n\n\t\t\treturn cached;\n\n\t\t}\n\n\t\tvar image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );\n\n\t\tfunction onImageLoad() {\n\n\t\t\timage.removeEventListener( 'load', onImageLoad, false );\n\t\t\timage.removeEventListener( 'error', onImageError, false );\n\n\t\t\tCache.add( url, this );\n\n\t\t\tif ( onLoad ) onLoad( this );\n\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t}\n\n\t\tfunction onImageError( event ) {\n\n\t\t\timage.removeEventListener( 'load', onImageLoad, false );\n\t\t\timage.removeEventListener( 'error', onImageError, false );\n\n\t\t\tif ( onError ) onError( event );\n\n\t\t\tscope.manager.itemError( url );\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t}\n\n\t\timage.addEventListener( 'load', onImageLoad, false );\n\t\timage.addEventListener( 'error', onImageError, false );\n\n\t\tif ( url.substr( 0, 5 ) !== 'data:' ) {\n\n\t\t\tif ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;\n\n\t\t}\n\n\t\tscope.manager.itemStart( url );\n\n\t\timage.src = url;\n\n\t\treturn image;\n\n\t}\n\n} );\n\n\nexport { ImageLoader };\n","/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction LoadingManager( onLoad, onProgress, onError ) {\n\n\tvar scope = this;\n\n\tvar isLoading = false;\n\tvar itemsLoaded = 0;\n\tvar itemsTotal = 0;\n\tvar urlModifier = undefined;\n\tvar handlers = [];\n\n\t// Refer to #5689 for the reason why we don't set .onStart\n\t// in the constructor\n\n\tthis.onStart = undefined;\n\tthis.onLoad = onLoad;\n\tthis.onProgress = onProgress;\n\tthis.onError = onError;\n\n\tthis.itemStart = function ( url ) {\n\n\t\titemsTotal ++;\n\n\t\tif ( isLoading === false ) {\n\n\t\t\tif ( scope.onStart !== undefined ) {\n\n\t\t\t\tscope.onStart( url, itemsLoaded, itemsTotal );\n\n\t\t\t}\n\n\t\t}\n\n\t\tisLoading = true;\n\n\t};\n\n\tthis.itemEnd = function ( url ) {\n\n\t\titemsLoaded ++;\n\n\t\tif ( scope.onProgress !== undefined ) {\n\n\t\t\tscope.onProgress( url, itemsLoaded, itemsTotal );\n\n\t\t}\n\n\t\tif ( itemsLoaded === itemsTotal ) {\n\n\t\t\tisLoading = false;\n\n\t\t\tif ( scope.onLoad !== undefined ) {\n\n\t\t\t\tscope.onLoad();\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tthis.itemError = function ( url ) {\n\n\t\tif ( scope.onError !== undefined ) {\n\n\t\t\tscope.onError( url );\n\n\t\t}\n\n\t};\n\n\tthis.resolveURL = function ( url ) {\n\n\t\tif ( urlModifier ) {\n\n\t\t\treturn urlModifier( url );\n\n\t\t}\n\n\t\treturn url;\n\n\t};\n\n\tthis.setURLModifier = function ( transform ) {\n\n\t\turlModifier = transform;\n\n\t\treturn this;\n\n\t};\n\n\tthis.addHandler = function ( regex, loader ) {\n\n\t\thandlers.push( regex, loader );\n\n\t\treturn this;\n\n\t};\n\n\tthis.removeHandler = function ( regex ) {\n\n\t\tvar index = handlers.indexOf( regex );\n\n\t\tif ( index !== - 1 ) {\n\n\t\t\thandlers.splice( index, 2 );\n\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\tthis.getHandler = function ( file ) {\n\n\t\tfor ( var i = 0, l = handlers.length; i < l; i += 2 ) {\n\n\t\t\tvar regex = handlers[ i ];\n\t\t\tvar loader = handlers[ i + 1 ];\n\n\t\t\tif ( regex.global ) regex.lastIndex = 0; // see #17920\n\n\t\t\tif ( regex.test( file ) ) {\n\n\t\t\t\treturn loader;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t};\n\n}\n\nvar DefaultLoadingManager = new LoadingManager();\n\n\nexport { DefaultLoadingManager, LoadingManager };\n","/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nimport { RGBAFormat, RGBFormat } from '../constants.js';\nimport { ImageLoader } from './ImageLoader.js';\nimport { Texture } from '../textures/Texture.js';\nimport { Loader } from './Loader.js';\n\nfunction TextureLoader( manager ) {\n\n\tLoader.call( this, manager );\n\n}\n\nTextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), {\n\n\tconstructor: TextureLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar texture = new Texture();\n\n\t\tvar loader = new ImageLoader( this.manager );\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\tloader.setPath( this.path );\n\n\t\tloader.load( url, function ( image ) {\n\n\t\t\ttexture.image = image;\n\n\t\t\t// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.\n\t\t\tvar isJPEG = url.search( /\\.jpe?g($|\\?)/i ) > 0 || url.search( /^data\\:image\\/jpeg/ ) === 0;\n\n\t\t\ttexture.format = isJPEG ? RGBFormat : RGBAFormat;\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad !== undefined ) {\n\n\t\t\t\tonLoad( texture );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t\treturn texture;\n\n\t}\n\n} );\n\n\nexport { TextureLoader };\n","import {TypedGlNode} from './_Base';\nimport {ThreeToGl} from '../../../core/ThreeToGl';\n\nimport {ConnectionPointType, ConnectionPointTypes} from '../utils/connections/ConnectionPointType';\n\nfunction typed_visible_options(type: ConnectionPointType) {\n\tconst val = ConnectionPointTypes.indexOf(type);\n\treturn {visible_if: {type: val}};\n}\n\nimport {BaseParamType} from '../../params/_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {ShadersCollectionController} from './code/utils/ShadersCollectionController';\nimport {GlConnectionsController} from './utils/ConnectionsController';\n\nclass ConstantGlParamsConfig extends NodeParamsConfig {\n\ttype = ParamConfig.INTEGER(ConnectionPointTypes.indexOf(ConnectionPointType.FLOAT), {\n\t\tmenu: {\n\t\t\tentries: ConnectionPointTypes.map((name, i) => {\n\t\t\t\treturn {name: name, value: i};\n\t\t\t}),\n\t\t},\n\t});\n\tbool = ParamConfig.BOOLEAN(0, typed_visible_options(ConnectionPointType.BOOL));\n\tint = ParamConfig.INTEGER(0, typed_visible_options(ConnectionPointType.INT));\n\tfloat = ParamConfig.FLOAT(0, typed_visible_options(ConnectionPointType.FLOAT));\n\tvec2 = ParamConfig.VECTOR2([0, 0], typed_visible_options(ConnectionPointType.VEC2));\n\tvec3 = ParamConfig.VECTOR3([0, 0, 0], typed_visible_options(ConnectionPointType.VEC3));\n\tvec4 = ParamConfig.VECTOR4([0, 0, 0, 0], typed_visible_options(ConnectionPointType.VEC4));\n}\nconst ParamsConfig = new ConstantGlParamsConfig();\nexport class ConstantGlNode extends TypedGlNode<ConstantGlParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'constant';\n\t}\n\tstatic readonly OUTPUT_NAME = 'val';\n\tprivate _params_by_type: Map<ConnectionPointType, BaseParamType> | undefined;\n\tpublic readonly gl_connections_controller: GlConnectionsController = new GlConnectionsController(this);\n\tprotected _allow_inputs_created_from_params: boolean = false;\n\t// private _update_signature_if_required_bound = this._update_signature_if_required.bind(this);\n\tinitialize_node() {\n\t\tthis.gl_connections_controller.initialize_node();\n\n\t\tthis.gl_connections_controller.set_output_name_function((index: number) => ConstantGlNode.OUTPUT_NAME);\n\t\tthis.gl_connections_controller.set_expected_input_types_function(() => []);\n\t\tthis.gl_connections_controller.set_expected_output_types_function(() => [this._current_connection_type]);\n\t\t// this.params.add_on_scene_load_hook('_update_signature_if_required', this._update_signature_if_required_bound);\n\t\t// this.params.set_post_create_params_hook(this._update_signature_if_required_bound);\n\t\t// this.add_post_dirty_hook('_update_signature_if_required', this._update_signature_if_required_bound);\n\t}\n\t// _update_signature_if_required(dirty_trigger?: CoreGraphNode) {\n\t// \tif (!this.lifecycle.creation_completed || dirty_trigger == this.p.type) {\n\t// \t\tthis.update_output_type();\n\t// \t\tthis.remove_dirty_state();\n\t// \t\tthis.make_output_nodes_dirty();\n\t// \t}\n\t// }\n\n\tset_lines(shaders_collection_controller: ShadersCollectionController) {\n\t\tconst param = this._current_param;\n\t\tif (param) {\n\t\t\tconst connection_type = this._current_connection_type;\n\t\t\tconst value = ThreeToGl.any(param.value);\n\t\t\tconst var_value = this._current_var_name;\n\t\t\tconst body_line = `${connection_type} ${var_value} = ${value}`;\n\t\t\tshaders_collection_controller.add_body_lines(this, [body_line]);\n\t\t} else {\n\t\t\tconsole.warn(`no param found for constant node for type '${this.pv.type}'`);\n\t\t}\n\t}\n\n\tprivate get _current_connection_type() {\n\t\tif (this.pv.type == null) {\n\t\t\tconsole.warn('constant gl node type if not valid');\n\t\t}\n\t\tconst connection_type = ConnectionPointTypes[this.pv.type];\n\t\tif (connection_type == null) {\n\t\t\tconsole.warn('constant gl node type if not valid');\n\t\t}\n\t\treturn connection_type;\n\t}\n\n\tprivate get _current_param(): BaseParamType {\n\t\tthis._params_by_type =\n\t\t\tthis._params_by_type ||\n\t\t\tnew Map<ConnectionPointType, BaseParamType>([\n\t\t\t\t[ConnectionPointType.BOOL, this.p.bool],\n\t\t\t\t[ConnectionPointType.INT, this.p.int],\n\t\t\t\t[ConnectionPointType.FLOAT, this.p.float],\n\t\t\t\t[ConnectionPointType.VEC2, this.p.vec2],\n\t\t\t\t[ConnectionPointType.VEC3, this.p.vec3],\n\t\t\t\t[ConnectionPointType.VEC4, this.p.vec4],\n\t\t\t]);\n\t\tconst connection_type = ConnectionPointTypes[this.pv.type];\n\t\treturn this._params_by_type.get(connection_type)!;\n\t}\n\tprivate get _current_var_name(): string {\n\t\treturn this.gl_var_name(ConstantGlNode.OUTPUT_NAME);\n\t}\n\n\t// private update_output_type() {\n\t// \tconst set_dirty = false;\n\t// \tconst current_connection = this.io.outputs.named_output_connection_points[0];\n\t// \tif (current_connection && current_connection.type == this._current_connection_type) {\n\t// \t\treturn;\n\t// \t}\n\t// \tthis.io.outputs.set_named_output_connection_points(\n\t// \t\t[new TypedNamedConnectionPoint(this._current_connection_type, this._current_connection_type)],\n\t// \t\tset_dirty\n\t// \t);\n\t// }\n}\n","import {TypedGlNode} from './_Base';\nimport {ThreeToGl} from '../../../core/ThreeToGl';\nimport {TypedNamedConnectionPoint} from '../utils/connections/NamedConnectionPoint';\nimport {ConnectionPointType} from '../utils/connections/ConnectionPointType';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {ShadersCollectionController} from './code/utils/ShadersCollectionController';\n\n//\n//\n// FLOAT TO INT\n//\n//\nconst OUTPUT_NAME_INT = 'int';\nclass FloatToIntGlParamsConfig extends NodeParamsConfig {\n\tfloat = ParamConfig.FLOAT(0);\n}\nconst ParamsConfigFloatToInt = new FloatToIntGlParamsConfig();\nexport class FloatToIntGlNode extends TypedGlNode<FloatToIntGlParamsConfig> {\n\tparams_config = ParamsConfigFloatToInt;\n\tstatic type() {\n\t\treturn 'float_to_int';\n\t}\n\n\tinitialize_node() {\n\t\tthis.io.outputs.set_named_output_connection_points([\n\t\t\tnew TypedNamedConnectionPoint(OUTPUT_NAME_INT, ConnectionPointType.INT),\n\t\t]);\n\t}\n\n\tset_lines(shaders_collection_controller: ShadersCollectionController) {\n\t\tconst float = this.variable_for_input('float');\n\n\t\tconst int = this.gl_var_name('int');\n\t\tconst body_line = `int ${int} = int(${ThreeToGl.float(float)})`;\n\t\tshaders_collection_controller.add_body_lines(this, [body_line]);\n\t}\n}\n\n//\n//\n// INT TO FLOAT\n//\n//\nconst OUTPUT_NAME_FLOAT = 'float';\nclass IntToFloatGlParamsConfig extends NodeParamsConfig {\n\tint = ParamConfig.INTEGER(0);\n}\nconst ParamsConfigIntToFloat = new IntToFloatGlParamsConfig();\nexport class IntToFloatGlNode extends TypedGlNode<IntToFloatGlParamsConfig> {\n\tparams_config = ParamsConfigIntToFloat;\n\tstatic type() {\n\t\treturn 'int_to_float';\n\t}\n\n\tinitialize_node() {\n\t\tthis.io.outputs.set_named_output_connection_points([\n\t\t\tnew TypedNamedConnectionPoint(OUTPUT_NAME_FLOAT, ConnectionPointType.FLOAT),\n\t\t]);\n\t}\n\n\tset_lines(shaders_collection_controller: ShadersCollectionController) {\n\t\tconst int = this.variable_for_input('int');\n\n\t\tconst float = this.gl_var_name('float');\n\t\tconst body_line = `float ${float} = float(${ThreeToGl.int(int)})`;\n\t\tshaders_collection_controller.add_body_lines(this, [body_line]);\n\t}\n}\n","import {TypedGlNode} from './_Base';\nimport {ThreeToGl} from '../../../core/ThreeToGl';\nimport {TypedNamedConnectionPoint} from '../utils/connections/NamedConnectionPoint';\nimport {ConnectionPointType} from '../utils/connections/ConnectionPointType';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {ShadersCollectionController} from './code/utils/ShadersCollectionController';\n\n//\n//\n// FLOAT TO VEC2\n//\n//\nclass FloatToVec2GlParamsConfig extends NodeParamsConfig {\n\tx = ParamConfig.FLOAT(0);\n\ty = ParamConfig.FLOAT(0);\n}\nconst ParamsConfig2 = new FloatToVec2GlParamsConfig();\nexport class FloatToVec2GlNode extends TypedGlNode<FloatToVec2GlParamsConfig> {\n\tparams_config = ParamsConfig2;\n\tstatic type() {\n\t\treturn 'float_to_vec2';\n\t}\n\tstatic readonly OUTPUT_NAME = 'vec2';\n\n\tinitialize_node() {\n\t\tthis.io.outputs.set_named_output_connection_points([\n\t\t\tnew TypedNamedConnectionPoint(FloatToVec2GlNode.OUTPUT_NAME, ConnectionPointType.VEC2),\n\t\t]);\n\t}\n\n\tset_lines(shaders_collection_controller: ShadersCollectionController) {\n\t\tconst x = this.variable_for_input('x');\n\t\tconst y = this.variable_for_input('y');\n\n\t\tconst vec = this.gl_var_name(FloatToVec2GlNode.OUTPUT_NAME);\n\t\tconst body_line = `vec2 ${vec} = ${ThreeToGl.float2(x, y)}`;\n\t\tshaders_collection_controller.add_body_lines(this, [body_line]);\n\t}\n}\n\n//\n//\n// FLOAT TO VEC3\n//\n//\nclass FloatToVec3GlParamsConfig extends NodeParamsConfig {\n\tx = ParamConfig.FLOAT(0);\n\ty = ParamConfig.FLOAT(0);\n\tz = ParamConfig.FLOAT(0);\n}\nconst ParamsConfig3 = new FloatToVec3GlParamsConfig();\nexport class FloatToVec3GlNode extends TypedGlNode<FloatToVec3GlParamsConfig> {\n\tparams_config = ParamsConfig3;\n\tstatic type() {\n\t\treturn 'float_to_vec3';\n\t}\n\tstatic readonly OUTPUT_NAME = 'vec3';\n\n\tinitialize_node() {\n\t\tthis.io.outputs.set_named_output_connection_points([\n\t\t\tnew TypedNamedConnectionPoint(FloatToVec3GlNode.OUTPUT_NAME, ConnectionPointType.VEC3),\n\t\t]);\n\t}\n\n\tset_lines(shaders_collection_controller: ShadersCollectionController) {\n\t\tconst x = this.variable_for_input('x');\n\t\tconst y = this.variable_for_input('y');\n\t\tconst z = this.variable_for_input('z');\n\n\t\tconst vec = this.gl_var_name(FloatToVec3GlNode.OUTPUT_NAME);\n\t\tconst body_line = `vec3 ${vec} = ${ThreeToGl.float3(x, y, z)}`;\n\t\tshaders_collection_controller.add_body_lines(this, [body_line]);\n\t}\n}\n\n//\n//\n// FLOAT TO VEC4\n//\n//\nclass FloatToVec4GlParamsConfig extends NodeParamsConfig {\n\tx = ParamConfig.FLOAT(0);\n\ty = ParamConfig.FLOAT(0);\n\tz = ParamConfig.FLOAT(0);\n\tw = ParamConfig.FLOAT(0);\n}\nconst ParamsConfig4 = new FloatToVec4GlParamsConfig();\nexport class FloatToVec4GlNode extends TypedGlNode<FloatToVec4GlParamsConfig> {\n\tparams_config = ParamsConfig4;\n\tstatic type() {\n\t\treturn 'float_to_vec4';\n\t}\n\tstatic readonly OUTPUT_NAME = 'vec4';\n\n\tinitialize_node() {\n\t\tthis.io.outputs.set_named_output_connection_points([\n\t\t\tnew TypedNamedConnectionPoint(FloatToVec4GlNode.OUTPUT_NAME, ConnectionPointType.VEC4),\n\t\t]);\n\t}\n\n\tset_lines(shaders_collection_controller: ShadersCollectionController) {\n\t\tconst x = this.variable_for_input('x');\n\t\tconst y = this.variable_for_input('y');\n\t\tconst z = this.variable_for_input('z');\n\t\tconst w = this.variable_for_input('w');\n\n\t\tconst vec = this.gl_var_name(FloatToVec4GlNode.OUTPUT_NAME);\n\t\tconst body_line = `vec4 ${vec} = ${ThreeToGl.float4(x, y, z, w)}`;\n\t\tshaders_collection_controller.add_body_lines(this, [body_line]);\n\t}\n}\n","import {TypedGlNode} from './_Base';\nimport {ParamType} from '../../poly/ParamType';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {ConnectionPointType} from '../utils/connections/ConnectionPointType';\nimport {TypedNamedConnectionPoint} from '../utils/connections/NamedConnectionPoint';\nimport {ShadersCollectionController} from './code/utils/ShadersCollectionController';\n\nclass VecToParamsConfig extends NodeParamsConfig {}\nconst ParamsConfig = new VecToParamsConfig();\nclass BaseVecToGlNode extends TypedGlNode<VecToParamsConfig> {\n\tparams_config = ParamsConfig;\n}\n\ninterface VecToGlOptions {\n\tcomponents: string[];\n\tparam_type: ParamType;\n}\n\nfunction VecToGlFactory(type: string, options: VecToGlOptions) {\n\tconst components = options.components;\n\tconst param_type = options.param_type;\n\treturn class VecToGlNode extends BaseVecToGlNode {\n\t\tstatic type() {\n\t\t\treturn type;\n\t\t}\n\n\t\tinitialize_node() {\n\t\t\tthis.io.outputs.set_named_output_connection_points(\n\t\t\t\tcomponents.map((c) => {\n\t\t\t\t\treturn new TypedNamedConnectionPoint(c, ConnectionPointType.FLOAT);\n\t\t\t\t})\n\t\t\t);\n\t\t}\n\t\tcreate_params() {\n\t\t\tthis.add_param(param_type, 'vec', components.map((c) => 0) as Number2);\n\t\t}\n\n\t\tset_lines(shaders_collection_controller: ShadersCollectionController) {\n\t\t\tconst body_lines: string[] = [];\n\n\t\t\tconst vec = this.variable_for_input('vec');\n\n\t\t\tthis.io.outputs.used_output_names().forEach((c) => {\n\t\t\t\tconst var_name = this.gl_var_name(c);\n\t\t\t\tbody_lines.push(`float ${var_name} = ${vec}.${c}`);\n\t\t\t});\n\t\t\tshaders_collection_controller.add_body_lines(this, body_lines);\n\t\t}\n\t};\n}\n\nconst components_v4 = ['x', 'y', 'z', 'w'];\n\nexport class Vec2ToFloatGlNode extends VecToGlFactory('vec2_to_float', {\n\tcomponents: ['x', 'y'],\n\tparam_type: ParamType.VECTOR2,\n}) {}\nexport class Vec3ToFloatGlNode extends VecToGlFactory('vec3_to_float', {\n\tcomponents: ['x', 'y', 'z'],\n\tparam_type: ParamType.VECTOR3,\n}) {}\nexport class Vec4ToFloatGlNode extends VecToGlFactory('vec4_to_float', {\n\tcomponents: components_v4,\n\tparam_type: ParamType.VECTOR4,\n}) {}\n\nexport class Vec4ToVectorGlNode extends BaseVecToGlNode {\n\tstatic type() {\n\t\treturn 'vec4_to_vector';\n\t}\n\tstatic readonly INPUT_NAME_VEC4 = 'vec4';\n\tstatic readonly OUTPUT_NAME_VEC3 = 'vec3';\n\tstatic readonly OUTPUT_NAME_W = 'w';\n\n\tinitialize_node() {\n\t\tthis.io.outputs.set_named_output_connection_points([\n\t\t\tnew TypedNamedConnectionPoint(Vec4ToVectorGlNode.OUTPUT_NAME_VEC3, ConnectionPointType.VEC3),\n\t\t\tnew TypedNamedConnectionPoint(Vec4ToVectorGlNode.OUTPUT_NAME_W, ConnectionPointType.FLOAT),\n\t\t]);\n\t}\n\tcreate_params() {\n\t\tthis.add_param(ParamType.VECTOR4, Vec4ToVectorGlNode.INPUT_NAME_VEC4, components_v4.map((c) => 0) as Number4);\n\t}\n\n\tset_lines(shaders_collection_controller: ShadersCollectionController) {\n\t\tconst body_lines = [];\n\n\t\tconst in_vec4 = Vec4ToVectorGlNode.INPUT_NAME_VEC4;\n\t\tconst out_vec3 = Vec4ToVectorGlNode.OUTPUT_NAME_VEC3;\n\t\tconst out_w = Vec4ToVectorGlNode.OUTPUT_NAME_W;\n\t\tconst vec = this.variable_for_input(in_vec4);\n\n\t\tconst used_output_names = this.io.outputs.used_output_names();\n\n\t\tif (used_output_names.indexOf(out_vec3) >= 0) {\n\t\t\tconst var_name = this.gl_var_name(out_vec3);\n\t\t\tbody_lines.push(`vec3 ${var_name} = ${vec}.xyz`);\n\t\t}\n\t\tif (used_output_names.indexOf(out_w) >= 0) {\n\t\t\tconst var_name = this.gl_var_name(out_w);\n\t\t\tbody_lines.push(`float ${var_name} = ${vec}.w`);\n\t\t}\n\t\tshaders_collection_controller.add_body_lines(this, body_lines);\n\t}\n}\n","import {TypedGlNode} from './_Base';\n// import {ParamType} from '../../../Engine/Param/_Module';\n// import {ThreeToGl} from '../../../Core/ThreeToGl'\n\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\n// import {CoreGraphNode} from '../../../core/graph/CoreGraphNode';\n// import {ConnectionPointType} from '../utils/connections/ConnectionPointType';\nimport {GlConnectionsController} from './utils/ConnectionsController';\n// import {TypedNamedConnectionPoint} from '../utils/connections/NamedConnectionPoint';\n\nclass BaseAdaptiveParamsConfig extends NodeParamsConfig {}\n\nexport abstract class BaseAdaptiveGlNode<T extends BaseAdaptiveParamsConfig> extends TypedGlNode<T> {\n\t// protected abstract gl_output_name(): string;\n\t// protected abstract gl_input_name(index: number): string;\n\t// protected abstract expected_input_types(): ConnectionPointType[];\n\t// protected abstract expected_output_types(): ConnectionPointType[];\n\n\tpublic readonly gl_connections_controller: GlConnectionsController = new GlConnectionsController(this);\n\n\tinitialize_node() {\n\t\tsuper.initialize_node();\n\t\tthis.gl_connections_controller.initialize_node();\n\t}\n}\n","import lodash_range from 'lodash/range';\nimport lodash_compact from 'lodash/compact';\nimport {BaseAdaptiveGlNode} from './_BaseAdaptive';\nimport {ThreeToGl} from '../../../core/ThreeToGl';\nimport {ShadersCollectionController} from './code/utils/ShadersCollectionController';\nimport {ConnectionPointType} from '../utils/connections/ConnectionPointType';\nimport {GLDefinitionType, TypedGLDefinition} from './utils/GLDefinition';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\n\nexport class BaseGlMathFunctionParamsConfig extends NodeParamsConfig {}\nconst ParamsConfig = new BaseGlMathFunctionParamsConfig();\nexport abstract class BaseGlMathFunctionGlNode extends BaseAdaptiveGlNode<BaseGlMathFunctionParamsConfig> {\n\tparams_config = ParamsConfig;\n\tprotected gl_method_name() {\n\t\treturn '';\n\t}\n\tprotected gl_function_definitions(): TypedGLDefinition<GLDefinitionType>[] {\n\t\treturn [];\n\t}\n\n\tinitialize_node() {\n\t\tsuper.initialize_node();\n\t\tthis.gl_connections_controller.set_expected_input_types_function(this._expected_input_types.bind(this));\n\t\tthis.gl_connections_controller.set_expected_output_types_function(this._expected_output_types.bind(this));\n\t\tthis.gl_connections_controller.set_input_name_function(this._gl_input_name.bind(this));\n\t}\n\tprotected _expected_input_types(): ConnectionPointType[] {\n\t\tconst type: ConnectionPointType =\n\t\t\tthis.gl_connections_controller.first_input_connection_type() || ConnectionPointType.FLOAT;\n\t\tif (this.io.connections.first_input_connection()) {\n\t\t\tlet count = Math.max(lodash_compact(this.io.connections.input_connections()).length + 1, 2);\n\t\t\treturn lodash_range(count).map((i) => type);\n\t\t} else {\n\t\t\treturn lodash_range(2).map((i) => type);\n\t\t}\n\t}\n\tprotected _expected_output_types() {\n\t\tconst type = this._expected_input_types()[0];\n\t\treturn [type];\n\t}\n\tprotected _gl_input_name(index: number) {\n\t\treturn 'in';\n\t}\n\n\tset_lines(shaders_collection_controller: ShadersCollectionController) {\n\t\tconst var_type: ConnectionPointType = this.io.outputs.named_output_connection_points[0].type;\n\t\tconst args = this.io.inputs.named_input_connection_points.map((connection, i) => {\n\t\t\tconst name = connection.name;\n\t\t\treturn ThreeToGl.any(this.variable_for_input(name));\n\t\t});\n\t\tconst joined_args = args.join(', ');\n\n\t\tconst sum = this.gl_var_name(this.gl_connections_controller.output_name(0));\n\t\tconst body_line = `${var_type} ${sum} = ${this.gl_method_name()}(${joined_args})`;\n\t\tshaders_collection_controller.add_body_lines(this, [body_line]);\n\t\tshaders_collection_controller.add_definitions(this, this.gl_function_definitions());\n\t}\n}\n\n//\n//\n// 1 argument\n//\n//\nexport abstract class BaseNodeGlMathFunctionArg1GlNode extends BaseGlMathFunctionGlNode {\n\tprotected _gl_input_name(index: number) {\n\t\treturn 'in';\n\t}\n\tprotected _expected_input_types() {\n\t\tconst type = this.gl_connections_controller.first_input_connection_type() || ConnectionPointType.FLOAT;\n\t\treturn [type];\n\t}\n}\n\n//\n//\n// 2 arguments\n//\n//\nexport abstract class BaseNodeGlMathFunctionArg2GlNode extends BaseGlMathFunctionGlNode {\n\tprotected _expected_input_types() {\n\t\tconst type = this.gl_connections_controller.first_input_connection_type() || ConnectionPointType.FLOAT;\n\t\treturn [type, type];\n\t}\n}\n\n//\n//\n// 3 arguments\n//\n//\nexport abstract class BaseNodeGlMathFunctionArg3GlNode extends BaseGlMathFunctionGlNode {\n\tprotected _expected_input_types() {\n\t\tconst type = this.gl_connections_controller.first_input_connection_type() || ConnectionPointType.FLOAT;\n\t\treturn [type, type, type];\n\t}\n}\n//\n//\n// 4 arguments\n//\n//\nexport abstract class BaseNodeGlMathFunctionArg4GlNode extends BaseGlMathFunctionGlNode {\n\tprotected _expected_input_types() {\n\t\tconst type = this.gl_connections_controller.first_input_connection_type() || ConnectionPointType.FLOAT;\n\t\treturn [type, type, type, type];\n\t}\n}\n//\n//\n// 5 arguments\n//\n//\nexport abstract class BaseNodeGlMathFunctionArg5GlNode extends BaseGlMathFunctionGlNode {\n\tprotected _expected_input_types() {\n\t\tconst type = this.gl_connections_controller.first_input_connection_type() || ConnectionPointType.FLOAT;\n\t\treturn [type, type, type, type, type];\n\t}\n}\n","import {BaseNodeGlMathFunctionArg1GlNode} from './_BaseMathFunction';\n\ninterface MathArg1Options {\n\tin?: string;\n\tout?: string;\n\tmethod?: string;\n}\n\nfunction MathFunctionArg1Factory(type: string, options: MathArg1Options = {}) {\n\tconst gl_method_name = options.method || type;\n\tconst gl_output_name = options.out || 'val';\n\tconst gl_input_name = options.in || 'in';\n\treturn class Node extends BaseNodeGlMathFunctionArg1GlNode {\n\t\tstatic type() {\n\t\t\treturn type;\n\t\t}\n\t\tinitialize_node() {\n\t\t\tsuper.initialize_node();\n\t\t\tthis.gl_connections_controller.set_input_name_function(this._gl_input_name.bind(this));\n\t\t\tthis.gl_connections_controller.set_output_name_function(this._gl_output_name.bind(this));\n\t\t}\n\t\tprotected _gl_input_name(index: number): string {\n\t\t\treturn gl_input_name;\n\t\t}\n\t\tprotected _gl_output_name(index: number): string {\n\t\t\treturn gl_output_name;\n\t\t}\n\t\tgl_method_name(): string {\n\t\t\treturn gl_method_name;\n\t\t}\n\t};\n}\nexport class AbsGlNode extends MathFunctionArg1Factory('abs') {}\nexport class AcosGlNode extends MathFunctionArg1Factory('acos', {out: 'radians'}) {}\nexport class AsinGlNode extends MathFunctionArg1Factory('asin', {out: 'radians'}) {}\nexport class AtanGlNode extends MathFunctionArg1Factory('atan', {out: 'radians'}) {}\nexport class CeilGlNode extends MathFunctionArg1Factory('ceil') {}\nexport class CosGlNode extends MathFunctionArg1Factory('cos', {in: 'radians'}) {}\nexport class DegreesGlNode extends MathFunctionArg1Factory('degrees', {in: 'radians', out: 'degrees'}) {}\n\nexport class ExpGlNode extends MathFunctionArg1Factory('exp') {}\nexport class Exp2GlNode extends MathFunctionArg1Factory('exp2') {}\nexport class FloorGlNode extends MathFunctionArg1Factory('floor') {}\nexport class FractGlNode extends MathFunctionArg1Factory('fract') {}\nexport class InverseSqrtGlNode extends MathFunctionArg1Factory('inverse_sqrt', {method: 'inversesqrt'}) {}\nexport class LogGlNode extends MathFunctionArg1Factory('log') {}\nexport class Log2GlNode extends MathFunctionArg1Factory('log2') {}\nexport class NormalizeGlNode extends MathFunctionArg1Factory('normalize', {out: 'normalized'}) {}\nexport class RadiansGlNode extends MathFunctionArg1Factory('radians', {in: 'degrees', out: 'radians'}) {}\nexport class SignGlNode extends MathFunctionArg1Factory('sign') {}\nexport class SinGlNode extends MathFunctionArg1Factory('sin', {in: 'radians'}) {}\nexport class SqrtGlNode extends MathFunctionArg1Factory('sqrt') {}\nexport class TanGlNode extends MathFunctionArg1Factory('tan') {}\n","import {BaseNodeGlMathFunctionArg2GlNode} from './_BaseMathFunction';\nimport {ConnectionPointType} from '../utils/connections/ConnectionPointType';\nimport {FunctionGLDefinition} from './utils/GLDefinition';\n\ninterface MathArg2Options {\n\tin?: [string, string];\n\tout?: string;\n\tdefault_in_type?: ConnectionPointType;\n\tallowed_in_types?: ConnectionPointType[];\n\tout_type?: ConnectionPointType;\n\tmethod?: string;\n\tfunctions?: string[];\n}\n\nexport function MathFunctionArg2Factory(type: string, options: MathArg2Options = {}) {\n\tconst gl_method_name = options.method || type;\n\tconst gl_output_name = options.out || 'val';\n\tconst gl_input_names = options.in || ['in0', 'in1'];\n\tconst default_in_type = options.default_in_type;\n\tconst allowed_in_types = options.allowed_in_types;\n\tconst out_type = options.out_type;\n\tconst functions = options.functions || [];\n\treturn class Node extends BaseNodeGlMathFunctionArg2GlNode {\n\t\tstatic type() {\n\t\t\treturn type;\n\t\t}\n\t\tinitialize_node() {\n\t\t\tsuper.initialize_node();\n\t\t\tthis.gl_connections_controller.set_input_name_function(this._gl_input_name.bind(this));\n\t\t\tthis.gl_connections_controller.set_output_name_function(this._gl_output_name.bind(this));\n\n\t\t\tthis.gl_connections_controller.set_expected_input_types_function(this._expected_input_types.bind(this));\n\n\t\t\tif (out_type) {\n\t\t\t\tthis.gl_connections_controller.set_expected_output_types_function(() => [out_type]);\n\t\t\t}\n\t\t}\n\t\t_gl_input_name(index: number): string {\n\t\t\treturn gl_input_names[index];\n\t\t}\n\t\t_gl_output_name(index: number): string {\n\t\t\treturn gl_output_name;\n\t\t}\n\t\tgl_method_name(): string {\n\t\t\treturn gl_method_name;\n\t\t}\n\t\tgl_function_definitions(): FunctionGLDefinition[] {\n\t\t\tif (out_type) {\n\t\t\t\treturn functions.map((f) => new FunctionGLDefinition(this, out_type, f));\n\t\t\t} else {\n\t\t\t\treturn [];\n\t\t\t}\n\t\t}\n\t\tprotected _expected_input_types() {\n\t\t\tlet first_input_type = this.gl_connections_controller.first_input_connection_type();\n\t\t\tif (first_input_type && allowed_in_types) {\n\t\t\t\tif (!allowed_in_types.includes(first_input_type)) {\n\t\t\t\t\t// if the first input type is not allowed, either leave the connection point as is,\n\t\t\t\t\t// or use the default if there is none\n\t\t\t\t\tconst first_connection = this.io.inputs.named_input_connection_points[0];\n\t\t\t\t\tif (first_connection) {\n\t\t\t\t\t\tfirst_input_type = first_connection.type;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfirst_input_type = default_in_type;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst type = first_input_type || default_in_type || ConnectionPointType.FLOAT;\n\t\t\treturn [type, type];\n\t\t}\n\t};\n}\nexport class DistanceGlNode extends MathFunctionArg2Factory('distance', {\n\tin: ['p0', 'p1'],\n\tdefault_in_type: ConnectionPointType.VEC3,\n\tallowed_in_types: [ConnectionPointType.VEC2, ConnectionPointType.VEC3, ConnectionPointType.VEC4],\n\tout_type: ConnectionPointType.FLOAT,\n}) {}\nexport class DotGlNode extends MathFunctionArg2Factory('dot', {\n\tin: ['vec0', 'vec1'],\n\tdefault_in_type: ConnectionPointType.VEC3,\n\tallowed_in_types: [ConnectionPointType.VEC2, ConnectionPointType.VEC3, ConnectionPointType.VEC4],\n\tout_type: ConnectionPointType.FLOAT,\n}) {}\nexport class MaxGlNode extends MathFunctionArg2Factory('max') {}\nexport class MinGlNode extends MathFunctionArg2Factory('min') {}\nexport class ModGlNode extends MathFunctionArg2Factory('mod') {}\nexport class PowGlNode extends MathFunctionArg2Factory('pow', {in: ['x', 'y']}) {}\nexport class ReflectGlNode extends MathFunctionArg2Factory('reflect', {\n\tin: ['I', 'N'],\n\tdefault_in_type: ConnectionPointType.VEC3,\n}) {}\nexport class StepGlNode extends MathFunctionArg2Factory('step', {in: ['edge', 'x']}) {}\n","import {BaseNodeGlMathFunctionArg2GlNode} from './_BaseMathFunction';\nimport {ConnectionPointType} from '../utils/connections/ConnectionPointType';\nimport {ShadersCollectionController} from './code/utils/ShadersCollectionController';\nimport {ThreeToGl} from '../../../core/ThreeToGl';\n\ninterface MathArg2OperationOptions {\n\tin_prefix: string;\n\tout: string;\n\toperation: string;\n\tallowed_in_types?: ConnectionPointType[];\n}\n\nfunction MathFunctionArg2OperationFactory(type: string, options: MathArg2OperationOptions) {\n\tconst in_prefix = options.in_prefix || type;\n\tconst output_name = options.out || 'val';\n\tconst operation = options.operation;\n\tconst allowed_in_types = options.allowed_in_types;\n\treturn class Node extends BaseNodeGlMathFunctionArg2GlNode {\n\t\tstatic type() {\n\t\t\treturn type;\n\t\t}\n\t\tinitialize_node() {\n\t\t\tsuper.initialize_node();\n\t\t\tthis.gl_connections_controller.set_input_name_function(this._gl_input_name.bind(this));\n\t\t\tthis.gl_connections_controller.set_output_name_function(this._gl_output_name.bind(this));\n\n\t\t\tthis.gl_connections_controller.set_expected_input_types_function(this._expected_input_types.bind(this));\n\t\t\tthis.gl_connections_controller.set_expected_output_types_function(this._expected_output_types.bind(this));\n\t\t}\n\t\tset_lines(shaders_collection_controller: ShadersCollectionController) {\n\t\t\tconst var_type: ConnectionPointType = this.io.outputs.named_output_connection_points[0].type;\n\t\t\tconst args = this.io.inputs.named_input_connection_points.map((connection, i) => {\n\t\t\t\tconst name = connection.name;\n\t\t\t\tconst variable = this.variable_for_input(name);\n\t\t\t\tif (variable) {\n\t\t\t\t\treturn ThreeToGl.any(variable);\n\t\t\t\t}\n\t\t\t});\n\t\t\tconst joined_args = args.join(` ${this.gl_operation()} `);\n\n\t\t\tconst sum = this.gl_var_name(this.gl_connections_controller.output_name(0));\n\t\t\tconst body_line = `${var_type} ${sum} = ${this.gl_method_name()}(${joined_args})`;\n\t\t\tshaders_collection_controller.add_body_lines(this, [body_line]);\n\t\t}\n\t\t_gl_input_name(index: number): string {\n\t\t\treturn `${in_prefix}${index}`;\n\t\t}\n\t\t_gl_output_name(index: number): string {\n\t\t\treturn output_name;\n\t\t}\n\t\tgl_operation(): string {\n\t\t\treturn operation;\n\t\t}\n\t\tprotected _expected_input_types() {\n\t\t\tlet first_input_type = this.gl_connections_controller.first_input_connection_type();\n\t\t\tif (first_input_type && allowed_in_types) {\n\t\t\t\tif (!allowed_in_types.includes(first_input_type)) {\n\t\t\t\t\t// if the first input type is not allowed, either leave the connection point as is,\n\t\t\t\t\t// or use the default if there is none\n\t\t\t\t\tconst first_connection = this.io.inputs.named_input_connection_points[0];\n\t\t\t\t\tif (first_connection) {\n\t\t\t\t\t\tfirst_input_type = first_connection.type;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tconst type = first_input_type || ConnectionPointType.FLOAT;\n\n\t\t\tconst current_connections = this.io.connections.input_connections();\n\t\t\tconst expected_count = current_connections ? Math.max(current_connections.length + 1, 2) : 2;\n\t\t\tconst expected_input_types = [];\n\t\t\tfor (let i = 0; i < expected_count; i++) {\n\t\t\t\texpected_input_types.push(type);\n\t\t\t}\n\t\t\treturn expected_input_types;\n\t\t}\n\t\tprotected _expected_output_types() {\n\t\t\tconst type = this._expected_input_types()[0];\n\t\t\treturn [type];\n\t\t}\n\t};\n}\nexport class AddGlNode extends MathFunctionArg2OperationFactory('add', {\n\tin_prefix: 'add',\n\tout: 'sum',\n\toperation: '+',\n}) {}\nexport class DivideGlNode extends MathFunctionArg2OperationFactory('divide', {\n\tin_prefix: 'div',\n\tout: 'divide',\n\toperation: '/',\n}) {}\nexport class SubstractGlNode extends MathFunctionArg2OperationFactory('substract', {\n\tin_prefix: 'sub',\n\tout: 'substract',\n\toperation: '-',\n}) {}\n\nexport class MultGlNode extends MathFunctionArg2OperationFactory('mult', {\n\tin_prefix: 'mult',\n\tout: 'product',\n\toperation: '*',\n}) {\n\tstatic type() {\n\t\treturn 'mult';\n\t}\n\tgl_input_default_value(name: string) {\n\t\treturn 1;\n\t}\n\n\tinitialize_node() {\n\t\tsuper.initialize_node();\n\t\tthis.gl_connections_controller.set_expected_input_types_function(this._expected_input_types.bind(this));\n\t\tthis.gl_connections_controller.set_expected_output_types_function(this._expected_output_types.bind(this));\n\t}\n\tprotected _expected_output_type() {\n\t\tconst input_types = this._expected_input_types();\n\t\tconst type = input_types[input_types.length - 1];\n\t\treturn [type];\n\t}\n\n\tprotected _expected_input_types() {\n\t\tconst input_connections = this.io.connections.input_connections();\n\t\tif (input_connections) {\n\t\t\tconst first_connection = input_connections[0];\n\n\t\t\tif (first_connection) {\n\t\t\t\tconst connection_point_for_first_connection = this.io.inputs.named_input_connection_points[\n\t\t\t\t\tfirst_connection.input_index\n\t\t\t\t];\n\t\t\t\tconst type = connection_point_for_first_connection.type;\n\t\t\t\tconst expected_count = input_connections ? input_connections.length + 1 : 2;\n\t\t\t\tconst empty_array = new Array(expected_count);\n\n\t\t\t\tif (type == ConnectionPointType.FLOAT) {\n\t\t\t\t\tconst second_connection = input_connections ? input_connections[1] : null;\n\t\t\t\t\tif (second_connection) {\n\t\t\t\t\t\tconst connection_point_for_second_connection = this.io.inputs.named_input_connection_points[\n\t\t\t\t\t\t\tsecond_connection.input_index\n\t\t\t\t\t\t];\n\t\t\t\t\t\tconst second_type = connection_point_for_second_connection.type;\n\t\t\t\t\t\tif (second_type == ConnectionPointType.FLOAT) {\n\t\t\t\t\t\t\t// if first 2 inputs are float: n+1 float inputs\n\t\t\t\t\t\t\treturn empty_array.map((i) => type);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// if first input is float and 2nd is different: 1 float, 1 like second, and no other input\n\t\t\t\t\t\t\treturn [type, second_type];\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// if only 1 input: 2 with same type\n\t\t\t\t\t\treturn [type, type];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// if first input is not a float: n+1 inputs with same type\n\t\t\t\t\treturn empty_array.map(() => type);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn [ConnectionPointType.FLOAT, ConnectionPointType.FLOAT];\n\t}\n}\n","import {BaseNodeGlMathFunctionArg2GlNode} from './_BaseMathFunction';\n\nimport {ThreeToGl} from '../../../core/ThreeToGl';\nimport {ConnectionPointType} from '../utils/connections/ConnectionPointType';\nimport {ShadersCollectionController} from './code/utils/ShadersCollectionController';\n\nexport abstract class BaseNodeGlMathFunctionArgBoolean2GlNode extends BaseNodeGlMathFunctionArg2GlNode {\n\tinitialize_node() {\n\t\tsuper.initialize_node();\n\t\tthis.gl_connections_controller.set_expected_input_types_function(this._expected_input_types.bind(this));\n\t\tthis.gl_connections_controller.set_expected_output_types_function(this._expected_output_types.bind(this));\n\t}\n\tprotected _expected_input_types() {\n\t\treturn [ConnectionPointType.BOOL, ConnectionPointType.BOOL];\n\t}\n\n\tprotected _expected_output_types() {\n\t\treturn [ConnectionPointType.BOOL];\n\t}\n\n\tabstract boolean_operation(): string;\n\n\tset_lines(shaders_collection_controller: ShadersCollectionController) {\n\t\tconst args = this.io.inputs.named_input_connection_points.map((named_input, i) => {\n\t\t\tconst name = named_input.name;\n\t\t\treturn ThreeToGl.any(this.variable_for_input(name));\n\t\t});\n\t\tconst joined_args = args.join(` ${this.boolean_operation()} `);\n\n\t\tconst sum = this.gl_var_name(this.gl_connections_controller.output_name(0));\n\t\tconst body_line = `bool ${sum} = ${joined_args}`;\n\t\tshaders_collection_controller.add_body_lines(this, [body_line]);\n\t}\n}\n","import {BaseNodeGlMathFunctionArgBoolean2GlNode} from './_BaseMathFunctionArgBoolean2';\n\ninterface MathArg2BooleanOptions {\n\top: string;\n}\n\nfunction MathFunctionArg2BooleanFactory(type: string, options: MathArg2BooleanOptions) {\n\treturn class Node extends BaseNodeGlMathFunctionArgBoolean2GlNode {\n\t\tstatic type() {\n\t\t\treturn type;\n\t\t}\n\t\tinitialize_node() {\n\t\t\tsuper.initialize_node();\n\t\t\tthis.gl_connections_controller.set_input_name_function(this._gl_input_name.bind(this));\n\t\t\tthis.gl_connections_controller.set_output_name_function(this._gl_output_name.bind(this));\n\t\t}\n\n\t\tboolean_operation(): string {\n\t\t\treturn options.op;\n\t\t}\n\t\tprotected _gl_output_name(index: number) {\n\t\t\treturn type;\n\t\t}\n\t\tprotected _gl_input_name(index = 0) {\n\t\t\treturn `${type}${index}`;\n\t\t}\n\t};\n}\nexport class AndGlNode extends MathFunctionArg2BooleanFactory('and', {op: '&&'}) {}\nexport class OrGlNode extends MathFunctionArg2BooleanFactory('or', {op: '||'}) {}\n","export default \"\\n\\n// https://github.com/mattatz/ShibuyaCrowd/blob/master/source/shaders/common/quaternion.glsl\\nvec4 quat_mult(vec4 q1, vec4 q2)\\n{\\n\\treturn vec4(\\n\\tq1.w * q2.x + q1.x * q2.w + q1.z * q2.y - q1.y * q2.z,\\n\\tq1.w * q2.y + q1.y * q2.w + q1.x * q2.z - q1.z * q2.x,\\n\\tq1.w * q2.z + q1.z * q2.w + q1.y * q2.x - q1.x * q2.y,\\n\\tq1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z\\n\\t);\\n}\\n// http://glmatrix.net/docs/quat.js.html#line97\\n//   let ax = a[0], ay = a[1], az = a[2], aw = a[3];\\n\\n//   let bx = b[0], by = b[1], bz = b[2], bw = b[3];\\n\\n//   out[0] = ax * bw + aw * bx + ay * bz - az * by;\\n\\n//   out[1] = ay * bw + aw * by + az * bx - ax * bz;\\n\\n//   out[2] = az * bw + aw * bz + ax * by - ay * bx;\\n\\n//   out[3] = aw * bw - ax * bx - ay * by - az * bz;\\n\\n//   return out\\n\\n\\n\\n// http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\\nmat4 rotationMatrix(vec3 axis, float angle)\\n{\\n\\taxis = normalize(axis);\\n\\tfloat s = sin(angle);\\n\\tfloat c = cos(angle);\\n\\tfloat oc = 1.0 - c;\\n\\n \\treturn mat4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, 0.0, oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s,  0.0, oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c, 0.0, 0.0, 0.0, 0.0, 1.0);\\n}\\n\\n// https://www.geeks3d.com/20141201/how-to-rotate-a-vertex-by-a-quaternion-in-glsl/\\nvec4 quat_from_axis_angle(vec3 axis, float angle)\\n{\\n\\tvec4 qr;\\n\\tfloat half_angle = (angle * 0.5); // * 3.14159 / 180.0;\\n\\tfloat sin_half_angle = sin(half_angle);\\n\\tqr.x = axis.x * sin_half_angle;\\n\\tqr.y = axis.y * sin_half_angle;\\n\\tqr.z = axis.z * sin_half_angle;\\n\\tqr.w = cos(half_angle);\\n\\treturn qr;\\n}\\nvec3 rotate_with_axis_angle(vec3 position, vec3 axis, float angle)\\n{\\n\\tvec4 q = quat_from_axis_angle(axis, angle);\\n\\tvec3 v = position.xyz;\\n\\treturn v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\\n}\\n// vec3 applyQuaternionToVector( vec4 q, vec3 v ){\\n// \\treturn v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w * v );\\n// }\\nvec3 rotate_with_quat( vec3 v, vec4 q )\\n{\\n\\t// vec4 qv = multQuat( quat, vec4(vec, 0.0) );\\n\\t// return multQuat( qv, vec4(-quat.x, -quat.y, -quat.z, quat.w) ).xyz;\\n\\treturn v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w * v );\\n}\\n// https://github.com/glslify/glsl-look-at/blob/gh-pages/index.glsl\\n// mat3 rotation_matrix(vec3 origin, vec3 target, float roll) {\\n// \\tvec3 rr = vec3(sin(roll), cos(roll), 0.0);\\n// \\tvec3 ww = normalize(target - origin);\\n// \\tvec3 uu = normalize(cross(ww, rr));\\n// \\tvec3 vv = normalize(cross(uu, ww));\\n\\n// \\treturn mat3(uu, vv, ww);\\n// }\\n// mat3 rotation_matrix(vec3 target, float roll) {\\n// \\tvec3 rr = vec3(sin(roll), cos(roll), 0.0);\\n// \\tvec3 ww = normalize(target);\\n// \\tvec3 uu = normalize(cross(ww, rr));\\n// \\tvec3 vv = normalize(cross(uu, ww));\\n\\n// \\treturn mat3(uu, vv, ww);\\n// }\\n\\nfloat vector_angle(vec3 start, vec3 dest){\\n\\tstart = normalize(start);\\n\\tdest = normalize(dest);\\n\\n\\tfloat cosTheta = dot(start, dest);\\n\\tvec3 c1 = cross(start, dest);\\n\\t// We use the dot product of the cross with the Y axis.\\n\\t// This is a little arbitrary, but can still give a good sense of direction\\n\\tvec3 y_axis = vec3(0.0, 1.0, 0.0);\\n\\tfloat d1 = dot(c1, y_axis);\\n\\tfloat angle = acos(cosTheta) * sign(d1);\\n\\treturn angle;\\n}\\n\\n// http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-17-quaternions/#i-need-an-equivalent-of-glulookat-how-do-i-orient-an-object-towards-a-point-\\nvec4 vector_align(vec3 start, vec3 dest){\\n\\tstart = normalize(start);\\n\\tdest = normalize(dest);\\n\\n\\tfloat cosTheta = dot(start, dest);\\n\\tvec3 axis;\\n\\n\\t// if (cosTheta < -1 + 0.001f){\\n\\t// \\t// special case when vectors in opposite directions:\\n\\t// \\t// there is no \\\"ideal\\\" rotation axis\\n\\t// \\t// So guess one; any will do as long as it's perpendicular to start\\n\\t// \\taxis = cross(vec3(0.0f, 0.0f, 1.0f), start);\\n\\t// \\tif (length2(axis) < 0.01 ) // bad luck, they were parallel, try again!\\n\\t// \\t\\taxis = cross(vec3(1.0f, 0.0f, 0.0f), start);\\n\\n\\t// \\taxis = normalize(axis);\\n\\t// \\treturn gtx::quaternion::angleAxis(glm::radians(180.0f), axis);\\n\\t// }\\n\\tif(cosTheta > (1.0 - 0.0001) || cosTheta < (-1.0 + 0.0001) ){\\n\\t\\taxis = normalize(cross(start, vec3(0.0, 1.0, 0.0)));\\n\\t\\tif (length(axis) < 0.001 ){ // bad luck, they were parallel, try again!\\n\\t\\t\\taxis = normalize(cross(start, vec3(1.0, 0.0, 0.0)));\\n\\t\\t}\\n\\t} else {\\n\\t\\taxis = normalize(cross(start, dest));\\n\\t}\\n\\n\\tfloat angle = acos(cosTheta);\\n\\n\\treturn quat_from_axis_angle(axis, angle);\\n}\\nvec4 vector_align_with_up(vec3 start, vec3 dest, vec3 up){\\n\\tvec4 rot1 = vector_align(start, dest);\\n\\tup = normalize(up);\\n\\n\\t// Recompute desiredUp so that it's perpendicular to the direction\\n\\t// You can skip that part if you really want to force desiredUp\\n\\t// vec3 right = normalize(cross(dest, up));\\n\\t// up = normalize(cross(right, dest));\\n\\n\\t// Because of the 1rst rotation, the up is probably completely screwed up.\\n\\t// Find the rotation between the \\\"up\\\" of the rotated object, and the desired up\\n\\tvec3 newUp = rotate_with_quat(vec3(0.0, 1.0, 0.0), rot1);//rot1 * vec3(0.0, 1.0, 0.0);\\n\\tvec4 rot2 = vector_align(up, newUp);\\n\\n\\t// return rot1;\\n\\treturn rot2;\\n\\t// return multQuat(rot1, rot2);\\n\\t// return rot2 * rot1;\\n\\n}\\n\\n// https://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\\nfloat quat_to_angle(vec4 q){\\n\\treturn 2.0 * acos(q.w);\\n}\\nvec3 quat_to_axis(vec4 q){\\n\\treturn vec3(\\n\\t\\tq.x / sqrt(1.0-q.w*q.w),\\n\\t\\tq.y / sqrt(1.0-q.w*q.w),\\n\\t\\tq.z / sqrt(1.0-q.w*q.w)\\n\\t);\\n}\\n\\nvec4 align(vec3 dir, vec3 up){\\n\\tvec3 start_dir = vec3(0.0, 0.0, 1.0);\\n\\tvec3 start_up = vec3(0.0, 1.0, 0.0);\\n\\tvec4 rot1 = vector_align(start_dir, dir);\\n\\tup = normalize(up);\\n\\n\\t// Recompute desiredUp so that it's perpendicular to the direction\\n\\t// You can skip that part if you really want to force desiredUp\\n\\tvec3 right = normalize(cross(dir, up));\\n\\tif(length(right)<0.001){\\n\\t\\tright = vec3(1.0, 0.0, 0.0);\\n\\t}\\n\\tup = normalize(cross(right, dir));\\n\\n\\t// Because of the 1rst rotation, the up is probably completely screwed up.\\n\\t// Find the rotation between the \\\"up\\\" of the rotated object, and the desired up\\n\\tvec3 newUp = rotate_with_quat(start_up, rot1);//rot1 * vec3(0.0, 1.0, 0.0);\\n\\tvec4 rot2 = vector_align(normalize(newUp), up);\\n\\n\\t// return rot1;\\n\\treturn quat_mult(rot1, rot2);\\n\\t// return rot2 * rot1;\\n\\n}\"","import {BaseNodeGlMathFunctionArg2GlNode} from './_BaseMathFunction';\nimport Quaternion from './gl/quaternion.glsl';\nimport {ConnectionPointType} from '../utils/connections/ConnectionPointType';\nimport {FunctionGLDefinition} from './utils/GLDefinition';\n\nenum InputName {\n\tDIR = 'dir',\n\tUP = 'up',\n}\nconst InputNames: Array<InputName> = [InputName.DIR, InputName.UP];\ninterface IDefaultValues {\n\t[InputName.DIR]: Number3;\n\t[InputName.UP]: Number3;\n}\nconst DEFAULT_DIR: Number3 = [0, 0, 1];\nconst DEFAULT_UP: Number3 = [0, 1, 0];\nconst DefaultValues: IDefaultValues = {\n\t[InputName.DIR]: DEFAULT_DIR,\n\t[InputName.UP]: DEFAULT_UP,\n};\n\nexport class AlignGlNode extends BaseNodeGlMathFunctionArg2GlNode {\n\tstatic type() {\n\t\treturn 'align';\n\t}\n\n\tinitialize_node() {\n\t\tsuper.initialize_node();\n\n\t\tthis.gl_connections_controller.set_input_name_function((index: number) => InputNames[index]);\n\t\tthis.gl_connections_controller.set_expected_input_types_function(() => [\n\t\t\tConnectionPointType.VEC3,\n\t\t\tConnectionPointType.VEC3,\n\t\t]);\n\t\tthis.gl_connections_controller.set_expected_output_types_function(() => [ConnectionPointType.VEC4]);\n\t}\n\n\t// gl_input_name(index: number) {\n\t// \treturn InputNames[index];\n\t// }\n\tgl_input_default_value(name: string) {\n\t\treturn DefaultValues[name as InputName];\n\t}\n\tgl_method_name(): string {\n\t\treturn 'align';\n\t}\n\n\t// protected expected_input_types() {\n\t// \treturn [ConnectionPointType.VEC3, ConnectionPointType.VEC3];\n\t// }\n\t// protected expected_output_types() {\n\t// \treturn [ConnectionPointType.VEC4];\n\t// }\n\tgl_function_definitions() {\n\t\treturn [new FunctionGLDefinition(this, ConnectionPointType.VEC4, Quaternion)];\n\t}\n}\n","import {BaseNodeGlMathFunctionArg1GlNode} from './_BaseMathFunction';\nimport ComplementMethods from './gl/complement.glsl';\nimport {FunctionGLDefinition} from './utils/GLDefinition';\nimport {ConnectionPointType} from '../utils/connections/ConnectionPointType';\n\nexport class ComplementGlNode extends BaseNodeGlMathFunctionArg1GlNode {\n\tstatic type() {\n\t\treturn 'complement';\n\t}\n\n\tgl_method_name(): string {\n\t\treturn 'complement';\n\t}\n\n\tgl_function_definitions() {\n\t\treturn [\n\t\t\tnew FunctionGLDefinition(\n\t\t\t\tthis,\n\t\t\t\tthis.gl_connections_controller.first_input_connection_type() || ConnectionPointType.FLOAT,\n\t\t\t\tComplementMethods\n\t\t\t),\n\t\t];\n\t}\n}\n","export default \"float complement(float x){return 1.0-x;}\\nvec2 complement(vec2 x){return vec2(1.0-x.x, 1.0-x.y);}\\nvec3 complement(vec3 x){return vec3(1.0-x.x, 1.0-x.y, 1.0-x.z);}\\nvec4 complement(vec4 x){return vec4(1.0-x.x, 1.0-x.y, 1.0-x.z, 1.0-x.w);}\\n\"","import {TypedGlNode} from './_Base';\nimport {ThreeToGl} from '../../../../src/core/ThreeToGl';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {TypedNamedConnectionPoint} from '../utils/connections/NamedConnectionPoint';\nimport {ConnectionPointType} from '../utils/connections/ConnectionPointType';\nimport {ShadersCollectionController} from './code/utils/ShadersCollectionController';\n\nconst OUTPUT_NAME = 'cross';\n\nclass CrossGlParamsConfig extends NodeParamsConfig {\n\tx = ParamConfig.VECTOR3([0, 0, 1]);\n\ty = ParamConfig.VECTOR3([0, 1, 0]);\n}\nconst ParamsConfig = new CrossGlParamsConfig();\nexport class CrossGlNode extends TypedGlNode<CrossGlParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'cross';\n\t}\n\n\tinitialize_node() {\n\t\tsuper.initialize_node();\n\n\t\tthis.io.outputs.set_named_output_connection_points([\n\t\t\tnew TypedNamedConnectionPoint(OUTPUT_NAME, ConnectionPointType.VEC3),\n\t\t]);\n\t}\n\n\tset_lines(shaders_collection_controller: ShadersCollectionController) {\n\t\tconst x = ThreeToGl.float(this.variable_for_input('x'));\n\t\tconst y = ThreeToGl.float(this.variable_for_input('y'));\n\n\t\tconst result = this.gl_var_name(OUTPUT_NAME);\n\t\tconst body_line = `vec3 ${result} = cross(${x}, ${y})`;\n\t\tshaders_collection_controller.add_body_lines(this, [body_line]);\n\t}\n}\n","import {BaseNodeGlMathFunctionArg3GlNode} from './_BaseMathFunction';\nimport {ConnectionPointType} from '../utils/connections/ConnectionPointType';\nimport {FunctionGLDefinition} from './utils/GLDefinition';\ninterface MathArg3Options {\n\tin?: [string, string, string];\n\tout?: string;\n\tout_type?: ConnectionPointType;\n\tmethod?: string;\n\tdefault?: Dictionary<any>;\n\tfunctions?: string[];\n}\n\nexport function MathFunctionArg3Factory(type: string, options: MathArg3Options = {}) {\n\tconst gl_method_name = options.method || type;\n\tconst gl_output_name = options.out || 'val';\n\tconst gl_input_names = options.in || ['in0', 'in1', 'in2'];\n\tconst gl_input_default_values = options.default || {};\n\tconst out_type = options.out_type || ConnectionPointType.FLOAT;\n\tconst functions = options.functions || [];\n\treturn class Node extends BaseNodeGlMathFunctionArg3GlNode {\n\t\tstatic type() {\n\t\t\treturn type;\n\t\t}\n\t\tinitialize_node() {\n\t\t\tsuper.initialize_node();\n\t\t\tthis.gl_connections_controller.set_input_name_function(this._gl_input_name.bind(this));\n\t\t\tthis.gl_connections_controller.set_output_name_function(this._gl_output_name.bind(this));\n\t\t\tthis.gl_connections_controller.set_expected_output_types_function(this._expected_output_types.bind(this));\n\t\t}\n\t\tprotected _gl_input_name(index: number): string {\n\t\t\treturn gl_input_names[index];\n\t\t}\n\t\tprotected _gl_output_name(index: number): string {\n\t\t\treturn gl_output_name;\n\t\t}\n\t\tgl_method_name(): string {\n\t\t\treturn gl_method_name;\n\t\t}\n\t\tprotected _expected_output_types() {\n\t\t\treturn [out_type];\n\t\t}\n\t\tgl_input_default_value(name: string) {\n\t\t\treturn gl_input_default_values[name];\n\t\t}\n\t\tgl_function_definitions(): FunctionGLDefinition[] {\n\t\t\treturn functions.map((f) => new FunctionGLDefinition(this, out_type, f));\n\t\t}\n\t};\n}\nexport class ClampGlNode extends MathFunctionArg3Factory('clamp', {in: ['value', 'min', 'max'], default: {max: 1}}) {}\nexport class FaceforwardGlNode extends MathFunctionArg3Factory('face_forward', {in: ['N', 'I', 'Nref']}) {}\nexport class SmoothStepGlNode extends MathFunctionArg3Factory('smoothstep', {in: ['edge0', 'edge1', 'x']}) {}\n","import CycleMethods from './gl/cycle.glsl';\nimport {MathFunctionArg3Factory} from './_Math_Arg3';\n\nexport class CycleGlNode extends MathFunctionArg3Factory('cycle', {\n\tin: ['in', 'min', 'max'],\n\tdefault: {max: 1},\n\tfunctions: [CycleMethods],\n}) {}\n","export default \"float cycle(float val, float val_min, float val_max){\\n\\tif(val >= val_min && val < val_max){\\n\\t\\treturn val;\\n\\t} else {\\n\\t\\tfloat range = val_max - val_min;\\n\\t\\tif(val >= val_max){\\n\\t\\t\\tfloat delta = (val - val_max);\\n\\t\\t\\treturn val_min + mod(delta, range);\\n\\t\\t} else {\\n\\t\\t\\tfloat delta = (val_min - val);\\n\\t\\t\\treturn val_max - mod(delta, range);\\n\\t\\t}\\n\\t}\\n}\"","import {TypedGlNode} from './_Base';\nimport {ThreeToGl} from '../../../../src/core/ThreeToGl';\nimport DiskMethods from './gl/disk.glsl';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {ConnectionPointType} from '../utils/connections/ConnectionPointType';\nimport {ShadersCollectionController} from './code/utils/ShadersCollectionController';\nimport {FunctionGLDefinition} from './utils/GLDefinition';\nimport {TypedNamedConnectionPoint} from '../utils/connections/NamedConnectionPoint';\n\nconst OUTPUT_NAME = 'float';\nclass DiskGlParamsConfig extends NodeParamsConfig {\n\tposition = ParamConfig.VECTOR2([0, 0]);\n\tcenter = ParamConfig.VECTOR2([0, 0]);\n\tradius = ParamConfig.FLOAT(1);\n\tfeather = ParamConfig.FLOAT(0.1);\n}\nconst ParamsConfig = new DiskGlParamsConfig();\nexport class DiskGlNode extends TypedGlNode<DiskGlParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'disk';\n\t}\n\n\tinitialize_node() {\n\t\tsuper.initialize_node();\n\n\t\tthis.io.outputs.set_named_output_connection_points([\n\t\t\tnew TypedNamedConnectionPoint(OUTPUT_NAME, ConnectionPointType.FLOAT),\n\t\t]);\n\t}\n\n\tset_lines(shaders_collection_controller: ShadersCollectionController) {\n\t\tconst position = ThreeToGl.vector2(this.variable_for_input('position'));\n\t\tconst center = ThreeToGl.vector2(this.variable_for_input('center'));\n\t\tconst radius = ThreeToGl.float(this.variable_for_input('radius'));\n\t\tconst feather = ThreeToGl.float(this.variable_for_input('feather'));\n\n\t\tconst float = this.gl_var_name('float');\n\t\tconst body_line = `float ${float} = disk(${position}, ${center}, ${radius}, ${feather})`;\n\t\t// this.set_function_declaration_lines(function_declaration_lines)\n\t\tshaders_collection_controller.add_body_lines(this, [body_line]);\n\n\t\tshaders_collection_controller.add_definitions(this, [\n\t\t\tnew FunctionGLDefinition(this, ConnectionPointType.FLOAT, DiskMethods),\n\t\t]);\n\t}\n}\n","export default \"float disk(vec2 pos, vec2 center, float radius, float feather){\\n\\tfloat dist = distance(pos, center);\\n\\tif(feather <= 0.0){\\n\\t\\tif(dist < radius){return 1.0;}else{return 0.0;}\\n\\t} else {\\n\\t\\tfloat half_feather = feather * 0.5;\\n\\t\\tif(dist < (radius - half_feather)){\\n\\t\\t\\treturn 1.0;\\n\\t\\t} else {\\n\\t\\t\\tif(dist > (radius + half_feather)){\\n\\t\\t\\t\\treturn 0.0;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfloat feather_start = (radius - half_feather);\\n\\t\\t\\t\\tfloat blend = 1.0 - (dist - feather_start) / feather;\\n\\t\\t\\t\\treturn blend;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\"","export default \"float circularInOut(float t) {\\n  return t < 0.5\\n    ? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))\\n    : 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\\n}\\n\\n\"","export default \"\\nfloat bounceOut(float t) {\\n  const float a = 4.0 / 11.0;\\n  const float b = 8.0 / 11.0;\\n  const float c = 9.0 / 10.0;\\n\\n  const float ca = 4356.0 / 361.0;\\n  const float cb = 35442.0 / 1805.0;\\n  const float cc = 16061.0 / 1805.0;\\n\\n  float t2 = t * t;\\n\\n  return t < a\\n    ? 7.5625 * t2\\n    : t < b\\n      ? 9.075 * t2 - 9.9 * t + 3.4\\n      : t < c\\n        ? ca * t2 - cb * t + cc\\n        : 10.8 * t * t - 20.52 * t + 10.72;\\n}\\n\\n\"","import {TypedGlNode} from './_Base';\nimport {ThreeToGl} from '../../../../src/core/ThreeToGl';\n\n// https://github.com/glslify/glsl-easings\nimport CircularInOut from './gl/easing/circular-in-out.glsl';\nimport ExponentialInOut from './gl/easing/exponential-in-out.glsl';\nimport CircularIn from './gl/easing/circular-in.glsl';\nimport ElasticOut from './gl/easing/elastic-out.glsl';\nimport CubicIn from './gl/easing/cubic-in.glsl';\nimport ExponentialOut from './gl/easing/exponential-out.glsl';\nimport QuinticOut from './gl/easing/quintic-out.glsl';\nimport ElasticInOut from './gl/easing/elastic-in-out.glsl';\nimport Linear from './gl/easing/linear.glsl';\nimport CircularOut from './gl/easing/circular-out.glsl';\nimport BackInOut from './gl/easing/back-in-out.glsl';\nimport BackIn from './gl/easing/back-in.glsl';\nimport SineIn from './gl/easing/sine-in.glsl';\nimport BackOut from './gl/easing/back-out.glsl';\nimport QuarticInOut from './gl/easing/quartic-in-out.glsl';\nimport QuadraticIn from './gl/easing/quadratic-in.glsl';\nimport CubicInOut from './gl/easing/cubic-in-out.glsl';\nimport ElasticIn from './gl/easing/elastic-in.glsl';\nimport BounceOut from './gl/easing/bounce-out.glsl';\nimport QuadraticInOut from './gl/easing/quadratic-in-out.glsl';\nimport ExponentialIn from './gl/easing/exponential-in.glsl';\nimport QuinticInOut from './gl/easing/quintic-in-out.glsl';\nimport SineInOut from './gl/easing/sine-in-out.glsl';\nimport CubicOut from './gl/easing/cubic-out.glsl';\nimport QuadraticOut from './gl/easing/quadratic-out.glsl';\nimport BounceInOut from './gl/easing/bounce-in-out.glsl';\nimport QuinticIn from './gl/easing/quintic-in.glsl';\nimport QuarticIn from './gl/easing/quartic-in.glsl';\nimport QuarticOut from './gl/easing/quartic-out.glsl';\nimport BounceIn from './gl/easing/bounce-in.glsl';\nimport SineOut from './gl/easing/sine-out.glsl';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {ConnectionPointType} from '../utils/connections/ConnectionPointType';\nimport {ShadersCollectionController} from './code/utils/ShadersCollectionController';\nimport {TypedNamedConnectionPoint} from '../utils/connections/NamedConnectionPoint';\nimport {FunctionGLDefinition} from './utils/GLDefinition';\n\nconst EASE_NAMES = [\n\t'back-in-out',\n\t'back-in',\n\t'back-out',\n\t'bounce-in-out',\n\t'bounce-in',\n\t'bounce-out',\n\t'circular-in-out',\n\t'circular-in',\n\t'circular-out',\n\t'cubic-in-out',\n\t'cubic-in',\n\t'cubic-out',\n\t'elastic-in-out',\n\t'elastic-in',\n\t'elastic-out',\n\t'exponential-in-out',\n\t'exponential-in',\n\t'exponential-out',\n\t'linear',\n\t'quadratic-in-out',\n\t'quadratic-in',\n\t'quadratic-out',\n\t// \"quartic-in-out\",\n\t// \"quartic-in\",\n\t// \"quartic-out\",\n\t// \"quintic-in-out\",\n\t// \"quintic-in\",\n\t// \"quintic-out\",\n\t'sine-in-out',\n\t'sine-in',\n\t'sine-out',\n];\n\nconst IMPORT_BY_EASE_NAME: Dictionary<string> = {\n\t'circular-in-out': CircularInOut,\n\t'exponential-in-out': ExponentialInOut,\n\t'circular-in': CircularIn,\n\t'elastic-out': ElasticOut,\n\t'cubic-in': CubicIn,\n\t'exponential-out': ExponentialOut,\n\t'quintic-out': QuinticOut,\n\t'elastic-in-out': ElasticInOut,\n\tlinear: Linear,\n\t'circular-out': CircularOut,\n\t'back-in-out': BackInOut,\n\t'back-in': BackIn,\n\t'sine-in': SineIn,\n\t'back-out': BackOut,\n\t'quartic-in-out': QuarticInOut,\n\t'quadratic-in': QuadraticIn,\n\t'cubic-in-out': CubicInOut,\n\t'elastic-in': ElasticIn,\n\t'bounce-out': BounceOut,\n\t'quadratic-in-out': QuadraticInOut,\n\t'exponential-in': ExponentialIn,\n\t'quintic-in-out': QuinticInOut,\n\t'sine-in-out': SineInOut,\n\t'cubic-out': CubicOut,\n\t'quadratic-out': QuadraticOut,\n\t'bounce-in-out': BounceInOut,\n\t'quintic-in': QuinticIn,\n\t'quartic-in': QuarticIn,\n\t'quartic-out': QuarticOut,\n\t'bounce-in': BounceIn,\n\t'sine-out': SineOut,\n};\nconst IMPORT_DEPENDENCIES_BY_EASE_NAME: Dictionary<string[]> = {\n\t'bounce-in': [BounceOut],\n\t'bounce-in-out': [BounceOut],\n};\n\nconst METHOD_NAMES_BY_EASE_NAME: Dictionary<string> = {\n\t'circular-in-out': 'circularInOut',\n\t'exponential-in-out': 'exponentialInOut',\n\t'circular-in': 'circularIn',\n\t'elastic-out': 'elasticOut',\n\t'cubic-in': 'cubicIn',\n\t'exponential-out': 'exponentialOut',\n\t'quintic-out': 'quinticOut',\n\t'elastic-in-out': 'elasticInOut',\n\tlinear: 'linear',\n\t'circular-out': 'circularOut',\n\t'back-in-out': 'backInOut',\n\t'back-in': 'backIn',\n\t'sine-in': 'sineIn',\n\t'back-out': 'backOut',\n\t'quartic-in-out': 'quarticInOut',\n\t'quadratic-in': 'quadraticIn',\n\t'cubic-in-out': 'cubicInOut',\n\t'elastic-in': 'elasticIn',\n\t'bounce-out': 'bounceOut',\n\t'quadratic-in-out': 'quadraticInOut',\n\t'exponential-in': 'exponentialIn',\n\t'quintic-in-out': 'quinticInOut',\n\t'sine-in-out': 'sineInOut',\n\t'cubic-out': 'cubicOut',\n\t'quadratic-out': 'quadraticOut',\n\t'bounce-in-out': 'bounceInOut',\n\t'quintic-in': 'quinticIn',\n\t'quartic-in': 'quarticIn',\n\t'quartic-out': 'quarticOut',\n\t'bounce-in': 'bounceIn',\n\t'sine-out': 'sineOut',\n};\n\nconst OUTPUT_NAME = 'out';\nconst default_ease_type = EASE_NAMES.indexOf('sine-in-out');\nclass EasingGlParamsConfig extends NodeParamsConfig {\n\ttype = ParamConfig.INTEGER(default_ease_type, {\n\t\tmenu: {\n\t\t\tentries: EASE_NAMES.map((name, i) => {\n\t\t\t\treturn {name: name, value: i};\n\t\t\t}),\n\t\t},\n\t});\n\tinput = ParamConfig.FLOAT(0);\n}\nconst ParamsConfig = new EasingGlParamsConfig();\nexport class EasingGlNode extends TypedGlNode<EasingGlParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'easing';\n\t}\n\n\tinitialize_node() {\n\t\tsuper.initialize_node();\n\n\t\tthis.spare_params_controller.set_inputless_param_names(['type']);\n\n\t\tthis.io.outputs.set_named_output_connection_points([\n\t\t\tnew TypedNamedConnectionPoint(OUTPUT_NAME, ConnectionPointType.FLOAT),\n\t\t]);\n\t}\n\n\tset_lines(shaders_collection_controller: ShadersCollectionController) {\n\t\tconst ease_name = EASE_NAMES[this.pv.type];\n\t\tconst method_name = METHOD_NAMES_BY_EASE_NAME[ease_name];\n\t\tconst glsl_function_code = IMPORT_BY_EASE_NAME[ease_name];\n\n\t\tlet ease_functions = [new FunctionGLDefinition(this, ConnectionPointType.FLOAT, glsl_function_code)];\n\t\tconst function_dependencies = (IMPORT_DEPENDENCIES_BY_EASE_NAME[ease_name] || []).map(\n\t\t\t(f) => new FunctionGLDefinition(this, ConnectionPointType.FLOAT, f)\n\t\t);\n\t\tif (function_dependencies) {\n\t\t\tease_functions = function_dependencies.concat(ease_functions);\n\t\t}\n\t\t// ease_functions.forEach(ease_function=>{\n\t\t// \tfunction_declaration_lines.push(ease_function)\n\t\t// })\n\n\t\tconst in_value = ThreeToGl.float(this.variable_for_input('input'));\n\t\tconst out_value = this.gl_var_name(OUTPUT_NAME);\n\n\t\tconst body_line = `float ${out_value} = ${method_name}(${in_value})`;\n\t\tshaders_collection_controller.add_definitions(this, ease_functions);\n\t\tshaders_collection_controller.add_body_lines(this, [body_line]);\n\t}\n}\n","export default \"float exponentialInOut(float t) {\\n  return t == 0.0 || t == 1.0\\n    ? t\\n    : t < 0.5\\n      ? +0.5 * pow(2.0, (20.0 * t) - 10.0)\\n      : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\\n}\\n\\n\"","export default \"float circularIn(float t) {\\n  return 1.0 - sqrt(1.0 - t * t);\\n}\\n\\n\"","export default \"#ifndef HALF_PI\\n#define HALF_PI 1.5707963267948966\\n#endif\\n\\nfloat elasticOut(float t) {\\n  return sin(-13.0 * (t + 1.0) * HALF_PI) * pow(2.0, -10.0 * t) + 1.0;\\n}\\n\\n\"","export default \"float cubicIn(float t) {\\n  return t * t * t;\\n}\\n\\n\"","export default \"float exponentialOut(float t) {\\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\\n}\\n\\n\"","export default \"float quinticOut(float t) {\\n  return 1.0 - (pow(t - 1.0, 5.0));\\n}\\n\\n\"","export default \"#ifndef HALF_PI\\n#define HALF_PI 1.5707963267948966\\n#endif\\n\\nfloat elasticInOut(float t) {\\n  return t < 0.5\\n    ? 0.5 * sin(+13.0 * HALF_PI * 2.0 * t) * pow(2.0, 10.0 * (2.0 * t - 1.0))\\n    : 0.5 * sin(-13.0 * HALF_PI * ((2.0 * t - 1.0) + 1.0)) * pow(2.0, -10.0 * (2.0 * t - 1.0)) + 1.0;\\n}\\n\\n\"","export default \"float linear(float t) {\\n  return t;\\n}\\n\\n\"","export default \"float circularOut(float t) {\\n  return sqrt((2.0 - t) * t);\\n}\\n\\n\"","export default \"\\nfloat backInOut(float t) {\\n  float f = t < 0.5\\n    ? 2.0 * t\\n    : 1.0 - (2.0 * t - 1.0);\\n\\n  float g = pow(f, 3.0) - f * sin(f * PI);\\n\\n  return t < 0.5\\n    ? 0.5 * g\\n    : 0.5 * (1.0 - g) + 0.5;\\n}\\n\\n\"","export default \"\\nfloat backIn(float t) {\\n  return pow(t, 3.0) - t * sin(t * PI);\\n}\\n\\n\"","export default \"#ifndef HALF_PI\\n#define HALF_PI 1.5707963267948966\\n#endif\\n\\nfloat sineIn(float t) {\\n  return sin((t - 1.0) * HALF_PI) + 1.0;\\n}\\n\\n\"","export default \"\\nfloat backOut(float t) {\\n  float f = 1.0 - t;\\n  return 1.0 - (pow(f, 3.0) - f * sin(f * PI));\\n}\\n\\n\"","export default \"float quarticInOut(float t) {\\n  return t < 0.5\\n    ? +8.0 * pow(t, 4.0)\\n    : -8.0 * pow(t - 1.0, 4.0) + 1.0;\\n}\\n\\n\"","export default \"float quadraticIn(float t) {\\n  return t * t;\\n}\\n\\n\"","export default \"float cubicInOut(float t) {\\n  return t < 0.5\\n    ? 4.0 * t * t * t\\n    : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\\n}\\n\\n\"","export default \"#ifndef HALF_PI\\n#define HALF_PI 1.5707963267948966\\n#endif\\n\\nfloat elasticIn(float t) {\\n  return sin(13.0 * t * HALF_PI) * pow(2.0, 10.0 * (t - 1.0));\\n}\\n\\n\"","export default \"float quadraticInOut(float t) {\\n  float p = 2.0 * t * t;\\n  return t < 0.5 ? p : -p + (4.0 * t) - 1.0;\\n}\\n\\n\"","export default \"float exponentialIn(float t) {\\n  return t == 0.0 ? t : pow(2.0, 10.0 * (t - 1.0));\\n}\\n\\n\"","export default \"float quinticInOut(float t) {\\n  return t < 0.5\\n    ? +16.0 * pow(t, 5.0)\\n    : -0.5 * pow(2.0 * t - 2.0, 5.0) + 1.0;\\n}\\n\\n\"","export default \"\\nfloat sineInOut(float t) {\\n  return -0.5 * (cos(PI * t) - 1.0);\\n}\\n\\n\"","export default \"float cubicOut(float t) {\\n  float f = t - 1.0;\\n  return f * f * f + 1.0;\\n}\\n\\n\"","export default \"float quadraticOut(float t) {\\n  return -t * (t - 2.0);\\n}\\n\\n\"","export default \"\\nfloat bounceInOut(float t) {\\n  return t < 0.5\\n    ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0))\\n    : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;\\n}\\n\\n\\n\\n\"","export default \"float quinticIn(float t) {\\n  return pow(t, 5.0);\\n}\\n\\n\"","export default \"float quarticIn(float t) {\\n  return pow(t, 4.0);\\n}\\n\\n\"","export default \"float quarticOut(float t) {\\n  return pow(t - 1.0, 3.0) * (1.0 - t) + 1.0;\\n}\\n\\n\"","export default \"\\nfloat bounceIn(float t) {\\n  return 1.0 - bounceOut(1.0 - t);\\n}\\n\\n\"","export default \"#ifndef HALF_PI\\n#define HALF_PI 1.5707963267948966\\n#endif\\n\\nfloat sineOut(float t) {\\n  return sin(t * HALF_PI);\\n}\\n\\n\"","export default \"\\nfloat fit01(float val, float src_min, float src_max){\\n\\tfloat size = src_max - src_min;\\n\\treturn (val - src_min) / size;\\n}\\nvec2 fit01(vec2 val, vec2 src_min, vec2 src_max){\\n\\treturn vec2(\\n\\t\\tfit01(val.x, src_min.x, src_max.x),\\n\\t\\tfit01(val.y, src_min.y, src_max.y)\\n\\t);\\n}\\nvec3 fit01(vec3 val, vec3 src_min, vec3 src_max){\\n\\treturn vec3(\\n\\t\\tfit01(val.x, src_min.x, src_max.x),\\n\\t\\tfit01(val.y, src_min.y, src_max.y),\\n\\t\\tfit01(val.z, src_min.z, src_max.z)\\n\\t);\\n}\\nvec4 fit01(vec4 val, vec4 src_min, vec4 src_max){\\n\\treturn vec4(\\n\\t\\tfit01(val.x, src_min.x, src_max.x),\\n\\t\\tfit01(val.y, src_min.y, src_max.y),\\n\\t\\tfit01(val.z, src_min.z, src_max.z),\\n\\t\\tfit01(val.w, src_min.w, src_max.w)\\n\\t);\\n}\\n\\nfloat fit(float val, float src_min, float src_max, float dest_min, float dest_max){\\n\\tfloat  src_range = src_max - src_min;\\n\\tfloat dest_range = dest_max - dest_min;\\n\\n\\tfloat r = (val - src_min) / src_range;\\n\\treturn (r * dest_range) + dest_min;\\n}\\nvec2 fit(vec2 val, vec2 src_min, vec2 src_max, vec2 dest_min, vec2 dest_max){\\n\\treturn vec2(\\n\\t\\tfit(val.x, src_min.x, src_max.x, dest_min.x, dest_max.x),\\n\\t\\tfit(val.y, src_min.y, src_max.y, dest_min.y, dest_max.y)\\n\\t);\\n}\\nvec3 fit(vec3 val, vec3 src_min, vec3 src_max, vec3 dest_min, vec3 dest_max){\\n\\treturn vec3(\\n\\t\\tfit(val.x, src_min.x, src_max.x, dest_min.x, dest_max.x),\\n\\t\\tfit(val.y, src_min.y, src_max.y, dest_min.y, dest_max.y),\\n\\t\\tfit(val.z, src_min.z, src_max.z, dest_min.z, dest_max.z)\\n\\t);\\n}\\nvec4 fit(vec4 val, vec4 src_min, vec4 src_max, vec4 dest_min, vec4 dest_max){\\n\\treturn vec4(\\n\\t\\tfit(val.x, src_min.x, src_max.x, dest_min.x, dest_max.x),\\n\\t\\tfit(val.y, src_min.y, src_max.y, dest_min.y, dest_max.y),\\n\\t\\tfit(val.z, src_min.z, src_max.z, dest_min.z, dest_max.z),\\n\\t\\tfit(val.w, src_min.w, src_max.w, dest_min.w, dest_max.w)\\n\\t);\\n}\\n\"","import {BaseNodeGlMathFunctionArg5GlNode} from './_BaseMathFunction';\nimport FitMethods from './gl/fit.glsl';\nimport {FunctionGLDefinition} from './utils/GLDefinition';\nimport {ConnectionPointType} from '../utils/connections/ConnectionPointType';\n\nconst DefaultValues: Dictionary<number> = {\n\tsrc_min: 0,\n\tsrc_max: 1,\n};\n\nexport class FitGlNode extends BaseNodeGlMathFunctionArg5GlNode {\n\tstatic type() {\n\t\treturn 'fit';\n\t}\n\n\tprotected _gl_input_name(index: number): string {\n\t\treturn ['val', 'src_min', 'src_max', 'dest_min', 'dest_max'][index];\n\t}\n\tgl_input_default_value(name: string) {\n\t\treturn DefaultValues[name];\n\t}\n\tprotected gl_method_name(): string {\n\t\treturn 'fit';\n\t}\n\n\tgl_function_definitions() {\n\t\treturn [new FunctionGLDefinition(this, ConnectionPointType.FLOAT, FitMethods)];\n\t}\n}\n","import {BaseNodeGlMathFunctionArg3GlNode} from './_BaseMathFunction';\nimport FitMethods from './gl/fit.glsl';\nimport {FunctionGLDefinition} from './utils/GLDefinition';\nimport {ConnectionPointType} from '../utils/connections/ConnectionPointType';\n\nconst DefaultValues: Dictionary<number> = {\n\tsrc_min: 0,\n\tsrc_max: 1,\n};\n\nexport class Fit01GlNode extends BaseNodeGlMathFunctionArg3GlNode {\n\tstatic type() {\n\t\treturn 'fit01';\n\t}\n\n\tgl_input_name(index: number): string {\n\t\treturn ['val', 'src_min', 'src_max'][index];\n\t}\n\tgl_input_default_value(name: string) {\n\t\treturn DefaultValues[name];\n\t}\n\tgl_method_name(): string {\n\t\treturn 'fit01';\n\t}\n\n\tgl_function_definitions() {\n\t\treturn [new FunctionGLDefinition(this, ConnectionPointType.FLOAT, FitMethods)];\n\t}\n}\n","import {TypedGlNode} from './_Base';\nimport {ThreeToGl} from '../../../../src/core/ThreeToGl';\n\nimport Hsv2Rgb from './gl/hsv2rgb.glsl';\nimport {ConnectionPointType} from '../utils/connections/ConnectionPointType';\nimport {TypedNamedConnectionPoint} from '../utils/connections/NamedConnectionPoint';\nimport {ShadersCollectionController} from './code/utils/ShadersCollectionController';\nimport {FunctionGLDefinition} from './utils/GLDefinition';\n\nconst OUTPUT_NAME = 'rgb';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nclass HsvToRgbGlParamsConfig extends NodeParamsConfig {\n\thsv = ParamConfig.VECTOR3([1, 1, 1]);\n}\nconst ParamsConfig = new HsvToRgbGlParamsConfig();\nexport class HsvToRgbGlNode extends TypedGlNode<HsvToRgbGlParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'hsv_to_rgb';\n\t}\n\n\tinitialize_node() {\n\t\tsuper.initialize_node();\n\n\t\tthis.io.outputs.set_named_output_connection_points([\n\t\t\tnew TypedNamedConnectionPoint(OUTPUT_NAME, ConnectionPointType.VEC3),\n\t\t]);\n\t}\n\n\tset_lines(shaders_collection_controller: ShadersCollectionController) {\n\t\tconst function_declaration_lines = [];\n\t\tconst body_lines = [];\n\n\t\tfunction_declaration_lines.push(new FunctionGLDefinition(this, ConnectionPointType.VEC3, Hsv2Rgb));\n\n\t\tconst value = ThreeToGl.vector3(this.variable_for_input(this.p.hsv.name));\n\n\t\tconst rgb = this.gl_var_name(OUTPUT_NAME);\n\t\tbody_lines.push(`vec3 ${rgb} = hsv2rgb(${value})`);\n\t\tshaders_collection_controller.add_definitions(this, function_declaration_lines);\n\t\tshaders_collection_controller.add_body_lines(this, body_lines);\n\t}\n}\n","export default \"// https://github.com/hughsk/glsl-hsv2rgb\\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\\nvec3 hsv2rgb(vec3 c) {\\n\\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\\n\\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\\n\\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\\n}\"","import {TypedGlNode} from './_Base';\nimport {ThreeToGl} from '../../../core/ThreeToGl';\n\nimport QuaternionMethods from './gl/quaternion.glsl';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {ConnectionPointType} from '../utils/connections/ConnectionPointType';\nimport {TypedNamedConnectionPoint} from '../utils/connections/NamedConnectionPoint';\nimport {ShadersCollectionController} from './code/utils/ShadersCollectionController';\nimport {FunctionGLDefinition} from './utils/GLDefinition';\n\nconst VARS = {\n\tposition: 'position',\n\tnormal: 'normal',\n\tinstance_position: 'instancePosition',\n\tinstance_orientation: 'instanceOrientation',\n\tinstance_scale: 'instanceScale',\n};\n\nclass InstanceTransformGlParamsConfig extends NodeParamsConfig {\n\tposition = ParamConfig.VECTOR3([0, 0, 0]);\n\tnormal = ParamConfig.VECTOR3([0, 0, 1]);\n\tinstance_position = ParamConfig.VECTOR3([0, 0, 0]);\n\tinstance_orientation = ParamConfig.VECTOR4([0, 0, 0, 0]);\n\tinstance_scale = ParamConfig.VECTOR3([1, 1, 1]);\n}\nconst ParamsConfig = new InstanceTransformGlParamsConfig();\nexport class InstanceTransformGlNode extends TypedGlNode<InstanceTransformGlParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'instance_transform';\n\t}\n\n\tinitialize_node() {\n\t\tsuper.initialize_node();\n\n\t\tthis.io.outputs.set_named_output_connection_points([\n\t\t\tnew TypedNamedConnectionPoint(this.gl_output_name_position(), ConnectionPointType.VEC3),\n\t\t\tnew TypedNamedConnectionPoint(this.gl_output_name_normal(), ConnectionPointType.VEC3),\n\t\t]);\n\t}\n\n\tset_lines(shaders_collection_controller: ShadersCollectionController) {\n\t\tconst body_lines = [];\n\t\tconst function_declaration_lines = [];\n\n\t\tfunction_declaration_lines.push(new FunctionGLDefinition(this, ConnectionPointType.VEC4, QuaternionMethods));\n\n\t\tconst input_position = this.io.inputs.named_input(this.p.position.name);\n\t\tconst position = input_position\n\t\t\t? ThreeToGl.float(this.variable_for_input(this.p.position.name))\n\t\t\t: this._default_position();\n\n\t\tconst input_normal = this.io.inputs.named_input(this.p.normal.name);\n\t\tconst normal = input_normal\n\t\t\t? ThreeToGl.float(this.variable_for_input(this.p.normal.name))\n\t\t\t: this._default_normal();\n\n\t\tconst input_instancePosition = this.io.inputs.named_input(this.p.instance_position.name);\n\t\tconst instancePosition = input_instancePosition\n\t\t\t? ThreeToGl.float(this.variable_for_input(this.p.instance_position.name))\n\t\t\t: this._default_instance_position(shaders_collection_controller);\n\t\t// const instancePosition = ThreeToGl.float(this.variable_for_input('instancePosition'))\n\n\t\tconst input_instanceOrientation = this.io.inputs.named_input(this.p.instance_orientation.name);\n\t\tconst instanceOrientation = input_instanceOrientation\n\t\t\t? ThreeToGl.float(this.variable_for_input(this.p.instance_orientation.name))\n\t\t\t: this._default_input_instance_orientation(shaders_collection_controller);\n\n\t\tconst input_instanceScale = this.io.inputs.named_input(this.p.instance_scale.name);\n\t\tconst instanceScale = input_instanceScale\n\t\t\t? ThreeToGl.float(this.variable_for_input(this.p.instance_scale.name))\n\t\t\t: this._default_input_instance_scale(shaders_collection_controller);\n\n\t\tconst result_position = this.gl_var_name(this.gl_output_name_position());\n\t\tconst result_normal = this.gl_var_name(this.gl_output_name_normal());\n\t\tbody_lines.push(`vec3 ${result_position} = vec3(${position})`);\n\t\tbody_lines.push(`${result_position} *= ${instanceScale}`);\n\t\tbody_lines.push(`${result_position} = rotate_with_quat( ${result_position}, ${instanceOrientation} )`);\n\t\tbody_lines.push(`${result_position} += ${instancePosition}`);\n\t\tbody_lines.push(`vec3 ${result_normal} = vec3(${normal})`);\n\t\tbody_lines.push(`${result_normal} = rotate_with_quat( ${result_normal}, ${instanceOrientation} )`);\n\n\t\tshaders_collection_controller.add_body_lines(this, body_lines);\n\t\tshaders_collection_controller.add_definitions(this, function_declaration_lines);\n\t}\n\tgl_output_name_position() {\n\t\treturn 'position';\n\t}\n\tgl_output_name_normal() {\n\t\treturn 'normal';\n\t}\n\n\tprivate _default_position(): string {\n\t\treturn VARS.position;\n\t}\n\tprivate _default_normal(): string {\n\t\treturn VARS.normal;\n\t}\n\tprivate _default_instance_position(shaders_collection_controller: ShadersCollectionController): string | undefined {\n\t\treturn this.material_node?.assembler_controller.assembler.globals_handler?.read_attribute(\n\t\t\tthis,\n\t\t\tConnectionPointType.VEC3,\n\t\t\tVARS.instance_position,\n\t\t\tshaders_collection_controller\n\t\t);\n\t\t// return this.assembler()\n\t\t// \t.globals_handler()\n\t\t// \t.read_attribute(this, 'vec3', VARS.instance_position, this._shader_name);\n\t}\n\tprivate _default_input_instance_orientation(shaders_collection_controller: ShadersCollectionController) {\n\t\treturn this.material_node?.assembler_controller.assembler.globals_handler?.read_attribute(\n\t\t\tthis,\n\t\t\tConnectionPointType.VEC4,\n\t\t\tVARS.instance_orientation,\n\t\t\tshaders_collection_controller\n\t\t);\n\t\t// return this.assembler()\n\t\t// \t.globals_handler()\n\t\t// \t.read_attribute(this, 'vec4', VARS.instance_orientation, this._shader_name);\n\t}\n\tprivate _default_input_instance_scale(shaders_collection_controller: ShadersCollectionController) {\n\t\treturn this.material_node?.assembler_controller.assembler.globals_handler?.read_attribute(\n\t\t\tthis,\n\t\t\tConnectionPointType.VEC3,\n\t\t\tVARS.instance_scale,\n\t\t\tshaders_collection_controller\n\t\t);\n\t\t// return this.assembler()\n\t\t// \t.globals_handler()\n\t\t// \t.read_attribute(this, 'vec3', VARS.instance_scale, this._shader_name);\n\t}\n}\n","import {BaseNodeGlMathFunctionArg1GlNode} from './_BaseMathFunction';\nimport {ConnectionPointType} from '../utils/connections/ConnectionPointType';\n\nexport class LengthGlNode extends BaseNodeGlMathFunctionArg1GlNode {\n\tstatic type() {\n\t\treturn 'length';\n\t}\n\n\tinitialize_node() {\n\t\tsuper.initialize_node();\n\n\t\tthis.gl_connections_controller.set_input_name_function(this._gl_input_name.bind(this));\n\t\tthis.gl_connections_controller.set_expected_output_types_function(this._expected_output_types.bind(this));\n\t}\n\n\tprotected _gl_input_name(index: number) {\n\t\treturn ['x'][index];\n\t}\n\tgl_method_name(): string {\n\t\treturn 'length';\n\t}\n\n\tprotected _expected_output_types() {\n\t\treturn [ConnectionPointType.FLOAT];\n\t}\n}\n","import {TypedGlNode} from './_Base';\nimport {ConnectionPointType} from '../utils/connections/ConnectionPointType';\nimport {TypedNamedConnectionPoint} from '../utils/connections/NamedConnectionPoint';\nimport {ThreeToGl} from '../../../core/ThreeToGl';\nimport {ShadersCollectionController} from './code/utils/ShadersCollectionController';\n\nconst OUTPUT_NAME = 'lum';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nclass LuminanceGlParamsConfig extends NodeParamsConfig {\n\thsv = ParamConfig.VECTOR3([1, 1, 1]);\n}\nconst ParamsConfig = new LuminanceGlParamsConfig();\nexport class LuminanceGlNode extends TypedGlNode<LuminanceGlParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'luminance';\n\t}\n\n\tinitialize_node() {\n\t\tsuper.initialize_node();\n\n\t\tthis.io.outputs.set_named_output_connection_points([\n\t\t\tnew TypedNamedConnectionPoint(OUTPUT_NAME, ConnectionPointType.FLOAT),\n\t\t]);\n\t}\n\n\tset_lines(shaders_collection_controller: ShadersCollectionController) {\n\t\tconst value = ThreeToGl.vector3(this.variable_for_input('color'));\n\n\t\tconst lum = this.gl_var_name('lum');\n\t\t// linearToRelativeLuminance is declared in threejs common.glsl.js\n\t\tconst body_line = `float ${lum} = linearToRelativeLuminance(${value})`;\n\t\tshaders_collection_controller.add_body_lines(this, [body_line]);\n\t}\n}\n","import {BaseGlMathFunctionGlNode} from './_BaseMathFunction';\nimport {ConnectionPointType} from '../utils/connections/ConnectionPointType';\n\nexport class MixGlNode extends BaseGlMathFunctionGlNode {\n\tstatic type() {\n\t\treturn 'mix';\n\t}\n\n\tinitialize_node() {\n\t\tsuper.initialize_node();\n\n\t\tthis.gl_connections_controller.set_input_name_function((index: number) => ['value0', 'value1', 'blend'][index]);\n\t\tthis.gl_connections_controller.set_output_name_function(this._gl_output_name.bind(this));\n\t\tthis.gl_connections_controller.set_expected_input_types_function(this._expected_input_types.bind(this));\n\t\tthis.gl_connections_controller.set_expected_output_types_function(this._expected_output_types.bind(this));\n\t}\n\n\tprotected _gl_output_name() {\n\t\treturn 'mix';\n\t}\n\n\tprotected _expected_input_types() {\n\t\tconst type = this.gl_connections_controller.first_input_connection_type() || ConnectionPointType.FLOAT;\n\t\treturn [type, type, ConnectionPointType.FLOAT];\n\t}\n\n\tprotected _expected_output_types() {\n\t\tconst type = this._expected_input_types()[0];\n\t\treturn [type];\n\t}\n}\n","import {BaseNodeGlMathFunctionArg4GlNode} from './_BaseMathFunction';\nimport {ThreeToGl} from '../../../core/ThreeToGl';\nimport {ShadersCollectionController} from './code/utils/ShadersCollectionController';\n\nconst DefaultValues: Dictionary<number> = {\n\tmult: 1,\n};\n\nenum InputName {\n\tVALUE = 'value',\n\tPRE_ADD = 'pre_add',\n\tMULT = 'mult',\n\tPOST_ADD = 'post_add',\n}\n\nexport class MultAddGlNode extends BaseNodeGlMathFunctionArg4GlNode {\n\tstatic type() {\n\t\treturn 'mult_add';\n\t}\n\n\tprotected _gl_input_name(index: number) {\n\t\treturn [InputName.VALUE, InputName.PRE_ADD, InputName.MULT, InputName.POST_ADD][index];\n\t}\n\tgl_input_default_value(name: string) {\n\t\treturn DefaultValues[name];\n\t}\n\n\tset_lines(shaders_collection_controller: ShadersCollectionController) {\n\t\tconst value = ThreeToGl.any(this.variable_for_input(InputName.VALUE));\n\t\tconst pre_add = ThreeToGl.any(this.variable_for_input(InputName.PRE_ADD));\n\t\tconst mult = ThreeToGl.any(this.variable_for_input(InputName.MULT));\n\t\tconst post_add = ThreeToGl.any(this.variable_for_input(InputName.POST_ADD));\n\n\t\tconst gl_type = this._expected_output_types()[0];\n\t\tconst out_name = this.io.outputs.named_output_connection_points[0].name;\n\t\tconst out = this.gl_var_name(out_name);\n\t\tconst body_line = `${gl_type} ${out} = (${mult}*(${value} + ${pre_add})) + ${post_add}`;\n\t\tshaders_collection_controller.add_body_lines(this, [body_line]);\n\t}\n}\n","import {BaseNodeGlMathFunctionArg1GlNode} from './_BaseMathFunction';\nimport {ThreeToGl} from '../../../core/ThreeToGl';\nimport {ShadersCollectionController} from './code/utils/ShadersCollectionController';\n\nexport class NegateGlNode extends BaseNodeGlMathFunctionArg1GlNode {\n\tstatic type() {\n\t\treturn 'negate';\n\t}\n\n\tinitialize_node() {\n\t\tsuper.initialize_node();\n\n\t\tthis.gl_connections_controller.set_input_name_function((index: number) => ['in'][index]);\n\t}\n\n\tprotected _gl_input_name(index: number) {\n\t\treturn ['in'][index];\n\t}\n\n\tset_lines(shaders_collection_controller: ShadersCollectionController) {\n\t\tconst in_value = ThreeToGl.any(this.variable_for_input(this._gl_input_name(0)));\n\n\t\tconst gl_type = this.io.inputs.named_input_connection_points[0].type;\n\t\tconst out = this.gl_var_name(this.gl_connections_controller.output_name(0));\n\t\tconst body_line = `${gl_type} ${out} = -1.0 * ${in_value}`;\n\t\tshaders_collection_controller.add_body_lines(this, [body_line]);\n\t}\n}\n","export default \"// Modulo 289 without a division (only multiplications)\\nfloat mod289(float x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\nvec2 mod289(vec2 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\nvec3 mod289(vec3 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\nvec4 mod289(vec4 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n// Modulo 7 without a division\\nvec3 mod7(vec3 x) {\\n  return x - floor(x * (1.0 / 7.0)) * 7.0;\\n}\\n\\n// Permutation polynomial: (34x^2 + x) mod 289\\nfloat permute(float x) {\\n     return mod289(((x*34.0)+1.0)*x);\\n}\\nvec3 permute(vec3 x) {\\n  return mod289((34.0 * x + 1.0) * x);\\n}\\nvec4 permute(vec4 x) {\\n     return mod289(((x*34.0)+1.0)*x);\\n}\\n\\nfloat taylorInvSqrt(float r)\\n{\\n  return 1.79284291400159 - 0.85373472095314 * r;\\n}\\nvec4 taylorInvSqrt(vec4 r)\\n{\\n  return 1.79284291400159 - 0.85373472095314 * r;\\n}\\n\\nvec2 fade(vec2 t) {\\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\\n}\\nvec3 fade(vec3 t) {\\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\\n}\\nvec4 fade(vec4 t) {\\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\\n}\"","import lodash_range from 'lodash/range';\nimport {TypedGlNode} from './_Base';\nimport {TypedNamedConnectionPoint} from '../utils/connections/NamedConnectionPoint';\nimport {GlConnectionsController} from './utils/ConnectionsController';\n\n// https://github.com/stegu/webgl-noise/\nimport NoiseCommon from './gl/noise/common.glsl';\n// import cellular2D from './Gl/noise/cellular2D.glsl'\n// import cellular2x2 from './Gl/noise/cellular2x2.glsl'\n// import cellular2x2x2 from './Gl/noise/cellular2x2x2.glsl'\n// import cellular3D from './Gl/noise/cellular3D.glsl'\nimport classicnoise2D from './gl/noise/classicnoise2D.glsl';\nimport classicnoise3D from './gl/noise/classicnoise3D.glsl';\nimport classicnoise4D from './gl/noise/classicnoise4D.glsl';\nimport noise2D from './gl/noise/noise2D.glsl';\nimport noise3D from './gl/noise/noise3D.glsl';\n// import noise3Dgrad from './Gl/noise/noise3Dgrad.glsl'\nimport noise4D from './gl/noise/noise4D.glsl';\nimport {ConnectionPointType, ConnectionPointComponentsCountMap} from '../utils/connections/ConnectionPointType';\n// import psrdnoise2D from './Gl/noise/psrdnoise2D.glsl'\n\nenum NOISE_NAME {\n\t// 'cellular2D',\n\t// 'cellular2x2',\n\t// 'cellular2x2x2',\n\t// 'cellular3D',\n\tCLASSIC_PERLIN_2D = 'Classic Perlin 2D',\n\t// 'Classic Perlin 2D with periodic variant',\n\tCLASSIC_PERLIN_3D = 'Classic Perlin 3D',\n\t// 'Classic Perlin 3D with periodic variant',\n\tCLASSIC_PERLIN_4D = 'Classic Perlin 4D',\n\t// 'Classic Perlin 4D with periodic variant',\n\tNOISE_2D = 'noise2D',\n\tNOISE_3D = 'noise3D',\n\t// 'noise3Dgrad',\n\tNOISE_4D = 'noise4D',\n\t// 'Periodic Simplex Rotating Derivative', // psrdnoise\n\t// 'Periodic Simplex Derivative', // psdnoise\n\t// 'Periodic Simplex Rotating', // psrnoise\n\t// 'Periodic Simplex', // psnoise\n\t// 'Simplex Rotating Derivating', // srdnoise\n\t// 'Simplex Derivating', // sdnoise\n\t// 'Simplex Rotating', // srnoise\n\t// 'Simplex', // snoise\n}\nconst NOISE_NAMES: Array<NOISE_NAME> = [\n\tNOISE_NAME.CLASSIC_PERLIN_2D,\n\tNOISE_NAME.CLASSIC_PERLIN_3D,\n\tNOISE_NAME.CLASSIC_PERLIN_4D,\n\tNOISE_NAME.NOISE_2D,\n\tNOISE_NAME.NOISE_3D,\n\tNOISE_NAME.NOISE_4D,\n];\n\ntype StringByNoise = {[key in NOISE_NAME]: string};\nconst IMPORT_BY_NOISE_NAME: StringByNoise = {\n\t[NOISE_NAME.CLASSIC_PERLIN_2D]: classicnoise2D,\n\t[NOISE_NAME.CLASSIC_PERLIN_3D]: classicnoise3D,\n\t[NOISE_NAME.CLASSIC_PERLIN_4D]: classicnoise4D,\n\t[NOISE_NAME.NOISE_2D]: noise2D,\n\t[NOISE_NAME.NOISE_3D]: noise3D,\n\t[NOISE_NAME.NOISE_4D]: noise4D,\n};\ntype ConnectionTypeByNoise = {[key in NOISE_NAME]: ConnectionPointType};\nconst INPUT_TYPES_BY_NOISE_NAME: ConnectionTypeByNoise = {\n\t[NOISE_NAME.CLASSIC_PERLIN_2D]: ConnectionPointType.VEC2,\n\t[NOISE_NAME.CLASSIC_PERLIN_3D]: ConnectionPointType.VEC3,\n\t[NOISE_NAME.CLASSIC_PERLIN_4D]: ConnectionPointType.VEC4,\n\t[NOISE_NAME.NOISE_2D]: ConnectionPointType.VEC2,\n\t[NOISE_NAME.NOISE_3D]: ConnectionPointType.VEC3,\n\t[NOISE_NAME.NOISE_4D]: ConnectionPointType.VEC4,\n};\n\nconst OUTPUT_TYPE_BY_NOISE_NAME: ConnectionTypeByNoise = {\n\t[NOISE_NAME.CLASSIC_PERLIN_2D]: ConnectionPointType.FLOAT,\n\t[NOISE_NAME.CLASSIC_PERLIN_3D]: ConnectionPointType.FLOAT,\n\t[NOISE_NAME.CLASSIC_PERLIN_4D]: ConnectionPointType.FLOAT,\n\t[NOISE_NAME.NOISE_2D]: ConnectionPointType.FLOAT,\n\t[NOISE_NAME.NOISE_3D]: ConnectionPointType.FLOAT,\n\t[NOISE_NAME.NOISE_4D]: ConnectionPointType.FLOAT,\n};\nconst METHOD_NAMES_BY_NOISE_NAME: StringByNoise = {\n\t[NOISE_NAME.CLASSIC_PERLIN_2D]: 'cnoise',\n\t[NOISE_NAME.CLASSIC_PERLIN_3D]: 'cnoise',\n\t[NOISE_NAME.CLASSIC_PERLIN_4D]: 'cnoise',\n\t[NOISE_NAME.NOISE_2D]: 'snoise',\n\t[NOISE_NAME.NOISE_3D]: 'snoise',\n\t[NOISE_NAME.NOISE_4D]: 'snoise',\n};\n\nenum OUTPUT_TYPE {\n\tNoChange = 0,\n\tFloat = 1,\n\tVec2 = 2,\n\tVec3 = 3,\n\tVec4 = 4,\n}\nconst OUTPUT_TYPES: Array<OUTPUT_TYPE> = [\n\tOUTPUT_TYPE.NoChange,\n\tOUTPUT_TYPE.Float,\n\tOUTPUT_TYPE.Vec2,\n\tOUTPUT_TYPE.Vec3,\n\tOUTPUT_TYPE.Vec4,\n];\ntype StringByOutputType = {[key in OUTPUT_TYPE]: string};\nconst OUTPUT_TYPE_LABEL: StringByOutputType = {\n\t[OUTPUT_TYPE.NoChange]: 'Same as noise',\n\t[OUTPUT_TYPE.Float]: 'Float',\n\t[OUTPUT_TYPE.Vec2]: 'Vec2',\n\t[OUTPUT_TYPE.Vec3]: 'Vec3',\n\t[OUTPUT_TYPE.Vec4]: 'Vec4',\n};\ntype ConnectionTypeByOutputType = {[key in OUTPUT_TYPE]: ConnectionPointType};\nconst CONNECTION_TYPE_BY_OUTPUT_TYPE: ConnectionTypeByOutputType = {\n\t[OUTPUT_TYPE.NoChange]: ConnectionPointType.FLOAT,\n\t[OUTPUT_TYPE.Float]: ConnectionPointType.FLOAT,\n\t[OUTPUT_TYPE.Vec2]: ConnectionPointType.VEC2,\n\t[OUTPUT_TYPE.Vec3]: ConnectionPointType.VEC3,\n\t[OUTPUT_TYPE.Vec4]: ConnectionPointType.VEC4,\n};\n\nconst ALL_COMPONENTS = ['x', 'y', 'z', 'w'];\nconst OUTPUT_NAME = 'noise';\nconst default_noise_type = NOISE_NAMES.indexOf(NOISE_NAME.NOISE_3D);\nconst default_output_type = OUTPUT_TYPE.NoChange;\n\nconst DefaultValues: Dictionary<number> = {\n\tamp: 1,\n\tfreq: 1,\n};\n\nenum InputName {\n\tAMP = 'amp',\n\tPOSITION = 'position',\n\tFREQ = 'freq',\n\tOFFSET = 'offset',\n}\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {ShadersCollectionController} from './code/utils/ShadersCollectionController';\nimport {ThreeToGl} from '../../../core/ThreeToGl';\nimport {FunctionGLDefinition} from './utils/GLDefinition';\nclass NoiseGlParamsConfig extends NodeParamsConfig {\n\ttype = ParamConfig.INTEGER(default_noise_type, {\n\t\tmenu: {\n\t\t\tentries: NOISE_NAMES.map((noise_name, i) => {\n\t\t\t\tconst noise_output_type = OUTPUT_TYPE_BY_NOISE_NAME[noise_name];\n\t\t\t\tconst name = `${noise_name} (output: ${noise_output_type})`;\n\t\t\t\treturn {name: name, value: i};\n\t\t\t}),\n\t\t},\n\t});\n\toutput_type = ParamConfig.INTEGER(default_output_type, {\n\t\tmenu: {\n\t\t\tentries: OUTPUT_TYPES.map((output_type) => {\n\t\t\t\tconst val = OUTPUT_TYPES[output_type];\n\t\t\t\tconst name = OUTPUT_TYPE_LABEL[val];\n\t\t\t\treturn {name: name, value: val};\n\t\t\t}),\n\t\t},\n\t});\n\toctaves = ParamConfig.INTEGER(3, {range: [1, 10], range_locked: [true, false]});\n\tamp_attenuation = ParamConfig.FLOAT(0.5, {range: [0, 1]});\n\tfreq_increase = ParamConfig.FLOAT(2, {range: [0, 10]});\n\tseparator = ParamConfig.SEPARATOR();\n}\nconst ParamsConfig = new NoiseGlParamsConfig();\nexport class NoiseGlNode extends TypedGlNode<NoiseGlParamsConfig> {\n\tparams_config = ParamsConfig;\n\n\tstatic type() {\n\t\treturn 'noise';\n\t}\n\n\tpublic readonly gl_connections_controller: GlConnectionsController = new GlConnectionsController(this);\n\tinitialize_node() {\n\t\tsuper.initialize_node();\n\t\tthis.gl_connections_controller.initialize_node();\n\t\tthis.spare_params_controller.set_inputless_param_names(['octaves', 'amp_attenuation', 'freq_increase']);\n\n\t\tthis.io.outputs.set_named_output_connection_points([\n\t\t\tnew TypedNamedConnectionPoint(OUTPUT_NAME, ConnectionPointType.FLOAT),\n\t\t]);\n\n\t\tthis.gl_connections_controller.set_expected_input_types_function(this._expected_input_types.bind(this));\n\t\tthis.gl_connections_controller.set_expected_output_types_function(this._expected_output_types.bind(this));\n\t}\n\n\tprotected _gl_input_name(index: number) {\n\t\treturn [InputName.AMP, InputName.POSITION, InputName.FREQ, InputName.OFFSET][index];\n\t}\n\tgl_input_default_value(name: string) {\n\t\treturn DefaultValues[name];\n\t}\n\n\tprivate _expected_input_types(): ConnectionPointType[] {\n\t\tconst noise_name = NOISE_NAMES[this.pv.type];\n\t\tconst type = INPUT_TYPES_BY_NOISE_NAME[noise_name];\n\t\treturn [type, type, type, type];\n\t}\n\tprivate _expected_output_types(): ConnectionPointType[] {\n\t\tconst noise_name = NOISE_NAMES[this.pv.type];\n\t\tconst output_type = OUTPUT_TYPES[this.pv.output_type];\n\t\tif (output_type == OUTPUT_TYPE.NoChange) {\n\t\t\treturn [OUTPUT_TYPE_BY_NOISE_NAME[noise_name]];\n\t\t} else {\n\t\t\treturn [CONNECTION_TYPE_BY_OUTPUT_TYPE[output_type]];\n\t\t}\n\t}\n\n\tset_lines(shaders_collection_controller: ShadersCollectionController) {\n\t\tconst function_declaration_lines = [];\n\t\tconst body_lines = [];\n\n\t\tconst noise_name = NOISE_NAMES[this.pv.type];\n\t\tconst noise_function = IMPORT_BY_NOISE_NAME[noise_name];\n\t\tconst noise_output_gl_type = OUTPUT_TYPE_BY_NOISE_NAME[noise_name];\n\t\tfunction_declaration_lines.push(new FunctionGLDefinition(this, noise_output_gl_type, NoiseCommon));\n\t\tfunction_declaration_lines.push(new FunctionGLDefinition(this, noise_output_gl_type, noise_function));\n\t\tfunction_declaration_lines.push(new FunctionGLDefinition(this, noise_output_gl_type, this.fbm_function()));\n\n\t\tconst output_gl_type = this._expected_output_types()[0];\n\n\t\t// if the requested output type matches the noise signature\n\t\tif (output_gl_type == noise_output_gl_type) {\n\t\t\tconst line = this.single_noise_line();\n\t\t\t// body_lines.push( `${output_gl_type} ${noise} = ${amp}*${method_name}(${joined_args})` )\n\t\t\tbody_lines.push(line);\n\t\t} else {\n\t\t\t// if the requested output type does not match the noise signature\n\t\t\tconst requested_components_count = ConnectionPointComponentsCountMap[output_gl_type];\n\t\t\t// const noise_output_components_count = OUTPUT_TYPE_BY_NOISE_NAME[output_gl_type]\n\n\t\t\t// console.log(\"compare\", output_gl_type, requested_components_count, noise_output_components_count)\n\t\t\t// if(requested_components_count < noise_output_components_count){\n\t\t\t// \t// not sure we ever go through here with the current noise set\n\t\t\t// \tlet component = lodash_range(requested_components_count).map(i=>ALL_COMPONENTS[i]).join('')\n\t\t\t// \tconst line = this.single_noise_line('', component)\n\t\t\t// \tbody_lines.push(line)\n\t\t\t// } else {\n\t\t\tconst lines_count_required = requested_components_count;\n\t\t\tconst assembly_args: string[] = [];\n\t\t\tconst noise = this.gl_var_name('noise');\n\t\t\tfor (let i = 0; i < lines_count_required; i++) {\n\t\t\t\tconst component = ALL_COMPONENTS[i];\n\t\t\t\tassembly_args.push(`${noise}${component}`);\n\t\t\t\tconst input_type = INPUT_TYPES_BY_NOISE_NAME[noise_name];\n\t\t\t\t// if (lodash_isArray(input_constructor)) {\n\t\t\t\t// TODO: for noise3Dgrad and other noises with 2 inputs\n\t\t\t\t// } else {\n\t\t\t\t// console.log(INPUT_TYPES_BY_NOISE_NAME, noise_name)\n\t\t\t\tconst offset_gl_type = input_type;\n\t\t\t\tconst offset_components_count = ConnectionPointComponentsCountMap[offset_gl_type];\n\t\t\t\tconst offset_values = lodash_range(offset_components_count)\n\t\t\t\t\t.map((j) => ThreeToGl.float(1000 * i))\n\t\t\t\t\t.join(', ');\n\t\t\t\tconst offset2 = `${offset_gl_type}(${offset_values})`;\n\t\t\t\tconst line = this.single_noise_line(component, component, offset2);\n\t\t\t\tbody_lines.push(line);\n\t\t\t\t// }\n\t\t\t}\n\t\t\tconst joined_args = assembly_args.join(', ');\n\t\t\tconst assembly_line = `vec${lines_count_required} ${noise} = vec${lines_count_required}(${joined_args})`;\n\t\t\tbody_lines.push(assembly_line);\n\t\t\t// }\n\t\t}\n\n\t\tshaders_collection_controller.add_definitions(this, function_declaration_lines);\n\t\tshaders_collection_controller.add_body_lines(this, body_lines);\n\t}\n\n\tprivate fbm_method_name() {\n\t\tconst noise_name = NOISE_NAMES[this.pv.type];\n\t\tconst method_name = METHOD_NAMES_BY_NOISE_NAME[noise_name];\n\t\treturn `fbm_${method_name}_${this.name}`;\n\t}\n\n\tprivate fbm_function() {\n\t\tconst noise_name = NOISE_NAMES[this.pv.type];\n\t\tconst method_name = METHOD_NAMES_BY_NOISE_NAME[noise_name];\n\n\t\tconst input_type = INPUT_TYPES_BY_NOISE_NAME[noise_name];\n\n\t\treturn `\nfloat ${this.fbm_method_name()} (in ${input_type} st) {\n\tfloat value = 0.0;\n\tfloat amplitude = 1.0;\n\tfor (int i = 0; i < ${ThreeToGl.int(this.pv.octaves)}; i++) {\n\t\tvalue += amplitude * ${method_name}(st);\n\t\tst *= ${ThreeToGl.float(this.pv.freq_increase)};\n\t\tamplitude *= ${ThreeToGl.float(this.pv.amp_attenuation)};\n\t}\n\treturn value;\n}\n`;\n\t}\n\n\tprivate single_noise_line(output_name_suffix?: string, component?: string, offset2?: string) {\n\t\tconst noise_name = NOISE_NAMES[this.pv.type];\n\t\t// const method_name = METHOD_NAMES_BY_NOISE_NAME[noise_name]\n\t\tconst method_name = this.fbm_method_name();\n\n\t\tconst amp = ThreeToGl.any(this.variable_for_input(InputName.AMP));\n\t\tconst position = ThreeToGl.any(this.variable_for_input(InputName.POSITION));\n\t\tconst freq = ThreeToGl.any(this.variable_for_input(InputName.FREQ));\n\t\tlet offset = ThreeToGl.any(this.variable_for_input(InputName.OFFSET));\n\t\tif (offset2) {\n\t\t\toffset = `(${offset}+${offset2})`;\n\t\t}\n\t\tconst args = [`(${position}*${freq})+${offset}`];\n\n\t\t// we cannot use amp as is in all cases\n\t\t// if the noise outputs a vec2 and the amp is vec3, we cannot simply do vec3*vec2\n\t\t// therefore, in such a case, we must only take the required component of vec3\n\t\t// examples:\n\t\t// - noise is cellular 2D (outputs vec2) and requested output is float:\n\t\t//\t\tnothing to do\n\t\t// - noise is cellular 2D (outputs vec2) and requested output is vec2:\n\t\t//\t\tnothing to do\n\t\t// - noise is cellular 2D (outputs vec3) and requested output is vec2:\n\t\t//\t\twe have:\n\t\t//\t\t\tx = amp.x * vec2.x\n\t\t//\t\t\ty = amp.y * vec2.y\n\t\t//\t\t\tz = amp.z * 0\n\t\t//\t\t\toutput = vec3(x,y,z)\n\n\t\t// add other args if required\n\t\t// const input_type = INPUT_TYPES_BY_NOISE_NAME[noise_name];\n\t\t// if (lodash_isArray(input_constructor)) {\n\t\t// \tconst properties = lodash_clone(input_constructor);\n\t\t// \tproperties.shift(); // remove position\n\t\t// \tproperties.forEach((property) => {\n\t\t// \t\tconst arg_name = Object.keys(property)[0];\n\t\t// \t\tconst arg = ThreeToGl.any(this.variable_for_input(arg_name));\n\t\t// \t\targs.push(arg);\n\t\t// \t});\n\t\t// }\n\t\tconst joined_args = args.join(', ');\n\n\t\t// let output_type = OUTPUT_TYPE_BY_NOISE_NAME[noise_name]\n\n\t\tconst noise = this.gl_var_name(OUTPUT_NAME);\n\t\tconst right_hand = `${amp}*${method_name}(${joined_args})`;\n\t\tif (component) {\n\t\t\treturn `float ${noise}${output_name_suffix} = (${right_hand}).${component}`;\n\t\t} else {\n\t\t\t// it looks like we never go here with the current set of noises\n\t\t\tconst output_type = OUTPUT_TYPE_BY_NOISE_NAME[noise_name];\n\t\t\treturn `${output_type} ${noise} = ${right_hand}`;\n\t\t}\n\t}\n}\n","export default \"//\\n// GLSL textureless classic 2D noise \\\"cnoise\\\",\\n// with an RSL-style periodic variant \\\"pnoise\\\".\\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\\n// Version: 2011-08-22\\n//\\n// Many thanks to Ian McEwan of Ashima Arts for the\\n// ideas for permutation and gradient selection.\\n//\\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\\n// Distributed under the MIT license. See LICENSE file.\\n// https://github.com/stegu/webgl-noise\\n//\\n\\n\\n// Classic Perlin noise\\nfloat cnoise(vec2 P)\\n{\\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\\n  Pi = mod289(Pi); // To avoid truncation effects in permutation\\n  vec4 ix = Pi.xzxz;\\n  vec4 iy = Pi.yyww;\\n  vec4 fx = Pf.xzxz;\\n  vec4 fy = Pf.yyww;\\n\\n  vec4 i = permute(permute(ix) + iy);\\n\\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\\n  vec4 gy = abs(gx) - 0.5 ;\\n  vec4 tx = floor(gx + 0.5);\\n  gx = gx - tx;\\n\\n  vec2 g00 = vec2(gx.x,gy.x);\\n  vec2 g10 = vec2(gx.y,gy.y);\\n  vec2 g01 = vec2(gx.z,gy.z);\\n  vec2 g11 = vec2(gx.w,gy.w);\\n\\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\\n  g00 *= norm.x;  \\n  g01 *= norm.y;  \\n  g10 *= norm.z;  \\n  g11 *= norm.w;  \\n\\n  float n00 = dot(g00, vec2(fx.x, fy.x));\\n  float n10 = dot(g10, vec2(fx.y, fy.y));\\n  float n01 = dot(g01, vec2(fx.z, fy.z));\\n  float n11 = dot(g11, vec2(fx.w, fy.w));\\n\\n  vec2 fade_xy = fade(Pf.xy);\\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\\n  return 2.3 * n_xy;\\n}\\n\\n// Classic Perlin noise, periodic variant\\nfloat pnoise(vec2 P, vec2 rep)\\n{\\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\\n  Pi = mod(Pi, rep.xyxy); // To create noise with explicit period\\n  Pi = mod289(Pi);        // To avoid truncation effects in permutation\\n  vec4 ix = Pi.xzxz;\\n  vec4 iy = Pi.yyww;\\n  vec4 fx = Pf.xzxz;\\n  vec4 fy = Pf.yyww;\\n\\n  vec4 i = permute(permute(ix) + iy);\\n\\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\\n  vec4 gy = abs(gx) - 0.5 ;\\n  vec4 tx = floor(gx + 0.5);\\n  gx = gx - tx;\\n\\n  vec2 g00 = vec2(gx.x,gy.x);\\n  vec2 g10 = vec2(gx.y,gy.y);\\n  vec2 g01 = vec2(gx.z,gy.z);\\n  vec2 g11 = vec2(gx.w,gy.w);\\n\\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\\n  g00 *= norm.x;  \\n  g01 *= norm.y;  \\n  g10 *= norm.z;  \\n  g11 *= norm.w;  \\n\\n  float n00 = dot(g00, vec2(fx.x, fy.x));\\n  float n10 = dot(g10, vec2(fx.y, fy.y));\\n  float n01 = dot(g01, vec2(fx.z, fy.z));\\n  float n11 = dot(g11, vec2(fx.w, fy.w));\\n\\n  vec2 fade_xy = fade(Pf.xy);\\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\\n  return 2.3 * n_xy;\\n}\\n\"","export default \"//\\n// GLSL textureless classic 3D noise \\\"cnoise\\\",\\n// with an RSL-style periodic variant \\\"pnoise\\\".\\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\\n// Version: 2011-10-11\\n//\\n// Many thanks to Ian McEwan of Ashima Arts for the\\n// ideas for permutation and gradient selection.\\n//\\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\\n// Distributed under the MIT license. See LICENSE file.\\n// https://github.com/stegu/webgl-noise\\n//\\n\\n// Classic Perlin noise\\nfloat cnoise(vec3 P)\\n{\\n  vec3 Pi0 = floor(P); // Integer part for indexing\\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\\n  Pi0 = mod289(Pi0);\\n  Pi1 = mod289(Pi1);\\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\\n  vec4 iz0 = Pi0.zzzz;\\n  vec4 iz1 = Pi1.zzzz;\\n\\n  vec4 ixy = permute(permute(ix) + iy);\\n  vec4 ixy0 = permute(ixy + iz0);\\n  vec4 ixy1 = permute(ixy + iz1);\\n\\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\\n  gx0 = fract(gx0);\\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\\n  vec4 sz0 = step(gz0, vec4(0.0));\\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\\n\\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\\n  gx1 = fract(gx1);\\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\\n  vec4 sz1 = step(gz1, vec4(0.0));\\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\\n\\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\\n\\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\\n  g000 *= norm0.x;\\n  g010 *= norm0.y;\\n  g100 *= norm0.z;\\n  g110 *= norm0.w;\\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\\n  g001 *= norm1.x;\\n  g011 *= norm1.y;\\n  g101 *= norm1.z;\\n  g111 *= norm1.w;\\n\\n  float n000 = dot(g000, Pf0);\\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\\n  float n111 = dot(g111, Pf1);\\n\\n  vec3 fade_xyz = fade(Pf0);\\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \\n  return 2.2 * n_xyz;\\n}\\n\\n// Classic Perlin noise, periodic variant\\nfloat pnoise(vec3 P, vec3 rep)\\n{\\n  vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\\n  vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\\n  Pi0 = mod289(Pi0);\\n  Pi1 = mod289(Pi1);\\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\\n  vec4 iz0 = Pi0.zzzz;\\n  vec4 iz1 = Pi1.zzzz;\\n\\n  vec4 ixy = permute(permute(ix) + iy);\\n  vec4 ixy0 = permute(ixy + iz0);\\n  vec4 ixy1 = permute(ixy + iz1);\\n\\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\\n  gx0 = fract(gx0);\\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\\n  vec4 sz0 = step(gz0, vec4(0.0));\\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\\n\\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\\n  gx1 = fract(gx1);\\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\\n  vec4 sz1 = step(gz1, vec4(0.0));\\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\\n\\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\\n\\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\\n  g000 *= norm0.x;\\n  g010 *= norm0.y;\\n  g100 *= norm0.z;\\n  g110 *= norm0.w;\\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\\n  g001 *= norm1.x;\\n  g011 *= norm1.y;\\n  g101 *= norm1.z;\\n  g111 *= norm1.w;\\n\\n  float n000 = dot(g000, Pf0);\\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\\n  float n111 = dot(g111, Pf1);\\n\\n  vec3 fade_xyz = fade(Pf0);\\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \\n  return 2.2 * n_xyz;\\n}\\n\"","export default \"//\\n// GLSL textureless classic 4D noise \\\"cnoise\\\",\\n// with an RSL-style periodic variant \\\"pnoise\\\".\\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\\n// Version: 2011-08-22\\n//\\n// Many thanks to Ian McEwan of Ashima Arts for the\\n// ideas for permutation and gradient selection.\\n//\\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\\n// Distributed under the MIT license. See LICENSE file.\\n// https://github.com/stegu/webgl-noise\\n//\\n\\n\\n\\n// Classic Perlin noise\\nfloat cnoise(vec4 P)\\n{\\n  vec4 Pi0 = floor(P); // Integer part for indexing\\n  vec4 Pi1 = Pi0 + 1.0; // Integer part + 1\\n  Pi0 = mod289(Pi0);\\n  Pi1 = mod289(Pi1);\\n  vec4 Pf0 = fract(P); // Fractional part for interpolation\\n  vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0\\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\\n  vec4 iz0 = vec4(Pi0.zzzz);\\n  vec4 iz1 = vec4(Pi1.zzzz);\\n  vec4 iw0 = vec4(Pi0.wwww);\\n  vec4 iw1 = vec4(Pi1.wwww);\\n\\n  vec4 ixy = permute(permute(ix) + iy);\\n  vec4 ixy0 = permute(ixy + iz0);\\n  vec4 ixy1 = permute(ixy + iz1);\\n  vec4 ixy00 = permute(ixy0 + iw0);\\n  vec4 ixy01 = permute(ixy0 + iw1);\\n  vec4 ixy10 = permute(ixy1 + iw0);\\n  vec4 ixy11 = permute(ixy1 + iw1);\\n\\n  vec4 gx00 = ixy00 * (1.0 / 7.0);\\n  vec4 gy00 = floor(gx00) * (1.0 / 7.0);\\n  vec4 gz00 = floor(gy00) * (1.0 / 6.0);\\n  gx00 = fract(gx00) - 0.5;\\n  gy00 = fract(gy00) - 0.5;\\n  gz00 = fract(gz00) - 0.5;\\n  vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\\n  vec4 sw00 = step(gw00, vec4(0.0));\\n  gx00 -= sw00 * (step(0.0, gx00) - 0.5);\\n  gy00 -= sw00 * (step(0.0, gy00) - 0.5);\\n\\n  vec4 gx01 = ixy01 * (1.0 / 7.0);\\n  vec4 gy01 = floor(gx01) * (1.0 / 7.0);\\n  vec4 gz01 = floor(gy01) * (1.0 / 6.0);\\n  gx01 = fract(gx01) - 0.5;\\n  gy01 = fract(gy01) - 0.5;\\n  gz01 = fract(gz01) - 0.5;\\n  vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\\n  vec4 sw01 = step(gw01, vec4(0.0));\\n  gx01 -= sw01 * (step(0.0, gx01) - 0.5);\\n  gy01 -= sw01 * (step(0.0, gy01) - 0.5);\\n\\n  vec4 gx10 = ixy10 * (1.0 / 7.0);\\n  vec4 gy10 = floor(gx10) * (1.0 / 7.0);\\n  vec4 gz10 = floor(gy10) * (1.0 / 6.0);\\n  gx10 = fract(gx10) - 0.5;\\n  gy10 = fract(gy10) - 0.5;\\n  gz10 = fract(gz10) - 0.5;\\n  vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\\n  vec4 sw10 = step(gw10, vec4(0.0));\\n  gx10 -= sw10 * (step(0.0, gx10) - 0.5);\\n  gy10 -= sw10 * (step(0.0, gy10) - 0.5);\\n\\n  vec4 gx11 = ixy11 * (1.0 / 7.0);\\n  vec4 gy11 = floor(gx11) * (1.0 / 7.0);\\n  vec4 gz11 = floor(gy11) * (1.0 / 6.0);\\n  gx11 = fract(gx11) - 0.5;\\n  gy11 = fract(gy11) - 0.5;\\n  gz11 = fract(gz11) - 0.5;\\n  vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\\n  vec4 sw11 = step(gw11, vec4(0.0));\\n  gx11 -= sw11 * (step(0.0, gx11) - 0.5);\\n  gy11 -= sw11 * (step(0.0, gy11) - 0.5);\\n\\n  vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\\n  vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\\n  vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\\n  vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\\n  vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\\n  vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\\n  vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\\n  vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\\n  vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\\n  vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\\n  vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\\n  vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\\n  vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\\n  vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\\n  vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\\n  vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\\n\\n  vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\\n  g0000 *= norm00.x;\\n  g0100 *= norm00.y;\\n  g1000 *= norm00.z;\\n  g1100 *= norm00.w;\\n\\n  vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\\n  g0001 *= norm01.x;\\n  g0101 *= norm01.y;\\n  g1001 *= norm01.z;\\n  g1101 *= norm01.w;\\n\\n  vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\\n  g0010 *= norm10.x;\\n  g0110 *= norm10.y;\\n  g1010 *= norm10.z;\\n  g1110 *= norm10.w;\\n\\n  vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\\n  g0011 *= norm11.x;\\n  g0111 *= norm11.y;\\n  g1011 *= norm11.z;\\n  g1111 *= norm11.w;\\n\\n  float n0000 = dot(g0000, Pf0);\\n  float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\\n  float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\\n  float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\\n  float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\\n  float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\\n  float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\\n  float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\\n  float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\\n  float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\\n  float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\\n  float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\\n  float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\\n  float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\\n  float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\\n  float n1111 = dot(g1111, Pf1);\\n\\n  vec4 fade_xyzw = fade(Pf0);\\n  vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\\n  vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\\n  vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\\n  vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\\n  float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\\n  return 2.2 * n_xyzw;\\n}\\n\\n// Classic Perlin noise, periodic version\\nfloat pnoise(vec4 P, vec4 rep)\\n{\\n  vec4 Pi0 = mod(floor(P), rep); // Integer part modulo rep\\n  vec4 Pi1 = mod(Pi0 + 1.0, rep); // Integer part + 1 mod rep\\n  Pi0 = mod289(Pi0);\\n  Pi1 = mod289(Pi1);\\n  vec4 Pf0 = fract(P); // Fractional part for interpolation\\n  vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0\\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\\n  vec4 iz0 = vec4(Pi0.zzzz);\\n  vec4 iz1 = vec4(Pi1.zzzz);\\n  vec4 iw0 = vec4(Pi0.wwww);\\n  vec4 iw1 = vec4(Pi1.wwww);\\n\\n  vec4 ixy = permute(permute(ix) + iy);\\n  vec4 ixy0 = permute(ixy + iz0);\\n  vec4 ixy1 = permute(ixy + iz1);\\n  vec4 ixy00 = permute(ixy0 + iw0);\\n  vec4 ixy01 = permute(ixy0 + iw1);\\n  vec4 ixy10 = permute(ixy1 + iw0);\\n  vec4 ixy11 = permute(ixy1 + iw1);\\n\\n  vec4 gx00 = ixy00 * (1.0 / 7.0);\\n  vec4 gy00 = floor(gx00) * (1.0 / 7.0);\\n  vec4 gz00 = floor(gy00) * (1.0 / 6.0);\\n  gx00 = fract(gx00) - 0.5;\\n  gy00 = fract(gy00) - 0.5;\\n  gz00 = fract(gz00) - 0.5;\\n  vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\\n  vec4 sw00 = step(gw00, vec4(0.0));\\n  gx00 -= sw00 * (step(0.0, gx00) - 0.5);\\n  gy00 -= sw00 * (step(0.0, gy00) - 0.5);\\n\\n  vec4 gx01 = ixy01 * (1.0 / 7.0);\\n  vec4 gy01 = floor(gx01) * (1.0 / 7.0);\\n  vec4 gz01 = floor(gy01) * (1.0 / 6.0);\\n  gx01 = fract(gx01) - 0.5;\\n  gy01 = fract(gy01) - 0.5;\\n  gz01 = fract(gz01) - 0.5;\\n  vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\\n  vec4 sw01 = step(gw01, vec4(0.0));\\n  gx01 -= sw01 * (step(0.0, gx01) - 0.5);\\n  gy01 -= sw01 * (step(0.0, gy01) - 0.5);\\n\\n  vec4 gx10 = ixy10 * (1.0 / 7.0);\\n  vec4 gy10 = floor(gx10) * (1.0 / 7.0);\\n  vec4 gz10 = floor(gy10) * (1.0 / 6.0);\\n  gx10 = fract(gx10) - 0.5;\\n  gy10 = fract(gy10) - 0.5;\\n  gz10 = fract(gz10) - 0.5;\\n  vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\\n  vec4 sw10 = step(gw10, vec4(0.0));\\n  gx10 -= sw10 * (step(0.0, gx10) - 0.5);\\n  gy10 -= sw10 * (step(0.0, gy10) - 0.5);\\n\\n  vec4 gx11 = ixy11 * (1.0 / 7.0);\\n  vec4 gy11 = floor(gx11) * (1.0 / 7.0);\\n  vec4 gz11 = floor(gy11) * (1.0 / 6.0);\\n  gx11 = fract(gx11) - 0.5;\\n  gy11 = fract(gy11) - 0.5;\\n  gz11 = fract(gz11) - 0.5;\\n  vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\\n  vec4 sw11 = step(gw11, vec4(0.0));\\n  gx11 -= sw11 * (step(0.0, gx11) - 0.5);\\n  gy11 -= sw11 * (step(0.0, gy11) - 0.5);\\n\\n  vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\\n  vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\\n  vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\\n  vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\\n  vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\\n  vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\\n  vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\\n  vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\\n  vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\\n  vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\\n  vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\\n  vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\\n  vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\\n  vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\\n  vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\\n  vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\\n\\n  vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\\n  g0000 *= norm00.x;\\n  g0100 *= norm00.y;\\n  g1000 *= norm00.z;\\n  g1100 *= norm00.w;\\n\\n  vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\\n  g0001 *= norm01.x;\\n  g0101 *= norm01.y;\\n  g1001 *= norm01.z;\\n  g1101 *= norm01.w;\\n\\n  vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\\n  g0010 *= norm10.x;\\n  g0110 *= norm10.y;\\n  g1010 *= norm10.z;\\n  g1110 *= norm10.w;\\n\\n  vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\\n  g0011 *= norm11.x;\\n  g0111 *= norm11.y;\\n  g1011 *= norm11.z;\\n  g1111 *= norm11.w;\\n\\n  float n0000 = dot(g0000, Pf0);\\n  float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\\n  float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\\n  float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\\n  float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\\n  float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\\n  float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\\n  float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\\n  float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\\n  float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\\n  float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\\n  float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\\n  float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\\n  float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\\n  float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\\n  float n1111 = dot(g1111, Pf1);\\n\\n  vec4 fade_xyzw = fade(Pf0);\\n  vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\\n  vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\\n  vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\\n  vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\\n  float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\\n  return 2.2 * n_xyzw;\\n}\\n\"","export default \"//\\n// Description : Array and textureless GLSL 2D simplex noise function.\\n//      Author : Ian McEwan, Ashima Arts.\\n//  Maintainer : stegu\\n//     Lastmod : 20110822 (ijm)\\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\\n//               Distributed under the MIT License. See LICENSE file.\\n//               https://github.com/ashima/webgl-noise\\n//               https://github.com/stegu/webgl-noise\\n// \\n\\n\\nfloat snoise(vec2 v)\\n  {\\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\\n                      0.024390243902439); // 1.0 / 41.0\\n// First corner\\n  vec2 i  = floor(v + dot(v, C.yy) );\\n  vec2 x0 = v -   i + dot(i, C.xx);\\n\\n// Other corners\\n  vec2 i1;\\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\\n  //i1.y = 1.0 - i1.x;\\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\\n  // x1 = x0 - i1 + 1.0 * C.xx ;\\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\\n  vec4 x12 = x0.xyxy + C.xxzz;\\n  x12.xy -= i1;\\n\\n// Permutations\\n  i = mod289(i); // Avoid truncation effects in permutation\\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\\n\\t\\t+ i.x + vec3(0.0, i1.x, 1.0 ));\\n\\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\\n  m = m*m ;\\n  m = m*m ;\\n\\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\\n\\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\\n  vec3 h = abs(x) - 0.5;\\n  vec3 ox = floor(x + 0.5);\\n  vec3 a0 = x - ox;\\n\\n// Normalise gradients implicitly by scaling m\\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\\n\\n// Compute final noise value at P\\n  vec3 g;\\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\\n  return 130.0 * dot(m, g);\\n}\\n\"","export default \"//\\n// Description : Array and textureless GLSL 2D/3D/4D simplex \\n//               noise functions.\\n//      Author : Ian McEwan, Ashima Arts.\\n//  Maintainer : stegu\\n//     Lastmod : 20110822 (ijm)\\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\\n//               Distributed under the MIT License. See LICENSE file.\\n//               https://github.com/ashima/webgl-noise\\n//               https://github.com/stegu/webgl-noise\\n// \\n\\n\\n\\nfloat snoise(vec3 v)\\n  { \\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\\n\\n// First corner\\n  vec3 i  = floor(v + dot(v, C.yyy) );\\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\\n\\n// Other corners\\n  vec3 g = step(x0.yzx, x0.xyz);\\n  vec3 l = 1.0 - g;\\n  vec3 i1 = min( g.xyz, l.zxy );\\n  vec3 i2 = max( g.xyz, l.zxy );\\n\\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\\n  vec3 x1 = x0 - i1 + C.xxx;\\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\\n\\n// Permutations\\n  i = mod289(i); \\n  vec4 p = permute( permute( permute( \\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\\n\\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\\n  float n_ = 0.142857142857; // 1.0/7.0\\n  vec3  ns = n_ * D.wyz - D.xzx;\\n\\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\\n\\n  vec4 x_ = floor(j * ns.z);\\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\\n\\n  vec4 x = x_ *ns.x + ns.yyyy;\\n  vec4 y = y_ *ns.x + ns.yyyy;\\n  vec4 h = 1.0 - abs(x) - abs(y);\\n\\n  vec4 b0 = vec4( x.xy, y.xy );\\n  vec4 b1 = vec4( x.zw, y.zw );\\n\\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\\n  vec4 s0 = floor(b0)*2.0 + 1.0;\\n  vec4 s1 = floor(b1)*2.0 + 1.0;\\n  vec4 sh = -step(h, vec4(0.0));\\n\\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\\n\\n  vec3 p0 = vec3(a0.xy,h.x);\\n  vec3 p1 = vec3(a0.zw,h.y);\\n  vec3 p2 = vec3(a1.xy,h.z);\\n  vec3 p3 = vec3(a1.zw,h.w);\\n\\n//Normalise gradients\\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\\n  p0 *= norm.x;\\n  p1 *= norm.y;\\n  p2 *= norm.z;\\n  p3 *= norm.w;\\n\\n// Mix final noise value\\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\\n  m = m * m;\\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \\n                                dot(p2,x2), dot(p3,x3) ) );\\n  }\\n\"","export default \"//\\n// Description : Array and textureless GLSL 2D/3D/4D simplex \\n//               noise functions.\\n//      Author : Ian McEwan, Ashima Arts.\\n//  Maintainer : stegu\\n//     Lastmod : 20110822 (ijm)\\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\\n//               Distributed under the MIT License. See LICENSE file.\\n//               https://github.com/ashima/webgl-noise\\n//               https://github.com/stegu/webgl-noise\\n// \\n\\n\\n\\n\\n\\n\\n\\nvec4 grad4(float j, vec4 ip)\\n  {\\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\\n  vec4 p,s;\\n\\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\\n  s = vec4(lessThan(p, vec4(0.0)));\\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \\n\\n  return p;\\n  }\\n\\t\\t\\t\\t\\t\\t\\n// (sqrt(5) - 1)/4 = F4, used once below\\n#define F4 0.309016994374947451\\n\\nfloat snoise(vec4 v)\\n  {\\n  const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\\n                        0.276393202250021,  // 2 * G4\\n                        0.414589803375032,  // 3 * G4\\n                       -0.447213595499958); // -1 + 4 * G4\\n\\n// First corner\\n  vec4 i  = floor(v + dot(v, vec4(F4)) );\\n  vec4 x0 = v -   i + dot(i, C.xxxx);\\n\\n// Other corners\\n\\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\\n  vec4 i0;\\n  vec3 isX = step( x0.yzw, x0.xxx );\\n  vec3 isYZ = step( x0.zww, x0.yyz );\\n//  i0.x = dot( isX, vec3( 1.0 ) );\\n  i0.x = isX.x + isX.y + isX.z;\\n  i0.yzw = 1.0 - isX;\\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\\n  i0.y += isYZ.x + isYZ.y;\\n  i0.zw += 1.0 - isYZ.xy;\\n  i0.z += isYZ.z;\\n  i0.w += 1.0 - isYZ.z;\\n\\n  // i0 now contains the unique values 0,1,2,3 in each channel\\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\\n\\n  //  x0 = x0 - 0.0 + 0.0 * C.xxxx\\n  //  x1 = x0 - i1  + 1.0 * C.xxxx\\n  //  x2 = x0 - i2  + 2.0 * C.xxxx\\n  //  x3 = x0 - i3  + 3.0 * C.xxxx\\n  //  x4 = x0 - 1.0 + 4.0 * C.xxxx\\n  vec4 x1 = x0 - i1 + C.xxxx;\\n  vec4 x2 = x0 - i2 + C.yyyy;\\n  vec4 x3 = x0 - i3 + C.zzzz;\\n  vec4 x4 = x0 + C.wwww;\\n\\n// Permutations\\n  i = mod289(i); \\n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\\n  vec4 j1 = permute( permute( permute( permute (\\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\\n\\n// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\\n\\n  vec4 p0 = grad4(j0,   ip);\\n  vec4 p1 = grad4(j1.x, ip);\\n  vec4 p2 = grad4(j1.y, ip);\\n  vec4 p3 = grad4(j1.z, ip);\\n  vec4 p4 = grad4(j1.w, ip);\\n\\n// Normalise gradients\\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\\n  p0 *= norm.x;\\n  p1 *= norm.y;\\n  p2 *= norm.z;\\n  p3 *= norm.w;\\n  p4 *= taylorInvSqrt(dot(p4,p4));\\n\\n// Mix contributions from the five corners\\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\\n  m0 = m0 * m0;\\n  m1 = m1 * m1;\\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\\n\\n  }\\n\"","import {BaseNodeGlMathFunctionArg1GlNode} from './_BaseMathFunction';\n// import {ParamType} from '../../../Engine/Param/_Module';\n// import {TypedConnectionFloat} from './GlData'\nimport {ThreeToGl} from '../../../core/ThreeToGl';\nimport {ShadersCollectionController} from './code/utils/ShadersCollectionController';\n\nexport class NullGlNode extends BaseNodeGlMathFunctionArg1GlNode {\n\tstatic type() {\n\t\treturn 'null';\n\t}\n\n\tset_lines(shaders_collection_controller: ShadersCollectionController) {\n\t\tconst in_value = ThreeToGl.any(this.variable_for_input('in'));\n\n\t\tconst gl_type = this.io.inputs.named_input_connection_points[0].type;\n\t\tconst out = this.gl_var_name('value');\n\t\tconst body_line = `${gl_type} ${out} = ${in_value}`;\n\t\tshaders_collection_controller.add_body_lines(this, [body_line]);\n\t}\n}\n","import {TypedGlNode} from './_Base';\n// import {ThreeToGl} from '../../../Core/ThreeToGl';\n// import {CodeBuilder} from './Util/CodeBuilder'\n// import {Definition} from './Definition/_Module';\n// import {ShaderName, LineType, LINE_TYPES} from './Assembler/Util/CodeBuilder';\n\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {ShadersCollectionController} from './code/utils/ShadersCollectionController';\nclass OutputGlParamsConfig extends NodeParamsConfig {\n\t// type = ParamConfig.INTEGER(0, {\n\t// \tmenu: {\n\t// \t\tentries: ConnectionPointTypes.map((name, i) => {\n\t// \t\t\treturn {name: name, value: i};\n\t// \t\t}),\n\t// \t},\n\t// });\n\t// value_float = ParamConfig.FLOAT(0, ConstantGlNode.typed_visible_options(ConnectionPointType.FLOAT));\n\t// value_vec2 = ParamConfig.VECTOR2([0, 0], ConstantGlNode.typed_visible_options(ConnectionPointType.VEC2));\n\t// value_vec3 = ParamConfig.VECTOR3([0, 0, 0], ConstantGlNode.typed_visible_options(ConnectionPointType.VEC3));\n\t// value_vec4 = ParamConfig.VECTOR4([0, 0, 0, 0], ConstantGlNode.typed_visible_options(ConnectionPointType.VEC4));\n}\nconst ParamsConfig = new OutputGlParamsConfig();\n\nexport class OutputGlNode extends TypedGlNode<OutputGlParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'output';\n\t}\n\n\tinitialize_node() {\n\t\tsuper.initialize_node();\n\t\tthis.add_post_dirty_hook('_set_mat_to_recompile', this._set_mat_to_recompile.bind(this));\n\t}\n\n\tcreate_params() {\n\t\tthis.material_node?.assembler_controller.add_output_params(this);\n\t}\n\n\tset_lines(shaders_collection_controller: ShadersCollectionController) {\n\t\t// if (shaders_collection_controller.shader_name) {\n\t\tthis.material_node?.assembler_controller.assembler.set_node_lines_output(this, shaders_collection_controller);\n\t\t// }\n\t}\n\n\t// set_color_declaration(color_declaration: string){\n\t// \tthis._color_declaration = color_declaration\n\t// }\n}\n","import {TypedGlNode} from './_Base';\nimport {\n\tConnectionPointTypes,\n\tConnectionPointType,\n\tConnectionPointInitValueMap,\n\tConnectionPointTypeToParamTypeMap,\n} from '../utils/connections/ConnectionPointType';\nimport lodash_isArray from 'lodash/isArray';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {ParamType} from '../../poly/ParamType';\nimport {UniformGLDefinition} from './utils/GLDefinition';\nimport {ParamConfigsController} from '../utils/code/controllers/ParamConfigsController';\nimport {ShadersCollectionController} from './code/utils/ShadersCollectionController';\nimport {GlConnectionsController} from './utils/ConnectionsController';\nclass ParamGlParamsConfig extends NodeParamsConfig {\n\tname = ParamConfig.STRING('');\n\ttype = ParamConfig.INTEGER(ConnectionPointTypes.indexOf(ConnectionPointType.FLOAT), {\n\t\tmenu: {\n\t\t\tentries: ConnectionPointTypes.map((name, i) => {\n\t\t\t\treturn {name: name, value: i};\n\t\t\t}),\n\t\t},\n\t});\n\tas_color = ParamConfig.BOOLEAN(0, {\n\t\tvisible_if: {type: ConnectionPointTypes.indexOf(ConnectionPointType.VEC3)},\n\t});\n}\nconst ParamsConfig = new ParamGlParamsConfig();\n\nexport class ParamGlNode extends TypedGlNode<ParamGlParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'param';\n\t}\n\tprotected _allow_inputs_created_from_params: boolean = false;\n\tprivate _on_create_set_name_if_none_bound = this._on_create_set_name_if_none.bind(this);\n\tpublic readonly gl_connections_controller: GlConnectionsController = new GlConnectionsController(this);\n\t// private _update_signature_if_required_bound = this._update_signature_if_required.bind(this);\n\tinitialize_node() {\n\t\tthis.add_post_dirty_hook('_set_mat_to_recompile', this._set_mat_to_recompile.bind(this));\n\t\tthis.lifecycle.add_on_create_hook(this._on_create_set_name_if_none_bound);\n\t\tthis.gl_connections_controller.initialize_node();\n\n\t\tthis.gl_connections_controller.set_expected_input_types_function(() => []);\n\t\tthis.gl_connections_controller.set_expected_output_types_function(() => [ConnectionPointTypes[this.pv.type]]);\n\t\t// this.params.add_on_scene_load_hook('_update_signature_if_required', this._update_signature_if_required_bound);\n\t\t// this.params.set_post_create_params_hook(this._update_signature_if_required_bound);\n\t\t// this.add_post_dirty_hook('_update_if_type_changed', this._update_signature_if_required_bound);\n\t}\n\t// private _update_signature_if_required(dirty_trigger?: CoreGraphNode) {\n\t// \tif (!this.lifecycle.creation_completed || dirty_trigger == this.p.type) {\n\t// \t\tthis.update_output_type();\n\t// \t\tthis.remove_dirty_state();\n\t// \t\tthis.make_output_nodes_dirty();\n\t// \t}\n\t// }\n\n\tset_lines(shaders_collection_controller: ShadersCollectionController) {\n\t\tconst definitions = [];\n\n\t\tconst gl_type = ConnectionPointTypes[this.pv.type];\n\t\tconst var_name = this.uniform_name();\n\n\t\tdefinitions.push(new UniformGLDefinition(this, gl_type, var_name));\n\t\tshaders_collection_controller.add_definitions(this, definitions);\n\t}\n\tset_param_configs() {\n\t\tconst gl_type = ConnectionPointTypes[this.pv.type];\n\t\tconst default_value = ConnectionPointInitValueMap[gl_type];\n\t\tlet param_type = ConnectionPointTypeToParamTypeMap[gl_type];\n\n\t\tthis._param_configs_controller = this._param_configs_controller || new ParamConfigsController();\n\t\tthis._param_configs_controller.reset();\n\n\t\tif (\n\t\t\tparam_type == ParamType.VECTOR3 &&\n\t\t\tthis.p.as_color.value &&\n\t\t\tlodash_isArray(default_value) &&\n\t\t\tdefault_value.length == 3\n\t\t) {\n\t\t\tthis._param_configs_controller.create_and_push(\n\t\t\t\tParamType.COLOR,\n\t\t\t\tthis.pv.name,\n\t\t\t\tdefault_value,\n\t\t\t\tthis.uniform_name()\n\t\t\t);\n\t\t} else {\n\t\t\tthis._param_configs_controller.create_and_push(\n\t\t\t\tparam_type,\n\t\t\t\tthis.pv.name,\n\t\t\t\tdefault_value,\n\t\t\t\tthis.uniform_name()\n\t\t\t);\n\t\t}\n\t}\n\tuniform_name() {\n\t\tconst output_connection_point = this.io.outputs.named_output_connection_points[0];\n\t\tconst var_name = this.gl_var_name(output_connection_point.name);\n\t\treturn var_name;\n\t}\n\n\t// update_output_type() {\n\t// \tconst set_dirty = false;\n\t// \tthis.io.outputs.set_named_output_connection_points(\n\t// \t\t[new TypedNamedConnectionPoint(OUTPUT_NAME, ConnectionPointTypes[this.pv.type])],\n\t// \t\tset_dirty\n\t// \t);\n\t// }\n\t//\n\t//\n\t// HOOKS\n\t//\n\t//\n\tprivate _on_create_set_name_if_none() {\n\t\tif (this.pv.name == '') {\n\t\t\tthis.p.name.set(this.name);\n\t\t}\n\t}\n}\n","import {BaseGlMathFunctionGlNode} from './_BaseMathFunction';\nimport {ConnectionPointType} from '../utils/connections/ConnectionPointType';\n\nexport class RefractGlNode extends BaseGlMathFunctionGlNode {\n\tstatic type() {\n\t\treturn 'refract';\n\t}\n\n\tinitialize_node() {\n\t\tsuper.initialize_node();\n\n\t\tthis.gl_connections_controller.set_input_name_function((index: number) => ['I', 'N', 'eta'][index]);\n\t\tthis.gl_connections_controller.set_output_name_function((index: number) => 'refract');\n\t\tthis.gl_connections_controller.set_expected_input_types_function(this._expected_input_types.bind(this));\n\t\tthis.gl_connections_controller.set_expected_output_types_function(this._expected_output_types.bind(this));\n\t}\n\n\tgl_method_name(): string {\n\t\treturn 'refract';\n\t}\n\n\tprotected _expected_input_types() {\n\t\tconst type = this.gl_connections_controller.first_input_connection_type() || ConnectionPointType.VEC3;\n\t\treturn [type, type, ConnectionPointType.FLOAT];\n\t}\n\n\tprotected _expected_output_types() {\n\t\tconst type = this._expected_input_types()[0];\n\t\treturn [type];\n\t}\n}\n","import {BaseNodeGlMathFunctionArg1GlNode} from './_BaseMathFunction';\nimport Quaternion from './gl/quaternion.glsl';\nimport {ConnectionPointType} from '../utils/connections/ConnectionPointType';\nimport {FunctionGLDefinition} from './utils/GLDefinition';\n\nexport class QuatMultGlNode extends BaseNodeGlMathFunctionArg1GlNode {\n\tstatic type() {\n\t\treturn 'quat_mult';\n\t}\n\tinitialize_node() {\n\t\tsuper.initialize_node();\n\n\t\tthis.gl_connections_controller.set_input_name_function((index: number) => ['quat0', 'quat1'][index]);\n\t\tthis.gl_connections_controller.set_expected_input_types_function(() => [\n\t\t\tConnectionPointType.VEC4,\n\t\t\tConnectionPointType.VEC4,\n\t\t]);\n\t\tthis.gl_connections_controller.set_expected_output_types_function(() => [ConnectionPointType.VEC4]);\n\t}\n\n\t// protected _gl_input_name(index: number) {\n\t// \treturn ['quat0', 'quat1'][index];\n\t// }\n\tgl_method_name(): string {\n\t\treturn 'quat_mult';\n\t}\n\n\t// protected _expected_input_types() {\n\t// \treturn [ConnectionPointType.VEC4, ConnectionPointType.VEC4];\n\t// }\n\t// protected _expected_output_types() {\n\t// \treturn [ConnectionPointType.VEC4];\n\t// }\n\tgl_function_definitions() {\n\t\treturn [new FunctionGLDefinition(this, ConnectionPointType.VEC4, Quaternion)];\n\t}\n}\n","import {BaseNodeGlMathFunctionArg2GlNode} from './_BaseMathFunction';\nimport Quaternion from './gl/quaternion.glsl';\nimport {ConnectionPointType} from '../utils/connections/ConnectionPointType';\nimport {FunctionGLDefinition} from './utils/GLDefinition';\n\nenum InputName {\n\tAXIS = 'axis',\n\tANGLE = 'angle',\n}\nconst InputNames: Array<InputName> = [InputName.AXIS, InputName.ANGLE];\ninterface IDefaultValues {\n\t[InputName.AXIS]: Number3;\n\t[InputName.ANGLE]: number;\n}\nconst DEFAULT_AXIS: Number3 = [0, 0, 1];\nconst DEFAULT_ANGLE: number = 0;\nconst DefaultValues: IDefaultValues = {\n\t[InputName.AXIS]: DEFAULT_AXIS,\n\t[InputName.ANGLE]: DEFAULT_ANGLE,\n};\n\nexport class QuatFromAxisAngleGlNode extends BaseNodeGlMathFunctionArg2GlNode {\n\tstatic type() {\n\t\treturn 'quat_from_axis_angle';\n\t}\n\n\tinitialize_node() {\n\t\tsuper.initialize_node();\n\n\t\tthis.gl_connections_controller.set_input_name_function((index: number) => InputNames[index]);\n\t\tthis.gl_connections_controller.set_expected_input_types_function(() => [\n\t\t\tConnectionPointType.VEC3,\n\t\t\tConnectionPointType.FLOAT,\n\t\t]);\n\t\tthis.gl_connections_controller.set_expected_output_types_function(() => [ConnectionPointType.VEC4]);\n\t}\n\n\t// protected _gl_input_name(index: number) {\n\t// \treturn InputNames[index];\n\t// }\n\tgl_input_default_value(name: string) {\n\t\treturn DefaultValues[name as InputName];\n\t}\n\tgl_method_name(): string {\n\t\treturn 'quat_from_axis_angle';\n\t}\n\n\t// protected _expected_input_types() {\n\t// \treturn [ConnectionPointType.VEC3, ConnectionPointType.FLOAT];\n\t// }\n\t// protected expected_output_types() {\n\t// \treturn [ConnectionPointType.VEC4];\n\t// }\n\tgl_function_definitions() {\n\t\treturn [new FunctionGLDefinition(this, ConnectionPointType.VEC4, Quaternion)];\n\t}\n}\n","import {BaseNodeGlMathFunctionArg1GlNode} from './_BaseMathFunction';\nimport Quaternion from './gl/quaternion.glsl';\nimport {ConnectionPointType} from '../utils/connections/ConnectionPointType';\nimport {FunctionGLDefinition} from './utils/GLDefinition';\n\nexport class QuatToAngleGlNode extends BaseNodeGlMathFunctionArg1GlNode {\n\tstatic type() {\n\t\treturn 'quat_to_angle';\n\t}\n\n\tinitialize_node() {\n\t\tsuper.initialize_node();\n\n\t\tthis.gl_connections_controller.set_input_name_function((index: number) => ['quat'][index]);\n\t\tthis.gl_connections_controller.set_expected_input_types_function(() => [ConnectionPointType.VEC4]);\n\t\tthis.gl_connections_controller.set_expected_output_types_function(() => [ConnectionPointType.FLOAT]);\n\t}\n\n\t// protected _gl_input_name(index: number) {\n\t// \treturn ['quat'][index];\n\t// }\n\tgl_method_name(): string {\n\t\treturn 'quat_to_angle';\n\t}\n\n\t// protected _expected_input_types() {\n\t// \treturn [ConnectionPointType.VEC4];\n\t// }\n\t// protected _expected_output_types() {\n\t// \treturn [ConnectionPointType.FLOAT];\n\t// }\n\tgl_function_definitions() {\n\t\treturn [new FunctionGLDefinition(this, ConnectionPointType.FLOAT, Quaternion)];\n\t}\n}\n","import {BaseNodeGlMathFunctionArg1GlNode} from './_BaseMathFunction';\nimport Quaternion from './gl/quaternion.glsl';\nimport {ConnectionPointType} from '../utils/connections/ConnectionPointType';\nimport {FunctionGLDefinition} from './utils/GLDefinition';\n\nexport class QuatToAxisGlNode extends BaseNodeGlMathFunctionArg1GlNode {\n\tstatic type() {\n\t\treturn 'quat_to_axis';\n\t}\n\n\tinitialize_node() {\n\t\tsuper.initialize_node();\n\n\t\tthis.gl_connections_controller.set_input_name_function((index: number) => ['quat'][index]);\n\t\tthis.gl_connections_controller.set_expected_input_types_function(() => [ConnectionPointType.VEC4]);\n\t\tthis.gl_connections_controller.set_expected_output_types_function(() => [ConnectionPointType.VEC3]);\n\t}\n\n\t// protected _gl_input_name(index: number) {\n\t// \treturn ['quat'][index];\n\t// }\n\tgl_method_name(): string {\n\t\treturn 'quat_to_axis';\n\t}\n\n\t// protected _expected_input_types() {\n\t// \treturn [ConnectionPointType.VEC4];\n\t// }\n\t// protected _expected_output_types() {\n\t// \treturn [ConnectionPointType.VEC3];\n\t// }\n\tgl_function_definitions() {\n\t\treturn [new FunctionGLDefinition(this, ConnectionPointType.VEC3, Quaternion)];\n\t}\n}\n","import {TypedGlNode} from './_Base';\nimport {ConnectionPointType} from '../utils/connections/ConnectionPointType';\nimport {TypedNamedConnectionPoint} from '../utils/connections/NamedConnectionPoint';\nimport {ShadersCollectionController} from './code/utils/ShadersCollectionController';\nimport {UniformGLDefinition} from './utils/GLDefinition';\nimport {RampParam} from '../../params/Ramp';\nimport {ParamConfigsController} from '../utils/code/controllers/ParamConfigsController';\nimport {ParamType} from '../../poly/ParamType';\n\nconst OUTPUT_NAME = 'val';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nclass RampGlParamsConfig extends NodeParamsConfig {\n\tname = ParamConfig.STRING('ramp');\n\tinput = ParamConfig.FLOAT(0);\n}\nconst ParamsConfig = new RampGlParamsConfig();\nexport class RampGlNode extends TypedGlNode<RampGlParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'ramp';\n\t}\n\n\tinitialize() {\n\t\tsuper.initialize_node();\n\n\t\tthis.io.outputs.set_named_output_connection_points([\n\t\t\tnew TypedNamedConnectionPoint(OUTPUT_NAME, ConnectionPointType.FLOAT),\n\t\t]);\n\t}\n\n\tset_lines(shaders_collection_controller: ShadersCollectionController) {\n\t\tconst gl_type = ConnectionPointType.FLOAT;\n\t\tconst texture_name = this._uniform_name();\n\t\tconst var_name = this.gl_var_name(OUTPUT_NAME);\n\n\t\tconst definition = new UniformGLDefinition(this, ConnectionPointType.SAMPLER_2D, texture_name);\n\t\tshaders_collection_controller.add_definitions(this, [definition]);\n\n\t\tconst input_val = this.variable_for_input(this.p.input.name);\n\t\tconst body_line = `${gl_type} ${var_name} = texture2D(${this._uniform_name()}, vec2(${input_val}, 0.0)).x`;\n\t\tshaders_collection_controller.add_body_lines(this, [body_line]);\n\t}\n\tset_param_configs() {\n\t\tthis._param_configs_controller = this._param_configs_controller || new ParamConfigsController();\n\t\tthis._param_configs_controller.reset();\n\t\tthis._param_configs_controller.create_and_push(\n\t\t\tParamType.RAMP,\n\t\t\tthis.pv.name,\n\t\t\tRampParam.DEFAULT_VALUE,\n\t\t\tthis._uniform_name()\n\t\t);\n\t}\n\tprivate _uniform_name() {\n\t\treturn 'ramp_texture_' + this.gl_var_name(OUTPUT_NAME);\n\t}\n}\n","import {TypedGlNode} from './_Base';\nimport {ThreeToGl} from '../../../../src/core/ThreeToGl';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {ConnectionPointType} from '../utils/connections/ConnectionPointType';\nimport {TypedNamedConnectionPoint} from '../utils/connections/NamedConnectionPoint';\nimport {ShadersCollectionController} from './code/utils/ShadersCollectionController';\n\nconst OUTPUT_NAME = 'rand';\n\nclass RandomGlParamsConfig extends NodeParamsConfig {\n\tseed = ParamConfig.VECTOR2([1, 1]);\n}\nconst ParamsConfig = new RandomGlParamsConfig();\nexport class RandomGlNode extends TypedGlNode<RandomGlParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'random';\n\t}\n\n\tinitialize_node() {\n\t\tsuper.initialize_node();\n\n\t\tthis.io.outputs.set_named_output_connection_points([\n\t\t\tnew TypedNamedConnectionPoint(OUTPUT_NAME, ConnectionPointType.FLOAT),\n\t\t]);\n\t}\n\n\tset_lines(shaders_collection_controller: ShadersCollectionController) {\n\t\t// const function_declaration_lines = []\n\n\t\t// http://byteblacksmith.com/improvements-to-the-canonical-one-liner-glsl-rand-for-opengl-es-2-0/\n\t\t// \t\tfunction_declaration_lines.push(`highp float rand2(vec2 co){\n\t\t// \thighp float a = 12.9898;\n\t\t// \thighp float b = 78.233;\n\t\t// \thighp float c = 43758.5453;\n\t\t// \thighp float dt= dot(co.xy ,vec2(a,b));\n\t\t// \thighp float sn= mod(dt,3.14);\n\t\t// \treturn fract(sin(sn) * c);\n\t\t// }`)\n\n\t\tconst input_name = this.io.inputs.named_input_connection_points[0].name;\n\t\tconst value = ThreeToGl.vector2(this.variable_for_input(input_name));\n\n\t\tconst float = this.gl_var_name(OUTPUT_NAME);\n\t\tconst body_line = `float ${float} = rand(${value})`;\n\t\t// this.set_function_declaration_lines(function_declaration_lines)\n\t\tshaders_collection_controller.add_body_lines(this, [body_line]);\n\t}\n}\n","import {TypedGlNode} from './_Base';\nimport {ThreeToGl} from '../../../../src/core/ThreeToGl';\n\nimport Rgb2Hsv from './gl/rgb2hsv.glsl';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {ConnectionPointType} from '../utils/connections/ConnectionPointType';\nimport {FunctionGLDefinition} from './utils/GLDefinition';\nimport {TypedNamedConnectionPoint} from '../utils/connections/NamedConnectionPoint';\nimport {ShadersCollectionController} from './code/utils/ShadersCollectionController';\n\nconst OUTPUT_NAME = 'hsv';\nclass RgbToHsvGlParamsConfig extends NodeParamsConfig {\n\trgb = ParamConfig.VECTOR3([1, 1, 1]);\n}\nconst ParamsConfig = new RgbToHsvGlParamsConfig();\nexport class RgbToHsvGlNode extends TypedGlNode<RgbToHsvGlParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'rgb_to_hsv';\n\t}\n\n\tinitialize_node() {\n\t\tsuper.initialize_node();\n\n\t\tthis.io.outputs.set_named_output_connection_points([\n\t\t\tnew TypedNamedConnectionPoint(OUTPUT_NAME, ConnectionPointType.VEC3),\n\t\t]);\n\t}\n\n\tset_lines(shaders_collection_controller: ShadersCollectionController) {\n\t\tconst function_declaration_lines = [];\n\t\tconst body_lines = [];\n\n\t\tfunction_declaration_lines.push(new FunctionGLDefinition(this, ConnectionPointType.VEC3, Rgb2Hsv));\n\n\t\tconst rgb = ThreeToGl.vector3(this.variable_for_input('rgb'));\n\n\t\tconst hsv = this.gl_var_name('hsv');\n\t\tbody_lines.push(`vec3 ${hsv} = rgb2hsv(${rgb})`);\n\t\tshaders_collection_controller.add_definitions(this, function_declaration_lines);\n\t\tshaders_collection_controller.add_body_lines(this, body_lines);\n\t}\n}\n","export default \"// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\\nvec3 rgb2hsv(vec3 c)\\n{\\n\\tvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\\n\\tvec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\\n\\tvec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\\n\\n\\tfloat d = q.x - min(q.w, q.y);\\n\\tfloat e = 1.0e-10;\\n\\treturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\\n}\"","import {BaseAdaptiveGlNode} from './_BaseAdaptive';\nimport Quaternion from './gl/quaternion.glsl';\nimport {FunctionGLDefinition} from './utils/GLDefinition';\nimport {ConnectionPointType} from '../utils/connections/ConnectionPointType';\n\nenum Mode {\n\tAXIS = 0,\n\tQUAT = 1,\n}\nconst Modes: Array<Mode> = [Mode.AXIS, Mode.QUAT];\n\ntype StringByMode = {[key in Mode]: string};\nconst LabelByMode: StringByMode = {\n\t[Mode.AXIS]: 'from axis + angle',\n\t[Mode.QUAT]: 'from quaternion',\n};\ntype StringArrayByMode = {[key in Mode]: string[]};\nconst InputNamesByMode: StringArrayByMode = {\n\t[Mode.AXIS]: ['vector', 'axis', 'angle'],\n\t[Mode.QUAT]: ['vector', 'quat'],\n};\nconst MethodNameByMode: StringByMode = {\n\t[Mode.AXIS]: 'rotate_with_axis_angle',\n\t[Mode.QUAT]: 'rotate_with_quat',\n};\ntype ConnectionTypeArrayByMode = {[key in Mode]: ConnectionPointType[]};\nconst InputTypesByMode: ConnectionTypeArrayByMode = {\n\t[Mode.AXIS]: [ConnectionPointType.VEC3, ConnectionPointType.VEC3, ConnectionPointType.FLOAT],\n\t[Mode.QUAT]: [ConnectionPointType.VEC3, ConnectionPointType.VEC4],\n};\n\nconst DefaultValues: Dictionary<Number3> = {\n\tvector: [0, 0, 1],\n\taxis: [0, 1, 0],\n};\n\nimport {ParamConfig, NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {ShadersCollectionController} from './code/utils/ShadersCollectionController';\nimport {ThreeToGl} from '../../../core/ThreeToGl';\n\nclass RotateParamsConfig extends NodeParamsConfig {\n\tsignature = ParamConfig.INTEGER(Mode.AXIS, {\n\t\tmenu: {\n\t\t\tentries: Modes.map((mode, i) => {\n\t\t\t\tconst label = LabelByMode[mode];\n\t\t\t\treturn {name: label, value: i};\n\t\t\t}),\n\t\t},\n\t});\n}\n\nconst ParamsConfig = new RotateParamsConfig();\nexport class RotateGlNode extends BaseAdaptiveGlNode<RotateParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'rotate';\n\t}\n\n\t// _signature_name: string = 'AXIS';\n\n\tinitialize_node() {\n\t\tsuper.initialize_node();\n\t\tthis.gl_connections_controller.set_expected_input_types_function(this._expected_input_types.bind(this));\n\t\tthis.gl_connections_controller.set_expected_output_types_function(this._expected_output_types.bind(this));\n\t\tthis.gl_connections_controller.set_input_name_function(this._gl_input_name.bind(this));\n\t}\n\n\tprotected _gl_input_name(index: number) {\n\t\tconst mode = Modes[this.pv.signature];\n\t\treturn InputNamesByMode[mode][index];\n\t}\n\tgl_input_default_value(name: string) {\n\t\treturn DefaultValues[name];\n\t}\n\tgl_method_name(): string {\n\t\tconst mode = Modes[this.pv.signature];\n\t\treturn MethodNameByMode[mode];\n\t}\n\n\tprotected _expected_input_types() {\n\t\tconst mode = Modes[this.pv.signature];\n\t\treturn InputTypesByMode[mode];\n\t}\n\tprotected _expected_output_types() {\n\t\treturn [ConnectionPointType.VEC3];\n\t}\n\tgl_function_definitions() {\n\t\tconst type = this._expected_output_types()[0];\n\t\treturn [new FunctionGLDefinition(this, type, Quaternion)];\n\t}\n\n\tset_lines(shaders_collection_controller: ShadersCollectionController) {\n\t\tconst var_type: ConnectionPointType = this.io.outputs.named_output_connection_points[0].type;\n\t\tconst args = this.io.inputs.named_input_connection_points.map((connection, i) => {\n\t\t\tconst name = connection.name;\n\t\t\treturn ThreeToGl.any(this.variable_for_input(name));\n\t\t});\n\t\tconst joined_args = args.join(', ');\n\n\t\tconst sum = this.gl_var_name(this.gl_connections_controller.output_name(0));\n\t\tconst body_line = `${var_type} ${sum} = ${this.gl_method_name()}(${joined_args})`;\n\t\tshaders_collection_controller.add_body_lines(this, [body_line]);\n\t\tshaders_collection_controller.add_definitions(this, this.gl_function_definitions());\n\t}\n}\n","import {BaseNodeGlMathFunctionArg1GlNode} from './_BaseMathFunction';\nimport {ThreeToGl} from '../../../core/ThreeToGl';\nimport {ShadersCollectionController} from './code/utils/ShadersCollectionController';\nimport {ConnectionPointComponentsCountMap} from '../utils/connections/ConnectionPointType';\n\nconst ALL_COMPONENTS = ['x', 'y', 'z', 'w'];\n// const OUTPUT_NAME = 'round'\n\nexport class RoundGlNode extends BaseNodeGlMathFunctionArg1GlNode {\n\tstatic type() {\n\t\treturn 'round';\n\t}\n\n\t// initialize_node() {\n\t// \tsuper.initialize_node();\n\t// \tthis.set_named_outputs([new TypedConnectionFloat(v)]);\n\t// }\n\n\t// create_params() {\n\t// \tthis.add_param(ParamType.FLOAT, 'value', 1);\n\t// }\n\t// https://hub.jmonkeyengine.org/t/round-with-glsl/8186/6\n\tset_lines(shaders_collection_controller: ShadersCollectionController) {\n\t\t// const function_declaration_lines = []\n\n\t\t// \t\tfunction_declaration_lines.push(`highp float round(float num){\n\t\t// \treturn floor(num)-fract(num);\n\t\t// }`)\n\t\tconst input_connection = this.io.inputs.named_input_connection_points[0];\n\t\tconst value = ThreeToGl.vector2(this.variable_for_input(input_connection.name));\n\n\t\tconst output_connection = this.io.outputs.named_output_connection_points[0];\n\t\tconst var_name = this.gl_var_name(output_connection.name);\n\n\t\tconst body_lines: string[] = [];\n\t\tconst lines_count = ConnectionPointComponentsCountMap[output_connection.type];\n\t\tif (lines_count == 1) {\n\t\t\tbody_lines.push(`${output_connection.type} ${var_name} = ${this._simple_line(value)}`);\n\t\t} else {\n\t\t\tconst simple_lines: string[] = ALL_COMPONENTS.map((c) => {\n\t\t\t\treturn this._simple_line(`${value}.${c}`);\n\t\t\t});\n\t\t\tbody_lines.push(\n\t\t\t\t`${output_connection.type} ${var_name} = ${output_connection.type}(${simple_lines.join(',')})`\n\t\t\t);\n\t\t}\n\t\tshaders_collection_controller.add_body_lines(this, body_lines);\n\t}\n\n\tprivate _simple_line(value: string) {\n\t\treturn `sign(${value})*floor(abs(${value})+0.5)`;\n\t}\n}\n","import {TypedGlNode} from './_Base';\nimport {FileCopNode} from '../cop/File';\n\nimport {TypedNamedConnectionPoint} from '../utils/connections/NamedConnectionPoint';\nimport {ConnectionPointType} from '../utils/connections/ConnectionPointType';\nimport {ThreeToGl} from '../../../core/ThreeToGl';\nimport {UniformGLDefinition} from './utils/GLDefinition';\nimport {ShadersCollectionController} from './code/utils/ShadersCollectionController';\nimport {ParamConfigsController} from '../utils/code/controllers/ParamConfigsController';\nimport {ParamType} from '../../poly/ParamType';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nclass TextureParamsConfig extends NodeParamsConfig {\n\tparam_name = ParamConfig.STRING('texture_map');\n\tdefault_value = ParamConfig.STRING(FileCopNode.DEFAULT_NODE_PATH.UV);\n\tuv = ParamConfig.VECTOR2([0, 0]);\n}\nconst ParamsConfig = new TextureParamsConfig();\nexport class TextureGlNode extends TypedGlNode<TextureParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'texture';\n\t}\n\tstatic readonly OUTPUT_NAME = 'rgba';\n\n\tinitialize_node() {\n\t\tsuper.initialize_node();\n\n\t\tthis.io.outputs.set_named_output_connection_points([\n\t\t\tnew TypedNamedConnectionPoint(TextureGlNode.OUTPUT_NAME, ConnectionPointType.VEC4),\n\t\t]);\n\t}\n\n\tset_lines(shaders_collection_controller: ShadersCollectionController) {\n\t\tconst uv = ThreeToGl.vector2(this.variable_for_input(this.p.uv.name));\n\n\t\tconst rgba = this.gl_var_name(TextureGlNode.OUTPUT_NAME);\n\t\tconst map = this._uniform_name();\n\t\tconst definition = new UniformGLDefinition(this, ConnectionPointType.SAMPLER_2D, map);\n\t\tconst body_line = `vec4 ${rgba} = texture2D(${map}, ${uv})`;\n\t\tshaders_collection_controller.add_definitions(this, [definition]);\n\t\tshaders_collection_controller.add_body_lines(this, [body_line]);\n\t}\n\n\tset_param_configs() {\n\t\tthis._param_configs_controller = this._param_configs_controller || new ParamConfigsController();\n\t\tthis._param_configs_controller.reset();\n\n\t\tthis._param_configs_controller.create_and_push(\n\t\t\tParamType.OPERATOR_PATH,\n\t\t\tthis.pv.param_name,\n\t\t\tthis.pv.default_value,\n\t\t\tthis._uniform_name()\n\t\t);\n\t}\n\tprivate _uniform_name() {\n\t\treturn this.gl_var_name(this.pv.param_name);\n\t}\n}\n","import {ParamlessTypedGlNode} from './_Base';\nimport {ThreeToGl} from '../../../core/ThreeToGl';\nimport {GlConnectionsController} from './utils/ConnectionsController';\n\nconst OUTPUT_NAME = 'value';\nenum InputName {\n\tCONDITION = 'condition',\n\tIF_TRUE = 'if_true',\n\tIF_FALSE = 'if_false',\n}\nconst InputNames: Array<InputName> = [InputName.CONDITION, InputName.IF_TRUE, InputName.IF_FALSE];\n\nimport {ConnectionPointType} from '../utils/connections/ConnectionPointType';\nimport {ShadersCollectionController} from './code/utils/ShadersCollectionController';\nexport class TwoWaySwitchGlNode extends ParamlessTypedGlNode {\n\tstatic type() {\n\t\treturn 'two_way_switch';\n\t}\n\n\tpublic readonly gl_connections_controller: GlConnectionsController = new GlConnectionsController(this);\n\tinitialize_node() {\n\t\tsuper.initialize_node();\n\t\tthis.gl_connections_controller.initialize_node();\n\n\t\tthis.gl_connections_controller.set_expected_input_types_function(this._expected_input_types.bind(this));\n\t\tthis.gl_connections_controller.set_expected_output_types_function(this._expected_output_types.bind(this));\n\t\tthis.gl_connections_controller.set_input_name_function(this._gl_input_name.bind(this));\n\t\tthis.gl_connections_controller.set_output_name_function(this._gl_output_name.bind(this));\n\t}\n\n\tprotected _gl_input_name(index: number) {\n\t\treturn InputNames[index];\n\t}\n\tprotected _gl_output_name() {\n\t\treturn OUTPUT_NAME;\n\t}\n\tprotected _expected_input_types(): ConnectionPointType[] {\n\t\tconst second_or_third_connection =\n\t\t\tthis.io.connections.input_connection(1) || this.io.connections.input_connection(2);\n\t\tconst type: ConnectionPointType = second_or_third_connection\n\t\t\t? this.gl_connections_controller.connection_type_from_connection(second_or_third_connection)\n\t\t\t: ConnectionPointType.FLOAT;\n\t\treturn [ConnectionPointType.BOOL, type, type];\n\t}\n\tprotected _expected_output_types() {\n\t\tconst type = this._expected_input_types()[1];\n\t\treturn [type];\n\t}\n\n\tset_lines(shaders_collection_controller: ShadersCollectionController) {\n\t\tconst body_lines: string[] = [];\n\n\t\tconst value = this.gl_var_name(OUTPUT_NAME);\n\t\tconst condition = ThreeToGl.bool(this.variable_for_input(InputName.CONDITION));\n\t\tconst if_true = ThreeToGl.any(this.variable_for_input(InputName.IF_TRUE));\n\t\tconst if_false = ThreeToGl.any(this.variable_for_input(InputName.IF_FALSE));\n\n\t\tconst gl_type = this._expected_output_types()[1];\n\t\tbody_lines.push(`${gl_type} ${value}`);\n\t\tbody_lines.push(`if(${condition}){`);\n\t\tbody_lines.push(`${value} = ${if_true}`);\n\t\tbody_lines.push(`} else {`);\n\t\tbody_lines.push(`${value} = ${if_false}`);\n\t\tbody_lines.push(`}`);\n\t\tshaders_collection_controller.add_body_lines(this, body_lines);\n\t}\n}\n","import Quaternion from './gl/quaternion.glsl';\nimport {MathFunctionArg3Factory} from './_Math_Arg3';\nimport {ConnectionPointType} from '../utils/connections/ConnectionPointType';\n\nconst DefaultValues: Dictionary<Number3> = {\n\tstart: [0, 0, 1],\n\tend: [1, 0, 0],\n\tup: [0, 1, 0],\n};\n\nexport class VectorAlignGlNode extends MathFunctionArg3Factory('vector_align', {\n\tin: ['start', 'end', 'up'],\n\tmethod: 'vector_align_with_up',\n\tfunctions: [Quaternion],\n}) {\n\tprotected _expected_input_types() {\n\t\tconst type = ConnectionPointType.VEC3;\n\t\treturn [type, type, type];\n\t}\n\tprotected _expected_output_types() {\n\t\treturn [ConnectionPointType.VEC4];\n\t}\n\tgl_input_default_value(name: string) {\n\t\treturn DefaultValues[name];\n\t}\n}\n","import Quaternion from './gl/quaternion.glsl';\nimport {MathFunctionArg2Factory} from './_Math_Arg2';\nimport {ConnectionPointType} from '../utils/connections/ConnectionPointType';\n\nconst DefaultValues: Dictionary<Number3> = {\n\tstart: [0, 0, 1],\n\tend: [1, 0, 0],\n};\n\nexport class VectorAngleGlNode extends MathFunctionArg2Factory('vector_angle', {\n\tin: ['start', 'end'],\n\tmethod: 'vector_angle',\n\tfunctions: [Quaternion],\n}) {\n\tprotected _expected_input_types() {\n\t\tconst type = ConnectionPointType.VEC3;\n\t\treturn [type, type];\n\t}\n\tprotected _expected_output_types() {\n\t\treturn [ConnectionPointType.FLOAT];\n\t}\n\tgl_input_default_value(name: string) {\n\t\treturn DefaultValues[name];\n\t}\n}\n","import {CATEGORY_GL} from './Category';\n\nimport {FloatToIntGlNode, IntToFloatGlNode} from '../../nodes/gl/_ConversionMisc';\nimport {FloatToVec2GlNode, FloatToVec3GlNode, FloatToVec4GlNode} from '../../nodes/gl/_ConversionToVec';\n\nimport {\n\tVec2ToFloatGlNode,\n\tVec3ToFloatGlNode,\n\tVec4ToFloatGlNode,\n\tVec4ToVectorGlNode,\n} from '../../nodes/gl/_ConversionVecTo';\n\nimport {\n\tAbsGlNode,\n\tAcosGlNode,\n\tAsinGlNode,\n\tAtanGlNode,\n\tCeilGlNode,\n\tCosGlNode,\n\tDegreesGlNode,\n\tExpGlNode,\n\tExp2GlNode,\n\tFloorGlNode,\n\tFractGlNode,\n\tInverseSqrtGlNode,\n\tLogGlNode,\n\tLog2GlNode,\n\tNormalizeGlNode,\n\tRadiansGlNode,\n\tSignGlNode,\n\tSinGlNode,\n\tSqrtGlNode,\n\tTanGlNode,\n} from '../../nodes/gl/_Math_Arg1';\n\nimport {\n\tDistanceGlNode,\n\tDotGlNode,\n\tMaxGlNode,\n\tMinGlNode,\n\tModGlNode,\n\tPowGlNode,\n\tReflectGlNode,\n\tStepGlNode,\n} from '../../nodes/gl/_Math_Arg2';\n\nimport {AddGlNode, DivideGlNode, MultGlNode, SubstractGlNode} from '../../nodes/gl/_Math_Arg2Operation';\n\nimport {AndGlNode, OrGlNode} from '../../nodes/gl/_Math_Arg2Boolean';\nimport {AlignGlNode} from '../../nodes/gl/Align';\nimport {AttributeGlNode} from '../../nodes/gl/Attribute';\nimport {ConstantGlNode} from '../../nodes/gl/Constant';\nimport {ComplementGlNode} from '../../nodes/gl/Complement';\nimport {CrossGlNode} from '../../nodes/gl/Cross';\nimport {CycleGlNode} from '../../nodes/gl/Cycle';\nimport {DiskGlNode} from '../../nodes/gl/Disk';\nimport {EasingGlNode} from '../../nodes/gl/Easing';\nimport {FitGlNode} from '../../nodes/gl/Fit';\nimport {Fit01GlNode} from '../../nodes/gl/Fit01';\nimport {GlobalsGlNode} from '../../nodes/gl/Globals';\nimport {HsvToRgbGlNode} from '../../nodes/gl/HsvToRgb';\nimport {InstanceTransformGlNode} from '../../nodes/gl/InstanceTransform';\nimport {LengthGlNode} from '../../nodes/gl/Length';\nimport {LuminanceGlNode} from '../../nodes/gl/Luminance';\nimport {MixGlNode} from '../../nodes/gl/Mix';\nimport {MultAddGlNode} from '../../nodes/gl/MultAdd';\nimport {NegateGlNode} from '../../nodes/gl/Negate';\nimport {NoiseGlNode} from '../../nodes/gl/Noise';\nimport {NullGlNode} from '../../nodes/gl/Null';\nimport {OutputGlNode} from '../../nodes/gl/Output';\nimport {ParamGlNode} from '../../nodes/gl/Param';\nimport {RefractGlNode} from '../../nodes/gl/Refract';\nimport {QuatMultGlNode} from '../../nodes/gl/QuatMult';\nimport {QuatFromAxisAngleGlNode} from '../../nodes/gl/QuatFromAxisAngle';\nimport {QuatToAngleGlNode} from '../../nodes/gl/QuatToAngle';\nimport {QuatToAxisGlNode} from '../../nodes/gl/QuatToAxis';\nimport {RampGlNode} from '../../nodes/gl/Ramp';\nimport {RandomGlNode} from '../../nodes/gl/Random';\nimport {RgbToHsvGlNode} from '../../nodes/gl/RgbToHsv';\nimport {RotateGlNode} from '../../nodes/gl/Rotate';\nimport {RoundGlNode} from '../../nodes/gl/Round';\nimport {TextureGlNode} from '../../nodes/gl/Texture';\nimport {TwoWaySwitchGlNode} from '../../nodes/gl/TwoWaySwitch';\nimport {VectorAlignGlNode} from '../../nodes/gl/VectorAlign';\nimport {VectorAngleGlNode} from '../../nodes/gl/VectorAngle';\n\nexport interface GlNodeChildrenMap {\n\tabs: AbsGlNode;\n\tacos: AcosGlNode;\n\tadd: AddGlNode;\n\talign: AlignGlNode;\n\tand: AndGlNode;\n\tasin: AsinGlNode;\n\tatan: AtanGlNode;\n\tattribute: AttributeGlNode;\n\tceil: CeilGlNode;\n\tconstant: ConstantGlNode;\n\tcos: CosGlNode;\n\tcomplement: ComplementGlNode;\n\tcross: CrossGlNode;\n\tcycle: CycleGlNode;\n\tdegrees: DegreesGlNode;\n\tdisk: DiskGlNode;\n\tdistance: DistanceGlNode;\n\tdivide: DivideGlNode;\n\tdot: DotGlNode;\n\teasing: EasingGlNode;\n\texp: ExpGlNode;\n\texp2: Exp2GlNode;\n\tfit: FitGlNode;\n\tfit01: Fit01GlNode;\n\tfloat_to_int: FloatToIntGlNode;\n\tfloat_to_vec2: FloatToVec2GlNode;\n\tfloat_to_vec3: FloatToVec3GlNode;\n\tfloat_to_vec4: FloatToVec4GlNode;\n\tfloor: FloorGlNode;\n\tfract: FractGlNode;\n\thsv_to_rgb: HsvToRgbGlNode;\n\tint_to_float: FloatToIntGlNode;\n\tinverse_sqrt: InverseSqrtGlNode;\n\tinstance_transform: InstanceTransformGlNode;\n\tlength: LengthGlNode;\n\tlog: LogGlNode;\n\tlog2: Log2GlNode;\n\tluminance: LuminanceGlNode;\n\tglobals: GlobalsGlNode;\n\tmax: MaxGlNode;\n\tmin: MinGlNode;\n\tmix: MixGlNode;\n\tmod: ModGlNode;\n\tmult: MultGlNode;\n\tmult_add: MultAddGlNode;\n\tnegate: NegateGlNode;\n\tnoise: NoiseGlNode;\n\tnormalize: NormalizeGlNode;\n\tnull: NullGlNode;\n\tor: OrGlNode;\n\toutput: OutputGlNode;\n\tparam: ParamGlNode;\n\tpow: PowGlNode;\n\tquat_mult: QuatMultGlNode;\n\tquat_from_axis_angle: QuatFromAxisAngleGlNode;\n\tquat_to_angle: QuatToAngleGlNode;\n\tquat_to_axis: QuatToAxisGlNode;\n\tradians: RadiansGlNode;\n\tramp: RampGlNode;\n\trandom: RandomGlNode;\n\treflect: ReflectGlNode;\n\trefract: RefractGlNode;\n\trgb_to_hsv: RgbToHsvGlNode;\n\trotate: RotateGlNode;\n\tround: RoundGlNode;\n\tsign: SignGlNode;\n\tsin: SinGlNode;\n\tsqrt: SqrtGlNode;\n\tstep: StepGlNode;\n\tsubstract: SubstractGlNode;\n\ttan: TanGlNode;\n\ttexture: TextureGlNode;\n\ttwo_way_switch: TwoWaySwitchGlNode;\n\tvec2_to_float: Vec2ToFloatGlNode;\n\tvec3_to_float: Vec3ToFloatGlNode;\n\tvec4_to_float: Vec4ToFloatGlNode;\n\tvec4_to_vector: Vec4ToVectorGlNode;\n\tvector_align: VectorAlignGlNode;\n\tvector_angle: VectorAngleGlNode;\n}\n\nimport {NodeContext} from '../NodeContext';\nimport {Poly} from '../../Poly';\nexport class GlRegister {\n\tstatic run(poly: Poly) {\n\t\tpoly.register_node(AbsGlNode, CATEGORY_GL.MATH);\n\t\tpoly.register_node(AcosGlNode, CATEGORY_GL.TRIGO);\n\t\tpoly.register_node(AddGlNode, CATEGORY_GL.MATH);\n\t\tpoly.register_node(AlignGlNode, CATEGORY_GL.TRIGO);\n\t\tpoly.register_node(AndGlNode, CATEGORY_GL.LOGIC);\n\t\tpoly.register_node(AsinGlNode, CATEGORY_GL.TRIGO);\n\t\tpoly.register_node(AtanGlNode, CATEGORY_GL.TRIGO);\n\t\tpoly.register_node(AttributeGlNode, CATEGORY_GL.GLOBALS, {except: [`${NodeContext.COP}/builder`]});\n\t\tpoly.register_node(CeilGlNode, CATEGORY_GL.MATH);\n\t\tpoly.register_node(CosGlNode, CATEGORY_GL.TRIGO);\n\t\tpoly.register_node(ConstantGlNode, CATEGORY_GL.GLOBALS);\n\t\tpoly.register_node(ComplementGlNode, CATEGORY_GL.MATH);\n\t\tpoly.register_node(CrossGlNode, CATEGORY_GL.GEOMETRY);\n\t\tpoly.register_node(CycleGlNode, CATEGORY_GL.MATH);\n\t\tpoly.register_node(DegreesGlNode, CATEGORY_GL.CONVERSION);\n\t\tpoly.register_node(DiskGlNode, CATEGORY_GL.GEOMETRY);\n\t\tpoly.register_node(DistanceGlNode, CATEGORY_GL.GEOMETRY);\n\t\tpoly.register_node(DivideGlNode, CATEGORY_GL.MATH);\n\t\tpoly.register_node(DotGlNode, CATEGORY_GL.GEOMETRY);\n\t\tpoly.register_node(EasingGlNode, CATEGORY_GL.MATH);\n\t\tpoly.register_node(ExpGlNode, CATEGORY_GL.MATH);\n\t\tpoly.register_node(Exp2GlNode, CATEGORY_GL.MATH);\n\t\tpoly.register_node(FitGlNode, CATEGORY_GL.MATH);\n\t\tpoly.register_node(Fit01GlNode, CATEGORY_GL.MATH);\n\t\tpoly.register_node(FloatToIntGlNode, CATEGORY_GL.CONVERSION);\n\t\tpoly.register_node(FloatToVec2GlNode, CATEGORY_GL.CONVERSION);\n\t\tpoly.register_node(FloatToVec3GlNode, CATEGORY_GL.CONVERSION);\n\t\tpoly.register_node(FloatToVec4GlNode, CATEGORY_GL.CONVERSION);\n\t\tpoly.register_node(FloorGlNode, CATEGORY_GL.MATH);\n\t\tpoly.register_node(FractGlNode, CATEGORY_GL.MATH);\n\t\tpoly.register_node(GlobalsGlNode, CATEGORY_GL.GLOBALS);\n\t\tpoly.register_node(HsvToRgbGlNode, CATEGORY_GL.COLOR);\n\t\tpoly.register_node(IntToFloatGlNode, CATEGORY_GL.CONVERSION);\n\t\tpoly.register_node(InverseSqrtGlNode, CATEGORY_GL.MATH);\n\t\tpoly.register_node(InstanceTransformGlNode, CATEGORY_GL.GEOMETRY);\n\t\tpoly.register_node(LengthGlNode, CATEGORY_GL.GEOMETRY);\n\t\tpoly.register_node(LuminanceGlNode, CATEGORY_GL.COLOR);\n\t\tpoly.register_node(NegateGlNode, CATEGORY_GL.MATH);\n\t\tpoly.register_node(LogGlNode, CATEGORY_GL.MATH);\n\t\tpoly.register_node(Log2GlNode, CATEGORY_GL.MATH);\n\t\tpoly.register_node(MaxGlNode, CATEGORY_GL.MATH);\n\t\tpoly.register_node(MinGlNode, CATEGORY_GL.MATH);\n\t\tpoly.register_node(ModGlNode, CATEGORY_GL.MATH);\n\t\tpoly.register_node(MixGlNode, CATEGORY_GL.MATH);\n\t\tpoly.register_node(MultGlNode, CATEGORY_GL.MATH);\n\t\tpoly.register_node(MultAddGlNode, CATEGORY_GL.MATH);\n\t\tpoly.register_node(NullGlNode, CATEGORY_GL.UTIL);\n\t\tpoly.register_node(NoiseGlNode, CATEGORY_GL.GEOMETRY);\n\t\tpoly.register_node(NormalizeGlNode, CATEGORY_GL.MATH);\n\t\tpoly.register_node(OrGlNode, CATEGORY_GL.LOGIC);\n\t\tpoly.register_node(OutputGlNode, CATEGORY_GL.GLOBALS);\n\t\tpoly.register_node(ParamGlNode, CATEGORY_GL.GLOBALS);\n\t\tpoly.register_node(PowGlNode, CATEGORY_GL.MATH);\n\t\tpoly.register_node(QuatMultGlNode, CATEGORY_GL.QUAT);\n\t\tpoly.register_node(QuatFromAxisAngleGlNode, CATEGORY_GL.QUAT);\n\t\tpoly.register_node(QuatToAngleGlNode, CATEGORY_GL.QUAT);\n\t\tpoly.register_node(QuatToAxisGlNode, CATEGORY_GL.QUAT);\n\t\tpoly.register_node(RampGlNode, CATEGORY_GL.GLOBALS);\n\t\tpoly.register_node(RandomGlNode, CATEGORY_GL.GLOBALS);\n\t\tpoly.register_node(RadiansGlNode, CATEGORY_GL.CONVERSION);\n\t\tpoly.register_node(ReflectGlNode, CATEGORY_GL.GEOMETRY);\n\t\tpoly.register_node(RefractGlNode, CATEGORY_GL.GEOMETRY);\n\t\tpoly.register_node(RgbToHsvGlNode, CATEGORY_GL.COLOR);\n\t\tpoly.register_node(RotateGlNode, CATEGORY_GL.GEOMETRY);\n\t\tpoly.register_node(RoundGlNode, CATEGORY_GL.MATH);\n\t\tpoly.register_node(SignGlNode, CATEGORY_GL.MATH);\n\t\tpoly.register_node(SinGlNode, CATEGORY_GL.TRIGO);\n\t\tpoly.register_node(SqrtGlNode, CATEGORY_GL.MATH);\n\t\tpoly.register_node(StepGlNode, CATEGORY_GL.GEOMETRY);\n\t\tpoly.register_node(SubstractGlNode, CATEGORY_GL.MATH);\n\t\tpoly.register_node(TanGlNode, CATEGORY_GL.TRIGO);\n\t\tpoly.register_node(TextureGlNode, CATEGORY_GL.COLOR);\n\t\tpoly.register_node(TwoWaySwitchGlNode, CATEGORY_GL.TRIGO);\n\t\tpoly.register_node(Vec2ToFloatGlNode, CATEGORY_GL.CONVERSION);\n\t\tpoly.register_node(Vec3ToFloatGlNode, CATEGORY_GL.CONVERSION);\n\t\tpoly.register_node(Vec4ToFloatGlNode, CATEGORY_GL.CONVERSION);\n\t\tpoly.register_node(Vec4ToVectorGlNode, CATEGORY_GL.CONVERSION);\n\t\tpoly.register_node(VectorAlignGlNode, CATEGORY_GL.GEOMETRY);\n\t\tpoly.register_node(VectorAngleGlNode, CATEGORY_GL.GEOMETRY);\n\t}\n}\n"],"sourceRoot":""}