{"version":3,"sources":["webpack://POLY/./src/engine/nodes/gl/utils/GLDefinition.ts","webpack://POLY/./src/core/ThreeToGl.ts","webpack://POLY/./src/engine/nodes/utils/shaders/ShaderName.ts","webpack://POLY/./src/engine/nodes/gl/utils/SpareParamsController.ts","webpack://POLY/./src/engine/nodes/gl/_Base.ts","webpack://POLY/./src/engine/nodes/utils/flags/Base.ts","webpack://POLY/./src/engine/nodes/utils/flags/Bypass.ts","webpack://POLY/./src/engine/nodes/utils/flags/Display.ts","webpack://POLY/./src/engine/nodes/utils/FlagsController.ts","webpack://POLY/./src/engine/nodes/gl/code/globals/Geometry.ts","webpack://POLY/./src/engine/containers/Texture.ts","webpack://POLY/./src/engine/nodes/cop/_Base.ts","webpack://POLY/./src/engine/nodes/gl/utils/ConnectionsController.ts","webpack://POLY/./src/core/loader/Texture.ts","webpack://POLY/./src/engine/nodes/cop/File.ts","webpack://POLY/./src/engine/poly/registers/Category.ts","webpack://POLY/./src/engine/nodes/gl/Attribute.ts","webpack://POLY/./src/engine/nodes/gl/code/configs/ShaderConfig.ts","webpack://POLY/./src/engine/nodes/gl/code/configs/VariableConfig.ts","webpack://POLY/./src/engine/io/json/export/Scene.ts","webpack://POLY/./src/engine/io/json/export/Node.ts","webpack://POLY/./src/engine/io/json/export/Param.ts","webpack://POLY/./src/engine/io/json/export/param/Numeric.ts","webpack://POLY/./src/engine/io/json/export/param/OperatorPath.ts","webpack://POLY/./src/engine/io/json/export/param/String.ts","webpack://POLY/./src/engine/io/json/export/param/Ramp.ts","webpack://POLY/./src/engine/io/json/export/Dispatcher.ts","webpack://POLY/./src/engine/nodes/gl/code/Controller.ts","webpack://POLY/./src/engine/nodes/gl/code/utils/LineType.ts","webpack://POLY/./src/engine/nodes/gl/code/utils/LinesController.ts","webpack://POLY/./src/engine/nodes/gl/code/utils/ShadersCollectionController.ts","webpack://POLY/./src/engine/nodes/gl/code/utils/CodeFormatter.ts","webpack://POLY/./src/engine/nodes/gl/code/utils/CodeBuilder.ts","webpack://POLY/./src/engine/nodes/gl/code/assemblers/_Base.ts","webpack://POLY/./src/engine/nodes/utils/shaders/BaseAssembler.ts","webpack://POLY/./src/engine/nodes/gl/utils/GLDefinitionCollection.ts","webpack://POLY/./src/engine/nodes/utils/code/configs/ParamConfig.ts","webpack://POLY/./src/engine/nodes/utils/code/controllers/ParamConfigsController.ts","webpack://POLY/./src/engine/nodes/gl/code/globals/_Base.ts","webpack://POLY/./src/engine/nodes/utils/shaders/NodeTraverser.ts","webpack://POLY/./src/engine/nodes/gl/Globals.ts","webpack://POLY/./src/engine/nodes/gl/code/utils/NodeFinder.ts","webpack://POLY/./src/engine/nodes/gl/code/assemblers/textures/Texture.ts","webpack://POLY/./src/engine/nodes/gl/code/templates/textures/Default.frag.glsl","webpack://POLY/./src/engine/nodes/cop/Builder.ts","webpack://POLY/./src/core/Sleep.ts","webpack://POLY/./src/engine/nodes/cop/EnvMap.ts","webpack://POLY/./src/engine/nodes/cop/Null.ts","webpack://POLY/./src/engine/nodes/cop/Switch.ts","webpack://POLY/./src/engine/poly/registers/Cop.ts"],"names":["GLDefinitionType","TypedGLDefinition","_definition_type","_data_type","_node","_name","this","AttributeGLDefinition","super","ATTRIBUTE","data_type","name","FunctionGLDefinition","FUNCTION","UniformGLDefinition","UNIFORM","VaryingGLDefinition","VARYING","ThreeToGl","value","ensure_float","values","toArray","map","v","length","join","vec","num","vector3","x","y","z","w","ShaderName","ParticleShaderNames","PARTICLES_0","PARTICLES_1","PARTICLES_2","PARTICLES_3","PARTICLES_4","PARTICLES_5","PARTICLES_6","PARTICLES_7","PARTICLES_8","PARTICLES_9","node","_allow_inputs_created_from_params","params","set_post_create_params_hook","create_inputs_from_params","bind","connections","param_name","names","add_input","_inputless_param_names","includes","has","param","get","parent_param","connection_type","type","connection","push","io","inputs","set_named_input_connection_points","raw_input_serialized_by_param_name","Map","default_value_serialized_by_param_name","current_param_names","spare_names","params_update_options","set","raw_input_serialized","default_value_serialized","names_to_delete","connection_point","named_input_connection_points","param_type","init_value","last_param_init_value","default_value_from_name","gl_input_default_value","array","Array","i","to_add","options","spare","scene","loading_controller","is_loading","update_params","spare_param","raw_input","spare_params_controller","NodeContext","GL","init_inputs","ui_data","set_layout_horizontal","outputs","set_named_output_connection_points","initialize_node","node_sibbling","console","warn","material_node","assembler_controller","set_compilation_required_and_dirty","parent","input_index","get_input_index","input_connection","input_node","node_src","output_connection_point","named_output_connection_points","output_index","output_name","gl_var_name","full_path","any","shaders_collection_controller","_param_configs_controller","reset","list","ParamlessTypedGlNode","params_config","BaseFlag","_state","_hooks","hook","new_state","on_update","run_hooks","emit","NodeEvent","FLAG_BYPASS_UPDATED","set_dirty","FLAG_DISPLAY_UPDATED","FlagsController","Display","Base","display","Bypass","bypass","FlagsControllerD","FlagsControllerB","FlagsControllerDB","VARIABLE_CONFIG_DEFAULT_BY_NAME","position","GlobalsGeometryHandler","globals_node","named_output_connection_points_by_name","var_name","gl_type","definition","add_definitions","assembler","shader_config","current_shader_name","dependencies","body_line","dependency","add_body_lines","variable_name","variable_config_default","attrib_name","read_attribute","PRE_DEFINED_ATTRIBUTES","indexOf","VERTEX","shader_name","FRAGMENT","varying_definition","definitions_by_shader_name","body_lines_by_shader_name","push_on_array_at_entry","set_varying_body_line","forEach","definitions","body_lines","IF_RULE","uv","content","set_content","_content","log","texture","clone","needsUpdate","image","width","height","DEFAULT_INPUT_NAMES","data","Uint16Array","EMPTY_DATA_TEXTURE","DataTexture","container_controller","flags","COP","set_has_one_output","set_container","BaseCopNodeClass","GlConnectionsController","_input_name_function","index","_output_name_function","_expected_input_types_function","first_input_connection_type","FLOAT","_expected_output_types_function","_update_signature_if_required_bound","update_signature_if_required","_initialized","func","add_on_set_input_hook","add_on_scene_load_hook","add_post_dirty_hook","dirty_trigger","lifecycle","creation_completed","_connections_match_inputs","update_connection_types","remove_dirty_state","make_successors_update_signatures","successor","graph_all_successors","gl_node","gl_connections_controller","expected_input_types","expected_output_types","named_input_connections","named_outputs","create_spare_parameters","current_input_types","c","current_output_types","input_connections","first_connection","connection_type_from_connection","Extension","_param","url","found_node","substring","node_path","find_node","request_container","states","error","load_url","texture_as_env","set_texture_for_mapping","graph_predecessors","graph_disconnect_predecessors","add_graph_input","Promise","resolve","reject","ext","_ext","VIDEO_EXTENSIONS","_load_as_video","loader_for_ext","then","loader","load","undefined","toLowerCase","EXR","EXRLoader","HDR","RGBELoader","setDataType","BASIS","BasisTextureLoader","setTranscoderPath","renderer","Poly","instance","renderers_controller","wait_for_renderer","detectSupport","TextureLoader","video","document","createElement","setAttribute","onloadedmetadata","pause","VideoTexture","source","VIDEO_SOURCE_TYPE_BY_EXT","_default_video_source_type","appendChild","img","canvas","context","getContext","drawImage","getImageData","elements","split","PARAM_DEFAULT","PARAM_ENV_DEFAULT","ogg","ogv","mp4","MAPPINGS","UVMapping","CubeReflectionMapping","CubeRefractionMapping","EquirectangularReflectionMapping","EquirectangularRefractionMapping","SphericalReflectionMapping","CubeUVReflectionMapping","CubeUVRefractionMapping","WRAPPINGS","ClampToEdgeWrapping","RepeatWrapping","MirroredRepeatWrapping","MAG_FILTERS","LinearFilter","NearestFilter","MIN_FILTERS","NearestMipMapNearestFilter","NearestMipMapLinearFilter","LinearMipMapNearestFilter","LinearMipMapLinearFilter","ATTRIB_MAPPING_KEYS","ATTRIB_MAPPING","mapping","wrapS","wrapT","minFilter","magFilter","STRING","desktop_browse","file_type","reload","BUTTON","callback","PARAM_CALLBACK_reload","INTEGER","menu","entries","m","Object","keys","wrap_s","wrap_t","mag_filter","min_filter","_is_static_image_url","pv","cook_for_image","cook_for_video","_load_texture","_update_texture_params","set_texture","clear_texture","_param_url_changed","_add_video_spare_params_if_required","_previous_param_url","_set_video_current_time","cook_controller","end_cook","texture_attrib","param_value","float","param_callback_reload","p","set_successors_dirty","_video","currentTime","constructor","has_param","VIDEO_TIME_PARAM_NAME","duration","add_param","ParamType","cook","range","range_locked","PARAMS_UPDATED","_remove_spare_params","_texture_loader","load_texture_from_url_or_op","e","DEFAULT_NODE_PATH","UV","ENV_MAP","CATEGORY_OBJ","LIGHT","MANAGER","GEOMETRY","CAMERA","MISC","CATEGORY_COP","INPUT","ADVANCED","CATEGORY_EVENT","CATEGORY_GL","COLOR","CONVERSION","DYNAMICS","GLOBALS","LOGIC","MATH","QUAT","TRIGO","UTIL","INSTANCE","CATEGORY_MAT","MESH","POINTS","LINE","VOLUME","CATEGORY_SOP","ANIMATION","MODIFIER","PRIMITIVES","RENDER","ConnectionPointTypesAvailableForAttribute","VEC2","VEC3","VEC4","AttributeGlParamsConfig","ParamsConfig","AttributeGlNode","_on_create_set_name_if_none_bound","_on_create_set_name_if_none","_set_mat_to_recompile_if_is_exporting","add_on_create_hook","set_expected_input_types_function","set_expected_output_types_function","allow_attribute_exports","BOOLEAN","INPUT_NAME","OUTPUT_NAME","set_node_lines_attribute","named_input","named_input_connection_point","input_name","used_output_names","export_when_connected","is_exporting","_set_mat_to_recompile","ShaderConfig","_input_names","_dependencies","VariableConfig","_options","_scene","_data","nodes_controller","reset_node_context_signatures","root_exporter","dispatch_node","root","nodes_data","properties","frame","frame_range","frame_range_locked","time_controller","master_camera_node_path","cameras_controller","ui","word","replace","escape_line_breaks","is_root","register_node_context_signature","children_controller","params_data","inputs_data","has_bypass","active","has_display","children_allowed","selection","children","selected_children","selected_ids","selected_node","nodes","graph_node_id","child","n","override_clonable_state_allowed","override","override_clonable_state","add_custom","comment","sanitize_string","node_exporter","input","has_named_inputs","output","param_exporter","dispatch_param","required","ParamJsonExporter","_complex_data","is_spare_and_not_component","is_spare","value_changed","is_default","_require_data_complex","_data_complex","_data_simple","current","add_main","has_options_overridden","overridden_options","options_overridden","option_name","option_value","JSON","stringify","val","OperatorPath","Ramp","assembler_class","_globals_handler","_compile_required","_deleted_params_data","_assembler","globals_handler","id","reset_configs","output_child","add_output_params","add_globals_params","globals","create_node","set_position","Vector2","trigger_node","set_compilation_required","param_config","param_configs","set_uniform_value","current_spare_param_names","assembler_param_names","spare_param_names_to_add","spare_param_names_to_remove","spare_params_with_same_name_as_params","error_message","param_options","default_value","LineType","_shader_name","_definitions_by_node_id","_body_lines_by_node_id","MapUtils","lines","line","_shader_names","_current_shader_name","_lines_controller_by_shader_name","lines_controller","LINE_SUFFIXES","FUNCTION_DECLARATION","DEFINE","BODY","LINE_PREFIXES","line_type","add_suffix","_gl_parent_node","ParamConfigsController","_param_configs_set_allowed","_lines","_function_declared","root_nodes","node_traverser","traverse","nodes_by_shader_name","shader_names","nodes_for_shader_name","sorted_nodes","root_nodes_for_shader","root_nodes_by_shader_name","root_node","sorted_node_ids","reset_code","eval_all","_shaders_collection_controller","set_current_shader_name","set_param_configs","set_lines","set_code_lines","lines_map","add_code_lines","GLDefinition","add_code_line_for_nodes_and_line_type","definition_type","node_definitions","filter","d","collection","uniq_definitions","uniq","errored","definitions_by_node_id","node_ids","node_id","lines_for_shader","boolean","first_definition","node_comment","line_wrap","separator","post_line_separator","nodes_count","is_last","add_code_line_for_node_and_line_type","INSERT_DEFINE_AFTER_MAP","INSERT_BODY_AFTER_MAP","LINES_TO_REMOVE_MAP","_shaders_by_name","_root_nodes","_leaf_nodes","_uniforms_time_dependent","_resolution_dependent","_template_shader","vertexShader","fragmentShader","template","_template_shader_for_shader_name","_replace_template","current_uniforms","uniform_name","uniform","uniforms_time_dependent","time","resolution_dependent","Globals","Attribute","output_node","attribute_node","_code_builder","code_builder","build_from_nodes","allow_new_param_configs","disallow_new_param_configs","all_lines","_param_config_owner","param_config_owner","VECTOR3","hidden","VECTOR2","ConnectionPointType","create_globals_node_output_connections","_reset_shader_configs","_reset_variable_configs","_reset_uniforms_time_dependency","_reset_resolution_dependency","_shader_configs","create_shader_configs","shader_configs","sc","_variable_configs","create_variable_configs","variable_configs","vc","default_from_attribute","prefix","if","input_names","function_declaration","builder_lines","define","body","template_lines","new_lines","line_before_define","insert_define_after","line_before_body","insert_body_after","lines_to_remove","line_before_define_found","line_before_body_found","template_line","_insert_lines","line_remove_required","line_to_remove","lines_to_add","line_to_add","TypedGLDefinitionCollection","_definitions","_errored","_error_message","definitions_by_name","existing","_type","_default_value","_uniform_name","_uniform","_create_uniform","uniform_by_type","callback_bound","_callback","OPERATOR_PATH","node_selection","Vector3","FOLDER","RAMP","SEPARATOR","VECTOR4","Vector4","unreachable","compute","has_value_changed","is_video_texture","set_uniform_value_from_texture","set_uniform_value_from_ramp","ramp_texture","new_value","param_constructor","ParamConstructorByType","_cached_param_value","has_changed","are_values_equal","clone_value","result","_param_configs","GlobalsBaseController","_id","__next_id","TypedNodeTraverser","_leaves_graph_id","_graph_ids_by_shader_name","_outputs_by_graph_id","_depth_by_graph_id","_graph_id_by_depth","_graph","graph","clear","input_names_for_shader_name","find_leaves_from_root_node","set_nodes_depth","depth","graph_id","LEAVES_FROM_NODES_SHADER","find_leaves","key","nodes_from_ids","depths","sort","a","b","graph_ids_for_depth","node_from_id","ids","unique_inputs","booleans_by_graph_id","set_node_depth","current_depth","Math","max","output_ids","output_id","GlobalsGlParamsConfig","GlobalsGlNode","set_node_lines_globals","GlNodeFinder","nodes_by_type","uniforms","_uniforms","build_code_from_nodes","_build_lines","add_uniforms","uniforms_controller","add_time_dependent_uniform_owner","remove_time_dependent_uniform_owner","default","gl_var","variable_for_input","set_uniforms_time_dependent","handle_gl_FragCoord","resolution","_assembler_controller","_create_assembler_controller","_texture_mesh","Mesh","_texture_material","ShaderMaterial","_texture_scene","Scene","_texture_camera","Camera","_children_controller_context","set_assembler_globals_handler","on_create","init","material","add","dirty_controller","_reset_if_resolution_changed","_render_target","_create_render_target","_renderer","_create_renderer","trigger","_reset","_pixelBuffer","_create_pixel_buffer","Float32Array","compile_if_required","render_on_target","fragment","_fragment_shader","compile_required","run_assembler","post_compile","output_nodes","find_output_nodes","set_root_nodes","update_fragment_shader","fragment_shader","time_dependent","force_time_dependent","unforce_time_dependent","render_target","WebGLRenderer","antialias","setPixelRatio","window","devicePixelRatio","autoClear","setRenderTarget","render","readRenderTargetPixels","setTimeout","sleep","WebGLRenderTarget","format","test","navigator","userAgent","stencilBuffer","depthBuffer","set_count","init_inputs_clonable_state","InputCloneMode","NEVER","input_contents","env_map","convert_texture_to_env_map","PMREMGenerator","fromEquirectangular","set_width","disallow_inputs_evaluation","has_input","container","request_input_container","poly","register_node","File"],"mappings":"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","file":"Cop.bundle.js","sourcesContent":["import {BaseGlNodeType} from '../_Base';\nimport {TypedGLDefinitionCollection} from './GLDefinitionCollection';\nimport {ConnectionPointType} from '../../utils/connections/ConnectionPointType';\n\nexport enum GLDefinitionType {\n\tATTRIBUTE = 'attribute',\n\tFUNCTION = 'function',\n\tUNIFORM = 'uniform',\n\tVARYING = 'varying',\n}\n\nexport abstract class TypedGLDefinition<T extends GLDefinitionType> {\n\t// constructor(protected _node: BaseGlNodeType, protected _name: string) {}\n\tconstructor(\n\t\tprotected _definition_type: T,\n\t\tprotected _data_type: ConnectionPointType,\n\t\tprotected _node: BaseGlNodeType,\n\t\tprotected _name: string\n\t) {\n\t\t// super(_node, _name);\n\t}\n\n\tget definition_type() {\n\t\treturn this._definition_type;\n\t}\n\tget data_type() {\n\t\treturn this._data_type;\n\t}\n\tget node() {\n\t\treturn this._node;\n\t}\n\tget name() {\n\t\treturn this._name;\n\t}\n\t// get id() {\n\t// \treturn this._data_type;\n\t// }\n\n\tabstract get line(): string;\n\tcollection_instance() {\n\t\treturn new TypedGLDefinitionCollection<T>();\n\t}\n}\n\nexport class AttributeGLDefinition extends TypedGLDefinition<GLDefinitionType.ATTRIBUTE> {\n\tconstructor(protected _node: BaseGlNodeType, protected _data_type: ConnectionPointType, protected _name: string) {\n\t\tsuper(GLDefinitionType.ATTRIBUTE, _data_type, _node, _name);\n\t}\n\tget line() {\n\t\treturn `attribute ${this.data_type} ${this.name}`;\n\t}\n}\n\nexport class FunctionGLDefinition extends TypedGLDefinition<GLDefinitionType.FUNCTION> {\n\tconstructor(protected _node: BaseGlNodeType, protected _data_type: ConnectionPointType, protected _name: string) {\n\t\tsuper(GLDefinitionType.FUNCTION, _data_type, _node, _name);\n\t}\n\tget line() {\n\t\treturn this.name;\n\t}\n}\n\nexport class UniformGLDefinition extends TypedGLDefinition<GLDefinitionType.UNIFORM> {\n\tconstructor(protected _node: BaseGlNodeType, protected _data_type: ConnectionPointType, protected _name: string) {\n\t\tsuper(GLDefinitionType.UNIFORM, _data_type, _node, _name);\n\t}\n\tget line() {\n\t\treturn `uniform ${this.data_type} ${this.name}`;\n\t}\n}\n\nexport class VaryingGLDefinition extends TypedGLDefinition<GLDefinitionType.VARYING> {\n\tconstructor(protected _node: BaseGlNodeType, protected _data_type: ConnectionPointType, protected _name: string) {\n\t\tsuper(GLDefinitionType.VARYING, _data_type, _node, _name);\n\t}\n\tget line() {\n\t\treturn `varying ${this.data_type} ${this.name}`;\n\t}\n}\nexport type BaseGLDefinition = TypedGLDefinition<GLDefinitionType>;\n","import {CoreString} from './String';\nimport {Vector3} from 'three/src/math/Vector3';\nimport {Vector2} from 'three/src/math/Vector2';\nimport lodash_isNumber from 'lodash/isNumber';\nimport lodash_isBoolean from 'lodash/isBoolean';\nimport lodash_isString from 'lodash/isString';\n\nexport class ThreeToGl {\n\tstatic any(value: any) {\n\t\tif (lodash_isString(value)) {\n\t\t\treturn value;\n\t\t}\n\t\tif (lodash_isBoolean(value)) {\n\t\t\treturn `${value}`;\n\t\t}\n\n\t\tif (lodash_isNumber(value)) {\n\t\t\treturn `${CoreString.ensure_float(value)}`;\n\t\t} else {\n\t\t\tconst values = value.toArray().map((v: number) => {\n\t\t\t\treturn `${CoreString.ensure_float(v)}`;\n\t\t\t});\n\t\t\tconst gl_type = `vec${values.length}`;\n\t\t\treturn `${gl_type}(${values.join(', ')})`;\n\t\t}\n\t}\n\n\tstatic vector3(vec: Vector3 | string): string {\n\t\tif (lodash_isString(vec)) {\n\t\t\treturn vec;\n\t\t}\n\t\tconst values = vec.toArray().map((v) => {\n\t\t\treturn `${CoreString.ensure_float(v)}`;\n\t\t});\n\t\treturn `vec3(${values.join(', ')})`;\n\t}\n\tstatic vector2(vec: Vector2 | string): string {\n\t\tif (lodash_isString(vec)) {\n\t\t\treturn vec;\n\t\t}\n\t\tconst values = vec.toArray().map((v) => {\n\t\t\treturn `${CoreString.ensure_float(v)}`;\n\t\t});\n\t\treturn `vec2(${values.join(', ')})`;\n\t}\n\n\tstatic vector3_float(vec: Vector3 | string, num: number | string): string {\n\t\tif (!lodash_isString(num)) {\n\t\t\tnum = CoreString.ensure_float(num);\n\t\t}\n\t\treturn `vec4(${this.vector3(vec)}, ${num})`;\n\t}\n\n\tstatic float4(x: number | string, y: number | string, z: number | string, w: number | string) {\n\t\tif (!lodash_isString(x)) {\n\t\t\tx = CoreString.ensure_float(x);\n\t\t}\n\t\tif (!lodash_isString(y)) {\n\t\t\ty = CoreString.ensure_float(y);\n\t\t}\n\t\tif (!lodash_isString(z)) {\n\t\t\tz = CoreString.ensure_float(z);\n\t\t}\n\t\tif (!lodash_isString(w)) {\n\t\t\tw = CoreString.ensure_float(w);\n\t\t}\n\t\treturn `vec4(${x}, ${y}, ${z}, ${w})`;\n\t}\n\tstatic float3(x: number | string, y: number | string, z: number | string) {\n\t\tif (!lodash_isString(x)) {\n\t\t\tx = CoreString.ensure_float(x);\n\t\t}\n\t\tif (!lodash_isString(y)) {\n\t\t\ty = CoreString.ensure_float(y);\n\t\t}\n\t\tif (!lodash_isString(z)) {\n\t\t\tz = CoreString.ensure_float(z);\n\t\t}\n\t\treturn `vec3(${x}, ${y}, ${z})`;\n\t}\n\tstatic float2(x: number | string, y: number | string) {\n\t\tif (!lodash_isString(x)) {\n\t\t\tx = CoreString.ensure_float(x);\n\t\t}\n\t\tif (!lodash_isString(y)) {\n\t\t\ty = CoreString.ensure_float(y);\n\t\t}\n\t\treturn `vec2(${x}, ${y})`;\n\t}\n\tstatic float(x: number | string) {\n\t\tif (!lodash_isString(x)) {\n\t\t\tx = CoreString.ensure_float(x);\n\t\t}\n\t\treturn `${x}`;\n\t}\n\tstatic int(x: number | string) {\n\t\treturn `${x}`;\n\t}\n\tstatic bool(x: number | string) {\n\t\treturn `${x}`;\n\t}\n}\n","export enum ShaderName {\n\tVERTEX = 'vertex',\n\tFRAGMENT = 'fragment',\n\tLEAVES_FROM_NODES_SHADER = 'leaves_from_nodes_shader',\n\tPARTICLES_0 = 'particles_0',\n\tPARTICLES_1 = 'particles_1',\n\tPARTICLES_2 = 'particles_2',\n\tPARTICLES_3 = 'particles_3',\n\tPARTICLES_4 = 'particles_4',\n\tPARTICLES_5 = 'particles_5',\n\tPARTICLES_6 = 'particles_6',\n\tPARTICLES_7 = 'particles_7',\n\tPARTICLES_8 = 'particles_8',\n\tPARTICLES_9 = 'particles_9',\n}\nexport const ParticleShaderNames: Array<ShaderName> = [\n\tShaderName.PARTICLES_0,\n\tShaderName.PARTICLES_1,\n\tShaderName.PARTICLES_2,\n\tShaderName.PARTICLES_3,\n\tShaderName.PARTICLES_4,\n\tShaderName.PARTICLES_5,\n\tShaderName.PARTICLES_6,\n\tShaderName.PARTICLES_7,\n\tShaderName.PARTICLES_8,\n\tShaderName.PARTICLES_9,\n];\n","import {ParamTypeToConnectionPointTypeMap} from '../../utils/connections/ConnectionPointType';\nimport {BaseGlNodeType} from '../_Base';\nimport {BaseNamedConnectionPointType, TypedNamedConnectionPoint} from '../../utils/connections/NamedConnectionPoint';\n// import {ParamValue} from '../../../params/types/ParamValue';\nimport {ParamType} from '../../../poly/ParamType';\n// import {ParamValueToDefaultConverter} from '../../utils/params/ParamValueToDefaultConverter';\n// import {NodeEvent} from '../../../poly/NodeEvent';\nimport {ParamsUpdateOptions} from '../../utils/params/ParamsController';\n// import {ParamInitValueSerializedTypeMap} from '../../../params/types/ParamInitValueSerializedTypeMap';\nimport {ParamInitValueSerialized} from '../../../params/types/ParamInitValueSerialized';\nimport lodash_clone from 'lodash/clone';\nimport lodash_isArray from 'lodash/isArray';\nimport lodash_isNumber from 'lodash/isNumber';\n\nexport class GlNodeSpareParamsController {\n\tprivate _allow_inputs_created_from_params: boolean = true;\n\tprivate _inputless_param_names: string[] | undefined;\n\tconstructor(private node: BaseGlNodeType) {}\n\n\tdisallow_inputs_created_from_params() {\n\t\tthis._allow_inputs_created_from_params = false;\n\t}\n\n\tinitialize_node() {\n\t\tthis.node.params.set_post_create_params_hook(this.create_inputs_from_params.bind(this));\n\t}\n\n\tcreate_inputs_from_params() {\n\t\tif (!this._allow_inputs_created_from_params) {\n\t\t\treturn;\n\t\t}\n\t\tconst connections: BaseNamedConnectionPointType[] = [];\n\t\tfor (let param_name of this.node.params.names) {\n\t\t\tlet add_input = true;\n\t\t\tif (\n\t\t\t\tthis._inputless_param_names &&\n\t\t\t\tthis._inputless_param_names.length > 0 &&\n\t\t\t\tthis._inputless_param_names.includes(param_name)\n\t\t\t) {\n\t\t\t\tadd_input = false;\n\t\t\t}\n\t\t\tif (add_input) {\n\t\t\t\tif (this.node.params.has(param_name)) {\n\t\t\t\t\tconst param = this.node.params.get(param_name);\n\t\t\t\t\tif (param && !param.parent_param) {\n\t\t\t\t\t\tconst connection_type = ParamTypeToConnectionPointTypeMap[param.type];\n\t\t\t\t\t\tif (connection_type) {\n\t\t\t\t\t\t\tconst connection = new TypedNamedConnectionPoint(param.name, connection_type);\n\t\t\t\t\t\t\tconnections.push(connection);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.node.io.inputs.set_named_input_connection_points(connections);\n\t}\n\n\tset_inputless_param_names(names: string[]) {\n\t\treturn (this._inputless_param_names = names);\n\t}\n\n\tcreate_spare_parameters() {\n\t\tconst raw_input_serialized_by_param_name: Map<string, ParamInitValueSerialized> = new Map();\n\t\tconst default_value_serialized_by_param_name: Map<string, ParamInitValueSerialized> = new Map();\n\t\tconst current_param_names: string[] = this.node.params.spare_names;\n\t\tconst params_update_options: ParamsUpdateOptions = {};\n\n\t\tfor (let param_name of current_param_names) {\n\t\t\tif (this.node.params.has(param_name)) {\n\t\t\t\tconst param = this.node.params.get(param_name);\n\t\t\t\tif (param) {\n\t\t\t\t\traw_input_serialized_by_param_name.set(param_name, param.raw_input_serialized);\n\t\t\t\t\tdefault_value_serialized_by_param_name.set(param_name, param.default_value_serialized);\n\t\t\t\t\tparams_update_options.names_to_delete = params_update_options.names_to_delete || [];\n\t\t\t\t\tparams_update_options.names_to_delete.push(param_name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (let connection_point of this.node.io.inputs.named_input_connection_points) {\n\t\t\tconst param_name = connection_point.name;\n\t\t\tconst param_type: ParamType = connection_point.param_type;\n\t\t\tlet init_value = connection_point.init_value;\n\t\t\t// let raw_input: ParamInitValueSerialized= null\n\n\t\t\t// const raw_input = raw_input_serialized_by_param_name.get(param_name);\n\t\t\tconst last_param_init_value = default_value_serialized_by_param_name.get(param_name);\n\t\t\t// if (last_param_raw_input != null && last_param_init_value != null) {\n\t\t\t// init_value = ParamValueToDefaultConverter.from_value(param_type, last_param_raw_input);\n\t\t\t// if (init_value == null) {\n\t\t\tconst default_value_from_name = this.node.gl_input_default_value(param_name);\n\n\t\t\t// TODO: this should really store the largest set value\n\t\t\t// (as in the ones with the most components)\n\t\t\t// so that for an Add Gl Node, if I set a vec4 to [1,2,3,4]\n\t\t\t// and then set an input type, which will transform the param to a float\n\t\t\t// it will have a value of 1.\n\t\t\t// But if I then set it to a vec4 again, it will remember [1,2,3,4]\n\t\t\tif (default_value_from_name != null) {\n\t\t\t\tinit_value = default_value_from_name;\n\t\t\t} else {\n\t\t\t\tif (last_param_init_value != null) {\n\t\t\t\t\tinit_value = last_param_init_value;\n\t\t\t\t} else {\n\t\t\t\t\tinit_value = connection_point.init_value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lodash_isArray(connection_point.init_value) && lodash_isNumber(init_value)) {\n\t\t\t\tconst array = new Array(connection_point.init_value.length) as Number2;\n\t\t\t\tfor (let i = 0; i < array.length; i++) {\n\t\t\t\t\tarray[i] = init_value;\n\t\t\t\t}\n\t\t\t\tinit_value = array;\n\t\t\t}\n\n\t\t\tif (init_value != null) {\n\t\t\t\tparams_update_options.to_add = params_update_options.to_add || [];\n\t\t\t\tparams_update_options.to_add.push({\n\t\t\t\t\tname: param_name,\n\t\t\t\t\ttype: param_type,\n\t\t\t\t\tinit_value: lodash_clone(init_value as any),\n\t\t\t\t\toptions: {\n\t\t\t\t\t\tspare: true,\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tif (!this.node.scene.loading_controller.is_loading) {\n\t\t\tthis.node.params.update_params(params_update_options);\n\n\t\t\tfor (let spare_param of this.node.params.spare) {\n\t\t\t\tif (!spare_param.parent_param) {\n\t\t\t\t\tconst raw_input = raw_input_serialized_by_param_name.get(spare_param.name);\n\t\t\t\t\tif (raw_input) {\n\t\t\t\t\t\tspare_param.set(raw_input as any);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","import {TypedNode} from '../_Base';\nimport {ThreeToGl} from '../../../core/ThreeToGl';\nimport {BaseGlShaderAssembler} from './code/assemblers/_Base';\nimport {AssemblerControllerNode} from './code/Controller';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {ParamConfigsController} from '../utils/code/controllers/ParamConfigsController';\nimport {ShadersCollectionController} from './code/utils/ShadersCollectionController';\nimport {ParamInitValueSerialized} from '../../params/types/ParamInitValueSerialized';\nimport {GlNodeSpareParamsController} from './utils/SpareParamsController';\nimport {GlConnectionsController} from './utils/ConnectionsController';\n\nexport class TypedGlNode<K extends NodeParamsConfig> extends TypedNode<'GL', BaseGlNodeType, K> {\n\tstatic node_context(): NodeContext {\n\t\treturn NodeContext.GL;\n\t}\n\tprotected _param_configs_controller: ParamConfigsController | undefined;\n\tprotected _assembler: BaseGlShaderAssembler | undefined;\n\n\treadonly spare_params_controller: GlNodeSpareParamsController = new GlNodeSpareParamsController(this);\n\tpublic readonly gl_connections_controller: GlConnectionsController | undefined;\n\n\tinitialize_base_node() {\n\t\t// this.io.inputs.set_depends_on_inputs(false);\n\t\tthis.io.connections.init_inputs();\n\t\tthis.ui_data.set_layout_horizontal();\n\t\tthis.io.outputs.set_named_output_connection_points([]);\n\n\t\tthis.spare_params_controller.initialize_node();\n\t}\n\tnode_sibbling(name: string): BaseGlNodeType | null {\n\t\treturn super.node_sibbling(name) as BaseGlNodeType | null;\n\t}\n\tcook() {\n\t\tconsole.warn('gl nodes should never cook');\n\t}\n\n\tprotected _set_mat_to_recompile() {\n\t\tthis.material_node?.assembler_controller.set_compilation_required_and_dirty(this);\n\t}\n\tget material_node(): AssemblerControllerNode | undefined {\n\t\tif (this.parent) {\n\t\t\tif (this.parent.type == this.type) {\n\t\t\t\treturn (this.parent as BaseGlNodeType)?.material_node;\n\t\t\t} else {\n\t\t\t\treturn this.parent as AssemblerControllerNode;\n\t\t\t}\n\t\t}\n\t}\n\n\t//\n\t//\n\t// VARIABLES\n\t//\n\t//\n\tgl_var_name(name: string) {\n\t\treturn `v_POLY_${this.name}_${name}`;\n\t}\n\n\tvariable_for_input(name: string): string {\n\t\tconst input_index = this.io.inputs.get_input_index(name);\n\t\tconst connection = this.io.connections.input_connection(input_index);\n\t\tif (connection) {\n\t\t\tconst input_node = (<unknown>connection.node_src) as BaseGlNodeType;\n\t\t\tconst output_connection_point =\n\t\t\t\tinput_node.io.outputs.named_output_connection_points[connection.output_index];\n\t\t\tif (output_connection_point) {\n\t\t\t\tconst output_name = output_connection_point.name;\n\t\t\t\treturn input_node.gl_var_name(output_name);\n\t\t\t} else {\n\t\t\t\tconsole.warn(`no output called '${name}' for gl node ${input_node.full_path()}`);\n\t\t\t\tthrow 'variable_for_input ERROR';\n\t\t\t}\n\t\t} else {\n\t\t\treturn ThreeToGl.any(this.params.get(name)?.value);\n\t\t}\n\t}\n\n\t//\n\t//\n\t// ADDED LINES\n\t//\n\t//\n\tset_lines(shaders_collection_controller: ShadersCollectionController) {}\n\n\treset_code() {\n\t\tthis._param_configs_controller?.reset();\n\t\t// this.reset_lines();\n\t}\n\n\t//\n\t//\n\t// PARAM CONFIGS\n\t//\n\t//\n\tpublic set_param_configs() {}\n\tparam_configs() {\n\t\treturn this._param_configs_controller?.list;\n\t}\n\t// private reset_param_configs() {\n\t// \tthis._param_configs = [];\n\t// }\n\t// add_param_config<T extends ParamType>(\n\t// \ttype: T,\n\t// \tname: string,\n\t// \tdefault_value: ParamInitValuesTypeMap[T],\n\t// \tuniform_name: string\n\t// ) {\n\t// \tconst param_config = new ParamConfig(type, name, default_value, uniform_name);\n\t// \tthis._param_configs.push(param_config);\n\t// }\n\t// param_configs() {\n\t// \treturn this._param_configs;\n\t// }\n\t//\n\t//\n\t// INPUT\n\t//\n\t//\n\tgl_input_default_value(name: string): ParamInitValueSerialized {\n\t\treturn null;\n\t}\n\n\t//\n\t//\n\t// MISC\n\t//\n\t//\n\n\t//\n\t//\n\t// NEEDED?\n\t//\n\t//\n\t// set_assembler(assembler: BaseGlShaderAssembler) {\n\t// \tthis._assembler = assembler;\n\t// }\n\t// get assembler(): BaseGlShaderAssembler | undefined {\n\t// \treturn this._assembler;\n\t// }\n\n\t// shader_configs() {\n\t// \treturn this.assembler?.shader_configs || [];\n\t// }\n\t// shader_config(name: string) {\n\t// \treturn this.assembler?.shader_config(name);\n\t// }\n\t// shader_names() {\n\t// \treturn this.assembler?.shader_names || [];\n\t// }\n}\n\nexport type BaseGlNodeType = TypedGlNode<NodeParamsConfig>;\nexport class BaseGlNodeClass extends TypedGlNode<NodeParamsConfig> {}\n\nclass ParamlessParamsConfig extends NodeParamsConfig {}\nconst ParamsConfig = new ParamlessParamsConfig();\nexport class ParamlessTypedGlNode extends TypedGlNode<ParamlessParamsConfig> {\n\tparams_config = ParamsConfig;\n}\n","import {BaseNodeType} from '../../_Base';\n\ntype FlagHookCallback = () => void;\n\nexport class BaseFlag {\n\t// protected _available_states: [boolean, boolean] = [];\n\tprotected _state: boolean = true;\n\tprotected _hooks: FlagHookCallback[] | null = null;\n\tconstructor(protected node: BaseNodeType) {}\n\n\t// set_available_states(states: T[]) {}\n\tadd_hook(hook: FlagHookCallback) {\n\t\tthis._hooks = this._hooks || [];\n\t\tthis._hooks.push(hook);\n\t}\n\tprotected on_update() {}\n\tset(new_state: boolean) {\n\t\tif (this._state != new_state) {\n\t\t\tthis._state = new_state;\n\t\t\tthis.on_update();\n\t\t\tthis.run_hooks();\n\t\t}\n\t}\n\tget active() {\n\t\treturn this._state;\n\t}\n\ttoggle() {\n\t\tthis.set(!this._state);\n\t}\n\trun_hooks() {\n\t\tif (this._hooks) {\n\t\t\tfor (let hook of this._hooks) {\n\t\t\t\thook();\n\t\t\t}\n\t\t}\n\t}\n}\n","import {BaseFlag} from './Base';\nimport {NodeEvent} from '../../../poly/NodeEvent';\n\n// export interface BypassOptions {\n// \thas_bypass_flag?: boolean;\n// }\n\nexport class BypassFlag extends BaseFlag {\n\tprotected _state: boolean = false;\n\ton_update() {\n\t\tthis.node.emit(NodeEvent.FLAG_BYPASS_UPDATED);\n\t\tthis.node.set_dirty();\n\t}\n}\n\n// export function Bypass<TBase extends Constructor>(Base: TBase) {\n// \treturn class Mixin extends Base {\n// \t\tprotected self: BaseNode = (<unknown>this) as BaseNode;\n// \t\t_has_bypass_flag: boolean = true;\n// \t\t_bypass_flag: boolean = false;\n\n// \t\t_init_bypass_flag(options: BypassOptions = {}) {\n// \t\t\tif (options['has_bypass_flag'] == null) {\n// \t\t\t\toptions['has_bypass_flag'] = true;\n// \t\t\t}\n\n// \t\t\tthis._has_bypass_flag = options['has_bypass_flag'];\n// \t\t\tthis._bypass_flag = false;\n// \t\t}\n\n// \t\thas_bypass_flag(): boolean {\n// \t\t\treturn this._has_bypass_flag;\n// \t\t}\n\n// \t\tis_bypassed(): boolean {\n// \t\t\treturn this._bypass_flag;\n// \t\t}\n\n// \t\tset_bypass_flag(state: boolean) {\n// \t\t\tif (state == null) {\n// \t\t\t\tstate = true;\n// \t\t\t}\n// \t\t\tif (state !== this._bypass_flag) {\n// \t\t\t\tthis._bypass_flag = state;\n// \t\t\t\tthis.self.emit('bypass_flag_update');\n// \t\t\t\tthis.self.set_dirty();\n// \t\t\t\t// this.post_set_bypass_flag()\n// \t\t\t}\n// \t\t}\n\n// \t\t// post_process_container_request_as_bypassed(input_node: BaseNode){}\n// \t\t// post_set_bypass_flag(){}\n\n// \t\ttoggle_bypass_flag() {\n// \t\t\tthis.set_bypass_flag(!this.is_bypassed());\n// \t\t}\n// \t};\n// }\n","import {BaseFlag} from './Base';\nimport {NodeEvent} from '../../../poly/NodeEvent';\n\nexport class DisplayFlag extends BaseFlag {\n\ton_update() {\n\t\tthis.node.emit(NodeEvent.FLAG_DISPLAY_UPDATED);\n\t\t// this.node.set_dirty();\n\t}\n}\n","import {BaseNodeType} from '../_Base';\n\nimport {BypassFlag} from './flags/Bypass';\nimport {DisplayFlag} from './flags/Display';\n\nexport class FlagsController {\n\tpublic readonly bypass: DisplayFlag | undefined;\n\tpublic readonly display: BypassFlag | undefined;\n\tconstructor(protected node: BaseNodeType) {}\n\thas_display(): boolean {\n\t\treturn false;\n\t}\n\thas_bypass(): boolean {\n\t\treturn false;\n\t}\n}\n\nfunction Display<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\tprotected node!: BaseNodeType;\n\t\tpublic display: DisplayFlag = new DisplayFlag(this.node);\n\t\thas_display(): boolean {\n\t\t\treturn true;\n\t\t}\n\t};\n}\nfunction Bypass<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\tprotected node!: BaseNodeType;\n\t\tpublic readonly bypass: BypassFlag = new BypassFlag(this.node);\n\t\thas_bypass(): boolean {\n\t\t\treturn true;\n\t\t}\n\t};\n}\n\nexport class FlagsControllerD extends Display(FlagsController) {}\nexport class FlagsControllerB extends Bypass(FlagsController) {}\nexport class FlagsControllerDB extends Bypass(Display(FlagsController)) {}\n","import {GlobalsBaseController} from './_Base';\nimport {GlobalsGlNode} from '../../Globals';\nimport {AttributeGlNode} from '../../Attribute';\n// import {Definition} from '../../Definition/_Module';\n// import {DefinitionBaseConfig} from '../Config/DefinitionBaseConfig';\n// import {BaseGlNodeType} from '../../_Base';\nimport {VaryingGLDefinition, AttributeGLDefinition} from '../../utils/GLDefinition';\nimport {ConnectionPointType} from '../../../utils/connections/ConnectionPointType';\n// import {TypeAssert} from '../../../../poly/Assert';\nimport {MapUtils} from '../../../../../core/MapUtils';\nimport {ShaderName} from '../../../utils/shaders/ShaderName';\nimport {BaseGlNodeType} from '../../_Base';\nimport {ShadersCollectionController} from '../utils/ShadersCollectionController';\n\nconst VARIABLE_CONFIG_DEFAULT_BY_NAME: Dictionary<string> = {\n\tposition: 'vec3( position )',\n};\n\nexport class GlobalsGeometryHandler extends GlobalsBaseController {\n\tstatic PRE_DEFINED_ATTRIBUTES = [\n\t\t'position',\n\t\t'color',\n\t\t'normal',\n\t\t'uv',\n\t\t'uv2',\n\t\t'morphTarget0',\n\t\t'morphTarget1',\n\t\t'morphTarget2',\n\t\t'morphTarget3',\n\t\t'skinIndex',\n\t\t'skinWeight',\n\t];\n\n\tstatic IF_RULE = {\n\t\tuv:\n\t\t\t'defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )',\n\t};\n\n\thandle_globals_node(\n\t\tglobals_node: GlobalsGlNode,\n\t\toutput_name: string,\n\t\tshaders_collection_controller: ShadersCollectionController\n\t\t// definitions_by_shader_name: Map<ShaderName, BaseGLDefinition[]>,\n\t\t// body_lines_by_shader_name: Map<ShaderName, string[]>,\n\t\t// body_lines: string[],\n\t\t// dependencies: ShaderName[],\n\t\t// shader_name: ShaderName\n\t): void {\n\t\tconst connection_point = globals_node.io.outputs.named_output_connection_points_by_name(output_name);\n\t\tif (!connection_point) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst var_name = globals_node.gl_var_name(output_name);\n\t\tconst gl_type = connection_point.type;\n\t\tconst definition = new VaryingGLDefinition(globals_node, gl_type, var_name);\n\n\t\t// MapUtils.push_on_array_at_entry(definitions_by_shader_name, shader_name, definition);\n\t\tshaders_collection_controller.add_definitions(globals_node, [definition]);\n\t\t// definitions_by_shader_name.get(shader_name)!.push(definition);\n\t\tconst assembler = globals_node.material_node?.assembler_controller.assembler;\n\t\tif (!assembler) {\n\t\t\treturn;\n\t\t}\n\t\tconst shader_config = assembler.shader_config(shaders_collection_controller.current_shader_name);\n\t\tif (!shader_config) {\n\t\t\treturn;\n\t\t}\n\t\tconst dependencies = shader_config.dependencies();\n\n\t\tconst body_line = `${var_name} = ${gl_type}(${output_name})`;\n\t\tfor (let dependency of dependencies) {\n\t\t\t// MapUtils.push_on_array_at_entry(definitions_by_shader_name, dependency, definition);\n\t\t\t// MapUtils.push_on_array_at_entry(body_lines_by_shader_name, dependency, body_line);\n\t\t\tshaders_collection_controller.add_definitions(globals_node, [definition], dependency);\n\t\t\tshaders_collection_controller.add_body_lines(globals_node, [body_line], dependency);\n\t\t}\n\t\tif (dependencies.length == 0) {\n\t\t\t// body_lines.push(body_line);\n\t\t\tshaders_collection_controller.add_body_lines(globals_node, [body_line]);\n\t\t}\n\t}\n\n\tstatic variable_config_default(variable_name: string): string | undefined {\n\t\treturn VARIABLE_CONFIG_DEFAULT_BY_NAME[variable_name];\n\t}\n\tvariable_config_default(variable_name: string): string | undefined {\n\t\treturn GlobalsGeometryHandler.variable_config_default(variable_name);\n\t}\n\t// variable_config_required_definitions(variable_name:string):DefinitionBaseConfig[]{\n\t// \treturn null\n\t// }\n\tread_attribute(\n\t\tnode: BaseGlNodeType,\n\t\tgl_type: ConnectionPointType,\n\t\tattrib_name: string,\n\t\tshaders_collection_controller: ShadersCollectionController\n\t) {\n\t\treturn GlobalsGeometryHandler.read_attribute(node, gl_type, attrib_name, shaders_collection_controller);\n\t}\n\n\tstatic read_attribute(\n\t\tnode: BaseGlNodeType,\n\t\tgl_type: ConnectionPointType,\n\t\tattrib_name: string,\n\t\tshaders_collection_controller: ShadersCollectionController\n\t): string | undefined {\n\t\tif (GlobalsGeometryHandler.PRE_DEFINED_ATTRIBUTES.indexOf(attrib_name) < 0) {\n\t\t\tshaders_collection_controller.add_definitions(\n\t\t\t\tnode,\n\t\t\t\t[new AttributeGLDefinition(node, gl_type, attrib_name)],\n\t\t\t\tShaderName.VERTEX\n\t\t\t);\n\t\t} else {\n\t\t\t// const if_rule = GlobalsGeometryHandler.IF_RULE[attrib_name]\n\t\t\t// if(if_rule){\n\t\t\t// \tconst definition = new Definition.Attribute(node, gl_type, attrib_name)\n\t\t\t// \tdefinition.set_if_rule(if_rule)\n\t\t\t// \tnode.add_definitions([definition])\n\t\t\t// }\n\t\t}\n\n\t\t// if (!shader_name) {\n\t\t// \tthrow 'no shader name';\n\t\t// }\n\t\tconst shader_name = shaders_collection_controller.current_shader_name;\n\t\tswitch (shader_name) {\n\t\t\tcase ShaderName.VERTEX: {\n\t\t\t\treturn attrib_name;\n\t\t\t}\n\t\t\tcase ShaderName.FRAGMENT: {\n\t\t\t\t// let's assume it can only be an attribute gl node\n\t\t\t\tif (!(node instanceof AttributeGlNode)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst var_name = 'varying_' + node.gl_var_name(node.output_name);\n\t\t\t\tconst varying_definition = new VaryingGLDefinition(node, gl_type, var_name);\n\n\t\t\t\tconst definitions_by_shader_name: Map<ShaderName, VaryingGLDefinition[]> = new Map();\n\t\t\t\t// definitions_by_shader_name.set(ShaderName.VERTEX, [])\n\t\t\t\tdefinitions_by_shader_name.set(ShaderName.FRAGMENT, []);\n\t\t\t\t// {\n\t\t\t\t// \t[ShaderName.VERTEX]: [],\n\t\t\t\t// \t[ShaderName.FRAGMENT]: [],\n\t\t\t\t// };\n\t\t\t\tconst body_lines_by_shader_name: Map<ShaderName, string[]> = new Map();\n\t\t\t\t// body_lines_by_shader_name.set(ShaderName.VERTEX, [])\n\t\t\t\tbody_lines_by_shader_name.set(ShaderName.FRAGMENT, []);\n\t\t\t\tMapUtils.push_on_array_at_entry(definitions_by_shader_name, shader_name, varying_definition);\n\n\t\t\t\tconst set_varying_body_line = `${var_name} = ${gl_type}(${attrib_name})`;\n\n\t\t\t\tconst shader_config = node.material_node?.assembler_controller.assembler.shader_config(shader_name);\n\t\t\t\tif (shader_config) {\n\t\t\t\t\tconst dependencies = shader_config.dependencies();\n\t\t\t\t\tfor (let dependency of dependencies) {\n\t\t\t\t\t\tMapUtils.push_on_array_at_entry(definitions_by_shader_name, dependency, varying_definition);\n\t\t\t\t\t\tMapUtils.push_on_array_at_entry(body_lines_by_shader_name, dependency, set_varying_body_line);\n\t\t\t\t\t}\n\t\t\t\t\tdefinitions_by_shader_name.forEach((definitions, shader_name) => {\n\t\t\t\t\t\tshaders_collection_controller.add_definitions(node, definitions, shader_name);\n\t\t\t\t\t});\n\t\t\t\t\tbody_lines_by_shader_name.forEach((body_lines, shader_name) => {\n\t\t\t\t\t\tshaders_collection_controller.add_body_lines(node, body_lines, shader_name);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn var_name;\n\t\t\t}\n\t\t}\n\t\t// TypeAssert.unreachable(shader_name);\n\n\t\t// const shader_name = node._shader_name // TODO: this is hack\n\t\t// const varying_definition = new Definition.Varying(node, gl_type, attrib_name)\n\t\t// const var_name = varying_definition.name()\n\t\t// definitions_by_shader_name[shader_name].push(varying_definition)\n\t\t// const shader_config = node.shader_config(shader_name)\n\t\t// const dependencies = shader_config.dependencies()\n\t\t// const body_line = `${var_name} = ${gl_type}(${attrib_name})`\n\t\t// for(let dependency of dependencies){\n\t\t// \tdefinitions_by_shader_name[dependency].push(varying_definition)\n\t\t// \tbody_lines_by_shader_name[dependency].push(body_line)\n\t\t// }\n\t\t// // if(dependencies.length == 0){\n\t\t// \t// body_lines.push(body_line)\n\t\t// \tnode.add_body_lines([body_line])\n\t\t// // }\n\t\t// for(let shader_name of Object.keys(definitions_by_shader_name)){\n\t\t// \tnode.add_definitions(definitions_by_shader_name[shader_name], shader_name)\n\t\t// }\n\t\t// for(let shader_name of Object.keys(body_lines_by_shader_name)){\n\t\t// \tnode.add_body_lines(body_lines_by_shader_name[shader_name], shader_name)\n\t\t// }\n\t\t// node.add_body_lines(body_lines)\n\t}\n\thandle_attribute_node(\n\t\tnode: AttributeGlNode,\n\t\tgl_type: ConnectionPointType,\n\t\tattrib_name: string,\n\t\tshaders_collection_controller: ShadersCollectionController\n\t) {\n\t\treturn GlobalsGeometryHandler.read_attribute(node, gl_type, attrib_name, shaders_collection_controller);\n\t}\n}\n","import {TypedContainer} from './_Base';\nimport {ContainableMap} from './utils/ContainableMap';\n\nexport class TextureContainer extends TypedContainer<ContainableMap['TEXTURE']> {\n\t// _content: Texture;\n\tset_content(content: ContainableMap['TEXTURE']) {\n\t\tsuper.set_content(content);\n\t}\n\n\t// set_texture(texture: Texture){\n\t// \tif (this._content != null) {\n\t// \t\tthis._content.dispose();\n\t// \t}\n\t// \tthis.set_content(texture);\n\t// }\n\ttexture(): ContainableMap['TEXTURE'] {\n\t\treturn this._content;\n\t}\n\tcore_content(): ContainableMap['TEXTURE'] {\n\t\treturn this._content;\n\t}\n\tcore_content_cloned(): ContainableMap['TEXTURE'] | undefined {\n\t\tconsole.log('clone', this._content);\n\t\tconst texture = this._content?.clone();\n\t\tif (texture) {\n\t\t\ttexture.needsUpdate = true;\n\t\t}\n\t\treturn texture;\n\t}\n\n\tobject() {\n\t\treturn this.texture();\n\t}\n\n\tinfos() {\n\t\tif (this._content != null) {\n\t\t\treturn [this._content];\n\t\t}\n\t}\n\tresolution(): [number, number] {\n\t\tif (this._content) {\n\t\t\tif (this._content.image) {\n\t\t\t\treturn [this._content.image.width, this._content.image.height];\n\t\t\t}\n\t\t}\n\t\treturn [-1, -1];\n\t}\n}\n","import {TypedNode} from '../_Base';\nimport {TextureContainer} from '../../containers/Texture';\nimport {Texture} from 'three/src/textures/Texture';\nimport {TypedContainerController} from '../utils/ContainerController';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {PolyScene} from '../../scene/PolyScene';\nimport {FlagsControllerB} from '../utils/FlagsController';\nimport {DataTexture} from 'three/src/textures/DataTexture';\nimport {LuminanceFormat, HalfFloatType} from 'three/src/constants';\n\nconst INPUT_COP_NAME = 'input texture';\nconst DEFAULT_INPUT_NAMES = [INPUT_COP_NAME, INPUT_COP_NAME, INPUT_COP_NAME, INPUT_COP_NAME];\n\nvar size = 32;\nvar data = new Uint16Array(size);\nfor (var i = 0; i < size; i++) {\n\tdata[i] = 0x70e2; // Half float 10000\n}\nconst EMPTY_DATA_TEXTURE = new DataTexture(data, size, 1, LuminanceFormat, HalfFloatType);\n\nexport class TypedCopNode<K extends NodeParamsConfig> extends TypedNode<'TEXTURE', BaseCopNodeType, K> {\n\tcontainer_controller: TypedContainerController<TextureContainer> = new TypedContainerController<TextureContainer>(\n\t\tthis,\n\t\tTextureContainer\n\t);\n\tpublic readonly flags: FlagsControllerB = new FlagsControllerB(this);\n\t// private _typed_array = new Uint8ClampedArray(512 * 512 * 4);\n\t// protected _texture: Texture = new DataTexture(this._typed_array, 512, 512, RGBFormat);\n\t// get texture() {\n\t// \treturn this._data_texture;\n\t// }\n\n\tstatic node_context(): NodeContext {\n\t\treturn NodeContext.COP;\n\t}\n\tstatic displayed_input_names(): string[] {\n\t\treturn DEFAULT_INPUT_NAMES;\n\t}\n\n\tconstructor(scene: PolyScene) {\n\t\tsuper(scene, 'BaseCopNode');\n\t}\n\n\tinitialize_base_node() {\n\t\t// this.flags.add_bypass();\n\n\t\t// this.flags.add_display();\n\t\t// if (this.flags.display) {\n\t\t// \tthis.flags.display.set(false);\n\t\t// }\n\t\tthis.io.outputs.set_has_one_output();\n\t\t// this.container_controller.init(CONTAINER_CLASS);\n\t}\n\tnode_sibbling(name: string): BaseCopNodeType | null {\n\t\treturn super.node_sibbling(name) as BaseCopNodeType | null;\n\t}\n\n\tset_texture(texture: Texture) {\n\t\t// this._copy_texture(texture);\n\t\ttexture.name = this.full_path();\n\t\tthis.set_container(texture);\n\t}\n\tclear_texture() {\n\t\tthis.set_container(EMPTY_DATA_TEXTURE);\n\t}\n\n\t// private _copy_texture(texture: Texture) {\n\t// \tconsole.log('_copy_texture', texture);\n\t// \tif (texture instanceof DataTexture) {\n\t// \t\tthis._data_texture.image = texture.image;\n\t// \t} else {\n\t// \t\tconst canvas = document.createElement('canvas');\n\t// \t\t// document.body.appendChild(canvas);\n\t// \t\tconst width = texture.image.width;\n\t// \t\tconst height = texture.image.height;\n\t// \t\tcanvas.width = width;\n\t// \t\tcanvas.height = height;\n\t// \t\tconst context = canvas.getContext('2d') as CanvasRenderingContext2D;\n\t// \t\tcontext.drawImage(texture.image, 0, 0);\n\t// \t\tconst image_data = context.getImageData(0, 0, width, height);\n\t// \t\tconsole.log(this._typed_array.length, image_data.data.length, image_data);\n\t// \t\tthis._data_texture.image = image_data;\n\t// \t}\n\t// \tthis._data_texture.format = texture.format;\n\t// \t// this._data_texture.mapping = texture.mapping;\n\t// \t// this._data_texture.wrapS = texture.wrapS;\n\t// \t// this._data_texture.wrapT = texture.wrapT;\n\t// \t// this._data_texture.minFilter = texture.minFilter;\n\t// \t// this._data_texture.magFilter = texture.magFilter;\n\t// \tthis._data_texture.needsUpdate = true;\n\t// \tconsole.log('updated data tex', this._data_texture);\n\n\t// \t// if (!this._texture || this._texture.uuid != texture.uuid) {\n\t// \t// \tif (!this._texture) {\n\t// \t// \t\tconsole.log('assign');\n\t// \t// \t\tthis._texture = texture.clone();\n\t// \t// \t\t// this._texture.name = this.full_path();\n\t// \t// \t} else {\n\t// \t// \t\tconsole.log('copy');\n\t// \t// \t\tconst keys = Object.keys(texture) as Array<keyof Texture>;\n\t// \t// \t\tconst protected_keys = ['uuid', 'name', 'node'];\n\t// \t// \t\tfor (let key of keys) {\n\t// \t// \t\t\tif (!protected_keys.includes(key)) {\n\t// \t// \t\t\t\tthis._texture[key] = texture[key] as never; // but why is 'never' needed?!\n\t// \t// \t\t\t}\n\t// \t// \t\t}\n\t// \t// \t}\n\t// \t// }\n\t// }\n}\n\nexport type BaseCopNodeType = TypedCopNode<any>;\nexport class BaseCopNodeClass extends TypedCopNode<any> {}\n","import {ConnectionPointType} from '../../utils/connections/ConnectionPointType';\nimport {BaseGlNodeType} from '../_Base';\nimport {CoreGraphNode} from '../../../../core/graph/CoreGraphNode';\nimport {TypedNamedConnectionPoint} from '../../utils/connections/NamedConnectionPoint';\nimport {NodeConnection} from '../../utils/connections/NodeConnection';\n\ntype IONameFunction = (index: number) => string;\ntype ExpectedConnectionTypesFunction = () => ConnectionPointType[];\n\nexport class GlConnectionsController {\n\tprivate _input_name_function: IONameFunction = (index: number) => {\n\t\treturn `in${index}`;\n\t};\n\tprivate _output_name_function: IONameFunction = (index: number) => {\n\t\treturn index == 0 ? 'val' : `val${index}`;\n\t};\n\t// private _default_input_type: ConnectionPointType = ConnectionPointType.FLOAT;\n\tprivate _expected_input_types_function: ExpectedConnectionTypesFunction = () => {\n\t\tconst type = this.first_input_connection_type() || ConnectionPointType.FLOAT;\n\t\treturn [type, type];\n\t};\n\tprivate _expected_output_types_function: ExpectedConnectionTypesFunction = () => {\n\t\treturn [this._expected_input_types_function()[0]];\n\t};\n\n\tconstructor(private node: BaseGlNodeType) {}\n\n\tset_input_name_function(func: IONameFunction) {\n\t\tthis._input_name_function = func;\n\t}\n\tset_output_name_function(func: IONameFunction) {\n\t\tthis._output_name_function = func;\n\t}\n\t// set_default_input_type(type: ConnectionPointType) {\n\t// \tthis._default_input_type = type;\n\t// }\n\tset_expected_input_types_function(func: ExpectedConnectionTypesFunction) {\n\t\tthis._expected_input_types_function = func;\n\t}\n\tset_expected_output_types_function(func: ExpectedConnectionTypesFunction) {\n\t\tthis._expected_output_types_function = func;\n\t}\n\n\toutput_name(index: number) {\n\t\treturn this._output_name_function(index);\n\t}\n\n\tprivate _update_signature_if_required_bound = this.update_signature_if_required.bind(this);\n\tprivate _initialized: boolean = false;\n\tinitialize_node() {\n\t\tif (this._initialized) {\n\t\t\tconsole.warn('already initialized', this.node);\n\t\t\treturn;\n\t\t}\n\t\tthis._initialized = true;\n\n\t\tthis.node.io.inputs.add_on_set_input_hook(\n\t\t\t'_update_signature_if_required',\n\t\t\tthis._update_signature_if_required_bound\n\t\t);\n\t\tthis.node.params.add_on_scene_load_hook(\n\t\t\t'_update_signature_if_required',\n\t\t\tthis._update_signature_if_required_bound\n\t\t);\n\t\tthis.node.params.set_post_create_params_hook(this._update_signature_if_required_bound);\n\t\tthis.node.add_post_dirty_hook('_update_signature_if_required', this._update_signature_if_required_bound);\n\t}\n\n\tupdate_signature_if_required(dirty_trigger?: CoreGraphNode) {\n\t\tif (!this.node.lifecycle.creation_completed || !this._connections_match_inputs()) {\n\t\t\tthis.update_connection_types();\n\t\t\tthis.node.remove_dirty_state();\n\t\t\tthis.make_successors_update_signatures();\n\t\t}\n\t}\n\t// used when a node changes its signature, adn the output nodes need to adapt their own signatures\n\tprivate make_successors_update_signatures() {\n\t\tfor (let successor of this.node.graph_all_successors()) {\n\t\t\tconst gl_node = successor as BaseGlNodeType;\n\t\t\tif (gl_node.gl_connections_controller) {\n\t\t\t\tgl_node.gl_connections_controller.update_signature_if_required(this.node);\n\t\t\t}\n\t\t}\n\t\t// this.node.io.connections\n\t\t// \t.output_connections()\n\t\t// \t.map((c) => c.node_dest)\n\t\t// \t.forEach((o) => {\n\t\t// \t\to.set_dirty(this.node);\n\t\t// \t});\n\t}\n\n\tupdate_connection_types() {\n\t\tconst set_dirty = false;\n\t\tconst expected_input_types = this._expected_input_types_function();\n\t\tconst expected_output_types = this._expected_output_types_function();\n\n\t\tconst named_input_connections = expected_input_types.map((type: ConnectionPointType, i: number) => {\n\t\t\treturn new TypedNamedConnectionPoint(this._input_name_function(i), type);\n\t\t});\n\t\tconst named_outputs = expected_output_types.map((type: ConnectionPointType, i: number) => {\n\t\t\treturn new TypedNamedConnectionPoint(this._output_name_function(i), type);\n\t\t});\n\n\t\tthis.node.io.inputs.set_named_input_connection_points(named_input_connections);\n\t\tthis.node.io.outputs.set_named_output_connection_points(named_outputs, set_dirty);\n\t\tthis.node.spare_params_controller.create_spare_parameters();\n\t}\n\n\tprotected _connections_match_inputs(): boolean {\n\t\tconst current_input_types = this.node.io.inputs.named_input_connection_points.map((c) => c.type);\n\t\tconst current_output_types = this.node.io.outputs.named_output_connection_points.map((c) => c.type);\n\t\tconst expected_input_types = this._expected_input_types_function();\n\t\tconst expected_output_types = this._expected_output_types_function();\n\n\t\tif (expected_input_types.length != current_input_types.length) {\n\t\t\treturn false;\n\t\t}\n\t\tif (expected_output_types.length != current_output_types.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (let i = 0; i < current_input_types.length; i++) {\n\t\t\tif (current_input_types[i] != expected_input_types[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tfor (let i = 0; i < current_output_types.length; i++) {\n\t\t\tif (current_output_types[i] != expected_output_types[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t// protected input_connection_type() {\n\t// \treturn this.first_input_connection_type();\n\t// }\n\t// protected output_connection_type() {\n\t// \treturn this.first_input_connection_type();\n\t// }\n\n\tfirst_input_connection_type(): ConnectionPointType | undefined {\n\t\tconst connections = this.node.io.connections.input_connections();\n\t\tif (connections) {\n\t\t\tconst first_connection = connections[0];\n\t\t\tif (first_connection) {\n\t\t\t\treturn this.connection_type_from_connection(first_connection);\n\t\t\t}\n\t\t}\n\t}\n\tconnection_type_from_connection(connection: NodeConnection): ConnectionPointType {\n\t\tconst node_src = connection.node_src;\n\t\tconst output_index = connection.output_index;\n\t\tconst node_src_output_connection = node_src.io.outputs.named_output_connection_points[output_index];\n\t\treturn node_src_output_connection.type;\n\t}\n}\n","import {VideoTexture} from 'three/src/textures/VideoTexture';\nimport {TextureLoader} from 'three/src/loaders/TextureLoader';\nimport {Texture} from 'three/src/textures/Texture';\n// import {RepeatWrapping} from 'three/src/constants';\n// import {Float32BufferAttribute} from 'three/src/core/BufferAttribute';\n// import lodash_isArray from 'lodash/isArray';\n// import {CoreScriptLoader} from '/Script';\n// import {CoreGeometry} from '../geometry/Geometry';\nimport {UnsignedByteType} from 'three/src/constants';\nimport {CoreWalker} from '../Walker';\n\nimport {BaseNodeType} from '../../engine/nodes/_Base';\nimport {BaseParamType} from '../../engine/params/_Base';\nimport {BaseCopNodeClass} from '../../engine/nodes/cop/_Base';\nimport {TextureContainer} from '../../engine/containers/Texture';\nimport {Poly} from '../../engine/Poly';\n// import {BufferGeometry} from 'three/src/core/BufferGeometry';\n\ninterface VideoSourceTypeByExt {\n\togg: string;\n\togv: string;\n\tmp4: string;\n}\n// interface ImageScriptUrlByExt {\n// \texr: string;\n// \tbasis: string;\n// }\ninterface ThreeLoaderByExt {\n\texr: string;\n\tbasis: string;\n\thdr: string;\n}\n\nenum Extension {\n\tEXR = 'exr',\n\tBASIS = 'basis',\n\tHDR = 'hdr',\n}\n\nexport class CoreTextureLoader {\n\tstatic PARAM_DEFAULT = '/examples/textures/uv.jpg';\n\tstatic PARAM_ENV_DEFAULT = '/examples/textures/piz_compressed.exr';\n\n\tstatic VIDEO_EXTENSIONS = ['mp4', 'webm', 'ogv'];\n\tstatic VIDEO_SOURCE_TYPE_BY_EXT: VideoSourceTypeByExt = {\n\t\togg: 'video/ogg; codecs=\"theora, vorbis\"',\n\t\togv: 'video/ogg; codecs=\"theora, vorbis\"',\n\t\tmp4: 'video/mp4; codecs=\"avc1.42E01E, mp4a.40.2\"',\n\t};\n\t// static SCRIPT_URL_BY_EXT: ImageScriptUrlByExt = {\n\t// \texr: 'EXRLoader',\n\t// \tbasis: 'BasisTextureLoader',\n\t// };\n\t// static THREE_LOADER_BY_EXT: ThreeLoaderByExt = {\n\t// \texr: 'EXRLoader',\n\t// \tbasis: 'BasisTextureLoader',\n\t// };\n\t// @load_texture: (url, callback)->\n\t// \tif url\n\t// \t\tloader = this._texture_loader(url)\n\n\t// \t\tloader.load(\n\t// \t\t\turl,\n\t// \t\t\tcallback,\n\t// \t\t\tnull,\n\t// \t\t\t(error)=>\n\t// \t\t\t\tthis.set_error(\"could not load texture #{url}\")\n\t// \t\t\t\t#this._on_error(error)\n\t// \t\t\t)\n\t// \telse\n\t// \t\tthis.set_error(\"not url given to Mat/Base._load_texture\")\n\t// _on_error: (error)->\n\t// \tconsole.log(\"ERROR\")\n\t// \tconsole.log(error)\n\t// \tthis.set_error_message()\n\n\tconstructor(private _node: BaseNodeType, private _param: BaseParamType) {}\n\n\tasync load_texture_from_url_or_op(url: string): Promise<Texture | VideoTexture | null> {\n\t\tlet texture: Texture | null = null;\n\t\tlet found_node;\n\n\t\tif (url.substring(0, 3) == 'op:') {\n\t\t\tconst node_path = url.substring(3);\n\t\t\tfound_node = CoreWalker.find_node(this._node, node_path);\n\t\t\tif (found_node) {\n\t\t\t\tif (found_node instanceof BaseCopNodeClass) {\n\t\t\t\t\tconst container: TextureContainer = await found_node.request_container();\n\t\t\t\t\ttexture = container.texture();\n\t\t\t\t} else {\n\t\t\t\t\tthis._node.states.error.set(`found node is not a texture node`);\n\t\t\t\t}\n\n\t\t\t\t// this._assign_texture(attrib, texture)\n\t\t\t} else {\n\t\t\t\tthis._node.states.error.set(`no node found in path '${node_path}'`);\n\t\t\t}\n\t\t} else {\n\t\t\ttexture = await this.load_url(url);\n\t\t\tif (texture) {\n\t\t\t\t// param.mark_as_referencing_asset(url)\n\t\t\t\tif (this._param.options.texture_as_env()) {\n\t\t\t\t\t// texture = await CoreTextureLoader.set_texture_for_env(texture, this._node);\n\t\t\t\t} else {\n\t\t\t\t\ttexture = CoreTextureLoader.set_texture_for_mapping(texture);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._node.states.error.set(`could not load texture ${url}`);\n\t\t\t}\n\t\t}\n\n\t\t// NOTE: if this._param gets its value from an expression like `ch('/CONTROL/photo_url')`\n\t\t// then found_node will be null, so the graph should not be changed\n\t\tif (found_node && this._param.graph_predecessors()[0] != found_node) {\n\t\t\tthis._param.graph_disconnect_predecessors();\n\t\t\tthis._param.add_graph_input(found_node);\n\t\t}\n\n\t\t// this._assign_texture(attrib, texture)\n\t\treturn texture;\n\t}\n\n\tasync load_url(url: string): Promise<Texture> {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\t// url = this._resolve_url(url)\n\t\t\tconst ext = CoreTextureLoader._ext(url);\n\n\t\t\tif (CoreTextureLoader.VIDEO_EXTENSIONS.includes(ext)) {\n\t\t\t\tconst texture: VideoTexture = await this._load_as_video(url);\n\t\t\t\treturn texture;\n\t\t\t} else {\n\t\t\t\tthis.loader_for_ext(ext).then((loader) => {\n\t\t\t\t\tloader.load(url, resolve, undefined, (error: any) => {\n\t\t\t\t\t\tconsole.warn('error', error);\n\t\t\t\t\t\treject();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\tasync loader_for_ext(ext: string) {\n\t\tconst ext_lowercase = ext.toLowerCase() as keyof ThreeLoaderByExt;\n\t\t// const script_name = CoreTextureLoader.SCRIPT_URL_BY_EXT[ext_lowercase];\n\t\t// var loader;\n\n\t\tswitch (ext_lowercase) {\n\t\t\tcase Extension.EXR: {\n\t\t\t\tconst {EXRLoader} = await import('../../../modules/three/examples/jsm/loaders/EXRLoader');\n\t\t\t\treturn new EXRLoader();\n\t\t\t}\n\t\t\tcase Extension.HDR: {\n\t\t\t\tconst {RGBELoader} = await import('../../../modules/three/examples/jsm/loaders/RGBELoader');\n\t\t\t\tconst loader = new RGBELoader();\n\t\t\t\tloader.setDataType(UnsignedByteType); // FloatType,HalfFloatType\n\t\t\t\t// loader.setPath('/examples/textures/equirectangular/');\n\t\t\t\treturn loader;\n\t\t\t}\n\t\t\tcase Extension.BASIS: {\n\t\t\t\tconst {BasisTextureLoader} = await import(\n\t\t\t\t\t'../../../modules/three/examples/jsm/loaders/BasisTextureLoader'\n\t\t\t\t);\n\t\t\t\tconst loader = new BasisTextureLoader();\n\t\t\t\tloader.setTranscoderPath('/three/js/libs/basis/');\n\t\t\t\tconst renderer = await Poly.instance().renderers_controller.wait_for_renderer();\n\t\t\t\tif (renderer) {\n\t\t\t\t\tloader.detectSupport(renderer);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.warn('texture loader found no renderer for basis texture loader');\n\t\t\t\t}\n\t\t\t\treturn loader;\n\t\t\t}\n\t\t}\n\n\t\t// if (script_name) {\n\t\t// const imported_classes = await CoreScriptLoader.load_module_three_loader(script_name)\n\t\t// const imported_classes = await CoreScriptLoader.three_module(`loaders/${script_name}`);\n\t\t// const imported_classes = await import(`modules/three/examples/jsm/loaders/${script_name}`);\n\t\t// const loader_class_name = CoreTextureLoader.THREE_LOADER_BY_EXT[ext_lowercase];\n\t\t// const loader_class = imported_classes[loader_class_name];\n\t\t// if (loader_class) {\n\t\t// \tloader = new loader_class();\n\t\t// \tif (ext == 'basis') {\n\t\t// \t\tloader.setTranscoderPath('/three/js/libs/basis/');\n\t\t// \t\tconst renderer = POLY.renderers_controller.first_renderer();\n\t\t// \t\tloader.detectSupport(renderer);\n\t\t// \t}\n\t\t// }\n\t\t// }\n\t\treturn new TextureLoader();\n\n\t\t// const constructor = (() => { switch (ext) {\n\t\t// \tcase 'exr': return EXRLoader;\n\t\t// \tdefault: return TextureLoader;\n\t\t// } })();\n\t\t// return new constructor();\n\t}\n\n\t_load_as_video(url: string): Promise<VideoTexture> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst video = document.createElement('video');\n\t\t\t// document.body.appendChild(video)\n\t\t\t// video.id = 'video'\n\t\t\t// console.log(\"video\", video)\n\t\t\tvideo.setAttribute('crossOrigin', 'anonymous');\n\t\t\tvideo.setAttribute('autoplay', `${true}`); // to ensure it loads\n\t\t\tvideo.setAttribute('loop', `${true}`);\n\n\t\t\t// wait for onloadedmetadata to ensure that we have a duration\n\t\t\tvideo.onloadedmetadata = function () {\n\t\t\t\tvideo.pause();\n\t\t\t\tconst texture = new VideoTexture(video);\n\t\t\t\tresolve(texture);\n\t\t\t};\n\t\t\t// video.setAttribute('controls', true)\n\t\t\t// video.style=\"display:none\"\n\t\t\tconst source = document.createElement('source');\n\t\t\tconst ext = CoreTextureLoader._ext(url) as keyof VideoSourceTypeByExt;\n\t\t\tlet type: string = CoreTextureLoader.VIDEO_SOURCE_TYPE_BY_EXT[ext];\n\t\t\ttype = type || CoreTextureLoader._default_video_source_type(url);\n\t\t\tsource.setAttribute('type', type);\n\t\t\tsource.setAttribute('src', url);\n\n\t\t\tvideo.appendChild(source);\n\t\t});\n\t}\n\tstatic _default_video_source_type(url: string) {\n\t\tconst ext = this._ext(url);\n\t\treturn `video/${ext}`;\n\t}\n\n\tstatic pixel_data(texture: Texture) {\n\t\tconst img = texture.image;\n\t\tconst canvas = document.createElement('canvas');\n\t\tcanvas.width = img.width;\n\t\tcanvas.height = img.height;\n\t\tconst context = canvas.getContext('2d');\n\t\tif (context) {\n\t\t\tcontext.drawImage(img, 0, 0, img.width, img.height);\n\t\t\treturn context.getImageData(0, 0, img.width, img.height);\n\t\t}\n\t}\n\n\t// TODO: typescript: check what type the pixel_data is\n\t// static pixel_data_to_attribute(pixel_data: Pixel, geometry: BufferGeometry, attrib_name_with_component:string, convert_method: (x:number, y:number, z:number, w:number)=>number) {\n\t// \tconst {data} = pixel_data;\n\t// \tconst geometry_wrapper = new CoreGeometry(geometry);\n\t// \t// TODO: add error if no uvs\n\t// \tconst values = [];\n\t// \tconst points = geometry_wrapper.points();\n\t// \tfor (let point of points) {\n\t// \t\tconst uv = point.attrib_value('uv');\n\t// \t\tconst x = Math.floor((pixel_data.width - 1) * uv.x);\n\t// \t\tconst y = Math.floor((pixel_data.height - 1) * (1 - uv.y));\n\t// \t\tconst i = y * pixel_data.width + x;\n\t// \t\t// const val = data[4*i] / 255.0;\n\t// \t\tif (convert_method) {\n\t// \t\t\tconst val = convert_method(data[4 * i + 0], data[4 * i + 1], data[4 * i + 2], data[4 * i + 3]);\n\t// \t\t\tvalues.push(val);\n\t// \t\t} else {\n\t// \t\t\tvalues.push([data[4 * i + 0], data[4 * i + 1], data[4 * i + 2]]);\n\t// \t\t}\n\t// \t}\n\n\t// \tconst attrib_name_elements = attrib_name_with_component.split('.');\n\t// \tlet attrib_name = attrib_name_elements[0];\n\t// \tlet component_offset = null;\n\t// \tif (attrib_name_elements.length > 1) {\n\t// \t\tconst component = attrib_name_elements[1] as keyof Vector4Like\n\t// \t\tcomponent_offset = {x: 0, y: 1, z: 2, w: 3}[component];\n\t// \t}\n\n\t// \tlet attrib = geometry.attributes[attrib_name];\n\t// \tif (attrib) {\n\t// \t\tconst array = attrib.array;\n\t// \t\tlet index = 0;\n\t// \t\tlet is_array = null;\n\t// \t\tfor (let value of values) {\n\t// \t\t\tif (is_array || lodash_isArray(value)) {\n\t// \t\t\t\tis_array = true;\n\t// \t\t\t\tlet component_index = 0;\n\t// \t\t\t\tfor (let value_c of value) {\n\t// \t\t\t\t\tarray[attrib.itemSize * index + component_index] = value_c;\n\t// \t\t\t\t\tcomponent_index++;\n\t// \t\t\t\t}\n\t// \t\t\t} else {\n\t// \t\t\t\tarray[attrib.itemSize * index + component_offset] = value;\n\t// \t\t\t}\n\t// \t\t\tindex++;\n\t// \t\t}\n\t// \t} else {\n\t// \t\tattrib = geometry.setAttribute(attrib_name, new Float32BufferAttribute(values, 1));\n\t// \t}\n\t// \tattrib.needsUpdate = true;\n\t// }\n\n\tstatic _ext(url: string) {\n\t\tconst elements = url.split('.');\n\t\treturn elements[elements.length - 1].toLowerCase();\n\t}\n\t// static private _resolve_url(url: string):string{\n\t// \tif(url[0] == '/'){\n\t// \t\tconst root_url = POLY.env_is_production() ? 'https://polygonjs.com' : 'http://localhost:5000'\n\t// \t\turl = `${root_url}${url}`\n\t// \t}\n\t// \treturn url\n\t// }\n\n\tstatic set_texture_for_mapping(texture: Texture) {\n\t\t// let val = texture['wrapS']\n\t\t// Object.defineProperty(texture, 'wrapS', {\n\t\t// \tget () {\n\t\t// \t\treturn val // Simply return the cached value\n\t\t// \t},\n\t\t// \tset (newVal) {\n\t\t// \t\tval = newVal // Save the newVal\n\t\t// \t\tconsole.warn(\"set\", newVal)\n\t\t// \t}\n\t\t// })\n\n\t\t// texture.wrapS = RepeatWrapping\n\t\t// texture.wrapT = RepeatWrapping\n\t\t// console.log(\"set_texture_for_mapping\", RepeatWrapping, texture, texture.wrapS)\n\t\treturn texture;\n\t}\n\n\t// static async set_texture_for_env(texture: Texture, registerer: BaseNode) {\n\t// \tif (registerer._registered_env_map) {\n\t// \t\tPOLY.renderers_controller.deregister_env_map(registerer._registered_env_map);\n\t// \t}\n\t// \tregisterer._registered_env_map = await POLY.renderers_controller.register_env_map(texture);\n\t// \treturn registerer._registered_env_map;\n\t// }\n}\n","import {VideoTexture} from 'three/src/textures/VideoTexture';\nimport {\n\tUVMapping,\n\tCubeReflectionMapping,\n\tCubeRefractionMapping,\n\tEquirectangularReflectionMapping,\n\tEquirectangularRefractionMapping,\n\tSphericalReflectionMapping,\n\tCubeUVReflectionMapping,\n\tCubeUVRefractionMapping,\n\tClampToEdgeWrapping,\n\tRepeatWrapping,\n\tMirroredRepeatWrapping,\n\tLinearFilter,\n\tNearestFilter,\n\tNearestMipMapNearestFilter,\n\tNearestMipMapLinearFilter,\n\tLinearMipMapNearestFilter,\n\tLinearMipMapLinearFilter,\n\t// UnsignedByteType,\n\t// ByteType,\n\t// ShortType,\n\t// UnsignedShortType,\n\t// IntType,\n\t// UnsignedIntType,\n\t// FloatType,\n\t// HalfFloatType,\n\t// UnsignedShort4444Type,\n\t// UnsignedShort5551Type,\n\t// UnsignedShort565Type,\n\t// UnsignedInt248Type,\n\t// AlphaFormat,\n\t// RGBFormat,\n\t// RGBAFormat,\n\t// LuminanceFormat,\n\t// LuminanceAlphaFormat,\n\t// RGBEFormat,\n\t// DepthFormat,\n\t// DepthStencilFormat,\n\t// LinearEncoding,\n\t// sRGBEncoding,\n\t// GammaEncoding,\n\t// RGBEEncoding,\n\t// LogLuvEncoding,\n\t// RGBM7Encoding,\n\t// RGBM16Encoding,\n\t// RGBDEncoding,\n\t// BasicDepthPacking,\n\t// RGBADepthPacking,\n} from 'three/src/constants';\nimport {Texture} from 'three/src/textures/Texture';\n// const THREE = {\n// \tTexture,\n// \tUVMapping,\n// \tVideoTexture,\n// \tCubeReflectionMapping,\n// \tCubeRefractionMapping,\n// \tEquirectangularReflectionMapping,\n// \tEquirectangularRefractionMapping,\n// \tSphericalReflectionMapping,\n// \tCubeUVReflectionMapping,\n// \tCubeUVRefractionMapping,\n// \tClampToEdgeWrapping,\n// \tRepeatWrapping,\n// \tMirroredRepeatWrapping,\n// \tLinearFilter,\n// \tNearestFilter,\n// \tNearestMipMapNearestFilter,\n// \tNearestMipMapLinearFilter,\n// \tLinearMipMapNearestFilter,\n// \tLinearMipMapLinearFilter,\n// \tUnsignedByteType,\n// \tByteType,\n// \tShortType,\n// \tUnsignedShortType,\n// \tIntType,\n// \tUnsignedIntType,\n// \tFloatType,\n// \tHalfFloatType,\n// \tUnsignedShort4444Type,\n// \tUnsignedShort5551Type,\n// \tUnsignedShort565Type,\n// \tUnsignedInt248Type,\n// \tAlphaFormat,\n// \tRGBFormat,\n// \tRGBAFormat,\n// \tLuminanceFormat,\n// \tLuminanceAlphaFormat,\n// \tRGBEFormat,\n// \tDepthFormat,\n// \tDepthStencilFormat,\n// \tLinearEncoding,\n// \tsRGBEncoding,\n// \tGammaEncoding,\n// \tRGBEEncoding,\n// \tLogLuvEncoding,\n// \tRGBM7Encoding,\n// \tRGBM16Encoding,\n// \tRGBDEncoding,\n// \tBasicDepthPacking,\n// \tRGBADepthPacking,\n// };\n// import lodash_last from 'lodash/last';\n// import NodeBase from '../_Base'\n\nimport {TypedCopNode} from './_Base';\n// import {BaseParam} from '../../../Engine/Param/_Base'\nimport {CoreTextureLoader} from '../../../core/loader/Texture';\nimport {ParamType} from '../../poly/ParamType';\nimport {NodeEvent} from '../../poly/NodeEvent';\n\n// this used to be named file_in, but I can't recall the decision of not calling it simply 'file'\n// so renaming it back to file for now\n\nconst MAPPINGS = [\n\t{UVMapping},\n\t{CubeReflectionMapping},\n\t{CubeRefractionMapping},\n\t{EquirectangularReflectionMapping},\n\t{EquirectangularRefractionMapping},\n\t{SphericalReflectionMapping},\n\t{CubeUVReflectionMapping},\n\t{CubeUVRefractionMapping},\n];\n\nconst WRAPPINGS: Dictionary<number>[] = [{ClampToEdgeWrapping}, {RepeatWrapping}, {MirroredRepeatWrapping}];\n\nconst MAG_FILTERS: Dictionary<number>[] = [{LinearFilter}, {NearestFilter}];\nconst MIN_FILTERS: Dictionary<number>[] = [\n\t{NearestFilter},\n\t{NearestMipMapNearestFilter},\n\t{NearestMipMapLinearFilter},\n\t{LinearFilter},\n\t{LinearMipMapNearestFilter},\n\t{LinearMipMapLinearFilter},\n];\n\n// const TYPES = [\n// \t\"UnsignedByteType\",\n// \t\"ByteType\",\n// \t\"ShortType\",\n// \t\"UnsignedShortType\",\n// \t\"IntType\",\n// \t\"UnsignedIntType\",\n// \t\"FloatType\",\n// \t\"HalfFloatType\",\n// \t\"UnsignedShort4444Type\",\n// \t\"UnsignedShort5551Type\",\n// \t\"UnsignedShort565Type\",\n// \t\"UnsignedInt248Type\"\n// ];\n\n// const FORMATS = [\n// \t\"AlphaFormat\",\n// \t\"RGBFormat\",\n// \t\"RGBAFormat\",\n// \t\"LuminanceFormat\",\n// \t\"LuminanceAlphaFormat\",\n// \t\"RGBEFormat\",\n// \t\"DepthFormat\",\n// \t\"DepthStencilFormat\"\n// ];\n\n// const ENCODINGS = [\n// \t\"LinearEncoding\",\n// \t\"sRGBEncoding\",\n// \t\"GammaEncoding\",\n// \t\"RGBEEncoding\",\n// \t\"LogLuvEncoding\",\n// \t\"RGBM7Encoding\",\n// \t\"RGBM16Encoding\",\n// \t\"RGBDEncoding\",\n// \t\"BasicDepthPacking\",\n// \t\"RGBADepthPacking\"\n// ];\n\ninterface AttribMapping {\n\tmapping: string;\n\twrapS: string;\n\twrapT: string;\n\tminFilter: string;\n\tmagFilter: string;\n}\nconst ATTRIB_MAPPING_KEYS: Array<keyof AttribMapping> = ['mapping', 'wrapS', 'wrapT', 'minFilter', 'magFilter'];\nconst ATTRIB_MAPPING: AttribMapping = {\n\tmapping: 'mapping',\n\twrapS: 'wrap_s',\n\twrapT: 'wrap_t',\n\tminFilter: 'min_filter',\n\tmagFilter: 'mag_filter',\n\t// type: 'type',\n\t// encoding: 'encoding'\n\t// format: 'format',\n};\n\nimport {BaseNodeType} from '../_Base';\nimport {BaseParamType} from '../../params/_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nclass FileCopParamsConfig extends NodeParamsConfig {\n\t// video_time = ParamConfig.FLOAT(1);\n\turl = ParamConfig.STRING(CoreTextureLoader.PARAM_DEFAULT, {\n\t\tdesktop_browse: {file_type: 'texture'},\n\t});\n\treload = ParamConfig.BUTTON(null, {\n\t\tcallback: (node: BaseNodeType, param: BaseParamType) => {\n\t\t\tFileCopNode.PARAM_CALLBACK_reload(node as FileCopNode, param);\n\t\t},\n\t});\n\tmapping = ParamConfig.INTEGER(UVMapping, {\n\t\tmenu: {\n\t\t\tentries: MAPPINGS.map((m) => {\n\t\t\t\treturn {\n\t\t\t\t\tname: Object.keys(m)[0],\n\t\t\t\t\tvalue: Object.values(m)[0] as number,\n\t\t\t\t};\n\t\t\t}),\n\t\t},\n\t});\n\twrap_s = ParamConfig.INTEGER(Object.values(WRAPPINGS[0])[0], {\n\t\tmenu: {\n\t\t\t// type: 'radio',\n\t\t\tentries: WRAPPINGS.map((m) => {\n\t\t\t\treturn {\n\t\t\t\t\tname: Object.keys(m)[0],\n\t\t\t\t\tvalue: Object.values(m)[0] as number,\n\t\t\t\t};\n\t\t\t}),\n\t\t},\n\t});\n\twrap_t = ParamConfig.INTEGER(Object.values(WRAPPINGS[0])[0], {\n\t\tmenu: {\n\t\t\t// type: 'radio',\n\t\t\tentries: WRAPPINGS.map((m) => {\n\t\t\t\treturn {\n\t\t\t\t\tname: Object.keys(m)[0],\n\t\t\t\t\tvalue: Object.values(m)[0] as number,\n\t\t\t\t};\n\t\t\t}),\n\t\t},\n\t});\n\tmag_filter = ParamConfig.INTEGER(Object.values(MAG_FILTERS[0])[0], {\n\t\tmenu: {\n\t\t\t// type: 'radio',\n\t\t\tentries: MAG_FILTERS.map((m) => {\n\t\t\t\treturn {\n\t\t\t\t\tname: Object.keys(m)[0],\n\t\t\t\t\tvalue: Object.values(m)[0] as number,\n\t\t\t\t};\n\t\t\t}),\n\t\t},\n\t});\n\tmin_filter = ParamConfig.INTEGER(Object.values(MIN_FILTERS[0])[0], {\n\t\tmenu: {\n\t\t\t// type: 'radio',\n\t\t\tentries: MIN_FILTERS.map((m) => {\n\t\t\t\treturn {\n\t\t\t\t\tname: Object.keys(m)[0],\n\t\t\t\t\tvalue: Object.values(m)[0] as number,\n\t\t\t\t};\n\t\t\t}),\n\t\t},\n\t});\n}\n\nconst ParamsConfig = new FileCopParamsConfig();\n\nexport class FileCopNode extends TypedCopNode<FileCopParamsConfig> {\n\tparams_config = ParamsConfig;\n\t// @ParamF('video_time') _param_video_time: number;\n\t// @ParamS('url') _param_url: string;\n\tprivate _previous_param_url: string | undefined;\n\tprivate _video: HTMLVideoElement | undefined;\n\n\tstatic type() {\n\t\treturn 'file';\n\t}\n\n\t// _param_video_time_param: BaseParam\n\tprivate _texture_loader: CoreTextureLoader | undefined;\n\n\tstatic readonly VIDEO_TIME_PARAM_NAME = 'video_time';\n\tstatic readonly DEFAULT_NODE_PATH = {\n\t\tUV: '/COP/file_uv',\n\t\tENV_MAP: '/COP/env_map',\n\t};\n\n\t// initialize_node() {\n\t// \t// this.io.inputs.set_count_to_zero();\n\t// }\n\n\t// create_params() {\n\t// \t// this.add_param(ParamType.STRING, 'url', CoreTextureLoader.PARAM_DEFAULT, {\n\t// \t// \tdesktop_browse: {file_type: 'texture'},\n\t// \t// });\n\t// \t// this.add_param(ParamType.BUTTON, 'reload', null, {\n\t// \t// \tcallback: this._reload.bind(this),\n\t// \t// });\n\t// \t// this.add_param(ParamType.FLOAT, 'video_time', 0, {range: [0, 10]})\n\t// \t// this.add_param(ParamType.INTEGER, 'mapping', UVMapping as number, {\n\t// \t// \tmenu: {\n\t// \t// \t\tentries: MAPPINGS.map((m) => {\n\t// \t// \t\t\treturn {\n\t// \t// \t\t\t\tname: Object.keys(m)[0],\n\t// \t// \t\t\t\tvalue: Object.values(m)[0] as number,\n\t// \t// \t\t\t};\n\t// \t// \t\t}),\n\t// \t// \t},\n\t// \t// });\n\t// \t// for (let wrap_name of ['wrap_s', 'wrap_t']) {\n\t// \t// \tconst wrap = Object.values(WRAPPINGS[0])[0] as number;\n\t// \t// \tthis.add_param(ParamType.INTEGER, wrap_name, wrap, {\n\t// \t// \t\tmenu: {\n\t// \t// \t\t\t// type: 'radio',\n\t// \t// \t\t\tentries: WRAPPINGS.map((m) => {\n\t// \t// \t\t\t\treturn {\n\t// \t// \t\t\t\t\tname: Object.keys(m)[0],\n\t// \t// \t\t\t\t\tvalue: Object.values(m)[0] as number,\n\t// \t// \t\t\t\t};\n\t// \t// \t\t\t}),\n\t// \t// \t\t},\n\t// \t// \t});\n\t// \t// }\n\t// \t// const mag_filter = Object.values(MAG_FILTERS[0])[0] as number;\n\t// \t// this.add_param(ParamType.INTEGER, 'mag_filter', mag_filter, {\n\t// \t// \tmenu: {\n\t// \t// \t\t// type: 'radio',\n\t// \t// \t\tentries: MAG_FILTERS.map((m) => {\n\t// \t// \t\t\treturn {\n\t// \t// \t\t\t\tname: Object.keys(m)[0],\n\t// \t// \t\t\t\tvalue: Object.values(m)[0] as number,\n\t// \t// \t\t\t};\n\t// \t// \t\t}),\n\t// \t// \t},\n\t// \t// });\n\t// \t// const min_filter: number = Object.values(MIN_FILTERS[0])[0] as number;\n\t// \t// this.add_param(ParamType.INTEGER, 'min_filter', min_filter, {\n\t// \t// \tmenu: {\n\t// \t// \t\t// type: 'radio',\n\t// \t// \t\tentries: MIN_FILTERS.map((m) => {\n\t// \t// \t\t\treturn {\n\t// \t// \t\t\t\tname: Object.keys(m)[0],\n\t// \t// \t\t\t\tvalue: Object.values(m)[0] as number,\n\t// \t// \t\t\t};\n\t// \t// \t\t}),\n\t// \t// \t},\n\t// \t// });\n\t// \t// TODO: to be added when I have some level of control\n\t// \t// for now, the type attribute overrides what piz_compressed.exr creates\n\t// \t// which in turns fucks up with the env_map\n\t// \t// advanced\n\t// \t// this.add_param(ParamType.TOGGLE, 'advanced', 0)\n\t// \t// this.add_param(ParamType.INTEGER, 'type', THREE[TYPES[0]], {\n\t// \t// \tmenu: { type: 'radio', entries: TYPES.map(m=>{ return { name: m, value: THREE[m] } })},\n\t// \t// \tvisible_if: {advanced: 1}\n\t// \t// })\n\t// \t// this.add_param(ParamType.INTEGER, 'format', THREE[FORMATS[0]], {\n\t// \t// \tmenu: { type: 'radio', entries: FORMATS.map(m=>{ return { name: m, value: THREE[m] } })},\n\t// \t// \tvisible_if: {advanced: 1}\n\t// \t// })\n\t// \t// this.add_param(ParamType.INTEGER, 'encoding', THREE[ENCODINGS[0]], {\n\t// \t// \tmenu: { type: 'radio', entries: ENCODINGS.map(m=>{ return { name: m, value: THREE[m] } })},\n\t// \t// \tvisible_if: {advanced: 1}\n\t// \t// })\n\t// }\n\n\tasync cook() {\n\t\tif (this._is_static_image_url(this.pv.url)) {\n\t\t\tawait this.cook_for_image();\n\t\t} else {\n\t\t\tawait this.cook_for_video();\n\t\t}\n\t}\n\n\tprivate _is_static_image_url(url: string) {\n\t\treturn true;\n\t}\n\n\tprivate async cook_for_image() {\n\t\tconst texture = await this._load_texture(this.pv.url);\n\n\t\tif (texture) {\n\t\t\tthis._update_texture_params(texture);\n\t\t\tthis.set_texture(texture);\n\t\t} else {\n\t\t\tthis.clear_texture();\n\t\t}\n\t}\n\n\tprivate async cook_for_video() {\n\t\tif (this._param_url_changed()) {\n\t\t\tconst texture = await this._load_texture(this.pv.url);\n\t\t\t// if (texture) {\n\t\t\t// \tthis._texture = texture;\n\t\t\t// }\n\n\t\t\tif (texture) {\n\t\t\t\tthis._add_video_spare_params_if_required(texture);\n\t\t\t}\n\t\t\tthis._previous_param_url = this.pv.url;\n\n\t\t\tthis._set_video_current_time();\n\n\t\t\tif (texture) {\n\t\t\t\tthis._update_texture_params(texture);\n\t\t\t\tthis.set_texture(texture);\n\t\t\t} else {\n\t\t\t\tthis.cook_controller.end_cook();\n\t\t\t}\n\t\t} else {\n\t\t\t// this._set_video_current_time();\n\t\t\t// this._update_texture_params();\n\t\t\t// if (texture?.needsUpdate) {\n\t\t\t// \tthis.set_texture(texture);\n\t\t\t// } else {\n\t\t\t// \tthis.cook_controller.end_cook();\n\t\t\t// }\n\t\t}\n\t}\n\n\tresolved_url() {\n\t\treturn this.pv.url;\n\t}\n\n\tprivate _update_texture_params(texture: Texture) {\n\t\t// const keys = Object.keys(ATTRIB_MAPPING) as keyof AttribMapping\n\t\tfor (let texture_attrib of ATTRIB_MAPPING_KEYS) {\n\t\t\tconst param_name = ATTRIB_MAPPING[texture_attrib];\n\t\t\tconst param_value = this.params.float(param_name);\n\t\t\t// const texture_attrib = ATTRIB_MAPPING[attrib];\n\n\t\t\tif (param_value != null && texture) {\n\t\t\t\tif (texture[texture_attrib] != param_value) {\n\t\t\t\t\ttexture[texture_attrib] = param_value;\n\t\t\t\t\ttexture.needsUpdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstatic PARAM_CALLBACK_reload(node: FileCopNode, param: BaseParamType) {\n\t\tnode.param_callback_reload();\n\t}\n\tprivate param_callback_reload() {\n\t\tthis._previous_param_url = undefined;\n\n\t\t// set the param dirty is preferable, in case this is used to refresh a local asset\n\t\tthis.p.url.set_successors_dirty();\n\t\t// this.set_dirty()\n\t}\n\n\tprivate _set_video_current_time() {\n\t\tif (this._video) {\n\t\t\tif (this.params.has('video_time')) {\n\t\t\t\tthis._video.currentTime = this.params.float('video_time');\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _add_video_spare_params_if_required(texture: Texture | VideoTexture | null) {\n\t\tif (texture) {\n\t\t\tconst is_video = texture.constructor == VideoTexture;\n\t\t\tif (is_video) {\n\t\t\t\tthis._video = texture.image;\n\t\t\t\tif (this._video) {\n\t\t\t\t\tif (!this.params.has_param(FileCopNode.VIDEO_TIME_PARAM_NAME)) {\n\t\t\t\t\t\tconst duration = this._video.duration;\n\n\t\t\t\t\t\tthis.add_param(ParamType.FLOAT, FileCopNode.VIDEO_TIME_PARAM_NAME, '$T', {\n\t\t\t\t\t\t\tspare: true,\n\t\t\t\t\t\t\tcook: true,\n\t\t\t\t\t\t\trange: [0, duration],\n\t\t\t\t\t\t\trange_locked: [true, true],\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tthis.emit(NodeEvent.PARAMS_UPDATED);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._remove_spare_params();\n\t\t\t}\n\t\t} else {\n\t\t\tthis._remove_spare_params();\n\t\t}\n\t}\n\n\tprivate _remove_spare_params() {\n\t\tif (this.params.has_param(FileCopNode.VIDEO_TIME_PARAM_NAME)) {\n\t\t\tthis.params.update_params({names_to_delete: [FileCopNode.VIDEO_TIME_PARAM_NAME]});\n\t\t\t// this.emit(NodeEvent.PARAMS_UPDATED);\n\t\t}\n\t}\n\n\tprivate _param_url_changed(): boolean {\n\t\treturn this._previous_param_url != this.pv.url;\n\t}\n\n\tprivate async _load_texture(url: string) {\n\t\tlet texture: Texture | VideoTexture | null = null;\n\t\tconst param = this.params.get('url');\n\t\tif (url && param) {\n\t\t\tthis._texture_loader = this._texture_loader || new CoreTextureLoader(this, param);\n\t\t\t// const ext = lodash_last(url.split('.')).toLowerCase()\n\t\t\ttry {\n\t\t\t\ttexture = await this._texture_loader.load_texture_from_url_or_op(url);\n\t\t\t} catch (e) {\n\t\t\t\t//console.log('FAIL');\n\t\t\t}\n\t\t\t// if(texture){\n\t\t\t// \tcallback(texture)\n\t\t\t// } else {\n\t\t\tif (!texture) {\n\t\t\t\tthis.states.error.set(`could not load texture '${url}'`);\n\t\t\t}\n\t\t\t// }).catch(error=>{\n\t\t\t// \tthis.self.set_error(`could not load texture ${url} (${error})`);\n\t\t\t// })\n\t\t} else {\n\t\t\tthis.states.error.set('not url given to Mat/Base._load_texture');\n\t\t}\n\t\treturn texture;\n\t}\n}\n","export const CATEGORY_OBJ = {\n\tLIGHT: 'lights',\n\tMANAGER: 'managers',\n\tGEOMETRY: 'geometries',\n\tCAMERA: 'cameras',\n\tMISC: 'misc',\n};\nexport const CATEGORY_COP = {\n\tINPUT: 'inputs',\n\tADVANCED: 'advanced',\n\tMISC: 'misc',\n};\nexport const CATEGORY_EVENT = {\n\tCAMERA: 'cameras',\n\tMISC: 'misc',\n};\nexport const CATEGORY_GL = {\n\tCOLOR: 'color',\n\tCONVERSION: 'conversion',\n\tDYNAMICS: 'dynamics',\n\tGEOMETRY: 'geometry',\n\tGLOBALS: 'globals',\n\tLOGIC: 'logic',\n\tMATH: 'math',\n\tQUAT: 'quat',\n\tTRIGO: 'trigo',\n\tUTIL: 'util',\n\tINSTANCE: 'instance',\n};\nexport const CATEGORY_MAT = {\n\tADVANCED: 'advanced',\n\tMESH: 'meshes',\n\tPOINTS: 'points',\n\tLINE: 'lines',\n\tVOLUME: 'volumes',\n\tINSTANCE: 'instances',\n};\nexport const CATEGORY_SOP = {\n\tADVANCED: 'advanced',\n\tANIMATION: 'animation',\n\tATTRIBUTE: 'attributes',\n\tDYNAMICS: 'dynamics',\n\tINPUT: 'inputs',\n\tMISC: 'misc',\n\tMODIFIER: 'modifiers',\n\tPRIMITIVES: 'primitives',\n\tRENDER: 'render',\n};\nexport const CATEGORY_POST = {\n\tPASS: 'passes',\n};\n","import lodash_trim from 'lodash/trim';\n\nimport {TypedGlNode, BaseGlNodeType} from './_Base';\n// import {BaseNodeGlMathFunctionArg1} from './_BaseMathFunctionArg1';\nimport {ConnectionPointType} from '../utils/connections/ConnectionPointType';\nimport {BaseNamedConnectionPointType} from '../utils/connections/NamedConnectionPoint';\nimport {ParamType} from '../../poly/ParamType';\nimport {ShadersCollectionController} from './code/utils/ShadersCollectionController';\nimport {GlConnectionsController} from './utils/ConnectionsController';\n\nexport const ConnectionPointTypesAvailableForAttribute = [\n\tConnectionPointType.FLOAT,\n\tConnectionPointType.VEC2,\n\tConnectionPointType.VEC3,\n\tConnectionPointType.VEC4,\n];\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nclass AttributeGlParamsConfig extends NodeParamsConfig {\n\tname = ParamConfig.STRING('');\n\ttype = ParamConfig.INTEGER(0, {\n\t\tmenu: {\n\t\t\tentries: ConnectionPointTypesAvailableForAttribute.map((name, i) => {\n\t\t\t\treturn {name: name, value: i};\n\t\t\t}),\n\t\t},\n\t});\n}\nconst ParamsConfig = new AttributeGlParamsConfig();\n\nexport class AttributeGlNode extends TypedGlNode<AttributeGlParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'attribute';\n\t}\n\tstatic readonly INPUT_NAME = 'export';\n\tstatic readonly OUTPUT_NAME = 'val';\n\n\tprivate _on_create_set_name_if_none_bound = this._on_create_set_name_if_none.bind(this);\n\t// private _update_signature_if_required_bound = this._update_signature_if_required.bind(this);\n\tpublic readonly gl_connections_controller: GlConnectionsController = new GlConnectionsController(this);\n\tinitialize_node() {\n\t\tthis.add_post_dirty_hook('_set_mat_to_recompile', this._set_mat_to_recompile_if_is_exporting.bind(this));\n\t\tthis.lifecycle.add_on_create_hook(this._on_create_set_name_if_none_bound);\n\t\tthis.gl_connections_controller.initialize_node();\n\n\t\tthis.gl_connections_controller.set_expected_input_types_function(() => []);\n\t\tthis.gl_connections_controller.set_expected_output_types_function(() => [\n\t\t\tConnectionPointTypesAvailableForAttribute[this.pv.type],\n\t\t]);\n\t\t// this.params.add_on_scene_load_hook('_update_signature_if_required', this._update_signature_if_required_bound);\n\t\t// this.params.set_post_create_params_hook(this._update_signature_if_required_bound);\n\t\t// this.add_post_dirty_hook('_update_signature_if_required', this._update_signature_if_required_bound);\n\t}\n\tcreate_params() {\n\t\tif (this.material_node?.assembler_controller.allow_attribute_exports()) {\n\t\t\tthis.add_param(ParamType.BOOLEAN, 'export_when_connected', 0);\n\t\t}\n\t}\n\t// inputless_params_names(): string[] {\n\t// \treturn ['type'];\n\t// }\n\n\tget input_name() {\n\t\treturn AttributeGlNode.INPUT_NAME;\n\t}\n\tget output_name() {\n\t\treturn AttributeGlNode.OUTPUT_NAME;\n\t}\n\n\t// private create_inputs_from_params() {\n\t// \tif (this.material_node.allow_attribute_exports) {\n\t// \t\t// this.set_named_inputs([new TypedConnectionFloat(AttributeGlNode.input_name())]);\n\t// \t\tthis.io.inputs.set_named_input_connection_points([\n\t// \t\t\tnew TypedNamedConnectionPoint(INPUT_NAME, ConnectionPointTypes[this.pv.type]),\n\t// \t\t]);\n\t// \t\t// this._init_graph_node_inputs();\n\t// \t}\n\t// }\n\n\tset_lines(shaders_collection_controller: ShadersCollectionController) {\n\t\t// if (lines_controller.shader_name) {\n\t\tthis.material_node?.assembler_controller.assembler.set_node_lines_attribute(\n\t\t\tthis,\n\t\t\tshaders_collection_controller\n\t\t);\n\t\t// }\n\t}\n\n\t// update_output_type(constructor) {\n\t// \tconst named_output = new constructor(Attribute.output_name());\n\t// \tthis.set_named_outputs([named_output]);\n\t// }\n\t// update_input_type(constructor) {\n\t// \tconst named_input = new constructor(Attribute.input_name());\n\t// \tthis.set_named_inputs([named_input]);\n\t// \tthis._init_graph_node_inputs();\n\t// }\n\n\tget attribute_name(): string {\n\t\treturn lodash_trim(this.pv.name);\n\t}\n\tgl_type(): ConnectionPointType {\n\t\treturn this.io.outputs.named_output_connection_points[0].type;\n\t}\n\t//\n\t//\n\t// Utility methods for SOP/ParticlesSystemGPU and Assembler/Particles\n\t//\n\t//\n\tconnected_input_node(): BaseGlNodeType | null {\n\t\t// if (this.io.inputs.has_named_inputs) {\n\t\treturn this.io.inputs.named_input(AttributeGlNode.INPUT_NAME);\n\t\t// }\n\t}\n\tconnected_input_connection_point(): BaseNamedConnectionPointType | undefined {\n\t\treturn this.io.inputs.named_input_connection_point(AttributeGlNode.INPUT_NAME);\n\t}\n\t// connected_input(): NamedConnection {\n\t// \tconst connection_point = this.connected_input_connection_point();\n\t// \tif (connection_point) {\n\t// \t\treturn this.io.inputs.named_inputs().filter((ni) => ni.name() == Attribute.input_name())[0];\n\t// \t}\n\t// }\n\toutput_connection_point(): BaseNamedConnectionPointType | undefined {\n\t\t// if (this.io.inputs.has_named_inputs) {\n\t\treturn this.io.outputs.named_output_connection_points_by_name(this.input_name);\n\t\t// }\n\t}\n\t// connected_output(): NamedConnection {\n\t// \tconst output = this.named_output(0);\n\t// \tif (output) {\n\t// \t\treturn output; //this.named_inputs().filter(ni=>ni.name() == Attribute.input_name())[0]\n\t// \t}\n\t// }\n\tget is_importing(): boolean {\n\t\treturn this.io.outputs.used_output_names().length > 0; // TODO: typescript - ensure that we can check that the connected outputs are part of the nodes retrived by the node traverser\n\t}\n\tget is_exporting(): boolean {\n\t\tif (this.pv.export_when_connected) {\n\t\t\tconst input_node = this.io.inputs.named_input(AttributeGlNode.INPUT_NAME);\n\t\t\treturn input_node != null;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\tprivate _set_mat_to_recompile_if_is_exporting() {\n\t\tif (this.is_exporting) {\n\t\t\tthis._set_mat_to_recompile();\n\t\t}\n\t}\n\t//\n\t//\n\t// HOOKS\n\t//\n\t//\n\tprivate _on_create_set_name_if_none() {\n\t\tif (this.pv.name == '') {\n\t\t\tthis.p.name.set(this.name);\n\t\t}\n\t}\n\n\t//\n\t//\n\t// SIGNATURE\n\t//\n\t//\n\t// private _update_signature_if_required(dirty_trigger?: CoreGraphNode) {\n\t// \tif (!this.lifecycle.creation_completed || dirty_trigger == this.p.type) {\n\t// \t\tthis.update_input_and_output_types();\n\t// \t\tthis.remove_dirty_state();\n\t// \t\tthis.make_output_nodes_dirty();\n\t// \t}\n\t// \tthis.material_node?.assembler_controller.set_compilation_required_and_dirty(this);\n\t// }\n\t// private update_input_and_output_types() {\n\t// \tconst set_dirty = false;\n\t// \tthis.io.outputs.set_named_output_connection_points(\n\t// \t\t[new TypedNamedConnectionPoint(this.output_name, ConnectionPointTypesAvailableForAttribute[this.pv.type])],\n\t// \t\tset_dirty\n\t// \t);\n\t// \tif (this.material_node?.assembler_controller.allow_attribute_exports()) {\n\t// \t\tthis.io.inputs.set_named_input_connection_points([\n\t// \t\t\tnew TypedNamedConnectionPoint(this.input_name, ConnectionPointTypesAvailableForAttribute[this.pv.type]),\n\t// \t\t]);\n\t// \t}\n\t// }\n}\n","import {ShaderName} from '../../../utils/shaders/ShaderName';\n\nexport class ShaderConfig {\n\tconstructor(private _name: ShaderName, private _input_names: string[], private _dependencies: ShaderName[]) {}\n\n\tname() {\n\t\treturn this._name;\n\t}\n\tinput_names() {\n\t\treturn this._input_names;\n\t}\n\tdependencies() {\n\t\treturn this._dependencies;\n\t}\n}\n","interface VariableConfigOptions {\n\t// asset refererences\n\tdefault_from_attribute?: boolean;\n\tdefault?: string;\n\tif?: string;\n\tprefix?: string;\n\tsuffix?: string;\n}\n\nexport class VariableConfig {\n\tconstructor(private _name: string, private _options: VariableConfigOptions = {}) {}\n\n\tname() {\n\t\treturn this._name;\n\t}\n\tdefault_from_attribute() {\n\t\treturn this._options['default_from_attribute'] || false;\n\t}\n\tdefault() {\n\t\treturn this._options['default'];\n\t}\n\tif_condition() {\n\t\treturn this._options['if'];\n\t}\n\t// required_definitions(){\n\t// \treturn this._options['required_definitions']\n\t// }\n\tprefix() {\n\t\treturn this._options['prefix'] || '';\n\t}\n\tsuffix() {\n\t\treturn this._options['suffix'] || '';\n\t}\n}\n","import {PolyScene} from '../../../scene/PolyScene';\n// import {JsonExporterVisitor} from './Visitor';\nimport {CoreString} from '../../../../core/String';\nimport {NodeJsonExporterData, NodeJsonExporterUIData} from './Node';\nimport {JsonExportDispatcher} from './Dispatcher';\n\nexport interface SceneJsonExporterData {\n\tproperties?: {\n\t\tframe: number;\n\t\tframe_range: Number2;\n\t\tframe_range_locked: Boolean2;\n\t\t// fps: number;\n\t\tmaster_camera_node_path: string | null;\n\t};\n\troot?: NodeJsonExporterData;\n\tui?: NodeJsonExporterUIData;\n}\n\nexport class SceneJsonExporter {\n\tprivate _data: SceneJsonExporterData = {};\n\tconstructor(private _scene: PolyScene) {}\n\n\tdata(): SceneJsonExporterData {\n\t\tthis._scene.nodes_controller.reset_node_context_signatures();\n\t\tconst root_exporter = JsonExportDispatcher.dispatch_node(this._scene.root);\n\t\tconst nodes_data = root_exporter.data();\n\t\tconst ui_data = root_exporter.ui_data();\n\n\t\tthis._data = {\n\t\t\t// __js_version: this._scene.js_version(),\n\t\t\tproperties: {\n\t\t\t\t// name: this._scene.name(), // this conflicts with saving the name from the admin page\n\t\t\t\tframe: this._scene.frame || 1,\n\t\t\t\tframe_range: this._scene.frame_range,\n\t\t\t\tframe_range_locked: this._scene.time_controller.frame_range_locked,\n\t\t\t\t// fps: this._scene.time_controller.fps,\n\t\t\t\tmaster_camera_node_path: this._scene.cameras_controller.master_camera_node_path,\n\t\t\t},\n\t\t\troot: nodes_data,\n\t\t\tui: ui_data,\n\t\t};\n\n\t\treturn this._data;\n\t}\n\n\tstatic sanitize_string(word: string): string {\n\t\tword = word.replace(/'/g, \"'\"); // escapes ' (used to be with 2 /, but now only one to have Ian's Mediation saved and loaded correctly - but is actually 2 in Code Exporter)\n\t\tword = CoreString.escape_line_breaks(word);\n\t\treturn word;\n\t}\n}\n","import {BaseNodeType} from '../../../nodes/_Base';\nimport {SceneJsonExporter} from './Scene';\n// import {JsonExporterVisitor} from './Visitor';\nimport {NodeContext} from '../../../poly/NodeContext';\nimport {JsonExportDispatcher} from './Dispatcher';\nimport {ParamJsonExporterData} from './Param';\nimport {ParamType} from '../../../poly/ParamType';\n\ninterface NamedInputData {\n\tname: string;\n\tnode: string;\n\toutput: string;\n}\ntype IndexedInputData = string | null;\nexport type InputData = NamedInputData | IndexedInputData;\n\ninterface FlagsData {\n\tbypass?: boolean;\n\tdisplay?: boolean;\n}\n\nexport interface NodeJsonExporterData {\n\ttype: string;\n\tnodes: Dictionary<NodeJsonExporterData>;\n\tchildren_context: NodeContext;\n\tparams?: Dictionary<ParamJsonExporterData<ParamType>>;\n\tinputs?: InputData[];\n\tselection?: string[];\n\tflags?: FlagsData;\n\toverride_clonable_state: boolean;\n}\n\nexport interface NodeJsonExporterUIData {\n\tpos?: Number2;\n\tcomment?: string;\n\tnodes: Dictionary<NodeJsonExporterUIData>;\n}\n\nexport class NodeJsonExporter<T extends BaseNodeType> {\n\tprivate _data: NodeJsonExporterData | undefined; // = {} as NodeJsonExporterData;\n\tconstructor(protected _node: T) {}\n\n\tdata(): NodeJsonExporterData {\n\t\tif (!this.is_root()) {\n\t\t\tthis._node.scene.nodes_controller.register_node_context_signature(this._node);\n\t\t}\n\t\tthis._data = {\n\t\t\ttype: this._node.type,\n\t\t} as NodeJsonExporterData;\n\n\t\t// const required_imports = this._node.required_imports()\n\t\t// if(required_imports){\n\t\t// \tthis._data['required_imports'] = required_imports\n\t\t// }\n\n\t\tconst nodes_data = this.nodes_data();\n\t\tif (Object.keys(nodes_data).length > 0) {\n\t\t\tthis._data['nodes'] = nodes_data;\n\n\t\t\t// required by the Store::Scene::Exporter.rb\n\t\t\tconst context = this._node.children_controller?.context;\n\t\t\tif (context) {\n\t\t\t\tthis._data['children_context'] = context;\n\t\t\t}\n\t\t}\n\n\t\tif (!this.is_root()) {\n\t\t\tthis._data['params'] = this.params_data();\n\t\t\t//data['custom'] = []\n\t\t\tthis._data['inputs'] = this.inputs_data();\n\t\t}\n\n\t\t// TODO: does that create flags automatically? it should not\n\t\tif (this._node.flags) {\n\t\t\tthis._data['flags'] = {};\n\t\t\tif (this._node.flags.has_bypass()) {\n\t\t\t\tif (this._node.flags.bypass?.active) {\n\t\t\t\t\tthis._data['flags']['bypass'] = this._node.flags.bypass.active;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this._node.flags.has_display()) {\n\t\t\t\tthis._data['flags']['display'] = this._node.flags.display?.active;\n\t\t\t}\n\t\t}\n\n\t\tif (this._node.children_allowed()) {\n\t\t\tconst selection = this._node.children_controller?.selection;\n\t\t\tif (selection && this._node.children().length > 0) {\n\t\t\t\t// only save the nodes that are still present, in case the selection just got deleted\n\t\t\t\tconst selected_children: BaseNodeType[] = [];\n\t\t\t\tconst selected_ids: Dictionary<boolean> = {};\n\t\t\t\tfor (let selected_node of selection.nodes()) {\n\t\t\t\t\tselected_ids[selected_node.graph_node_id] = true;\n\t\t\t\t}\n\t\t\t\tfor (let child of this._node.children()) {\n\t\t\t\t\tif (child.graph_node_id in selected_ids) {\n\t\t\t\t\t\tselected_children.push(child);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis._data['selection'] = selected_children.map((n) => n.name);\n\t\t\t}\n\t\t}\n\n\t\t// inputs clone\n\t\tif (this._node.io.inputs.override_clonable_state_allowed()) {\n\t\t\tconst override = this._node.io.inputs.override_clonable_state();\n\t\t\tif (override) {\n\t\t\t\tthis._data['override_clonable_state'] = override;\n\t\t\t}\n\t\t}\n\n\t\t// custom\n\t\tthis.add_custom();\n\n\t\treturn this._data;\n\t}\n\n\tui_data(): NodeJsonExporterUIData {\n\t\tconst data: NodeJsonExporterUIData = {} as NodeJsonExporterUIData;\n\t\tif (!this.is_root()) {\n\t\t\tconst ui_data = this._node.ui_data;\n\t\t\tdata['pos'] = ui_data.position.toArray() as Number2;\n\t\t\tconst comment = ui_data.comment;\n\t\t\tif (comment) {\n\t\t\t\tdata['comment'] = SceneJsonExporter.sanitize_string(comment);\n\t\t\t}\n\t\t}\n\t\tconst children = this._node.children();\n\t\tif (children.length > 0) {\n\t\t\tdata['nodes'] = {};\n\t\t\tchildren.forEach((child) => {\n\t\t\t\tconst node_exporter = JsonExportDispatcher.dispatch_node(child); //.visit(JsonExporterVisitor); //.json_exporter()\n\t\t\t\tdata['nodes'][child.name] = node_exporter.ui_data();\n\t\t\t});\n\t\t}\n\n\t\treturn data;\n\t}\n\n\tprivate is_root() {\n\t\treturn this._node.parent === null && this._node.graph_node_id == this._node.root.graph_node_id;\n\t}\n\n\tprotected inputs_data() {\n\t\tconst data: InputData[] = [];\n\t\t// Object.keys(this._node.io.inputs.inputs()).forEach((input_index) => {\n\t\tthis._node.io.inputs.inputs().forEach((input, input_index) => {\n\t\t\t// const input = this._node.io.inputs.input(input_index);\n\t\t\tif (input) {\n\t\t\t\t// const connection_point = this._node.io.inputs.named_input_connection_points;\n\t\t\t\tconst connection = this._node.io.connections.input_connection(input_index)!;\n\t\t\t\tif (this._node.io.inputs.has_named_inputs) {\n\t\t\t\t\tconst input_name = this._node.io.inputs.named_input_connection_points[input_index].name;\n\t\t\t\t\t// const output_index = input_connections[input_index].output_index();\n\t\t\t\t\tconst output_index = connection.output_index;\n\t\t\t\t\tconst output_name = input.io.outputs.named_output_connection_points[output_index].name;\n\t\t\t\t\tdata.push({name: input_name, node: input.name, output: output_name});\n\t\t\t\t} else {\n\t\t\t\t\tdata.push(input.name);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn data;\n\t}\n\n\tprotected params_data() {\n\t\tconst data: Dictionary<ParamJsonExporterData<ParamType>> = {};\n\n\t\tfor (let param_name of this._node.params.names) {\n\t\t\tconst param = this._node.params.get(param_name);\n\t\t\tif (param && !param.parent_param) {\n\t\t\t\tconst param_exporter = JsonExportDispatcher.dispatch_param(param); //.visit(JsonExporterVisitor); //.json_exporter()\n\t\t\t\tif (param_exporter.required) {\n\t\t\t\t\tconst params_data = param_exporter.data();\n\t\t\t\t\tdata[param.name] = params_data;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn data;\n\t}\n\n\tprotected nodes_data() {\n\t\tconst data: Dictionary<NodeJsonExporterData> = {};\n\t\tfor (let child of this._node.children()) {\n\t\t\tconst node_exporter = JsonExportDispatcher.dispatch_node(child); //.json_exporter()\n\t\t\tdata[child.name] = node_exporter.data();\n\t\t}\n\t\treturn data;\n\t}\n\n\tprotected add_custom() {}\n}\n","// import lodash_isArray from 'lodash/isArray'\n// import lodash_isString from 'lodash/isString'\nimport {BaseParamType} from '../../../params/_Base';\nimport {ParamType} from '../../../poly/ParamType';\nimport {ParamInitValueSerializedTypeMap} from '../../../params/types/ParamInitValueSerializedTypeMap';\n\nimport {ParamOptions} from '../../../params/utils/OptionsController';\n\ntype OverridenOptions = Dictionary<string>;\n\nexport type SimpleParamJsonExporterData<T extends ParamType> = ParamInitValueSerializedTypeMap[T];\n\nexport interface ComplexParamJsonExporterData<T extends ParamType> {\n\ttype?: T;\n\tdefault_value?: ParamInitValueSerializedTypeMap[T];\n\traw_input?: ParamInitValueSerializedTypeMap[T];\n\toptions?: ParamOptions;\n\toverriden_options?: OverridenOptions;\n\t// components?: ParamJsonExporterDataByName;\n\t// expression?: string;\n}\nexport type ParamJsonExporterData<T extends ParamType> =\n\t| SimpleParamJsonExporterData<T>\n\t| ComplexParamJsonExporterData<T>;\nexport type ParamJsonExporterDataByName = Dictionary<ParamJsonExporterData<ParamType>>;\n\nexport class ParamJsonExporter<T extends BaseParamType> {\n\t// protected _simple_data: SimpleParamJsonExporterData<ParamType>=0;\n\tprotected _complex_data: ComplexParamJsonExporterData<ParamType> = {};\n\tconstructor(protected _param: T) {}\n\n\tget required(): boolean {\n\t\tconst is_spare_and_not_component = this._param.options.is_spare && !this._param.parent_param;\n\n\t\t// we should not need to check if it has an expression anymore,\n\t\t// as it could have an expression AND be of default value\n\t\tconst value_changed = !this._param.is_default; //|| this._param.has_expression();\n\t\t// const referencing_asset = this._param.is_referencing_asset()\n\t\treturn is_spare_and_not_component || value_changed; // || referencing_asset\n\t}\n\n\tdata() {\n\t\tif (this._param.parent_param) {\n\t\t\tconsole.warn('no component should be saved');\n\t\t\tthrow 'no component should be saved';\n\t\t}\n\n\t\tif (this._require_data_complex()) {\n\t\t\treturn this._data_complex();\n\t\t} else {\n\t\t\treturn this._data_simple();\n\t\t}\n\t}\n\n\tprivate _data_simple() {\n\t\treturn this._param.raw_input_serialized;\n\t}\n\n\tprivate _data_complex() {\n\t\tthis._complex_data = {};\n\n\t\tif (this._param.options.is_spare && !this._param.parent_param) {\n\t\t\tthis._complex_data['type'] = this._param.type;\n\t\t\tthis._complex_data['default_value'] = this._param.default_value_serialized;\n\t\t\tthis._complex_data['raw_input'] = this._param.raw_input_serialized;\n\t\t\tthis._complex_data['options'] = this._param.options.current;\n\t\t}\n\n\t\tif (!this._param.is_default) {\n\t\t\tthis.add_main();\n\t\t}\n\n\t\t// if(this._param.is_referencing_asset()){\n\t\t// \t// console.log(\"this._param.is_referencing_asset()\", this._param.is_referencing_asset())\n\t\t// \tthis._data['referenced_asset'] = this._param.referenced_asset()\n\t\t// }\n\n\t\tif (this._param.options.has_options_overridden) {\n\t\t\tconst overridden_options: OverridenOptions = {};\n\t\t\tconst options_overridden = this._param.options.overridden_options;\n\t\t\tfor (let option_name of Object.keys(options_overridden)) {\n\t\t\t\tconst option_value = options_overridden[option_name as keyof ParamOptions];\n\t\t\t\toverridden_options[option_name] = JSON.stringify(option_value);\n\t\t\t}\n\t\t\tthis._complex_data['overriden_options'] = overridden_options;\n\t\t}\n\t\treturn this._complex_data;\n\t}\n\n\tprotected _require_data_complex() {\n\t\tif (this._param.options.is_spare) {\n\t\t\treturn true;\n\t\t}\n\t\tif (this._param.options.has_options_overridden) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t// default_value(): ParamValueSerialized {\n\t// \treturn this._param.default_value_serialized;\n\t// }\n\n\t// cannot remember why this is useful, but it messes up\n\t// with gl nodes like the noise node, as the default value\n\t// gets saved as a string '[1,1]' instead of an array [1,1] (should be without quotes)\n\t// protected default_value(){\n\t// \tlet default_value = this._param.default_value()\n\t// \tif(lodash_isString(default_value)){\n\t// \t\tdefault_value = `'${default_value}'`\n\t// \t}\n\t// \tif (lodash_isArray(default_value)){\n\t// \t\tdefault_value = `[${default_value}]`\n\t// \t}\n\t// \treturn default_value\n\t// }\n\n\tprotected add_main() {}\n}\n","import {ParamJsonExporter} from '../Param';\nimport {TypedNumericParam} from '../../../../params/_Numeric';\nimport {ParamType} from '../../../../poly/ParamType';\n\nexport class ParamNumericJsonExporter extends ParamJsonExporter<TypedNumericParam<ParamType>> {\n\tadd_main() {\n\t\t// if (this._param.has_expression() && this._param.expression_controller?.expression) {\n\t\t// \t// const escaped_expression = this._param.expression().replace(/'/g, \"\\\\'\");\n\t\t// \tthis._data['expression'] = this._param.expression_controller?.expression;\n\t\t// } else {\n\t\tif (this._require_data_complex()) {\n\t\t\tthis._complex_data['raw_input'] = this._param.raw_input_serialized;\n\t\t} else {\n\t\t\treturn this._param.raw_input_serialized;\n\t\t}\n\t\t// }\n\t}\n}\n","import {ParamJsonExporter} from '../Param';\nimport {OperatorPathParam} from '../../../../params/OperatorPath';\nimport {SceneJsonExporter} from '../Scene';\n\nexport class ParamOperatorPathJsonExporter extends ParamJsonExporter<OperatorPathParam> {\n\tadd_main() {\n\t\tlet val = this._param.raw_input;\n\t\t// val = val.replace(/'/g, \"\\\\'\");\n\t\tval = SceneJsonExporter.sanitize_string(val);\n\n\t\tif (this._require_data_complex()) {\n\t\t\tthis._complex_data['raw_input'] = val;\n\t\t} else {\n\t\t\treturn val;\n\t\t}\n\t}\n}\n","// import lodash_isString from 'lodash/isString'\nimport {ParamJsonExporter} from '../Param';\nimport {SceneJsonExporter} from '../Scene';\nimport {StringParam} from '../../../../params/String';\n\nexport class ParamStringJsonExporter extends ParamJsonExporter<StringParam> {\n\tadd_main() {\n\t\t// let val = this._param.input_value();\n\t\tlet val = this._param.raw_input;\n\t\t// if (lodash_isString(val)){\n\t\tval = SceneJsonExporter.sanitize_string(val);\n\t\t// }\n\t\tif (this._require_data_complex()) {\n\t\t\tthis._complex_data['raw_input'] = val;\n\t\t} else {\n\t\t\treturn val;\n\t\t}\n\t}\n}\n","import {ParamJsonExporter} from '../Param';\nimport {RampParam} from '../../../../params/Ramp';\n\nexport class ParamRampJsonExporter extends ParamJsonExporter<RampParam> {\n\tadd_main() {\n\t\tif (this._require_data_complex()) {\n\t\t\tthis._complex_data['raw_input'] = this._param.raw_input_serialized;\n\t\t} else {\n\t\t\treturn this._param.raw_input_serialized;\n\t\t}\n\t}\n}\n","import {BaseNodeType} from '../../../nodes/_Base';\nimport {BaseParamType} from '../../../params/_Base';\n\nimport {NodeJsonExporter} from './Node';\n// import {BaseNodeObjJsonExporter} from './node/Obj';\n// import {BaseNodeSopSubnetworkJsonExporter} from './node/Subnetwork';\n\nimport {ParamJsonExporter} from './Param';\n// import {ParamMultipleJsonExporter} from './param/Multiple';\nimport {ParamNumericJsonExporter} from './param/Numeric';\nimport {ParamOperatorPathJsonExporter} from './param/OperatorPath';\nimport {ParamStringJsonExporter} from './param/String';\nimport {ParamRampJsonExporter} from './param/Ramp';\n// import {TypedObjNode} from '../../../nodes/obj/_Base';\n// import {TypedMultipleParam} from '../../../params/_Multiple';\nimport {TypedNumericParam} from '../../../params/_Numeric';\nimport {OperatorPathParam} from '../../../params/OperatorPath';\nimport {StringParam} from '../../../params/String';\nimport {RampParam} from '../../../params/Ramp';\n\nexport class JsonExportDispatcher {\n\tstatic dispatch_node(node: BaseNodeType) {\n\t\t// if (node instanceof TypedObjNode) {\n\t\t// \treturn new BaseNodeObjJsonExporter(node);\n\t\t// }\n\t\treturn new NodeJsonExporter(node);\n\t}\n\n\tstatic dispatch_param(param: BaseParamType) {\n\t\t// if (param instanceof TypedMultipleParam) {\n\t\t// \treturn new ParamMultipleJsonExporter(param);\n\t\t// }\n\t\tif (param instanceof TypedNumericParam) {\n\t\t\treturn new ParamNumericJsonExporter(param);\n\t\t}\n\t\tif (param instanceof OperatorPathParam) {\n\t\t\treturn new ParamOperatorPathJsonExporter(param);\n\t\t}\n\t\tif (param instanceof StringParam) {\n\t\t\treturn new ParamStringJsonExporter(param);\n\t\t}\n\t\tif (param instanceof RampParam) {\n\t\t\treturn new ParamRampJsonExporter(param);\n\t\t}\n\t\treturn new ParamJsonExporter(param);\n\t}\n}\n","import lodash_merge from 'lodash/merge';\nimport lodash_intersection from 'lodash/intersection';\nimport lodash_difference from 'lodash/difference';\nimport {Vector2} from 'three/src/math/Vector2';\nimport {BaseNodeType, TypedNode} from '../../_Base';\n\nimport {BaseGlShaderAssembler} from './assemblers/_Base';\nimport {GlobalsBaseController} from './globals/_Base';\nimport {GlobalsGeometryHandler} from './globals/Geometry';\n\nimport {JsonExportDispatcher} from '../../../io/json/export/Dispatcher';\n// import {NodeEvent} from '../../../poly/NodeEvent';\nimport {OutputGlNode} from '../Output';\nimport {GlobalsGlNode} from '../Globals';\n// import {BaseParamType} from '../../../params/_Base';\nimport {ParamJsonExporterData} from '../../../io/json/export/Param';\nimport {GlNodeChildrenMap} from '../../../poly/registers/Gl';\nimport {BaseGlNodeType} from '../_Base';\nimport {ParamType} from '../../../poly/ParamType';\nimport {ParamsUpdateOptions} from '../../utils/params/ParamsController';\n\n// interface BaseShaderAssemblerConstructor {\n// \tnew (): BaseGlShaderAssembler;\n// }\n// interface GlobalsBaseControllerConstructor {\n// \tnew (): GlobalsBaseController;\n// }\n\n// export function AssemblerOwner<TBase extends Constructor>(Base: TBase) {\n// \treturn class Mixin extends Base {\n// \t\tprotected self: BaseNode = (<unknown>this) as BaseNode;\n// \t\tchildren_context() {\n// \t\t\treturn NodeContext.GL;\n// \t\t}\n\nexport class AssemblerControllerNode extends TypedNode<any, BaseNodeType, any> {\n\tcreate_node<K extends keyof GlNodeChildrenMap>(type: K): GlNodeChildrenMap[K] {\n\t\treturn super.create_node(type) as GlNodeChildrenMap[K];\n\t}\n\tchildren() {\n\t\treturn super.children() as BaseGlNodeType[];\n\t}\n\tnodes_by_type<K extends keyof GlNodeChildrenMap>(type: K): GlNodeChildrenMap[K][] {\n\t\treturn super.nodes_by_type(type) as GlNodeChildrenMap[K][];\n\t}\n\n\tassembler_controller!: GlAssemblerController<BaseGlShaderAssembler>;\n\t// set_compilation_required_and_dirty() {\n\t// \tthis.assembler_controller.set_compilation_required_and_dirty();\n\t// }\n}\n\ntype BaseGlShaderAssemblerConstructor<A extends BaseGlShaderAssembler> = new (...args: any[]) => A;\nexport class GlAssemblerController<A extends BaseGlShaderAssembler> {\n\tprotected _assembler!: A;\n\tprivate _globals_handler: GlobalsBaseController | undefined = new GlobalsGeometryHandler();\n\tprivate _compile_required: boolean = true;\n\t// private _requester: BaseNodeSop;\n\t// private _recompiled: boolean = false;\n\t// private _shaders_by_name: Map<ShaderName, string> = new Map();\n\n\tprivate _deleted_params_data: Map<string, ParamJsonExporterData<ParamType>> = new Map();\n\t// private _new_params: BaseParamType[] = [];\n\n\tconstructor(private node: AssemblerControllerNode, assembler_class: BaseGlShaderAssemblerConstructor<A>) {\n\t\t// if (assembler_class) {\n\t\tthis._assembler = new assembler_class(this.node);\n\t\t// }\n\t\t// this._shadow_depth_assembler = new ShaderAssemblerDepth()\n\t\t// this._shadow_distance_assembler = new ShaderAssemblerDistance()\n\n\t\t// this.self._init_hierarchy_children_owner();\n\n\t\t// let has_display_flag = false;\n\t\t// if (options['has_display_flag']) {\n\t\t// \thas_display_flag = options['has_display_flag'];\n\t\t// }\n\n\t\t// this.self._init_display_flag({\n\t\t// \thas_display_flag: has_display_flag,\n\t\t// \tmultiple_display_flags_allowed: false,\n\t\t// \taffects_hierarchy: true,\n\t\t// });\n\n\t\t// this ensures that material re evaluate their uniforms\n\t\t// without having the SOP/Material recook\n\t\t// which can be a killer in an animation\n\t\t// But this should be tweaked so that it can recook all params of a node\n\t\t// this.self.add_post_dirty_hook(this.eval_params_and_assign_uniform_values.bind(this))\n\t\t// - UPDATE: this seems to work at the moment. The only issue is that\n\t\t// the particle system now updates 2x when recreating the shaders\n\t\t// but that's fixed with update_on_dirty\n\t\t// - UPDATE 2: now that the params have been refactored, let's try without this\n\t\t// if (options['update_on_dirty'] != false) {\n\t\t// \tthis.self.add_post_dirty_hook(this.cook_main_if_scene_loaded.bind(this));\n\t\t// }\n\t}\n\tset_assembler_globals_handler(globals_handler: GlobalsBaseController) {\n\t\tconst current_id = this._globals_handler ? this._globals_handler.id() : null;\n\t\tconst new_id = globals_handler ? globals_handler.id() : null;\n\n\t\tif (current_id != new_id) {\n\t\t\tthis._globals_handler = globals_handler;\n\t\t\tthis.set_compilation_required_and_dirty();\n\t\t\tthis._assembler.reset_configs();\n\t\t}\n\t}\n\tget assembler() {\n\t\treturn this._assembler;\n\t}\n\t// get shaders_by_name() {\n\t// \treturn this._shaders_by_name;\n\t// }\n\tget globals_handler() {\n\t\treturn this._globals_handler;\n\t}\n\n\t// gltf_supported_material() {\n\t// \treturn this._assembler.constructor.convert_material_to_gltf_supported(this._material);\n\t// }\n\n\tadd_output_params(output_child: OutputGlNode) {\n\t\tthis._assembler.add_output_params(output_child);\n\t}\n\tadd_globals_params(globals_node: GlobalsGlNode) {\n\t\tthis._assembler.add_globals_params(globals_node);\n\t}\n\tallow_attribute_exports() {\n\t\treturn this._assembler.allow_attribute_exports();\n\t}\n\n\ton_create() {\n\t\tconst globals = this.node.create_node('globals');\n\t\tconst output = this.node.create_node('output');\n\n\t\tglobals.ui_data.set_position(new Vector2(-200, 0));\n\t\toutput.ui_data.set_position(new Vector2(200, 0));\n\t}\n\n\t// async compile_if_required() {\n\t// \t// this._recompiled = false;\n\t// \tif (this.compile_required()) {\n\t// \t\t// && !this._param_locked){\n\t// \t\tconst new_material = await this.run_assembler();\n\t// \t\tif (new_material) {\n\t// \t\t\tawait this.node.params.eval_params(this._new_params);\n\t// \t\t\tthis._material = new_material;\n\t// \t\t\t// this._recompiled = true;\n\t// \t\t} else {\n\t// \t\t\tconsole.error(`${this.node.full_path()} failed to generate a material`);\n\t// \t\t}\n\t// \t}\n\t// \tawait this.assign_uniform_values();\n\t// }\n\tset_compilation_required(new_state = true) {\n\t\tthis._compile_required = new_state;\n\t}\n\tset_compilation_required_and_dirty(trigger_node?: BaseGlNodeType) {\n\t\tthis.set_compilation_required();\n\t\tthis.node.set_dirty(trigger_node);\n\t}\n\tcompile_required(): boolean {\n\t\treturn this._compile_required;\n\t}\n\n\t// set_root_nodes(nodes: BaseGlNodeType[]) {\n\t// \tthis.assembler.set_root_nodes(nodes);\n\t// }\n\t// set_node_lines_globals(globals_node: GlobalsGlNode, shader_name: ShaderName) {\n\t// \tthis.assembler.set_node_lines_globals(globals_node, shader_name);\n\t// }\n\t// set_node_lines_output(output_node: OutputGlNode, shader_name: ShaderName) {\n\t// \tthis.assembler.set_node_lines_output(output_node, shader_name);\n\t// }\n\t// set_node_lines_attribute(attribute_node: AttributeGlNode, shader_name: ShaderName) {\n\t// \tthis.assembler.set_node_lines_attribute(attribute_node, shader_name);\n\t// }\n\n\tasync post_compile() {\n\t\t// if (!this.compile_required()) {\n\t\t// \treturn;\n\t\t// }\n\t\t// this.assembler.compile_for_node(this._gl);\n\t\tthis.create_spare_parameters();\n\t\tthis.set_compilation_required(false);\n\t}\n\n\t// private async run_assembler() {\n\t// \tconst output_node = this.find_output_node();\n\t// \tif (output_node) {\n\t// \t\tthis._assembler.set_root_nodes([output_node]);\n\t// \t}\n\t// \tthis.assembler.compile();\n\t// \tconst material = await this._assembler.get_material();\n\t// \tif (material) {\n\t// \t\tthis._shaders_by_name.set(ShaderName.VERTEX, material.vertexShader);\n\t// \t\tthis._shaders_by_name.set(ShaderName.FRAGMENT, material.fragmentShader);\n\n\t// \t\t// assign custom materials\n\t// \t\tconst custom_materials = await this._assembler.get_custom_materials();\n\t// \t\tconst material_with_custom_materials = material as ShaderMaterialWithCustomMaterials;\n\t// \t\tmaterial_with_custom_materials.custom_materials = {};\n\t// \t\tcustom_materials.forEach((custom_material, shader_name) => {\n\t// \t\t\tmaterial_with_custom_materials.custom_materials[shader_name] = custom_material;\n\t// \t\t});\n\n\t// \t\tmaterial.needsUpdate = true;\n\t// \t}\n\n\t// \tthis.create_spare_parameters();\n\n\t// \tthis._compile_required = false;\n\t// \treturn material;\n\t// }\n\n\t// find_output_node() {\n\t// \tconst nodes = this.node.nodes_by_type('output');\n\t// \tif (nodes.length > 1) {\n\t// \t\tthis.node.states.error.set('only one output node allowed');\n\t// \t}\n\t// \treturn nodes[0];\n\t// }\n\t// find_attribute_export_nodes() {\n\t// \tconst nodes = this.node.nodes_by_type('attribute');\n\t// \treturn nodes.filter((node) => {\n\t// \t\t// do not use attributes that are used as an input, as export\n\t// \t\t// return (node.used_output_names().length == 0) &&\n\t// \t\treturn node.is_exporting;\n\t// \t});\n\t// }\n\t// add_output_body_line(output_node, shader_name: ShaderName, input_name: string){\n\t// \tconst input = output_node.named_input(input_name)\n\t// \tconst var_input = output_node.variable_for_input(input_name)\n\t// \tconst variable_config = this.variable_config(input_name)\n\t// \tconst default_value = variable_config.default()\n\t// \tconst prefix = variable_config.prefix()\n\t// \tconst suffix = variable_config.suffix()\n\t// \tconst new_var = input ? ThreeToGl.vector3(var_input) : default_value\n\t// \tif(new_var){\n\t// \t\toutput_node.add_body_lines([`${prefix}${new_var}${suffix}`], shader_name)\n\t// \t}\n\t// }\n\t// set_output_node_lines(output_node){\n\t// \tfor(let shader_name of this.shader_names()){\n\t// \t\tconst body_lines = []\n\t// \t\tconst input_names = this.shader_config(shader_name).input_names()\n\t// \t\toutput_node.set_body_lines([], shader_name)\n\t// \t\tif(input_names){\n\t// \t\t\tfor(let input_name of input_names){\n\t// \t\t\t\tthis.add_output_body_line(output_node, shader_name, input_name)\n\n\t// \t\t\t}\n\t// \t\t}\n\t// \t}\n\n\t// \t// const vertex_body_lines = []\n\t// \t// const fragment_body_lines = []\n\n\t// \t// const named_input_position = this.named_input('position')\n\t// \t// const named_input_point_size = this.named_input('gl_PointSize')\n\t// \t// const named_input_normal = this.named_input('normal')\n\n\t// \t// const var_position = this.variable_for_input('position')\n\t// \t// const var_normal = this.variable_for_input('normal')\n\t// \t// const color = this.variable_for_input('color')\n\t// \t// const alpha = this.variable_for_input('alpha')\n\t// \t// const var_point_size = this.variable_for_input('gl_PointSize')\n\n\t// \t// fragment_body_lines.push( `${this._color_declaration} = ${ThreeToGl.vector3_float(color, alpha)}` )\n\t// \t// this.set_fragment_body_lines(fragment_body_lines)\n\n\t// \t// const new_position_var = named_input_position ? ThreeToGl.vector3(var_position) : 'vec3( position )'\n\t// \t// vertex_body_lines.push( `vec3 transformed = ${new_position_var}` )\n\n\t// \t// if(this.parent().is_point_material()){\n\t// \t// \tconst new_point_size_var = named_input_point_size ? ThreeToGl.float(var_point_size) : '1.0'\n\t// \t// \tvertex_body_lines.push( `float size2 = size * ${new_point_size_var}` )\n\t// \t// }\n\n\t// \t// if(named_input_normal){\n\t// \t// \tconst new_normal_var = ThreeToGl.vector3(var_normal)\n\t// \t// \tvertex_body_lines.push(`objectNormal = ${new_normal_var}`)\n\t// \t// }\n\n\t// \t// this.set_vertex_body_lines(vertex_body_lines)\n\t// \t// this.set_fragment_body_lines(fragment_body_lines)\n\t// }\n\t// private async eval_params_and_assign_uniform_values() {\n\t// \tif (!this.self.scene().loaded()) {\n\t// \t\treturn;\n\t// \t}\n\n\t// \tif (this._assembler) {\n\t// \t\tawait this.self.eval_all_params();\n\t// \t\tawait this.assign_uniform_values();\n\t// \t}\n\t// }\n\t// private async cook_main_if_scene_loaded() {\n\t// \tif (!this.self.scene().loaded()) {\n\t// \t\treturn;\n\t// \t}\n\t// \tif (this.self.params_referree().length > 0) {\n\t// \t\tawait this.self.cook_main();\n\t// \t}\n\t// \t// this.cook_main_without_inputs()\n\t// }\n\tasync assign_uniform_values() {\n\t\tif (this._assembler) {\n\t\t\tfor (let param_config of this._assembler.param_configs()) {\n\t\t\t\tawait param_config.set_uniform_value(this.node);\n\t\t\t}\n\t\t}\n\t}\n\n\t// process_uniforms(renderer, display_scene, camera, geometry, material, group) {\n\t// \tconst scene_frame = this.scene().frame()\n\n\t// \tconst material_frame = material.uniforms.frame\n\t// \tif(material_frame){ // check needed in case this method is given a post process material\n\t// \t\tmaterial.uniforms.frame.value = scene_frame\n\t// \t}\n\n\t// \tconst custom_materials = material.custom_materials\n\t// \tif(custom_materials){\n\t// \t\tfor(let custom_material_name of Object.keys(custom_materials)){\n\t// \t\t\tconst custom_material = custom_materials[custom_material_name]\n\t// \t\t\tcustom_material.uniforms.frame.value = scene_frame\n\t// \t\t}\n\t// \t}\n\t// }\n\n\t// create_material(){\n\t// \tconst template_shader = THREE.ShaderLib.basic\n\n\t// \tconst uniforms = THREE.UniformsUtils.clone( template_shader.uniforms )\n\t// \t// uniforms['frame'] = {\n\t// \t// \ttype: '1f',\n\t// \t// \tvalue: 1\n\t// \t// }\n\n\t// \tconst material = new THREE.ShaderMaterial({\n\t// \t\t// vertexColors: THREE.VertexColors,\n\t// \t\t// side: THREE.FrontSide,\n\t// \t\t// transparent: true,\n\t// \t\t// fog: true,\n\t// \t\t// lights: false,\n\t// \t\tuniforms: uniforms,\n\t// \t\tvertexShader: template_shader.vertexShader,\n\t// \t\tfragmentShader: template_shader.fragmentShader\n\t// \t})\n\t// \tthrow \"wtf\"\n\t// \treturn material\n\t// }\n\tcreate_spare_parameters() {\n\t\tconst current_spare_param_names: string[] = this.node.params.spare_names;\n\t\tconst param_configs = this._assembler.param_configs();\n\t\tconst assembler_param_names = param_configs.map((c) => c.name);\n\t\t// TODO: also remove the params that change type\n\t\tconst spare_param_names_to_add = lodash_difference(assembler_param_names, current_spare_param_names);\n\t\tconst spare_param_names_to_remove = lodash_difference(current_spare_param_names, assembler_param_names);\n\t\t// this._new_params = [];\n\t\tconst params_update_options: ParamsUpdateOptions = {};\n\n\t\t// check that param_names_to_add does not include any currently existing param names (that are not spare)\n\t\tconst current_param_names = this.node.params.names;\n\t\tconst spare_params_with_same_name_as_params = lodash_intersection(\n\t\t\tspare_param_names_to_add,\n\t\t\tcurrent_param_names\n\t\t);\n\t\tif (spare_params_with_same_name_as_params.length > 0) {\n\t\t\tconst error_message = `${this.node.full_path()} attempts to create spare params called '${spare_params_with_same_name_as_params.join(\n\t\t\t\t', '\n\t\t\t)}' with same name as params`;\n\t\t\tconsole.warn(error_message);\n\t\t\tthis.node.states.error.set(error_message);\n\t\t}\n\n\t\tspare_param_names_to_remove.forEach((param_name) => {\n\t\t\t// store the param data, in case it gets recreated later\n\t\t\t// this allows expressions to be kept in memory\n\t\t\tconst param = this.node.params.get(param_name);\n\t\t\tif (param) {\n\t\t\t\tconst param_exporter = JsonExportDispatcher.dispatch_param(param);\n\t\t\t\tif (param_exporter.required) {\n\t\t\t\t\tconst params_data = param_exporter.data();\n\t\t\t\t\tthis._deleted_params_data.set(param.name, params_data);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tparams_update_options.names_to_delete = params_update_options.names_to_delete || [];\n\t\t\tparams_update_options.names_to_delete.push(param_name);\n\t\t});\n\n\t\t// this.within_param_folder('spare_params', () => {\n\t\tfor (let param_config of param_configs) {\n\t\t\tif (spare_param_names_to_add.indexOf(param_config.name) >= 0) {\n\t\t\t\t// TODO: shouldn't it be cook: false ??\n\t\t\t\t// as there is no need to cook the node if I'm only changing the uniform\n\t\t\t\t// unless maybe for textures?\n\t\t\t\t// but if cook is false, there is no reason for it to be updated\n\t\t\t\tconst options = lodash_merge(param_config.param_options, {spare: true, cook: true});\n\n\t\t\t\t// const param = this.node.add_param(\n\t\t\t\t// \tparam_config.type,\n\t\t\t\t// \tparam_config.name,\n\t\t\t\t// \tparam_config.default_value,\n\t\t\t\t// \toptions\n\t\t\t\t// );\n\t\t\t\tparams_update_options.to_add = params_update_options.to_add || [];\n\t\t\t\tparams_update_options.to_add.push({\n\t\t\t\t\tname: param_config.name,\n\t\t\t\t\ttype: param_config.type,\n\t\t\t\t\tinit_value: param_config.default_value as any,\n\t\t\t\t\toptions: options,\n\t\t\t\t});\n\n\t\t\t\t// if (param) {\n\t\t\t\t// \t// restore saved state, like expressions\n\t\t\t\t// \tconst param_data = this._deleted_params_data.get(param.name);\n\t\t\t\t// \tif (param_data) {\n\t\t\t\t// \t\t// TODO: typescript\n\t\t\t\t// \t\t// JsonImportDispatcher.dispatch_param(param).process_data(param_data);\n\t\t\t\t// \t\t// looks like there are still some cases where the expression are not recreated\n\t\t\t\t// \t\t// so commenting this out now\n\t\t\t\t// \t\t// delete this._deleted_params_data[param.name()]\n\t\t\t\t// \t}\n\n\t\t\t\t// \tthis._new_params.push(param);\n\t\t\t\t// }\n\t\t\t}\n\t\t}\n\n\t\tthis.node.params.update_params(params_update_options);\n\t\t// if (spare_param_names_to_add.length > 0 || spare_param_names_to_remove.length > 0) {\n\t\t// \tthis.node.params.post_create_spare_params();\n\t\t// \tthis.node.emit(NodeEvent.PARAMS_UPDATED);\n\t\t// }\n\t}\n}\n","export enum LineType {\n\tFUNCTION_DECLARATION = 'function_declaration',\n\tDEFINE = 'define',\n\tBODY = 'body',\n}\n","import {ShaderName} from '../../../utils/shaders/ShaderName';\nimport {BaseGLDefinition} from '../../utils/GLDefinition';\nimport {BaseGlNodeType} from '../../_Base';\nimport {MapUtils} from '../../../../../core/MapUtils';\n\nexport class LinesController {\n\tprivate _definitions_by_node_id: Map<string, BaseGLDefinition[]> = new Map();\n\tprivate _body_lines_by_node_id: Map<string, string[]> = new Map();\n\n\tconstructor(private _shader_name: ShaderName) {}\n\n\tget shader_name() {\n\t\treturn this._shader_name;\n\t}\n\n\tadd_definitions(node: BaseGlNodeType, definitions: BaseGLDefinition[]) {\n\t\tfor (let definition of definitions) {\n\t\t\tMapUtils.push_on_array_at_entry(this._definitions_by_node_id, node.graph_node_id, definition);\n\t\t}\n\t}\n\tdefinitions(node: BaseGlNodeType): BaseGLDefinition[] | undefined {\n\t\treturn this._definitions_by_node_id.get(node.graph_node_id);\n\t}\n\n\tadd_body_lines(node: BaseGlNodeType, lines: string[]) {\n\t\tfor (let line of lines) {\n\t\t\tMapUtils.push_on_array_at_entry(this._body_lines_by_node_id, node.graph_node_id, line);\n\t\t}\n\t}\n\tbody_lines(node: BaseGlNodeType): string[] | undefined {\n\t\treturn this._body_lines_by_node_id.get(node.graph_node_id);\n\t}\n}\n","import {ShaderName} from '../../../utils/shaders/ShaderName';\nimport {BaseGLDefinition} from '../../utils/GLDefinition';\nimport {LinesController} from './LinesController';\nimport {BaseGlNodeType} from '../../_Base';\n\nexport class ShadersCollectionController {\n\tprivate _lines_controller_by_shader_name: Map<ShaderName, LinesController> = new Map();\n\tconstructor(private _shader_names: ShaderName[], private _current_shader_name: ShaderName) {\n\t\tfor (let shader_name of this._shader_names) {\n\t\t\tthis._lines_controller_by_shader_name.set(shader_name, new LinesController(shader_name));\n\t\t}\n\t}\n\n\tget shader_names() {\n\t\treturn this._shader_names;\n\t}\n\n\tset_current_shader_name(shader_name: ShaderName) {\n\t\tthis._current_shader_name = shader_name;\n\t}\n\tget current_shader_name() {\n\t\treturn this._current_shader_name;\n\t}\n\n\tadd_definitions(node: BaseGlNodeType, definitions: BaseGLDefinition[], shader_name?: ShaderName) {\n\t\tif (definitions.length == 0) {\n\t\t\treturn;\n\t\t}\n\t\tshader_name = shader_name || this._current_shader_name;\n\t\tconst lines_controller = this._lines_controller_by_shader_name.get(shader_name);\n\t\tif (lines_controller) {\n\t\t\tlines_controller.add_definitions(node, definitions);\n\t\t}\n\t}\n\tdefinitions(shader_name: ShaderName, node: BaseGlNodeType) {\n\t\tconst lines_controller = this._lines_controller_by_shader_name.get(shader_name);\n\t\tif (lines_controller) {\n\t\t\treturn lines_controller.definitions(node);\n\t\t}\n\t}\n\n\tadd_body_lines(node: BaseGlNodeType, lines: string[], shader_name?: ShaderName) {\n\t\tif (lines.length == 0) {\n\t\t\treturn;\n\t\t}\n\t\tshader_name = shader_name || this._current_shader_name;\n\t\tconst lines_controller = this._lines_controller_by_shader_name.get(shader_name);\n\t\tif (lines_controller) {\n\t\t\tlines_controller.add_body_lines(node, lines);\n\t\t}\n\t}\n\tbody_lines(shader_name: ShaderName, node: BaseGlNodeType) {\n\t\tconst lines_controller = this._lines_controller_by_shader_name.get(shader_name);\n\t\tif (lines_controller) {\n\t\t\treturn lines_controller.body_lines(node);\n\t\t}\n\t}\n}\n","import {BaseGlNodeType} from '../../_Base';\nimport {LineType} from './LineType';\n\nconst LINE_SUFFIXES = {\n\t[LineType.FUNCTION_DECLARATION]: '',\n\t[LineType.DEFINE]: ';',\n\t[LineType.BODY]: ';',\n};\n\nconst LINE_PREFIXES = {\n\t[LineType.FUNCTION_DECLARATION]: '',\n\t[LineType.DEFINE]: '',\n\t[LineType.BODY]: '\t',\n};\n\nexport class CodeFormatter {\n\tstatic node_comment(node: BaseGlNodeType, line_type: LineType): string {\n\t\tlet line = `// ${node.full_path()}`;\n\t\tif (line_type == LineType.BODY) {\n\t\t\tline = `\t${line}`;\n\t\t}\n\t\treturn line;\n\t}\n\tstatic line_wrap(line: string, line_type: LineType) {\n\t\tlet add_suffix = true;\n\t\tif (line.indexOf('#if') == 0 || line.indexOf('#endif') == 0) {\n\t\t\tadd_suffix = false;\n\t\t}\n\t\tif (add_suffix) {\n\t\t\treturn `${LINE_PREFIXES[line_type]}${line}${LINE_SUFFIXES[line_type]}`;\n\t\t} else {\n\t\t\treturn `${LINE_PREFIXES[line_type]}${line}`;\n\t\t}\n\t}\n\tstatic post_line_separator(line_type: LineType) {\n\t\treturn line_type == LineType.BODY ? '\t' : '';\n\t}\n}\n","import lodash_uniq from 'lodash/uniq';\nimport {BaseGlNodeType} from '../../_Base';\nimport {TypedNodeTraverser} from '../../../utils/shaders/NodeTraverser';\nimport {BaseNodeType} from '../../../_Base';\nimport {BaseGlShaderAssembler} from '../assemblers/_Base';\nimport {MapUtils} from '../../../../../core/MapUtils';\nimport {ShaderName} from '../../../utils/shaders/ShaderName';\nimport {GLDefinitionType, BaseGLDefinition} from '../../utils/GLDefinition';\nimport {TypedGLDefinitionCollection} from '../../utils/GLDefinitionCollection';\nimport {ParamConfigsController} from '../../../../nodes/utils/code/controllers/ParamConfigsController';\nimport {ShadersCollectionController} from './ShadersCollectionController';\nimport {CodeFormatter} from './CodeFormatter';\n\nimport {LineType} from './LineType';\n\nexport class CodeBuilder {\n\t_param_configs_controller: ParamConfigsController = new ParamConfigsController();\n\t_param_configs_set_allowed: boolean = true;\n\n\tprivate _shaders_collection_controller: ShadersCollectionController | undefined;\n\t_lines: Map<ShaderName, Map<LineType, string[]>> = new Map();\n\t_function_declared: Map<ShaderName, Map<string, boolean>> = new Map();\n\n\tconstructor(private _assembler: BaseGlShaderAssembler, private _gl_parent_node: BaseNodeType) {}\n\n\tasync build_from_nodes(root_nodes: BaseGlNodeType[]) {\n\t\tconst node_traverser = new TypedNodeTraverser<BaseGlNodeType>(this._assembler, this._gl_parent_node);\n\t\tnode_traverser.traverse(root_nodes);\n\n\t\tconst nodes_by_shader_name: Map<ShaderName, BaseGlNodeType[]> = new Map();\n\t\tfor (let shader_name of this.shader_names()) {\n\t\t\tnodes_by_shader_name.set(shader_name, node_traverser.nodes_for_shader_name(shader_name));\n\t\t}\n\t\tconst sorted_nodes = node_traverser.sorted_nodes();\n\t\tfor (let shader_name of this.shader_names()) {\n\t\t\tconst root_nodes_for_shader = this._assembler.root_nodes_by_shader_name(shader_name);\n\t\t\t// const leaf_nodes_for_shader = this._assembler.leaf_nodes_by_shader_name(shader_name);\n\n\t\t\t// keep track of which nodes are both leaf and root, and do not use their code twice\n\t\t\t// as this may happen with an attribute node, when used as both import and export\n\t\t\t// TODO: that seems useless, as I surely should be able to filter duplicates if needed\n\n\t\t\t// ensure nodes are unique\n\t\t\t// const node_ids: Map<string, boolean> = new Map();\n\t\t\t// nodes_by_shader_name.forEach((nodes, shader_name) => {\n\t\t\t// \tfor (let node of nodes) {\n\t\t\t// \t\tnode_ids.set(node.graph_node_id, true);\n\t\t\t// \t}\n\t\t\t// });\n\n\t\t\tfor (let root_node of root_nodes_for_shader) {\n\t\t\t\t// if(!both_leaf_and_root_nodes_by_id[root_node.graph_node_id()]){\n\t\t\t\t// if (!node_ids.get(root_node.graph_node_id)) {\n\t\t\t\tMapUtils.push_on_array_at_entry(nodes_by_shader_name, shader_name, root_node);\n\t\t\t\t// node_ids.set(root_node.graph_node_id, true);\n\t\t\t\t// }\n\t\t\t\t// }\n\t\t\t}\n\t\t\t// for (let leaf_node of leaf_nodes_for_shader) {\n\t\t\t// if(!both_leaf_and_root_nodes_by_id[leaf_node.graph_node_id()]){\n\t\t\t// if (!node_ids.get(leaf_node.graph_node_id)) {\n\t\t\t// MapUtils.unshift_on_array_at_entry(nodes_by_shader_name, shader_name, leaf_node);\n\t\t\t// }\n\t\t\t// }\n\t\t\t// }\n\t\t}\n\n\t\t// ensure nodes are not added if already present\n\t\tconst sorted_node_ids: Map<string, boolean> = new Map();\n\t\tfor (let node of sorted_nodes) {\n\t\t\tsorted_node_ids.set(node.graph_node_id, true);\n\t\t}\n\n\t\tfor (let root_node of root_nodes) {\n\t\t\tif (!sorted_node_ids.get(root_node.graph_node_id)) {\n\t\t\t\tsorted_nodes.push(root_node);\n\t\t\t\tsorted_node_ids.set(root_node.graph_node_id, true);\n\t\t\t}\n\t\t}\n\t\tfor (let node of sorted_nodes) {\n\t\t\t// node.set_assembler(this._assembler);\n\t\t\tnode.reset_code();\n\t\t}\n\t\tfor (let node of sorted_nodes) {\n\t\t\tawait node.params.eval_all();\n\t\t}\n\n\t\t// const param_promises = sorted_nodes.map(node=>{\n\t\t// \treturn node.eval_all_params()\n\t\t// })\n\t\t// await Promise.all(param_promises)\n\n\t\tthis._shaders_collection_controller = new ShadersCollectionController(\n\t\t\tthis.shader_names(),\n\t\t\tthis.shader_names()[0]\n\t\t);\n\t\tthis.reset();\n\t\tfor (let shader_name of this.shader_names()) {\n\t\t\tconst nodes = lodash_uniq(nodes_by_shader_name.get(shader_name));\n\t\t\tthis._shaders_collection_controller.set_current_shader_name(shader_name);\n\t\t\tif (nodes) {\n\t\t\t\tfor (let node of nodes) {\n\t\t\t\t\t// node.set_shader_name(shader_name);\n\t\t\t\t\tif (this._param_configs_set_allowed) {\n\t\t\t\t\t\tnode.set_param_configs();\n\t\t\t\t\t}\n\t\t\t\t\tnode.set_lines(this._shaders_collection_controller);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// fragment_nodes.forEach(node=>{\n\t\t// \tnode.set_shader_name(ShaderName.FRAGMENT)\n\t\t// \tnode.set_param_configs()\n\t\t// \tnode.set_lines()\n\t\t// })\n\t\tif (this._param_configs_set_allowed) {\n\t\t\tthis.set_param_configs(sorted_nodes);\n\t\t}\n\t\tthis.set_code_lines(sorted_nodes);\n\t}\n\n\tdisallow_new_param_configs() {\n\t\tthis._param_configs_set_allowed = false;\n\t}\n\tallow_new_param_configs() {\n\t\tthis._param_configs_set_allowed = true;\n\t}\n\n\tshader_names() {\n\t\treturn this._assembler.shader_names;\n\t}\n\n\tprivate reset() {\n\t\tfor (let shader_name of this.shader_names()) {\n\t\t\tconst lines_map = new Map();\n\t\t\t// for (let line_type of LINE_TYPES) {\n\t\t\t// \tlines_map.set(line_type, []);\n\t\t\t// }\n\t\t\tthis._lines.set(shader_name, lines_map);\n\t\t\tthis._function_declared.set(shader_name, new Map());\n\t\t}\n\t}\n\n\tparam_configs() {\n\t\treturn this._param_configs_controller.list || [];\n\t}\n\tlines(shader_name: ShaderName, line_type: LineType) {\n\t\treturn this._lines.get(shader_name)!.get(line_type);\n\t}\n\tall_lines() {\n\t\treturn this._lines;\n\t}\n\n\tset_param_configs(nodes: BaseGlNodeType[]) {\n\t\tthis._param_configs_controller.reset();\n\t\tfor (let node of nodes) {\n\t\t\tconst param_configs = node.param_configs();\n\t\t\tif (param_configs) {\n\t\t\t\tfor (let param_config of param_configs) {\n\t\t\t\t\tthis._param_configs_controller.push(param_config);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tset_code_lines(nodes: BaseGlNodeType[]) {\n\t\tfor (let shader_name of this.shader_names()) {\n\t\t\t// nodes.forEach((node, i)=>{\n\t\t\tthis.add_code_lines(nodes, shader_name);\n\t\t\t// })\n\t\t}\n\t}\n\n\tadd_code_lines(nodes: BaseGlNodeType[], shader_name: ShaderName) {\n\t\tthis.add_definitions(nodes, shader_name, GLDefinitionType.FUNCTION, LineType.FUNCTION_DECLARATION);\n\t\tthis.add_definitions(nodes, shader_name, GLDefinitionType.UNIFORM, LineType.DEFINE);\n\t\tthis.add_definitions(nodes, shader_name, GLDefinitionType.VARYING, LineType.DEFINE);\n\t\tthis.add_definitions(nodes, shader_name, GLDefinitionType.ATTRIBUTE, LineType.DEFINE);\n\n\t\tthis.add_code_line_for_nodes_and_line_type(nodes, shader_name, LineType.BODY);\n\t}\n\n\tprivate add_definitions(\n\t\tnodes: BaseGlNodeType[],\n\t\tshader_name: ShaderName,\n\t\tdefinition_type: GLDefinitionType,\n\t\tline_type: LineType\n\t) {\n\t\tif (!this._shaders_collection_controller) {\n\t\t\treturn;\n\t\t}\n\t\tconst definitions = [];\n\t\tfor (let node of nodes) {\n\t\t\tlet node_definitions = this._shaders_collection_controller.definitions(shader_name, node);\n\t\t\tif (node_definitions) {\n\t\t\t\tnode_definitions = node_definitions.filter((d) => d.definition_type == definition_type);\n\t\t\t\tfor (let definition of node_definitions) {\n\t\t\t\t\tdefinitions.push(definition);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (definitions.length > 0) {\n\t\t\tconst collection = new TypedGLDefinitionCollection<GLDefinitionType>(definitions);\n\t\t\tconst uniq_definitions = collection.uniq();\n\t\t\tif (collection.errored) {\n\t\t\t\t// TODO: handle error\n\t\t\t\tthrow `code builder error: ${collection.error_message}`;\n\t\t\t}\n\n\t\t\tconst definitions_by_node_id: Map<string, BaseGLDefinition[]> = new Map();\n\t\t\tconst node_ids: Map<string, boolean> = new Map();\n\t\t\tfor (let definition of uniq_definitions) {\n\t\t\t\tconst node_id = definition.node.graph_node_id;\n\t\t\t\tif (!node_ids.has(node_id)) {\n\t\t\t\t\tnode_ids.set(node_id, true);\n\t\t\t\t}\n\t\t\t\tMapUtils.push_on_array_at_entry(definitions_by_node_id, node_id, definition);\n\t\t\t}\n\t\t\tconst lines_for_shader = this._lines.get(shader_name)!;\n\t\t\tnode_ids.forEach((boolean: boolean, node_id: string) => {\n\t\t\t\tconst definitions = definitions_by_node_id.get(node_id);\n\t\t\t\tif (definitions) {\n\t\t\t\t\tconst first_definition = definitions[0];\n\n\t\t\t\t\tif (first_definition) {\n\t\t\t\t\t\tconst comment = CodeFormatter.node_comment(first_definition.node, line_type);\n\t\t\t\t\t\tMapUtils.push_on_array_at_entry(lines_for_shader, line_type, comment);\n\n\t\t\t\t\t\tfor (let definition of definitions) {\n\t\t\t\t\t\t\tconst line = CodeFormatter.line_wrap(definition.line, line_type);\n\t\t\t\t\t\t\tMapUtils.push_on_array_at_entry(lines_for_shader, line_type, line);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst separator = CodeFormatter.post_line_separator(line_type);\n\t\t\t\t\t\tMapUtils.push_on_array_at_entry(lines_for_shader, line_type, separator);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\tadd_code_line_for_nodes_and_line_type(nodes: BaseGlNodeType[], shader_name: ShaderName, line_type: LineType) {\n\t\tnodes = nodes.filter((node) => {\n\t\t\tif (this._shaders_collection_controller) {\n\t\t\t\tconst lines = this._shaders_collection_controller.body_lines(shader_name, node);\n\t\t\t\treturn lines && lines.length > 0;\n\t\t\t}\n\t\t});\n\n\t\tvar nodes_count = nodes.length;\n\t\tfor (let i = 0; i < nodes_count; i++) {\n\t\t\tconst is_last = i == nodes.length - 1;\n\t\t\tthis.add_code_line_for_node_and_line_type(nodes[i], shader_name, line_type, is_last);\n\t\t}\n\t}\n\tadd_code_line_for_node_and_line_type(\n\t\tnode: BaseGlNodeType,\n\t\tshader_name: ShaderName,\n\t\tline_type: LineType,\n\t\tis_last: boolean\n\t): void {\n\t\tif (!this._shaders_collection_controller) {\n\t\t\treturn;\n\t\t}\n\t\tconst lines = this._shaders_collection_controller.body_lines(shader_name, node);\n\n\t\tif (lines && lines.length > 0) {\n\t\t\tconst lines_for_shader = this._lines.get(shader_name)!;\n\t\t\tconst comment = CodeFormatter.node_comment(node, line_type);\n\t\t\tMapUtils.push_on_array_at_entry(lines_for_shader, line_type, comment);\n\t\t\tlodash_uniq(lines).forEach((line) => {\n\t\t\t\tline = CodeFormatter.line_wrap(line, line_type);\n\t\t\t\tMapUtils.push_on_array_at_entry(lines_for_shader, line_type, line);\n\t\t\t});\n\t\t\tif (!(line_type == LineType.BODY && is_last)) {\n\t\t\t\tconst separator = CodeFormatter.post_line_separator(line_type);\n\t\t\t\tMapUtils.push_on_array_at_entry(lines_for_shader, line_type, separator);\n\t\t\t}\n\t\t}\n\t}\n}\n","// import {UniformsUtils} from 'three/src/renderers/shaders/UniformsUtils';\nimport {ShaderMaterial} from 'three/src/materials/ShaderMaterial';\n// import {ShaderChunk} from 'three/src/renderers/shaders/ShaderChunk';\n// import {Shader} from 'three/src/renderers/shaders/ShaderLib'\n// import {MeshStandardMaterial} from 'three/src/materials/MeshStandardMaterial';\n// import {MeshPhysicalMaterial} from 'three/src/materials/MeshPhysicalMaterial';\n// import {Material} from 'three/src/materials/Material';\nimport {Vector2} from 'three/src/math/Vector2';\n\n// import {Connection} from '../../../../../Engine/Node/Gl/GlData';\nimport {LineType} from '../utils/LineType';\n// import {Output} from '../../../../../Engine/Node/Gl/Output'\n\nimport {ShaderConfig} from '../configs/ShaderConfig';\nimport {VariableConfig} from '../configs/VariableConfig';\n// import {ThreeToGl} from '../../../../../core/ThreeToGl';\n// const BODY_SPLIT_LINE = 'void main() {'\n// export const BODY_SEPARATOR_LINES = lodash_range(3).map(i=>'\t')\nimport {CodeBuilder} from '../utils/CodeBuilder';\n// import {BaseNode} from '../../../../../Engine/Node/_Base';\nimport {BaseGlNodeType} from '../../_Base';\nimport {GlobalsGeometryHandler} from '../globals/Geometry';\nimport {TypedAssembler} from '../../../utils/shaders/BaseAssembler';\nimport {ShaderName} from '../../../utils/shaders/ShaderName';\n// import {IUniformsWithFrame, IUniformsWithResolution} from '../../../../scene/utils/UniformsController';\nimport {OutputGlNode} from '../../Output';\nimport {ParamType} from '../../../../poly/ParamType';\nimport {TypedNamedConnectionPoint} from '../../../utils/connections/NamedConnectionPoint';\nimport {ConnectionPointType} from '../../../utils/connections/ConnectionPointType';\nimport {GlobalsGlNode} from '../../Globals';\nimport {AttributeGlNode} from '../../Attribute';\nimport {AssemblerControllerNode} from '../Controller';\nimport {GlobalsBaseController} from '../globals/_Base';\nimport {CustomMaterialName} from './materials/_BaseMaterial';\nimport {ShadersCollectionController} from '../utils/ShadersCollectionController';\nimport {IUniforms} from '../../../../../core/geometry/Material';\n\ntype StringArrayByShaderName = Map<ShaderName, string[]>;\n\ninterface ITemplateShader {\n\tvertexShader?: string;\n\tfragmentShader?: string;\n\tuniforms?: IUniforms;\n}\n\nconst INSERT_DEFINE_AFTER_MAP: Map<ShaderName, string> = new Map([\n\t[ShaderName.VERTEX, '#include <common>'],\n\t[ShaderName.FRAGMENT, '#include <common>'],\n]);\nconst INSERT_BODY_AFTER_MAP: Map<ShaderName, string> = new Map([\n\t[ShaderName.VERTEX, '#include <color_vertex>'],\n\t[ShaderName.FRAGMENT, 'vec4 diffuseColor = vec4( diffuse, opacity );'],\n]);\nconst LINES_TO_REMOVE_MAP: Map<ShaderName, string[]> = new Map([\n\t[ShaderName.VERTEX, ['#include <begin_vertex>', '#include <beginnormal_vertex>']],\n\t[ShaderName.FRAGMENT, []],\n]);\n\nconst SPACED_LINES = 3;\n\nexport class BaseGlShaderAssembler extends TypedAssembler<BaseGlNodeType> {\n\tprotected _shaders_by_name: Map<ShaderName, string> = new Map();\n\tprotected _lines: StringArrayByShaderName = new Map();\n\tprotected _code_builder: CodeBuilder | undefined;\n\tprivate _param_config_owner: CodeBuilder | undefined;\n\tprotected _root_nodes: BaseGlNodeType[] = [];\n\tprotected _leaf_nodes: BaseGlNodeType[] = [];\n\tprotected _material: ShaderMaterial | undefined;\n\n\tprivate _shader_configs: ShaderConfig[] | undefined;\n\tprivate _variable_configs: VariableConfig[] | undefined;\n\n\tprivate _uniforms_time_dependent: boolean = false;\n\tprivate _resolution_dependent: boolean = false;\n\n\tconstructor(protected _gl_parent_node: AssemblerControllerNode) {\n\t\tsuper();\n\t}\n\n\tasync compile() {}\n\n\t// private get material() {\n\t// \treturn (this._material = this._material || this._create_material());\n\t// }\n\t// async get_material(/*master_assembler?: BaseGlShaderAssembler*/) {\n\t// \tthis._material = this._material || this._create_material();\n\n\t// \tawait this._update_material(/*master_assembler*/);\n\t// \treturn this._material;\n\t// }\n\tprotected _template_shader_for_shader_name(shader_name: ShaderName): string | undefined {\n\t\tswitch (shader_name) {\n\t\t\tcase ShaderName.VERTEX:\n\t\t\t\treturn this._template_shader?.vertexShader;\n\t\t\tcase ShaderName.FRAGMENT:\n\t\t\t\treturn this._template_shader?.fragmentShader;\n\t\t}\n\t}\n\n\tget globals_handler(): GlobalsBaseController | undefined {\n\t\treturn this._gl_parent_node.assembler_controller.globals_handler;\n\t}\n\tcompile_allowed(): boolean {\n\t\treturn this._gl_parent_node.assembler_controller.globals_handler != null;\n\t}\n\tshaders_by_name() {\n\t\treturn this._shaders_by_name;\n\t}\n\n\t// protected create_material(): ShaderMaterial | undefined {\n\t// \treturn undefined;\n\t// }\n\tprotected _build_lines() {\n\t\tfor (let shader_name of this.shader_names) {\n\t\t\tconst template = this._template_shader_for_shader_name(shader_name);\n\t\t\tif (template) {\n\t\t\t\tthis._replace_template(template, shader_name);\n\t\t\t}\n\t\t}\n\t}\n\n\t// protected _build_lines_for_shader_name(shader_name: ShaderName){\n\t// \tconst template = this._template_shader()\n\t// \tthis._replace_template(template[`${shader_name}Shader`], shader_name)\n\t// }\n\n\tset_root_nodes(root_nodes: BaseGlNodeType[]) {\n\t\tthis._root_nodes = root_nodes;\n\t}\n\tprotected get _template_shader(): ITemplateShader | undefined {\n\t\treturn undefined;\n\t} //Shader - could not find the import?\n\t// abstract _color_declaration(): string\n\t// private async _update_material(/*master_assembler?: BaseGlShaderAssembler*/) {\n\t// \tif (!this.material || !this._material) {\n\t// \t\treturn;\n\t// \t}\n\t// \tconst template_shader = this._template_shader;\n\t// \tif (!template_shader) {\n\t// \t\treturn;\n\t// \t}\n\t// \tthis._lines = new Map();\n\t// \tfor (let shader_name of this.shader_names) {\n\t// \t\tconst template = this._template_shader_for_shader_name(shader_name);\n\t// \t\tif (template) {\n\t// \t\t\tthis._lines.set(shader_name, template.split('\\n'));\n\t// \t\t}\n\t// \t}\n\t// \tif (this._root_nodes.length > 0) {\n\t// \t\t// this._output_node.set_color_declaration(this._color_declaration())\n\t// \t\t// if(!master_assembler){\n\t// \t\t// this._output_node.set_assembler(this)\n\t// \t\tawait this.build_code_from_nodes(this._root_nodes);\n\t// \t\t// }\n\n\t// \t\t(this._material as any).extensions = {derivatives: true};\n\t// \t\t// this._material?.derivatives = true;\n\t// \t\tthis._build_lines();\n\t// \t\t// this._lines[ShaderName.FRAGMENT].unshift('#extension GL_OES_standard_derivatives : enable')\n\t// \t}\n\n\t// \t// TODO: typescript - not sure that is still useful\n\t// \t// for (let param_config of this.param_configs()) {\n\t// \t// \tparam_config.material = this._material;\n\t// \t// }\n\n\t// \t// instead of replacing fully the uniforms,\n\t// \t// I simply add to them the new ones or replace the existing ones\n\t// \t// otherwise this would break the particles_system_gpu\n\t// \t// which would not reset correctly when going back to first frame.\n\t// \t// Not entirely sure why, but this seems to be due to the texture uniforms\n\t// \t// which are removed and then readded. This seems to mess up somewhere with how\n\t// \t// the material updates itself...\n\t// \t// this._material.uniforms = this.build_uniforms(template_shader)\n\t// \tconst new_uniforms = this.build_uniforms(template_shader.uniforms);\n\t// \tthis.material.uniforms = this.material.uniforms || {};\n\t// \tfor (let uniform_name of Object.keys(new_uniforms)) {\n\t// \t\tthis.material.uniforms[uniform_name] = new_uniforms[uniform_name];\n\t// \t}\n\n\t// \tfor (let shader_name of this.shader_names) {\n\t// \t\tconst lines = this._lines.get(shader_name);\n\t// \t\tif (lines) {\n\t// \t\t\tconst shader = lines.join('\\n');\n\t// \t\t\tswitch (shader_name) {\n\t// \t\t\t\tcase ShaderName.VERTEX: {\n\t// \t\t\t\t\tthis._material.vertexShader = shader;\n\t// \t\t\t\t\tbreak;\n\t// \t\t\t\t}\n\t// \t\t\t\tcase ShaderName.FRAGMENT: {\n\t// \t\t\t\t\tthis._material.fragmentShader = shader;\n\t// \t\t\t\t\tbreak;\n\t// \t\t\t\t}\n\t// \t\t\t}\n\t// \t\t}\n\t// \t}\n\n\t// \tconst scene = this._gl_parent_node.scene;\n\t// \t// const id = this._gl_parent_node.graph_node_id()\n\t// \tif (this.frame_dependent()) {\n\t// \t\t// make sure not to use this._gl_parent_node.graph_node_id() as the id,\n\t// \t\t// as we need several materials:\n\t// \t\t// - the visible one\n\t// \t\t// - the multiple shadow ones\n\t// \t\t// - and possibly a depth one\n\t// \t\tscene.uniforms_controller.add_frame_dependent_uniform_owner(\n\t// \t\t\tthis._material.uuid,\n\t// \t\t\tthis._material.uniforms as IUniformsWithFrame\n\t// \t\t);\n\t// \t} else {\n\t// \t\tscene.uniforms_controller.remove_frame_dependent_uniform_owner(this._material.uuid);\n\t// \t}\n\n\t// \tif (this.resolution_dependent()) {\n\t// \t\tscene.uniforms_controller.add_resolution_dependent_uniform_owner(\n\t// \t\t\tthis._material.uuid,\n\t// \t\t\tthis._material.uniforms as IUniformsWithResolution\n\t// \t\t);\n\t// \t} else {\n\t// \t\tscene.uniforms_controller.remove_resolution_dependent_uniform_owner(this._material.uuid);\n\t// \t}\n\t// }\n\n\tprotected add_uniforms(current_uniforms: IUniforms) {\n\t\t// const new_uniforms = UniformsUtils.clone(template_uniforms);\n\n\t\t// copy the new uniforms onto the old ones, only adding, not removing\n\t\t// for (let uniform_name of Object.keys(new_uniforms)) {\n\n\t\t// }\n\n\t\t// copy the values of the old uniform\n\t\t// for (let uniform_name of Object.keys(old_uniforms)) {\n\t\t// \tconst new_uniform = new_uniforms[uniform_name];\n\t\t// \tif (new_uniform) {\n\t\t// \t\tnew_uniform.value = old_uniforms[uniform_name].value;\n\t\t// \t}\n\t\t// }\n\n\t\tfor (let param_config of this.param_configs()) {\n\t\t\tcurrent_uniforms[param_config.uniform_name] = param_config.uniform;\n\t\t}\n\n\t\tif (this.uniforms_time_dependent()) {\n\t\t\tcurrent_uniforms['time'] = {\n\t\t\t\t// type: '1f',\n\t\t\t\tvalue: this._gl_parent_node.scene.time,\n\t\t\t};\n\t\t}\n\t\tif (this.resolution_dependent()) {\n\t\t\tcurrent_uniforms['resolution'] = {\n\t\t\t\tvalue: new Vector2(1000, 1000),\n\t\t\t};\n\t\t}\n\n\t\t// return new_uniforms;\n\t}\n\n\t//\n\t//\n\t// ROOT NODES AND SHADER NAMES\n\t//\n\t//\n\troot_nodes_by_shader_name(shader_name: ShaderName): BaseGlNodeType[] {\n\t\t// return this._root_nodes\n\t\tconst list = [];\n\t\tfor (let node of this._root_nodes) {\n\t\t\tswitch (node.type) {\n\t\t\t\tcase 'output': {\n\t\t\t\t\tlist.push(node);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'attribute': {\n\t\t\t\t\t// TODO: typescript - gl - why is there a texture allocation controller in the base assembler?\n\t\t\t\t\t// const attrib_name = (node as AttributeGlNode).attribute_name;\n\t\t\t\t\t// const variable = this._texture_allocations_controller.variable(attrib_name);\n\t\t\t\t\t// if (variable) {\n\t\t\t\t\t// \tconst allocation_shader_name = variable.allocation().shader_name();\n\t\t\t\t\t// \tif (allocation_shader_name == shader_name) {\n\t\t\t\t\t// \t\tlist.push(node);\n\t\t\t\t\t// \t}\n\t\t\t\t\t// }\n\t\t\t\t\t// break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n\tleaf_nodes_by_shader_name(shader_name: ShaderName): BaseGlNodeType[] {\n\t\tconst list = [];\n\t\tfor (let node of this._leaf_nodes) {\n\t\t\tswitch (node.type) {\n\t\t\t\tcase GlobalsGlNode.type(): {\n\t\t\t\t\tlist.push(node);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase AttributeGlNode.type(): {\n\t\t\t\t\t// TODO: typescript - gl - why is there a texture allocation controller in the base assembler? AND especially since there is no way to assign it?\n\t\t\t\t\t// const attrib_name: string = (node as AttributeGlNode).attribute_name;\n\t\t\t\t\t// const variable = this._texture_allocations_controller.variable(attrib_name);\n\t\t\t\t\t// if (variable) {\n\t\t\t\t\t// \tconst allocation_shader_name = variable.allocation().shader_name();\n\t\t\t\t\t// \tif (allocation_shader_name == shader_name) {\n\t\t\t\t\t// \t\tlist.push(node);\n\t\t\t\t\t// \t}\n\t\t\t\t\t// }\n\t\t\t\t\t// break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n\tset_node_lines_globals(globals_node: GlobalsGlNode, shaders_collection_controller: ShadersCollectionController) {}\n\tset_node_lines_output(output_node: OutputGlNode, shaders_collection_controller: ShadersCollectionController) {}\n\tset_node_lines_attribute(\n\t\tattribute_node: AttributeGlNode,\n\t\tshaders_collection_controller: ShadersCollectionController\n\t) {}\n\n\t//\n\t//\n\t// CHILDREN NODES PARAMS\n\t//\n\t//\n\tget code_builder() {\n\t\treturn (this._code_builder = this._code_builder || new CodeBuilder(this, this._gl_parent_node));\n\t}\n\tasync build_code_from_nodes(root_nodes: BaseGlNodeType[]) {\n\t\tawait this.code_builder.build_from_nodes(root_nodes);\n\t}\n\tallow_new_param_configs() {\n\t\tthis.code_builder.allow_new_param_configs();\n\t}\n\tdisallow_new_param_configs() {\n\t\tthis.code_builder.disallow_new_param_configs();\n\t}\n\tbuilder_param_configs() {\n\t\treturn this.code_builder.param_configs();\n\t}\n\tbuilder_lines(shader_name: ShaderName, line_type: LineType) {\n\t\treturn this.code_builder.lines(shader_name, line_type);\n\t}\n\tall_builder_lines() {\n\t\treturn this.code_builder.all_lines();\n\t}\n\tparam_configs() {\n\t\tconst code_builder = this._param_config_owner || this.code_builder;\n\t\treturn code_builder.param_configs();\n\t}\n\tset_param_configs_owner(param_config_owner: CodeBuilder) {\n\t\tthis._param_config_owner = param_config_owner;\n\t\tif (this._param_config_owner) {\n\t\t\tthis.code_builder.disallow_new_param_configs();\n\t\t} else {\n\t\t\tthis.code_builder.allow_new_param_configs();\n\t\t}\n\t}\n\n\t//\n\t//\n\t// CHILDREN NODES PARAMS\n\t//\n\t//\n\tstatic add_output_params(output_child: OutputGlNode) {\n\t\toutput_child.params.add_param(ParamType.VECTOR3, 'position', [0, 0, 0], {hidden: true});\n\t\toutput_child.params.add_param(ParamType.VECTOR3, 'normal', [0, 0, 0], {hidden: true});\n\t\toutput_child.params.add_param(ParamType.COLOR, 'color', [1, 1, 1], {hidden: true});\n\t\toutput_child.params.add_param(ParamType.FLOAT, 'alpha', 1, {hidden: true});\n\t\toutput_child.params.add_param(ParamType.VECTOR2, 'uv', [0, 0], {hidden: true});\n\t}\n\tadd_output_params(output_child: OutputGlNode) {\n\t\tBaseGlShaderAssembler.add_output_params(output_child);\n\t}\n\tstatic create_globals_node_output_connections() {\n\t\treturn [\n\t\t\tnew TypedNamedConnectionPoint('position', ConnectionPointType.VEC3),\n\t\t\tnew TypedNamedConnectionPoint('normal', ConnectionPointType.VEC3),\n\t\t\tnew TypedNamedConnectionPoint('color', ConnectionPointType.VEC3),\n\t\t\tnew TypedNamedConnectionPoint('uv', ConnectionPointType.VEC2),\n\t\t\tnew TypedNamedConnectionPoint('gl_FragCoord', ConnectionPointType.VEC4),\n\t\t\tnew TypedNamedConnectionPoint('resolution', ConnectionPointType.VEC2),\n\t\t\t// new Connection.Vec2('gl_PointCoord'),\n\t\t\t// new TypedConnectionVec2('uv'),\n\t\t\tnew TypedNamedConnectionPoint('time', ConnectionPointType.FLOAT),\n\t\t];\n\t}\n\tcreate_globals_node_output_connections() {\n\t\treturn BaseGlShaderAssembler.create_globals_node_output_connections();\n\t}\n\tadd_globals_params(globals_node: GlobalsGlNode) {\n\t\tglobals_node.io.outputs.set_named_output_connection_points(this.create_globals_node_output_connections());\n\t}\n\tallow_attribute_exports() {\n\t\treturn false;\n\t}\n\n\t//\n\t//\n\t// CONFIGS\n\t//\n\t//\n\treset_configs() {\n\t\tthis._reset_shader_configs();\n\t\tthis._reset_variable_configs();\n\t\tthis._reset_uniforms_time_dependency();\n\t\tthis._reset_resolution_dependency();\n\t}\n\tget shader_configs() {\n\t\treturn (this._shader_configs = this._shader_configs || this.create_shader_configs());\n\t}\n\tset_shader_configs(shader_configs: ShaderConfig[]) {\n\t\tthis._shader_configs = shader_configs;\n\t}\n\tget shader_names(): ShaderName[] {\n\t\treturn this.shader_configs?.map((sc) => sc.name()) || [];\n\t}\n\tprotected _reset_shader_configs() {\n\t\tthis._shader_configs = undefined;\n\t\t// this.shader_configs; // TODO: typescript - why do I need to re-initialize here?\n\t}\n\tcreate_shader_configs(): ShaderConfig[] {\n\t\treturn [\n\t\t\tnew ShaderConfig(ShaderName.VERTEX, ['position', 'normal', 'uv'], []),\n\t\t\tnew ShaderConfig(ShaderName.FRAGMENT, ['color', 'alpha'], [ShaderName.VERTEX]),\n\t\t];\n\t}\n\tshader_config(name: string): ShaderConfig | undefined {\n\t\treturn this.shader_configs?.filter((sc) => {\n\t\t\treturn sc.name() == name;\n\t\t})[0];\n\t}\n\tvariable_configs() {\n\t\treturn (this._variable_configs = this._variable_configs || this.create_variable_configs());\n\t}\n\tset_variable_configs(variable_configs: VariableConfig[]) {\n\t\tthis._variable_configs = variable_configs;\n\t}\n\tvariable_config(name: string) {\n\t\treturn this.variable_configs().filter((vc) => {\n\t\t\treturn vc.name() == name;\n\t\t})[0];\n\t}\n\tstatic create_variable_configs() {\n\t\treturn [\n\t\t\tnew VariableConfig('position', {\n\t\t\t\tdefault_from_attribute: true,\n\t\t\t\t// default: this.globals_handler().variable_config_default('position'),\n\t\t\t\t// required_definitions: this.globals_handler().variable_config_required_definitions('position'),\n\t\t\t\tprefix: 'vec3 transformed = ',\n\t\t\t}),\n\t\t\tnew VariableConfig('normal', {\n\t\t\t\tdefault_from_attribute: true,\n\t\t\t\tprefix: 'vec3 objectNormal = ',\n\t\t\t\t// post_lines: ['#ifdef USE_TANGENT', 'vec3 objectTangent = vec3( tangent.xyz );', '#endif'],\n\t\t\t}),\n\t\t\tnew VariableConfig('color', {\n\t\t\t\tprefix: 'diffuseColor.xyz = ',\n\t\t\t}),\n\t\t\tnew VariableConfig('alpha', {\n\t\t\t\tprefix: 'diffuseColor.a = ',\n\t\t\t}),\n\t\t\tnew VariableConfig('uv', {\n\t\t\t\t// default_from_attribute: true,\n\t\t\t\tprefix: 'vUv = ',\n\t\t\t\tif: GlobalsGeometryHandler.IF_RULE.uv,\n\t\t\t}),\n\t\t];\n\t}\n\tcreate_variable_configs(): VariableConfig[] {\n\t\treturn BaseGlShaderAssembler.create_variable_configs();\n\t}\n\tprotected _reset_variable_configs() {\n\t\tthis._variable_configs = undefined;\n\t\tthis.variable_configs();\n\t}\n\tinput_names_for_shader_name(root_node: BaseGlNodeType, shader_name: ShaderName) {\n\t\treturn this.shader_config(shader_name)?.input_names() || [];\n\t}\n\n\t// time dependency\n\tprotected _reset_uniforms_time_dependency() {\n\t\tthis._uniforms_time_dependent = false;\n\t}\n\tset_uniforms_time_dependent() {\n\t\tthis._uniforms_time_dependent = true;\n\t}\n\tuniforms_time_dependent(): boolean {\n\t\treturn this._uniforms_time_dependent;\n\t}\n\t// resolution dependency\n\tprotected _reset_resolution_dependency() {\n\t\tthis._resolution_dependent = false;\n\t}\n\tset_resolution_dependent() {\n\t\tthis._resolution_dependent = true;\n\t}\n\tresolution_dependent(): boolean {\n\t\treturn this._resolution_dependent;\n\t}\n\n\t//\n\t//\n\t// TEMPLATE HOOKS\n\t//\n\t//\n\tprotected insert_define_after(shader_name: ShaderName): string | undefined {\n\t\treturn INSERT_DEFINE_AFTER_MAP.get(shader_name);\n\t}\n\tprotected insert_body_after(shader_name: ShaderName): string | undefined {\n\t\treturn INSERT_BODY_AFTER_MAP.get(shader_name);\n\t}\n\tprotected lines_to_remove(shader_name: ShaderName): string[] | undefined {\n\t\treturn LINES_TO_REMOVE_MAP.get(shader_name);\n\t}\n\n\t//\n\t//\n\t// TEMPLATE CODE REPLACEMENT\n\t//\n\t//\n\n\tprivate _replace_template(template: string, shader_name: ShaderName) {\n\t\tconst function_declaration = this.builder_lines(shader_name, LineType.FUNCTION_DECLARATION);\n\t\tconst define = this.builder_lines(shader_name, LineType.DEFINE);\n\t\t// let all_define = function_declaration.concat(define);\n\t\tconst body = this.builder_lines(shader_name, LineType.BODY);\n\n\t\tlet template_lines = template.split('\\n');\n\t\t// const scene = this._gl_parent_node.scene;\n\t\tconst new_lines = [\n\t\t\t// `#define FPS ${ThreeToGl.float(scene.time_controller.fps)}`,\n\t\t\t// `#define TIME_INCREMENT (1.0/${ThreeToGl.float(scene.time_controller.fps)})`,\n\t\t\t// `#define FRAME_RANGE_START ${ThreeToGl.float(scene.time_controller.frame_range[0])}`,\n\t\t\t// `#define FRAME_RANGE_END ${ThreeToGl.float(scene.time_controller.frame_range[1])}`,\n\t\t];\n\n\t\tconst line_before_define = this.insert_define_after(shader_name);\n\t\tconst line_before_body = this.insert_body_after(shader_name);\n\t\tconst lines_to_remove = this.lines_to_remove(shader_name);\n\t\tlet line_before_define_found = false;\n\t\tlet line_before_body_found = false;\n\n\t\tfor (let template_line of template_lines) {\n\t\t\tif (line_before_define_found == true) {\n\t\t\t\tif (function_declaration) {\n\t\t\t\t\tthis._insert_lines(new_lines, function_declaration);\n\t\t\t\t}\n\t\t\t\tif (define) {\n\t\t\t\t\tthis._insert_lines(new_lines, define);\n\t\t\t\t}\n\t\t\t\tline_before_define_found = false;\n\t\t\t}\n\t\t\tif (line_before_body_found == true) {\n\t\t\t\t// this._insert_default_body_declarations(new_lines, shader_name)\n\t\t\t\tif (body) {\n\t\t\t\t\tthis._insert_lines(new_lines, body);\n\t\t\t\t}\n\t\t\t\tline_before_body_found = false;\n\t\t\t}\n\n\t\t\tlet line_remove_required = false;\n\t\t\tif (lines_to_remove) {\n\t\t\t\tfor (let line_to_remove of lines_to_remove) {\n\t\t\t\t\tif (template_line.indexOf(line_to_remove) >= 0) {\n\t\t\t\t\t\tline_remove_required = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!line_remove_required) {\n\t\t\t\tnew_lines.push(template_line);\n\t\t\t} else {\n\t\t\t\tnew_lines.push('// removed:');\n\t\t\t\tnew_lines.push(`//${template_line}`);\n\t\t\t}\n\n\t\t\tif (line_before_define && template_line.indexOf(line_before_define) >= 0) {\n\t\t\t\tline_before_define_found = true;\n\t\t\t}\n\t\t\tif (line_before_body && template_line.indexOf(line_before_body) >= 0) {\n\t\t\t\tline_before_body_found = true;\n\t\t\t}\n\n\t\t\t// if(template_line.indexOf('// INSERT DEFINE') >= 0){\n\t\t\t// } else {\n\t\t\t// \tif(template_line.indexOf('// INSERT BODY') >= 0){\n\t\t\t// \t\tif(body.length > 0){\n\t\t\t// \t\t\tlodash_times(3, ()=>new_lines.push('\t'))\n\t\t\t// \t\t\tbody.forEach(body_line=>{\n\t\t\t// \t\t\t\tnew_lines.push(body_line)\n\t\t\t// \t\t\t})\n\t\t\t// \t\t\tlodash_times(3, ()=>new_lines.push('\t'))\n\t\t\t// \t\t}\n\t\t\t// \t} else {\n\t\t\t// \t\tif(template_line.indexOf('// TO REMOVE') < 0){\n\t\t\t// \t\t\tnew_lines.push(template_line)\n\t\t\t// \t\t}\n\t\t\t// \t}\n\t\t\t// }\n\t\t}\n\t\tthis._lines.set(shader_name, new_lines);\n\t}\n\n\t// protected _insert_default_body_declarations(new_lines, shader_name){\n\t// \tnew_lines.push('float POLY_roughness = 1.0;')\n\t// }\n\n\tprivate _insert_lines(new_lines: string[], lines_to_add: string[]) {\n\t\tif (lines_to_add.length > 0) {\n\t\t\tfor (let i = 0; i < SPACED_LINES; i++) {\n\t\t\t\tnew_lines.push('');\n\t\t\t}\n\n\t\t\tfor (let line_to_add of lines_to_add) {\n\t\t\t\tnew_lines.push(line_to_add);\n\t\t\t}\n\t\t\tfor (let i = 0; i < SPACED_LINES; i++) {\n\t\t\t\tnew_lines.push('');\n\t\t\t}\n\t\t}\n\t}\n\n\tasync get_custom_materials(): Promise<Map<CustomMaterialName, ShaderMaterial>> {\n\t\treturn new Map<CustomMaterialName, ShaderMaterial>();\n\t}\n\n\t// protected expand_shader(shader_string: string) {\n\t// \tfunction parseIncludes(string: string) {\n\t// \t\tvar pattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\n\t// \t\tfunction replace(match: string, include: string) {\n\t// \t\t\tvar replace = ShaderChunk[include];\n\n\t// \t\t\tif (replace === undefined) {\n\t// \t\t\t\tthrow new Error('Can not resolve #include <' + include + '>');\n\t// \t\t\t}\n\n\t// \t\t\treturn parseIncludes(replace);\n\t// \t\t}\n\n\t// \t\treturn string.replace(pattern, replace);\n\t// \t}\n\t// \treturn parseIncludes(shader_string);\n\t// }\n\n\t//\n\t//\n\t// GLTF EXPORT\n\t//\n\t//\n\t// static convert_material_to_gltf_supported(material: ShaderMaterial): Material{\n\t// \tconst gltf_constructor = this.is_physical() ? MeshPhysicalMaterial : MeshStandardMaterial\n\t// \tconst options = {}\n\t// \tthis._match_uniform('color', options, material, 'diffuse')\n\t// \tthis._match_uniform('map', options, material)\n\t// \tthis._match_uniform('envMap', options, material)\n\t// \tthis._match_uniform('envMapIntensity', options, material)\n\t// \tthis._match_uniform('metalness', options, material)\n\t// \tthis._match_uniform('roughness', options, material)\n\t// \tconst gltf_material = new gltf_constructor(options)\n\t// \treturn gltf_material\n\t// }\n\t// static _match_uniform(name: string, options: object, material: ShaderMaterial, uniform_name?: string) {\n\t// \tuniform_name = uniform_name || name;\n\t// \toptions[name] = material.uniforms[uniform_name].value;\n\t// }\n}\n","import {TypedNode} from '../../_Base';\nimport {ShaderName} from './ShaderName';\n\nexport abstract class TypedAssembler<T extends TypedNode<any, any, any>> {\n\tabstract get shader_names(): ShaderName[];\n\tabstract input_names_for_shader_name(node: T, shader_name: ShaderName): string[];\n}\n","import {TypedGLDefinition, GLDefinitionType} from './GLDefinition';\n\nexport class TypedGLDefinitionCollection<T extends GLDefinitionType> {\n\t_errored: boolean = false;\n\t_error_message: string | undefined;\n\n\tconstructor(private _definitions: TypedGLDefinition<T>[] = []) {}\n\n\tget errored() {\n\t\treturn this._errored;\n\t}\n\tget error_message() {\n\t\treturn this._error_message;\n\t}\n\n\tuniq(): TypedGLDefinition<T>[] {\n\t\tconst definitions_by_name: Map<string, TypedGLDefinition<T>> = new Map();\n\t\tconst names: string[] = [];\n\n\t\tfor (let definition of this._definitions) {\n\t\t\tif (!this._errored) {\n\t\t\t\tconst name = definition.name;\n\t\t\t\tconst existing = definitions_by_name.get(name);\n\t\t\t\tif (existing) {\n\t\t\t\t\tif (existing.data_type != definition.data_type) {\n\t\t\t\t\t\tthis._errored = true;\n\t\t\t\t\t\tthis._error_message = `attempt to create ${definition.name} with types ${definition.data_type}`;\n\t\t\t\t\t\tconsole.warn('emitting error message', this._error_message);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdefinitions_by_name.set(name, definition);\n\t\t\t\t\tnames.push(name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst uniq_definitions: TypedGLDefinition<T>[] = [];\n\t\tfor (let name of names) {\n\t\t\tconst definition = definitions_by_name.get(name);\n\t\t\tif (definition) {\n\t\t\t\tuniq_definitions.push(definition);\n\t\t\t}\n\t\t}\n\t\t// sorting may make dependencies be declared after the function calling them\n\t\t// const sorted_definitions = lodash_sortBy(uniq_definitions, (d)=>d.name())\n\t\treturn uniq_definitions;\n\t}\n}\n","import {VideoTexture} from 'three/src/textures/VideoTexture';\nimport {Vector4} from 'three/src/math/Vector4';\nimport {Vector3} from 'three/src/math/Vector3';\nimport {Vector2} from 'three/src/math/Vector2';\n\nimport {ParamType} from '../../../../poly/ParamType';\nimport {ParamInitValuesTypeMap} from '../../../../params/types/ParamInitValuesTypeMap';\nimport {ParamValuesTypeMap} from '../../../../params/types/ParamValuesTypeMap';\nimport {ParamConstructorByType} from '../../../../params/types/ParamConstructorByType';\n\nimport {BaseNodeType} from '../../../_Base';\nimport {TypedParam, BaseParamType} from '../../../../params/_Base';\nimport {NodeContext} from '../../../../poly/NodeContext';\nimport {TypeAssert} from '../../../../poly/Assert';\nimport {IUniform} from 'three/src/renderers/shaders/UniformsLib';\n// import { RampValue } from '../../../../params/ramp/RampValue';\nimport {RampParam} from '../../../../params/Ramp';\nimport {OperatorPathParam} from '../../../../params/OperatorPath';\n// import {ParamValueComparer} from '../../params/ParamValueComparer';\n// import {ParamValueCloner} from '../../params/ParamValueCloner';\n// import {CoreTextureLoader} from '../../../../../Core/Loader/Texture'\n\nexport class ParamConfig<T extends ParamType> {\n\tprivate _uniform: IUniform | undefined;\n\tprivate _cached_param_value: ParamValuesTypeMap[T] | undefined;\n\t// private _texture_loader: CoreTextureLoader\n\n\tconstructor(\n\t\tprivate _type: T,\n\t\tprivate _name: string,\n\t\tprivate _default_value: ParamInitValuesTypeMap[T],\n\t\tprivate _uniform_name: string\n\t) {}\n\n\tstatic from_param<K extends ParamType>(param: TypedParam<K>, uniform_name: string): ParamConfig<K> {\n\t\treturn new ParamConfig<K>(param.type, param.name, param.default_value, uniform_name);\n\t}\n\n\tget type() {\n\t\treturn this._type;\n\t}\n\tget name() {\n\t\treturn this._name;\n\t}\n\tget default_value() {\n\t\treturn this._default_value;\n\t}\n\tget uniform_name() {\n\t\treturn this._uniform_name;\n\t}\n\n\tget uniform() {\n\t\treturn (this._uniform = this._uniform || this._create_uniform());\n\t}\n\n\tprivate _create_uniform() {\n\t\treturn ParamConfig.uniform_by_type(this._type);\n\t}\n\n\tget param_options() {\n\t\tconst callback_bound = this._callback.bind(this);\n\t\tswitch (this._type) {\n\t\t\tcase ParamType.OPERATOR_PATH:\n\t\t\t\treturn {callback: callback_bound, node_selection: {context: NodeContext.COP}};\n\t\t\tdefault:\n\t\t\t\treturn {callback: callback_bound};\n\t\t}\n\t}\n\n\tprivate _callback(node: BaseNodeType, param: BaseParamType) {\n\t\tthis.uniform.value = param.value;\n\t}\n\n\t// TODO: refactor that to use the default values map?\n\tstatic uniform_by_type(type: ParamType): IUniform {\n\t\tswitch (type) {\n\t\t\tcase ParamType.BOOLEAN:\n\t\t\t\treturn {value: 0};\n\t\t\tcase ParamType.BUTTON:\n\t\t\t\treturn {value: 0};\n\t\t\tcase ParamType.COLOR:\n\t\t\t\treturn {value: new Vector3(0, 0, 0)};\n\t\t\tcase ParamType.FLOAT:\n\t\t\t\treturn {value: 0};\n\t\t\tcase ParamType.FOLDER:\n\t\t\t\treturn {value: 0};\n\t\t\tcase ParamType.INTEGER:\n\t\t\t\treturn {value: 0};\n\t\t\tcase ParamType.OPERATOR_PATH:\n\t\t\t\treturn {value: 0};\n\t\t\t// case ParamType.STRING: return {type: 't', value: null} // new Texture()}\n\t\t\tcase ParamType.RAMP:\n\t\t\t\treturn {value: null}; // new Texture()}\n\t\t\tcase ParamType.SEPARATOR:\n\t\t\t\treturn {value: 0};\n\t\t\tcase ParamType.STRING:\n\t\t\t\treturn {value: null};\n\t\t\tcase ParamType.VECTOR2:\n\t\t\t\treturn {value: new Vector2(0, 0)};\n\t\t\tcase ParamType.VECTOR3:\n\t\t\t\treturn {value: new Vector3(0, 0, 0)};\n\t\t\tcase ParamType.VECTOR4:\n\t\t\t\treturn {value: new Vector4(0, 0, 0, 0)};\n\t\t}\n\t\tTypeAssert.unreachable(type);\n\t}\n\n\tasync set_uniform_value(node: BaseNodeType) {\n\t\t// return new Promise( async (resolve, reject)=>{\n\t\tconst uniform = this.uniform;\n\t\t// the cache cannot be trusted...\n\t\tconst param = node.params.get(this._name) as TypedParam<T>;\n\t\tif (param) {\n\t\t\tawait param.compute(); //node[node.param_cache_name(this._name)]\n\t\t\tconst value = param.value;\n\n\t\t\tif ((value != null && this.has_value_changed(value)) || this.is_video_texture()) {\n\t\t\t\t// this._update_cached_value(value);\n\t\t\t\t// console.log(this._name, value)\n\n\t\t\t\tswitch (this._type) {\n\t\t\t\t\tcase ParamType.OPERATOR_PATH: {\n\t\t\t\t\t\tawait this.set_uniform_value_from_texture((<unknown>param) as OperatorPathParam, uniform);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase ParamType.RAMP: {\n\t\t\t\t\t\tthis.set_uniform_value_from_ramp((<unknown>param) as RampParam, uniform);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\tuniform.value = param.value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// resolve()\n\t\t\t} // else {\n\t\t\t//\tresolve()\n\t\t\t//}\n\t\t\t// })\n\t\t}\n\t}\n\n\tasync set_uniform_value_from_texture(param: OperatorPathParam, uniform: IUniform) {\n\t\t// this._texture_loader = this._texture_loader || new CoreTextureLoader(node, node.param(this.name()))\n\n\t\t// // param.graph_disconnect_predecessors()\n\t\t// const texture = await this._texture_loader.load_texture_from_url_or_op( url );\n\t\t// uniform.value = texture\n\t\tconst found_node = param.found_node();\n\t\tif (found_node) {\n\t\t\tconst container = await found_node.request_container();\n\t\t\tconst texture = container.texture();\n\t\t\tuniform.value = texture;\n\t\t} else {\n\t\t\tuniform.value = null;\n\t\t}\n\t}\n\n\tset_uniform_value_from_ramp(param: RampParam, uniform: IUniform) {\n\t\tuniform.value = param.ramp_texture();\n\t}\n\n\thas_value_changed(new_value: ParamValuesTypeMap[T]): boolean {\n\t\tconst param_constructor = ParamConstructorByType[this._type];\n\t\tif (this._cached_param_value) {\n\t\t\tconst has_changed = !param_constructor.are_values_equal(new_value, this._cached_param_value);\n\t\t\tif (has_changed) {\n\t\t\t\tthis._cached_param_value = param_constructor.clone_value(new_value);\n\t\t\t}\n\t\t\treturn has_changed;\n\t\t} else {\n\t\t\tthis._cached_param_value = param_constructor.clone_value(new_value);\n\t\t\treturn false;\n\t\t}\n\n\t\t// let has_changed = false;\n\t\t// if (this._type == ParamType.RAMP) {\n\t\t// \thas_changed = new_value.uuid() != this._cached_param_value;\n\t\t// \t// if(has_changed){ this._cached_param_value = new_value.uuid() }\n\t\t// } else {\n\t\t// \tif (this._cached_param_value != null) {\n\t\t// \t\tif (lodash_isString(new_value) || lodash_isNumber(new_value)) {\n\t\t// \t\t\t// console.log(\"new f\", new_value, this._cached_param_value)\n\t\t// \t\t\thas_changed = this._cached_param_value != new_value;\n\t\t// \t\t} else {\n\t\t// \t\t\tif (new_value != null) {\n\t\t// \t\t\t\t// console.log(\"new v\", new_value, this._cached_param_value)\n\t\t// \t\t\t\thas_changed = new_value.toArray().join('.') != this._cached_param_value.toArray().join('.');\n\t\t// \t\t\t} else {\n\t\t// \t\t\t\thas_changed = this._cached_param_value != new_value;\n\t\t// \t\t\t}\n\t\t// \t\t}\n\t\t// \t} else {\n\t\t// \t\thas_changed = true;\n\t\t// \t}\n\t\t// \t// this._cached_param_value = new_value\n\t\t// }\n\t\t// return has_changed;\n\t}\n\t// private _update_cached_value(new_value) {\n\t// \t// console.log(\"_update_cached_value\", this._name, new_value)\n\t// \tif (this._type == 'ramp') {\n\t// \t\tthis._cached_param_value = new_value.uuid();\n\t// \t} else {\n\t// \t\tif (lodash_isString(new_value) || lodash_isNumber(new_value)) {\n\t// \t\t\tthis._cached_param_value = new_value;\n\t// \t\t} else {\n\t// \t\t\t// make sure to copy the value, not assign to it\n\t// \t\t\t// otherwise we won't detect changes (since the objects would be the same)\n\t// \t\t\tthis._cached_param_value = this._cached_param_value || new_value.clone();\n\t// \t\t\tthis._cached_param_value.copy(new_value);\n\t// \t\t}\n\t// \t}\n\t// }\n\n\tis_video_texture(): boolean {\n\t\tlet result = false;\n\t\tconst uniform = this.uniform;\n\t\tif (uniform) {\n\t\t\tconst value = uniform.value;\n\t\t\tif (value) {\n\t\t\t\tresult = value.constructor == VideoTexture;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n}\n","import {ParamConfig} from '../configs/ParamConfig';\nimport {ParamType} from '../../../../poly/ParamType';\nimport {ParamInitValuesTypeMap} from '../../../../params/types/ParamInitValuesTypeMap';\n\nexport class ParamConfigsController {\n\tprivate _param_configs: ParamConfig<ParamType>[] = [];\n\n\treset() {\n\t\tthis._param_configs = [];\n\t}\n\n\tpush(param_config: ParamConfig<ParamType>) {\n\t\tthis._param_configs.push(param_config);\n\t}\n\tcreate_and_push<T extends ParamType>(\n\t\ttype: T,\n\t\tname: string,\n\t\tdefault_value: ParamInitValuesTypeMap[T],\n\t\tuniform_name: string\n\t) {\n\t\tconst param_config = new ParamConfig(type, name, default_value, uniform_name);\n\t\tthis._param_configs.push(param_config);\n\t}\n\n\tget list(): Readonly<ParamConfig<ParamType>[]> {\n\t\treturn this._param_configs;\n\t}\n}\n","import {GlobalsGlNode} from '../../Globals';\nimport {ConnectionPointType} from '../../../utils/connections/ConnectionPointType';\nimport {BaseGlNodeType} from '../../_Base';\nimport {ShadersCollectionController} from '../utils/ShadersCollectionController';\n\nexport abstract class GlobalsBaseController {\n\tprivate static __next_id: number = 0;\n\tprivate _id: number;\n\n\tconstructor() {\n\t\tthis._id = GlobalsBaseController.__next_id++;\n\t}\n\tid() {\n\t\treturn this._id;\n\t}\n\n\thandle_globals_node(\n\t\tglobals_node: GlobalsGlNode,\n\t\toutput_name: string,\n\t\tshaders_collection_controller: ShadersCollectionController\n\t\t// definitions_by_shader_name: Map<ShaderName, BaseGLDefinition[]>,\n\t\t// body_lines_by_shader_name: Map<ShaderName, string[]>,\n\t\t// body_lines: string[],\n\t\t// dependencies: ShaderName[],\n\t\t// shader_name: ShaderName\n\t): void {}\n\n\tabstract read_attribute(\n\t\tnode: BaseGlNodeType,\n\t\tgl_type: ConnectionPointType,\n\t\tattrib_name: string,\n\t\tshaders_collection_controller: ShadersCollectionController\n\t): string | undefined;\n}\n","import lodash_compact from 'lodash/compact';\nimport lodash_uniq from 'lodash/uniq';\n// import {BaseGlNodeType} from '../../gl/_Base';\n// import {OutputGlNode} from '../gl/Output';\nimport {CoreGraph} from '../../../../core/graph/CoreGraph';\nimport {BaseNodeType, TypedNode} from '../../_Base';\nimport {TypedAssembler} from './BaseAssembler';\nimport {MapUtils} from '../../../../core/MapUtils';\nimport {ShaderName} from './ShaderName';\n\ntype NumberByString = Map<string, number>;\ntype BooleanByString = Map<string, boolean>;\ntype BooleanByStringByShaderName = Map<ShaderName, BooleanByString>;\ntype StringArrayByString = Map<string, string[]>;\n\n// interface BaseNodeGlArrayByString {\n// \t[propName: string]: BaseNodeGl[]\n// }\n// interface StringArrayByString {\n// \t[propName: string]: string[]\n// }\n\n// import {LineType, LINE_TYPES} from './CodeBuilder'\n\n// const VERTEX_INPUT_NAMES = [\n// \t'position',\n// \t'normal',\n// \t'gl_PointSize'\n// ]\n// const FRAGMENT_INPUT_NAMES = [\n// \t'color',\n// \t'alpha'\n// ]\n\nexport class TypedNodeTraverser<T extends TypedNode<any, T, any>> {\n\tprivate _leaves_graph_id: BooleanByStringByShaderName = new Map();\n\tprivate _graph_ids_by_shader_name: BooleanByStringByShaderName = new Map();\n\tprivate _outputs_by_graph_id: StringArrayByString = new Map();\n\tprivate _depth_by_graph_id: NumberByString = new Map();\n\tprivate _graph_id_by_depth: Map<number, string[]> = new Map();\n\tprivate _graph: CoreGraph;\n\tprivate _shader_name!: ShaderName;\n\n\tconstructor(private _assembler: TypedAssembler<T>, private _gl_parent_node: BaseNodeType) {\n\t\tthis._graph = this._gl_parent_node.scene.graph;\n\t}\n\n\tprivate reset() {\n\t\tthis._leaves_graph_id.clear();\n\t\tthis._outputs_by_graph_id.clear();\n\t\tthis._depth_by_graph_id.clear();\n\t\tthis._graph_id_by_depth.clear();\n\n\t\tthis.shader_names().forEach((shader_name) => {\n\t\t\tthis._graph_ids_by_shader_name.set(shader_name, new Map());\n\t\t});\n\t}\n\n\tshader_names() {\n\t\treturn this._assembler.shader_names;\n\t}\n\tinput_names_for_shader_name(root_node: T, shader_name: ShaderName) {\n\t\treturn this._assembler.input_names_for_shader_name(root_node, shader_name);\n\t}\n\n\ttraverse(root_nodes: T[]) {\n\t\tthis.reset();\n\n\t\tfor (let shader_name of this.shader_names()) {\n\t\t\tthis._leaves_graph_id.set(shader_name, new Map());\n\t\t}\n\n\t\tfor (let shader_name of this.shader_names()) {\n\t\t\tthis._shader_name = shader_name;\n\t\t\tfor (let root_node of root_nodes) {\n\t\t\t\tthis.find_leaves_from_root_node(root_node);\n\t\t\t\tthis.set_nodes_depth();\n\t\t\t}\n\t\t}\n\n\t\t// graph_ids.forEach((graph_id) => {\n\t\tthis._depth_by_graph_id.forEach((depth: number, graph_id: string) => {\n\t\t\tif (depth != null) {\n\t\t\t\t// this._graph_id_by_depth.set(depth, this._graph_id_by_depth.get(depth) || []);\n\t\t\t\t// this._graph_id_by_depth.get(depth)?.push(graph_id);\n\t\t\t\tMapUtils.push_on_array_at_entry(this._graph_id_by_depth, depth, graph_id);\n\t\t\t}\n\t\t});\n\t}\n\n\tleaves_from_nodes(nodes: T[]) {\n\t\tthis._shader_name = ShaderName.LEAVES_FROM_NODES_SHADER;\n\t\tthis._graph_ids_by_shader_name.set(this._shader_name, new Map());\n\t\tthis._leaves_graph_id.set(this._shader_name, new Map());\n\t\tfor (let node of nodes) {\n\t\t\tthis.find_leaves(node);\n\t\t}\n\n\t\tconst node_ids: string[] = [];\n\t\tthis._leaves_graph_id.get(this._shader_name)?.forEach((value: boolean, key: string) => {\n\t\t\tnode_ids.push(key);\n\t\t});\n\t\treturn this._graph.nodes_from_ids(node_ids) as T[];\n\t}\n\n\tnodes_for_shader_name(shader_name: ShaderName) {\n\t\tconst depths: number[] = [];\n\t\tthis._graph_id_by_depth.forEach((value: string[], key: number) => {\n\t\t\tdepths.push(key);\n\t\t});\n\t\tdepths.sort((a, b) => a - b);\n\t\tconst nodes: T[] = [];\n\t\tdepths.forEach((depth) => {\n\t\t\tconst graph_ids_for_depth = this._graph_id_by_depth.get(depth);\n\t\t\tif (graph_ids_for_depth) {\n\t\t\t\tgraph_ids_for_depth.forEach((graph_id: string) => {\n\t\t\t\t\tconst is_present = this._graph_ids_by_shader_name.get(shader_name)?.get(graph_id);\n\t\t\t\t\tif (is_present) {\n\t\t\t\t\t\tconst node = this._graph.node_from_id(graph_id) as T;\n\t\t\t\t\t\tnodes.push(node);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\treturn nodes;\n\t}\n\tsorted_nodes() {\n\t\tconst depths: number[] = [];\n\t\tthis._graph_id_by_depth.forEach((ids: string[], depth: number) => {\n\t\t\tdepths.push(depth);\n\t\t});\n\t\tdepths.sort((a, b) => a - b);\n\t\tconst nodes: T[] = [];\n\t\tdepths.forEach((depth) => {\n\t\t\tconst graph_ids_for_depth = this._graph_id_by_depth.get(depth);\n\t\t\tif (graph_ids_for_depth) {\n\t\t\t\tfor (let graph_id of graph_ids_for_depth) {\n\t\t\t\t\tconst node = this._graph.node_from_id(graph_id) as T;\n\t\t\t\t\tif (node) {\n\t\t\t\t\t\tnodes.push(node);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn nodes;\n\t}\n\tprivate find_leaves_from_root_node(root_node: T) {\n\t\t// if(this._shader_name == ShaderName.VERTEX){\n\t\t// this._leaves_graph_id[this._shader_name] = {}\n\t\tthis._graph_ids_by_shader_name.get(this._shader_name)?.set(root_node.graph_node_id, true);\n\n\t\tconst input_names = this.input_names_for_shader_name(root_node, this._shader_name);\n\t\tif (input_names) {\n\t\t\tfor (let input_name of input_names) {\n\t\t\t\t// if (root_node.type == 'output') {\n\t\t\t\tconst input = root_node.io.inputs.named_input(input_name);\n\t\t\t\tif (input) {\n\t\t\t\t\tMapUtils.push_on_array_at_entry(\n\t\t\t\t\t\tthis._outputs_by_graph_id,\n\t\t\t\t\t\tinput.graph_node_id,\n\t\t\t\t\t\troot_node.graph_node_id\n\t\t\t\t\t);\n\t\t\t\t\tthis.find_leaves(input);\n\t\t\t\t}\n\t\t\t\t// TODO: typescript - GL - check that I dont need to consider the Attrib as a special case\n\t\t\t\t// } else {\n\t\t\t\t// \t// if attribute\n\t\t\t\t// \tconst input = root_node.io.inputs.connected_named_input();\n\t\t\t\t// \tif (input) {\n\t\t\t\t// \t\tthis.find_leaves(input);\n\t\t\t\t// \t}\n\t\t\t\t// }\n\t\t\t}\n\t\t}\n\t\t// const position_input = this._output.named_input('position')\n\t\t// const normal_input = this._output.named_input('normal')\n\t\t// const instancePosition_input = this._output.named_input('instancePosition')\n\t\t// if(position_input){ this.find_leaves(position_input) }\n\t\t// if(normal_input){ this.find_leaves(normal_input) }\n\t\t// if(instancePosition_input){ this.find_leaves(instancePosition_input) }\n\t\t// }\n\t\t// if(this._shader_name == ShaderName.FRAGMENT){\n\t\t// \tthis._leaves_graph_id[this._shader_name] = {}\n\t\t// \tFRAGMENT_INPUT_NAMES.forEach(name=>{\n\t\t// \t\tconst input = this._output.named_input(name)\n\t\t// \t\tif(input){\n\t\t// \t\t\tthis.find_leaves(input)\n\t\t// \t\t}\n\t\t// \t})\n\t\t// \t// const color_input = this._output.named_input('color')\n\t\t// \t// const alpha_input = this._output.named_input('alpha')\n\t\t// \t// if(color_input){ this.find_leaves(color_input) }\n\t\t// \t// if(alpha_input){ this.find_leaves(alpha_input) }\n\t\t// }\n\n\t\tthis._outputs_by_graph_id.forEach((outputs: string[], graph_id: string) => {\n\t\t\tthis._outputs_by_graph_id.set(graph_id, lodash_uniq(outputs));\n\t\t});\n\t}\n\n\tprivate find_leaves(node: T) {\n\t\tthis._graph_ids_by_shader_name.get(this._shader_name)?.set(node.graph_node_id, true);\n\n\t\tconst inputs = lodash_compact(node.io.inputs.inputs());\n\t\tconst input_graph_ids = lodash_uniq(inputs.map((n) => n.graph_node_id));\n\t\tconst unique_inputs = input_graph_ids.map((graph_id) => this._graph.node_from_id(graph_id)) as T[];\n\t\tif (unique_inputs.length > 0) {\n\t\t\t// const promises = unique_inputs.forEach((input)=>{\n\t\t\tfor (let input of unique_inputs) {\n\t\t\t\tMapUtils.push_on_array_at_entry(this._outputs_by_graph_id, input.graph_node_id, node.graph_node_id);\n\n\t\t\t\tthis.find_leaves(input);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._leaves_graph_id.get(this._shader_name)!.set(node.graph_node_id, true);\n\t\t}\n\t}\n\n\tprivate set_nodes_depth() {\n\t\tthis._leaves_graph_id.forEach((booleans_by_graph_id, shader_name) => {\n\t\t\tbooleans_by_graph_id.forEach((boolean, graph_id) => {\n\t\t\t\tthis.set_node_depth(graph_id);\n\t\t\t});\n\t\t});\n\t\t// const leave_ids = Object.keys(this._leaves_graph_id[this._shader_name]);\n\t\t// leave_ids.forEach((graph_id) => {\n\t\t// \tthis.set_node_depth(graph_id);\n\t\t// });\n\t}\n\n\tprivate set_node_depth(graph_id: string, depth: number = 0) {\n\t\tconst current_depth = this._depth_by_graph_id.get(graph_id);\n\t\tif (current_depth != null) {\n\t\t\tthis._depth_by_graph_id.set(graph_id, Math.max(current_depth, depth));\n\t\t} else {\n\t\t\tthis._depth_by_graph_id.set(graph_id, depth);\n\t\t}\n\n\t\t// const node = this._graph.node_from_id(graph_id);\n\n\t\tconst output_ids = this._outputs_by_graph_id.get(graph_id);\n\t\tif (output_ids) {\n\t\t\toutput_ids.forEach((output_id) => {\n\t\t\t\tthis.set_node_depth(output_id, depth + 1);\n\t\t\t});\n\t\t}\n\t}\n}\n","import {TypedGlNode} from './_Base';\n// import {ParamType} from '../../../Engine/Param/_Module';\n// import {Connection} from './GlData';\n// import {Definition} from './Definition/_Module';\n// import {ShaderName} from './Assembler/Util/CodeBuilder';\n\n// list of globals\n// https://www.khronos.org/opengl/wiki/Built-in_Variable_(GLSL)\n// gl_PointCoord\n\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {ShadersCollectionController} from './code/utils/ShadersCollectionController';\nclass GlobalsGlParamsConfig extends NodeParamsConfig {}\nconst ParamsConfig = new GlobalsGlParamsConfig();\n\nexport class GlobalsGlNode extends TypedGlNode<GlobalsGlParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'globals';\n\t}\n\n\tcreate_params() {\n\t\tthis.material_node?.assembler_controller.add_globals_params(this);\n\t}\n\n\tset_lines(shaders_collection_controller: ShadersCollectionController) {\n\t\t// if (lines_controller.shader_name) {\n\t\tthis.material_node?.assembler_controller?.assembler.set_node_lines_globals(this, shaders_collection_controller);\n\t\t// }\n\t\t// const vertex_definitions = []\n\t\t// const fragment_definitions = []\n\t\t// const definitions = []\n\t\t// // const vertex_body_lines = []\n\t\t// const fragment_body_lines = []\n\t\t// const body_lines = []\n\n\t\t// const shader_config = this.shader_config(this._shader_name)\n\t\t// const dependencies = shader_config.dependencies()\n\n\t\t// const definitions_by_shader_name = {}\n\t\t// definitions_by_shader_name[this._shader_name] = []\n\t\t// for(let dependency of dependencies){ definitions_by_shader_name[dependency] = [] }\n\n\t\t// const body_lines_by_shader_name = {}\n\t\t// body_lines_by_shader_name[this._shader_name] = []\n\t\t// for(let dependency of dependencies){ body_lines_by_shader_name[dependency] = [] }\n\n\t\t// let definition\n\t\t// let body_line\n\t\t// for(let output_name of this.used_output_names()){\n\t\t// \tconst var_name = this.gl_var_name(output_name)\n\n\t\t// \tswitch (output_name){\n\t\t// \t\tcase 'frame':\n\t\t// \t\t\tdefinition = new Definition.Uniform(this, 'float', output_name)\n\t\t// \t\t\t// vertex_definitions.push(definition)\n\t\t// \t\t\t// fragment_definitions.push(definition)\n\t\t// \t\t\tdefinitions_by_shader_name[this._shader_name].push(definition)\n\n\t\t// \t\t\tbody_line = `float ${var_name} = ${output_name}`\n\t\t// \t\t\tfor(let dependency of dependencies){\n\t\t// \t\t\t\tdefinitions_by_shader_name[dependency].push(definition)\n\t\t// \t\t\t\tbody_lines_by_shader_name[dependency].push(body_line)\n\t\t// \t\t\t}\n\n\t\t// \t\t\t// vertex_body_lines.push(`float ${var_name} = ${output_name}`)\n\t\t// \t\t\tbody_lines.push(body_line)\n\t\t// \t\t\tbreak;\n\t\t// \t\tcase 'gl_FragCoord':\n\t\t// \t\t\tif( this._shader_name == ShaderName.FRAGMENT ){\n\t\t// \t\t\t\tfragment_body_lines.push(`vec4 ${var_name} = gl_FragCoord`)\n\t\t// \t\t\t}\n\t\t// \t\t\tbreak;\n\t\t// \t\tcase 'gl_PointCoord':\n\t\t// \t\t\tif( this._shader_name == ShaderName.FRAGMENT ){\n\t\t// \t\t\t\tif(this.parent().is_point_material()){\n\t\t// \t\t\t\t\tfragment_body_lines.push(`vec2 ${var_name} = gl_PointCoord`)\n\t\t// \t\t\t\t}\n\t\t// \t\t\t}\n\t\t// \t\t\tbreak;\n\t\t// \t\tdefault:\n\t\t// \t\t\tconst named_output = this.named_output_by_name(output_name)\n\t\t// \t\t\tconst gl_type = named_output.gl_type()\n\t\t// \t\t\tdefinition = new Definition.Varying(this, gl_type, var_name)\n\t\t// \t\t\tdefinitions_by_shader_name[this._shader_name].push(definition)\n\n\t\t// \t\t\tbody_line = `${var_name} = vec3(${output_name})`\n\t\t// \t\t\tfor(let dependency of dependencies){\n\t\t// \t\t\t\tdefinitions_by_shader_name[dependency].push(definition)\n\t\t// \t\t\t\tbody_lines_by_shader_name[dependency].push(body_line)\n\t\t// \t\t\t}\n\t\t// \t\t\tif(dependencies.length == 0){\n\t\t// \t\t\t\tbody_lines.push(body_line)\n\t\t// \t\t\t}\n\t\t// \t}\n\t\t// }\n\t\t// // this.set_vertex_definitions(vertex_definitions)\n\t\t// // this.set_fragment_definitions(fragment_definitions)\n\t\t// for(let shader_name of Object.keys(definitions_by_shader_name)){\n\t\t// \tthis.set_definitions(definitions_by_shader_name[shader_name], shader_name)\n\t\t// }\n\t\t// for(let shader_name of Object.keys(body_lines_by_shader_name)){\n\t\t// \tthis.add_body_lines(body_lines_by_shader_name[shader_name], shader_name)\n\t\t// }\n\t\t// // this.add_definitions(definitions)\n\t\t// // this.set_vertex_body_lines(vertex_body_lines)\n\t\t// // this.set_fragment_body_lines(fragment_body_lines)\n\n\t\t// this.add_body_lines(body_lines)\n\t}\n}\n","import {AssemblerControllerNode} from '../Controller';\n\nexport class GlNodeFinder {\n\tstatic find_output_nodes(node: AssemblerControllerNode) {\n\t\tconst nodes = node.nodes_by_type('output');\n\t\treturn nodes;\n\t\t// if (nodes.length > 1) {\n\t\t// \tnode.states.error.set('only one output node allowed');\n\t\t// }\n\t\t// return nodes[0];\n\t}\n\tstatic find_attribute_export_nodes(node: AssemblerControllerNode) {\n\t\tconst nodes = node.nodes_by_type('attribute');\n\t\treturn nodes.filter((node) => {\n\t\t\t// do not use attributes that are used as an input, as export\n\t\t\t// return (node.used_output_names().length == 0) &&\n\t\t\treturn node.is_exporting;\n\t\t});\n\t}\n}\n","import {BaseGlShaderAssembler} from '../_Base';\nimport {IUniforms} from '../../../../../../core/geometry/Material';\n// import {GlobalsTextureHandler} from '../../../../../Engine/Node/Gl/Assembler/Globals/Texture'\nimport {ThreeToGl} from '../../../../../../core/ThreeToGl';\nimport TemplateDefault from '../../templates/textures/Default.frag.glsl';\n\nimport {ShaderConfig} from '../../configs/ShaderConfig';\nimport {VariableConfig} from '../../configs/VariableConfig';\nimport {ShaderName} from '../../../../utils/shaders/ShaderName';\nimport {IUniformsWithTime} from '../../../../../scene/utils/UniformsController';\nimport {OutputGlNode} from '../../../Output';\nimport {ParamType} from '../../../../../poly/ParamType';\nimport {GlobalsGlNode} from '../../../Globals';\nimport {TypedNamedConnectionPoint} from '../../../../utils/connections/NamedConnectionPoint';\nimport {ConnectionPointType} from '../../../../utils/connections/ConnectionPointType';\nimport {ShadersCollectionController} from '../../utils/ShadersCollectionController';\nimport {UniformGLDefinition} from '../../../utils/GLDefinition';\n// import {BaseGlNodeType} from '../../../_Base';\n\nexport class ShaderAssemblerTexture extends BaseGlShaderAssembler {\n\tprivate _uniforms: IUniforms | undefined;\n\n\tget _template_shader() {\n\t\treturn {\n\t\t\tfragmentShader: TemplateDefault,\n\t\t\tvertexShader: undefined,\n\t\t\tuniforms: undefined,\n\t\t};\n\t}\n\n\t// async compile() {\n\t// \tawait this.update_fragment_shader();\n\t// }\n\n\tfragment_shader() {\n\t\treturn this._shaders_by_name.get(ShaderName.FRAGMENT);\n\t}\n\t// async get_shaders(){\n\t// \tawait this.update_shaders()\n\t// \treturn this._shaders_by_name\n\t// }\n\n\tuniforms() {\n\t\treturn this._uniforms;\n\t}\n\t// _create_material() {\n\t// \treturn undefined;\n\t// }\n\n\tasync update_fragment_shader() {\n\t\tthis._lines = new Map();\n\t\tthis._shaders_by_name = new Map();\n\t\tfor (let shader_name of this.shader_names) {\n\t\t\tif (shader_name == ShaderName.FRAGMENT) {\n\t\t\t\tconst template = this._template_shader.fragmentShader;\n\t\t\t\tthis._lines.set(shader_name, template.split('\\n'));\n\t\t\t}\n\t\t}\n\t\tif (this._root_nodes.length > 0) {\n\t\t\t// this._output_node.set_assembler(this)\n\t\t\tawait this.build_code_from_nodes(this._root_nodes);\n\n\t\t\tthis._build_lines();\n\t\t}\n\n\t\tthis._uniforms = this._uniforms || {};\n\t\tthis.add_uniforms(this._uniforms);\n\t\t// const new_uniforms = this.build_uniforms({}, this._uniforms || {});\n\t\t// this._uniforms = new_uniforms;\n\t\t// this._uniforms = this._uniforms || {};\n\t\t// for (let uniform_name of Object.keys(new_uniforms)) {\n\t\t// \tthis._uniforms[uniform_name] = new_uniforms[uniform_name];\n\t\t// }\n\t\t// this._material.uniforms = this.build_uniforms(template_shader)\n\t\tfor (let shader_name of this.shader_names) {\n\t\t\tconst lines = this._lines.get(shader_name);\n\t\t\tif (lines) {\n\t\t\t\tthis._shaders_by_name.set(shader_name, lines.join('\\n'));\n\t\t\t}\n\t\t}\n\n\t\t// That's actually useless, since this doesn't make the texture recook\n\t\tconst scene = this._gl_parent_node.scene;\n\t\tconst id = this._gl_parent_node.graph_node_id;\n\t\tif (this.uniforms_time_dependent()) {\n\t\t\tif (this._uniforms) {\n\t\t\t\tscene.uniforms_controller.add_time_dependent_uniform_owner(id, this._uniforms as IUniformsWithTime);\n\t\t\t}\n\t\t} else {\n\t\t\tscene.uniforms_controller.remove_time_dependent_uniform_owner(id);\n\t\t}\n\t}\n\n\t//\n\t//\n\t// CHILDREN NODES PARAMS\n\t//\n\t//\n\tadd_output_params(output_child: OutputGlNode) {\n\t\toutput_child.add_param(ParamType.COLOR, 'color', [1, 1, 1], {hidden: true});\n\t\toutput_child.add_param(ParamType.FLOAT, 'alpha', 1, {hidden: true});\n\t}\n\tadd_globals_params(globals_node: GlobalsGlNode) {\n\t\tglobals_node.io.outputs.set_named_output_connection_points([\n\t\t\tnew TypedNamedConnectionPoint('gl_FragCoord', ConnectionPointType.VEC2),\n\t\t\tnew TypedNamedConnectionPoint('time', ConnectionPointType.FLOAT),\n\t\t\t// new Connection.Vec2('resolution'),\n\t\t]);\n\t}\n\n\t//\n\t//\n\t// CONFIGS\n\t//\n\t//\n\tcreate_shader_configs() {\n\t\treturn [new ShaderConfig(ShaderName.FRAGMENT, ['color', 'alpha'], [])];\n\t}\n\tcreate_variable_configs() {\n\t\treturn [\n\t\t\tnew VariableConfig('color', {\n\t\t\t\tprefix: 'diffuseColor.xyz = ',\n\t\t\t}),\n\t\t\tnew VariableConfig('alpha', {\n\t\t\t\tprefix: 'diffuseColor.a = ',\n\t\t\t\tdefault: '1.0',\n\t\t\t}),\n\t\t];\n\t}\n\n\t//\n\t//\n\t// TEMPLATE HOOKS\n\t//\n\t//\n\tprotected insert_define_after(shader_name: ShaderName) {\n\t\treturn '// INSERT DEFINE';\n\t}\n\tprotected insert_body_after(shader_name: ShaderName) {\n\t\treturn '// INSERT BODY';\n\t}\n\tprotected lines_to_remove(shader_name: ShaderName) {\n\t\treturn ['// INSERT DEFINE', '// INSERT BODY'];\n\t}\n\n\thandle_gl_FragCoord(body_lines: string[], shader_name: ShaderName, var_name: string) {\n\t\tif (shader_name == 'fragment') {\n\t\t\tbody_lines.push(`vec2 ${var_name} = vec2(gl_FragCoord.x / resolution.x, gl_FragCoord.y / resolution.y)`);\n\t\t}\n\t}\n\n\t//\n\t//\n\t// TEMPLATE CODE REPLACEMENT\n\t//\n\t//\n\t// add_export_body_line(\n\t// \texport_node: BaseGlNodeType,\n\t// \tshader_name: ShaderName,\n\t// \tinput_name: string,\n\t// \tinput: BaseGlNodeType,\n\t// \tvariable_name: string\n\t// ) {\n\t// \t// let input\n\t// \t// let variable_name\n\t// \t// if(export_node.type() == 'output'){\n\t// \t// \tinput = export_node.named_input(input_name)\n\t// \t// \tvariable_name = input_name\n\t// \t// } else {\n\t// \t// \t// if attribute\n\t// \t// \tinput = export_node.connected_named_input()\n\t// \t// \tvariable_name = export_node.attribute_name()\n\t// \t// }\n\n\t// \tif (input) {\n\t// \t\tconst var_input = export_node.variable_for_input(input_name);\n\t// \t\tconst new_var = ThreeToGl.vector3(var_input);\n\t// \t\tif (new_var) {\n\t// \t\t\t// const texture_variable = this._texture_allocations_controller.find_variable(\n\t// \t\t\t// \texport_node,\n\t// \t\t\t// \tshader_name,\n\t// \t\t\t// \tvariable_name\n\t// \t\t\t// )\n\t// \t\t\tconst texture_variable = this._texture_allocations_controller.variable(variable_name);\n\t// \t\t\t// if we are in the texture this variable is allocated to, we write it back\n\t// \t\t\tif (texture_variable.allocation().shader_name() == shader_name) {\n\t// \t\t\t\tconst component = texture_variable.component();\n\n\t// \t\t\t\tconst line = `gl_FragColor.${component} = ${new_var}`;\n\t// \t\t\t\texport_node.add_body_lines([line], shader_name);\n\t// \t\t\t}\n\t// \t\t}\n\t// \t}\n\t// }\n\t// add_import_body_line(\n\t// \timport_node: BaseNodeGl,\n\t// \tshader_name: ShaderName,\n\t// \toutput_name: string,\n\t// \tvariable_name: string\n\t// \t){\n\t// \t\tthrow \"not sure I want to use this method anymore\"\n\t// \tconst named_output = import_node.named_output_by_name(output_name)\n\t// \tconst gl_type = named_output.gl_type()\n\n\t// \tconst map_name = `texture_${shader_name}`\n\t// \tconst definition = new Definition.Uniform(import_node, 'sampler2D', map_name)\n\t// \t// definitions_by_shader_name[import_node._shader_name].push(definition)\n\t// \timport_node.add_definitions([definition])\n\n\t// \tconst var_name = import_node.gl_var_name(output_name)\n\n\t// \tconst texture_variable = this._texture_allocations_controller.find_variable(\n\t// \t\timport_node,\n\t// \t\tshader_name,\n\t// \t\tvariable_name\n\t// \t)\n\t// \tif(!texture_variable){\n\t// \t\tthis._texture_allocations_controller.print(this._gl_parent_node.scene())\n\t// \t}\n\t// \tconst component = texture_variable.component()\n\t// \tconst lines = [\n\t// \t\t`${gl_type} ${var_name} = texture2D( ${map_name}, particleUV ).${component}`,\n\t// \t\t`gl_FragColor.${component} = ${var_name}`\n\t// \t]\n\t// \timport_node.add_body_lines(lines, shader_name)\n\t// }\n\n\tset_node_lines_output(output_node: OutputGlNode, shaders_collection_controller: ShadersCollectionController) {\n\t\tconst input_names = this.input_names_for_shader_name(\n\t\t\toutput_node,\n\t\t\tshaders_collection_controller.current_shader_name\n\t\t);\n\t\tif (input_names) {\n\t\t\tfor (let input_name of input_names) {\n\t\t\t\tconst input = output_node.io.inputs.named_input(input_name);\n\n\t\t\t\tif (input) {\n\t\t\t\t\tconst gl_var = output_node.variable_for_input(input_name);\n\n\t\t\t\t\tlet body_line: string | undefined;\n\t\t\t\t\tif (input_name == 'color') {\n\t\t\t\t\t\tbody_line = `diffuseColor.xyz = ${ThreeToGl.any(gl_var)}`;\n\t\t\t\t\t}\n\t\t\t\t\tif (input_name == 'alpha') {\n\t\t\t\t\t\tbody_line = `diffuseColor.a = ${ThreeToGl.any(gl_var)}`;\n\t\t\t\t\t}\n\t\t\t\t\tif (body_line) {\n\t\t\t\t\t\tshaders_collection_controller.add_body_lines(output_node, [body_line]);\n\t\t\t\t\t}\n\t\t\t\t\t// this.add_export_body_line(\n\t\t\t\t\t// \toutput_node,\n\t\t\t\t\t// \tshaders_collection_controller.current_shader_name,\n\t\t\t\t\t// \tinput_name,\n\t\t\t\t\t// \tinput,\n\t\t\t\t\t// \tvariable_name\n\t\t\t\t\t// \t)\n\t\t\t\t} else {\n\t\t\t\t\t// position reads the default attribute position\n\t\t\t\t\t// or maybe there is no need?\n\t\t\t\t\t// if(input_name == 'position'){\n\t\t\t\t\t// \tthis.globals_handler().read_attribute(output_node, 'vec3', 'position')\n\t\t\t\t\t// }\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t// set_node_lines_attribute(attribute_node: Attribute, shader_name: ShaderName){\n\n\t// \tif(attribute_node.is_importing()){\n\t// \t\tconst gl_type = attribute_node.gl_type()\n\t// \t\tconst attribute_name = attribute_node.attribute_name()\n\t// \t\tconst new_value = this.globals_handler().read_attribute(\n\t// \t\t\tattribute_node,\n\t// \t\t\tgl_type,\n\t// \t\t\tattribute_name,\n\t// \t\t\tshader_name\n\t// \t\t\t)\n\t// \t\tconst var_name = attribute_node.gl_var_name(Attribute.output_name())\n\t// \t\tconst body_line = `${gl_type} ${var_name} = ${new_value}`\n\t// \t\tattribute_node.add_body_lines([body_line])\n\n\t// \t\t// re-export to ensure it is available on next frame\n\t// \t\tconst texture_variable = this._texture_allocations_controller.variable(attribute_name)\n\t// \t\tif(texture_variable.allocation().shader_name() == shader_name){\n\n\t// \t\t\tconst variable = this._texture_allocations_controller.variable(attribute_name)\n\t// \t\t\tconst component = variable.component()\n\t// \t\t\tattribute_node.add_body_lines([\n\t// \t\t\t\t`gl_FragColor.${component} = ${var_name}`\n\t// \t\t\t])\n\t// \t\t}\n\n\t// \t\t// this.add_import_body_line(\n\t// \t\t// \tattribute_node,\n\t// \t\t// \tshader_name,\n\t// \t\t// \tAttribute.output_name(),\n\t// \t\t// \tattribute_node.attribute_name()\n\t// \t\t// \t)\n\t// \t}\n\t// \tif(attribute_node.is_exporting()){\n\t// \t\tconst input = attribute_node.connected_named_input()\n\t// \t\tconst variable_name = attribute_node.attribute_name()\n\n\t// \t\tthis.add_export_body_line(\n\t// \t\t\tattribute_node,\n\t// \t\t\tshader_name,\n\t// \t\t\tAttribute.input_name(),\n\t// \t\t\tinput,\n\t// \t\t\tvariable_name\n\t// \t\t\t)\n\t// \t}\n\t// }\n\tset_node_lines_globals(globals_node: GlobalsGlNode, shaders_collection_controller: ShadersCollectionController) {\n\t\t// const vertex_definitions = []\n\t\t// const fragment_definitions = []\n\t\t// const definitions = []\n\t\t// const vertex_body_lines = []\n\t\t// const fragment_body_lines = []\n\t\tconst shader_name = shaders_collection_controller.current_shader_name;\n\t\tconst shader_config = this.shader_config(shader_name);\n\t\tif (!shader_config) {\n\t\t\treturn;\n\t\t}\n\t\tconst body_lines: string[] = [];\n\t\tconst definitions: UniformGLDefinition[] = [];\n\n\t\t// const shader_config = this.shader_config(shader_name)\n\t\t// const dependencies = shader_config.dependencies()\n\n\t\t// const definitions_by_shader_name = {}\n\t\t// definitions_by_shader_name[shader_name] = []\n\t\t// for(let dependency of dependencies){ definitions_by_shader_name[dependency] = [] }\n\n\t\t// const body_lines_by_shader_name = {}\n\t\t// body_lines_by_shader_name[shader_name] = []\n\t\t// for(let dependency of dependencies){ body_lines_by_shader_name[dependency] = [] }\n\n\t\tfor (let output_name of globals_node.io.outputs.used_output_names()) {\n\t\t\tconst var_name = globals_node.gl_var_name(output_name);\n\t\t\t// const globals_shader_name = shaders_collection_controller.current_shader_name;\n\n\t\t\tswitch (output_name) {\n\t\t\t\tcase 'time':\n\t\t\t\t\tdefinitions.push(new UniformGLDefinition(globals_node, ConnectionPointType.FLOAT, output_name));\n\t\t\t\t\t// vertex_definitions.push(definition)\n\t\t\t\t\t// fragment_definitions.push(definition)\n\t\t\t\t\t// definitions_by_shader_name[globals_node._shader_name].push(definition)\n\n\t\t\t\t\tbody_lines.push(`float ${var_name} = ${output_name}`);\n\t\t\t\t\t// for(let dependency of dependencies){\n\t\t\t\t\t// \tdefinitions_by_shader_name[dependency].push(definition)\n\t\t\t\t\t// \tbody_lines_by_shader_name[dependency].push(body_line)\n\t\t\t\t\t// }\n\n\t\t\t\t\t// vertex_body_lines.push(`float ${var_name} = ${output_name}`)\n\t\t\t\t\t// body_lines.push(body_line)\n\t\t\t\t\tthis.set_uniforms_time_dependent();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'gl_FragCoord':\n\t\t\t\t\tthis.handle_gl_FragCoord(body_lines, shader_name, var_name);\n\t\t\t\t\tbreak;\n\t\t\t\t// default:\n\t\t\t\t// \t// this.add_import_body_line(globals_node, shader_name, output_name, output_name)\n\t\t\t\t// \tconst named_output = globals_node.named_output_by_name(output_name)\n\t\t\t\t// \tconst gl_type = named_output.gl_type()\n\n\t\t\t\t// \tconst attrib_read = this.globals_handler().read_attribute(\n\t\t\t\t// \t\tglobals_node,\n\t\t\t\t// \t\tgl_type,\n\t\t\t\t// \t\toutput_name,\n\t\t\t\t// \t\tshader_name\n\t\t\t\t// \t)\n\t\t\t\t// \tbody_line = `${gl_type} ${var_name} = ${attrib_read}`\n\t\t\t\t// \tbody_lines.push(body_line)\n\t\t\t\t// \t//\n\n\t\t\t\t// \t// const map_name = `texture_${output_name}`\n\t\t\t\t// \t// definition = new Definition.Uniform(globals_node, 'sampler2D', map_name)\n\t\t\t\t// \t// definitions_by_shader_name[globals_node._shader_name].push(definition)\n\n\t\t\t\t// \t// body_line = `${gl_type} ${var_name} = texture2D( ${map_name}, particleUV ).xyz`\n\n\t\t\t\t// \t// // // if(dependencies.length == 0){\n\t\t\t\t// \t// body_lines.push(body_line)\n\t\t\t\t// \t// }\n\t\t\t}\n\t\t}\n\n\t\tshaders_collection_controller.add_definitions(globals_node, definitions, shader_name);\n\t\tshaders_collection_controller.add_body_lines(globals_node, body_lines);\n\t\t// this.set_vertex_definitions(vertex_definitions)\n\t\t// this.set_fragment_definitions(fragment_definitions)\n\t\t// for(let shader_name of Object.keys(definitions_by_shader_name)){\n\t\t// \tglobals_node.add_definitions(definitions_by_shader_name[shader_name], shader_name)\n\t\t// }\n\t\t// for(let shader_name of Object.keys(body_lines_by_shader_name)){\n\t\t// \tglobals_node.add_body_lines(body_lines_by_shader_name[shader_name], shader_name)\n\t\t// }\n\t\t// this.add_definitions(definitions)\n\t\t// this.set_vertex_body_lines(vertex_body_lines)\n\t\t// this.set_fragment_body_lines(fragment_body_lines)\n\n\t\t// globals_node.add_body_lines(body_lines)\n\t}\n}\n","export default \"#include <common>\\n\\nuniform vec2 resolution;\\n\\n// INSERT DEFINE\\n\\nvoid main() {\\n\\n\\tvec4 diffuseColor = vec4(1.0,0.0,1.0,1.0);\\n\\n\\n\\t// INSERT BODY\\n\\n\\tgl_FragColor = vec4( diffuseColor );\\n}\"","import {WebGLRenderer} from 'three/src/renderers/WebGLRenderer';\nimport {WebGLRenderTarget} from 'three/src/renderers/WebGLRenderTarget';\nimport {ShaderMaterial} from 'three/src/materials/ShaderMaterial';\nimport {Scene} from 'three/src/scenes/Scene';\nimport {RGBAFormat} from 'three/src/constants';\nimport {PlaneBufferGeometry} from 'three/src/geometries/PlaneGeometry';\nimport {NearestFilter} from 'three/src/constants';\nimport {Mesh} from 'three/src/objects/Mesh';\nimport {HalfFloatType} from 'three/src/constants';\nimport {FloatType} from 'three/src/constants';\nimport {DataTexture} from 'three/src/textures/DataTexture';\nimport {ClampToEdgeWrapping} from 'three/src/constants';\nimport {Camera} from 'three/src/cameras/Camera';\n\n// import NodeBase from '../_Base'\n\n// import Container from '../../Container/Texture'\n// import {CoreImage} from '../../../Core/Image'\n\nimport {TypedCopNode} from './_Base';\n\n// import { GlobalsGeometryHandler } from \"src/Engine/Node/Gl/Assembler/Globals/Geometry\";\nimport {GlAssemblerController} from '../gl/code/Controller';\nimport {ShaderAssemblerTexture} from '../gl/code/assemblers/textures/Texture';\n\nimport {IUniform} from 'three/src/renderers/shaders/UniformsLib';\nexport interface IUniforms {\n\t[uniform: string]: IUniform;\n}\n\nconst PASS_THROUGH_SHADER = `\nvoid main()\t{\n\tgl_Position = vec4( position, 1.0 );\n}\n`;\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {CoreGraphNode} from '../../../core/graph/CoreGraphNode';\nimport {GlobalsGeometryHandler} from '../gl/code/globals/Geometry';\nimport {GlNodeChildrenMap} from '../../poly/registers/Gl';\nimport {BaseGlNodeType} from '../gl/_Base';\nimport {GlNodeFinder} from '../gl/code/utils/NodeFinder';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {CoreSleep} from '../../../core/Sleep';\nclass BuilderCopParamsConfig extends NodeParamsConfig {\n\tresolution = ParamConfig.VECTOR2([256, 256]);\n}\n\nconst ParamsConfig = new BuilderCopParamsConfig();\n\nexport class BuilderCopNode extends TypedCopNode<BuilderCopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'builder';\n\t}\n\tprotected _assembler_controller: GlAssemblerController<\n\t\tShaderAssemblerTexture\n\t> = this._create_assembler_controller();\n\n\tprivate _create_assembler_controller() {\n\t\tconst globals_handler = new GlobalsGeometryHandler();\n\t\tconst assembler_controller = new GlAssemblerController<ShaderAssemblerTexture>(this, ShaderAssemblerTexture);\n\t\tassembler_controller.set_assembler_globals_handler(globals_handler);\n\t\treturn assembler_controller;\n\t}\n\n\tget assembler_controller() {\n\t\treturn this._assembler_controller;\n\t}\n\n\tprivate _texture_mesh: Mesh = new Mesh(new PlaneBufferGeometry(2, 2));\n\tprivate _fragment_shader: string | undefined;\n\tprivate _uniforms: IUniforms | undefined;\n\tprivate _texture_material: ShaderMaterial = new ShaderMaterial({\n\t\tuniforms: {},\n\t\tvertexShader: PASS_THROUGH_SHADER,\n\t\tfragmentShader: '',\n\t});\n\tprivate _texture_scene: Scene = new Scene();\n\tprivate _texture_camera: Camera = new Camera();\n\tprivate _render_target: WebGLRenderTarget | undefined;\n\tprivate _renderer: WebGLRenderer | undefined;\n\tprivate _pixelBuffer: Float32Array | undefined;\n\t// private _assembler: ShaderAssemblerTexture;\n\n\tprotected _children_controller_context = NodeContext.GL;\n\tinitialize_node() {\n\t\tthis.lifecycle.add_on_create_hook(this.assembler_controller.on_create.bind(this.assembler_controller));\n\t\tthis.children_controller?.init();\n\t\tthis._texture_mesh.material = this._texture_material;\n\t\tthis._texture_scene.add(this._texture_mesh);\n\t\tthis._texture_camera.position.z = 1;\n\n\t\t// this._init_common_shader_builder(ShaderAssemblerTexture, {\n\t\t// \thas_display_flag: true\n\t\t// });\n\t\t// this.set_inputs_count_to_zero();\n\n\t\tthis.dirty_controller.add_post_dirty_hook(\n\t\t\t'_reset_if_resolution_changed',\n\t\t\tthis._reset_if_resolution_changed.bind(this)\n\t\t);\n\t\tthis.params.set_post_create_params_hook(() => {\n\t\t\tthis._render_target = this._create_render_target();\n\t\t\tthis._renderer = this._create_renderer(this._render_target);\n\t\t});\n\t}\n\n\tcreate_node<K extends keyof GlNodeChildrenMap>(type: K): GlNodeChildrenMap[K] {\n\t\treturn super.create_node(type) as GlNodeChildrenMap[K];\n\t}\n\tchildren() {\n\t\treturn super.children() as BaseGlNodeType[];\n\t}\n\tnodes_by_type<K extends keyof GlNodeChildrenMap>(type: K): GlNodeChildrenMap[K][] {\n\t\treturn super.nodes_by_type(type) as GlNodeChildrenMap[K][];\n\t}\n\n\tprivate _reset_if_resolution_changed(trigger?: CoreGraphNode) {\n\t\tif (trigger && trigger.graph_node_id == this.p.resolution.graph_node_id) {\n\t\t\tthis._reset();\n\t\t}\n\t}\n\tprivate _reset() {\n\t\tthis._render_target = this._create_render_target();\n\t\tthis._renderer = this._create_renderer(this._render_target);\n\t\tthis._pixelBuffer = this._create_pixel_buffer();\n\t}\n\tprivate _create_pixel_buffer() {\n\t\tconst width = this.pv.resolution.x;\n\t\tconst height = this.pv.resolution.y;\n\t\treturn new Float32Array(width * height * 4);\n\t}\n\n\tasync cook() {\n\t\tawait this.compile_if_required();\n\t\t// await this.assembler_controller.assign_uniform_values();\n\n\t\tthis.render_on_target();\n\t}\n\n\tshaders_by_name() {\n\t\treturn {\n\t\t\tfragment: this._fragment_shader,\n\t\t};\n\t}\n\n\tasync compile_if_required() {\n\t\tif (this.assembler_controller.compile_required()) {\n\t\t\t// && !this.pv.locked){\n\t\t\t// this._texture_material = undefined;\n\t\t\tawait this.run_assembler();\n\t\t\t// const fragment_shader = this.assembler_controller.assembler.fragment_shader();\n\t\t\t// const uniforms = this.assembler_controller.assembler.uniforms();\n\t\t\t// if (fragment_shader && uniforms) {\n\t\t\t// \t// await this.eval_params(this._new_params);\n\t\t\t// \tthis._fragment_shader = fragment_shader;\n\t\t\t// \tthis._uniforms = uniforms;\n\t\t\t// } else {\n\t\t\t// \tthrow 'STOP';\n\t\t\t// }\n\t\t\tthis.assembler_controller.post_compile();\n\t\t}\n\t}\n\tprivate async run_assembler() {\n\t\tconst output_nodes = GlNodeFinder.find_output_nodes(this);\n\t\tif (output_nodes.length > 1) {\n\t\t\tthis.states.error.set('only one output node allowed');\n\t\t\treturn;\n\t\t}\n\t\tconst output_node = output_nodes[0];\n\t\tif (output_node) {\n\t\t\tthis.assembler_controller.assembler.set_root_nodes([output_node]);\n\n\t\t\t// main compilation\n\t\t\tawait this.assembler_controller.assembler.update_fragment_shader();\n\n\t\t\t// receives fragment and uniforms\n\t\t\tconst fragment_shader = this.assembler_controller.assembler.fragment_shader();\n\t\t\tconst uniforms = this.assembler_controller.assembler.uniforms();\n\t\t\tif (fragment_shader && uniforms) {\n\t\t\t\tthis._fragment_shader = fragment_shader;\n\t\t\t\tthis._uniforms = uniforms;\n\t\t\t}\n\n\t\t\t// TODO: remove this once the scene knows how to re-render\n\t\t\t// the render target if it is .uniforms_time_dependent()\n\t\t\tif (this.assembler_controller.assembler.uniforms_time_dependent()) {\n\t\t\t\tthis.states.time_dependent.force_time_dependent();\n\t\t\t} else {\n\t\t\t\tthis.states.time_dependent.unforce_time_dependent();\n\t\t\t}\n\t\t}\n\n\t\tif (this._fragment_shader && this._uniforms) {\n\t\t\tthis._texture_material.fragmentShader = this._fragment_shader;\n\t\t\tthis._texture_material.uniforms = this._uniforms;\n\t\t\tthis._texture_material.needsUpdate = true;\n\t\t\tthis._texture_material.uniforms.resolution = {\n\t\t\t\tvalue: this.pv.resolution,\n\t\t\t};\n\t\t}\n\n\t\t// this._compile_required = false;\n\t}\n\n\tprivate _create_renderer(render_target: WebGLRenderTarget) {\n\t\tconst renderer = new WebGLRenderer({antialias: true});\n\t\trenderer.setPixelRatio(window.devicePixelRatio);\n\t\t// document.body.appendChild( renderer.domElement )\n\t\trenderer.autoClear = false;\n\n\t\trenderer.setRenderTarget(render_target);\n\n\t\treturn renderer;\n\t}\n\n\tasync render_on_target() {\n\t\tconst width = this.pv.resolution.x;\n\t\tconst height = this.pv.resolution.y;\n\n\t\t// var passThruUniforms = {\n\t\t// \tpassThruTexture: { value: null }\n\t\t// };\n\n\t\tif (!(this._renderer && this._render_target)) {\n\t\t\treturn;\n\t\t}\n\t\tthis._renderer.clear();\n\t\tthis._renderer.render(this._texture_scene, this._texture_camera);\n\t\t// renderer.setClearColor( 0x000000 ) // cancels the bg color\n\n\t\t//read the pixel\n\t\tthis._pixelBuffer = this._pixelBuffer || this._create_pixel_buffer();\n\t\tthis._renderer.readRenderTargetPixels(this._render_target, 0, 0, width, height, this._pixelBuffer);\n\n\t\t// renderer.setRenderTarget( null );\n\n\t\t// var pixelBuffer2 = new Uint8Array( width * height * 4 );\n\t\t// var pixelBuffer2 = Uint8Array.from(pixelBuffer)\n\n\t\t// be careful about the type FloatType\n\t\t// as this may require webgl extensions\n\t\t// see https://threejs.org/docs/#api/en/textures/DataTexture\n\t\tconst texture = new DataTexture(this._pixelBuffer, width, height, RGBAFormat, FloatType);\n\t\t// // texture.wrapS = ClampToEdgeWrapping\n\t\t// // texture.wrapT = ClampToEdgeWrapping\n\t\t// // texture.wrapS = ClampToEdgeWrapping\n\t\t// // texture.wrapT = ClampToEdgeWrapping\n\t\t// this._texture.needsUpdate = true;\n\n\t\tawait CoreSleep.sleep(2000);\n\n\t\tif (texture) {\n\t\t\tthis.set_texture(texture);\n\t\t} else {\n\t\t\tthis.cook_controller.end_cook();\n\t\t}\n\n\t\t// this.set_texture(this._texture);\n\t\t// this.cook_controller.end_cook();\n\t}\n\n\tprivate _create_render_target() {\n\t\tconst wrapS = ClampToEdgeWrapping;\n\t\tconst wrapT = ClampToEdgeWrapping;\n\n\t\tconst minFilter = NearestFilter;\n\t\tconst magFilter = NearestFilter;\n\n\t\tvar renderTarget = new WebGLRenderTarget(this.pv.resolution.x, this.pv.resolution.y, {\n\t\t\twrapS: wrapS,\n\t\t\twrapT: wrapT,\n\t\t\tminFilter: minFilter,\n\t\t\tmagFilter: magFilter,\n\t\t\tformat: RGBAFormat,\n\t\t\ttype: /(iPad|iPhone|iPod)/g.test(navigator.userAgent) ? HalfFloatType : FloatType,\n\t\t\tstencilBuffer: false,\n\t\t\tdepthBuffer: false,\n\t\t});\n\t\treturn renderTarget;\n\t}\n\n\t// create_material(fragment_shader:string, uniforms:IUniforms) {\n\t// \tvar material = new ShaderMaterial({\n\t// \t\tuniforms: uniforms,\n\t// \t\tvertexShader: PASS_THROUGH_SHADER,\n\t// \t\tfragmentShader: fragment_shader\n\t// \t});\n\n\t// \t// addResolutionDefine( material );\n\n\t// \treturn material;\n\t// }\n}\n","export class CoreSleep {\n\tstatic sleep(time: number): Promise<void> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tsetTimeout(() => {\n\t\t\t\tresolve();\n\t\t\t}, time);\n\t\t});\n\t}\n}\n","import {Texture} from 'three/src/textures/Texture';\n// import {NearestFilter} from 'three/src/constants';\n// import {LinearEncoding} from 'three/src/constants';\n// import {HalfFloatType} from 'three/src/constants';\n// import {WebGLRenderTargetCube} from 'three/src/renderers/WebGLRenderTargetCube';\nimport {PMREMGenerator} from 'three/src/extras/PMREMGenerator';\n\n// import NodeBase from '../_Base'\n\nimport {TypedCopNode} from './_Base';\n// import {BaseParam} from '../../../Engine/Param/_Base'\n// import {CoreTextureLoader} from '../../../core/loader/Texture';\n// import { CoreScriptLoader } from \"src/Core/Loader/Script\";\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nimport {Poly} from '../../Poly';\nclass EnvMapCopParamsConfig extends NodeParamsConfig {\n\t// url = ParamConfig.STRING(CoreTextureLoader.PARAM_DEFAULT, {\n\t// \tdesktop_browse: {file_type: 'texture'},\n\t// });\n}\nconst ParamsConfig = new EnvMapCopParamsConfig();\nexport class EnvMapCopNode extends TypedCopNode<EnvMapCopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'env_map';\n\t}\n\t// static required_three_imports() {\n\t// \treturn [\n\t// \t\t'loaders/EXRLoader',\n\t// \t\t// 'pmrem/PMREMGenerator',\n\t// \t\t// 'pmrem/PMREMCubeUVPacker',\n\t// \t];\n\t// }\n\n\t// private _texture_loader: CoreTextureLoader\n\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(1);\n\n\t\t// for now, if I clone the input, it gets messed up\n\t\tthis.io.inputs.init_inputs_clonable_state([InputCloneMode.NEVER]);\n\t}\n\n\t// create_params() {\n\t// \t// this.add_param(ParamType.STRING, 'url', CoreTextureLoader.PARAM_DEFAULT)\n\t// }\n\n\tasync cook(input_contents: Texture[]) {\n\t\tconst texture = input_contents[0];\n\t\tconst env_map = await this.convert_texture_to_env_map(texture);\n\t\tif (env_map) {\n\t\t\tthis.set_texture(env_map);\n\t\t} else {\n\t\t\tthis.cook_controller.end_cook();\n\t\t}\n\t}\n\n\tprivate async convert_texture_to_env_map(texture: Texture): Promise<Texture | undefined> {\n\t\t// texture.minFilter = NearestFilter;\n\t\t// texture.encoding = LinearEncoding;\n\n\t\tconst renderer = await Poly.instance().renderers_controller.wait_for_renderer();\n\t\t// if (!renderer) {\n\t\t// \tawait CoreSleep.sleep(1000);\n\t\t// \tconsole.log('waited 1s');\n\t\t// \trenderer = POLY.renderers_controller.first_renderer();\n\t\t// \tconsole.log('renderer', renderer, texture);\n\t\t// }\n\n\t\tif (renderer) {\n\t\t\tconst pmremGenerator = new PMREMGenerator(renderer);\n\t\t\t// console.log('env inout', texture);\n\t\t\tconst exrCubeRenderTarget = pmremGenerator.fromEquirectangular(texture);\n\n\t\t\t// pmremGenerator.dispose();\n\t\t\t// texture.dispose();\n\t\t\t// console.log('exrCubeRenderTarget.texture', exrCubeRenderTarget.texture);\n\t\t\tconst env_map_texture = exrCubeRenderTarget.texture;\n\t\t\t// (window.scene as any).background = env_map_texture;\n\t\t\t// (window.scene as any).environment = env_map_texture;\n\t\t\treturn env_map_texture;\n\t\t} else {\n\t\t\tthis.states.error.set('no renderer found to convert the texture to an env map');\n\t\t}\n\t}\n}\n","import {Texture} from 'three/src/textures/Texture';\nimport {TypedCopNode} from './_Base';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\n\nconst ParamsConfig = new NodeParamsConfig();\nexport class NullCopNode extends TypedCopNode<NodeParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'null';\n\t}\n\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(1);\n\t\tthis.io.inputs.init_inputs_clonable_state([InputCloneMode.NEVER]);\n\t}\n\n\tasync cook(input_contents: Texture[]) {\n\t\tconst texture = input_contents[0];\n\t\tthis.set_texture(texture);\n\t}\n}\n","import {TypedCopNode} from './_Base';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {InputCloneMode} from '../../poly/InputCloneMode';\nclass SwitchCopParamsConfig extends NodeParamsConfig {\n\tinput = ParamConfig.INTEGER(0, {\n\t\trange: [0, 3],\n\t\trange_locked: [true, true],\n\t});\n}\nconst ParamsConfig = new SwitchCopParamsConfig();\n\nexport class SwitchCopNode extends TypedCopNode<SwitchCopParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'switch';\n\t}\n\n\tinitialize_node() {\n\t\tthis.io.inputs.set_count(0, 4);\n\t\tthis.io.inputs.init_inputs_clonable_state([\n\t\t\tInputCloneMode.NEVER,\n\t\t\tInputCloneMode.NEVER,\n\t\t\tInputCloneMode.NEVER,\n\t\t\tInputCloneMode.NEVER,\n\t\t]);\n\t\tthis.ui_data.set_width(100);\n\t\t// this.ui_data.set_icon('code-branch');\n\n\t\tthis.cook_controller.disallow_inputs_evaluation();\n\t}\n\n\tasync cook() {\n\t\tconst input_index = this.pv.input;\n\t\tif (this.io.inputs.has_input(input_index)) {\n\t\t\tconst container = await this.container_controller.request_input_container(input_index);\n\t\t\tthis.set_texture(container.texture());\n\t\t} else {\n\t\t\tthis.states.error.set(`no input ${input_index}`);\n\t\t}\n\t}\n}\n","import {CATEGORY_COP} from './Category';\n\nimport {BuilderCopNode} from '../../nodes/cop/Builder';\nimport {EnvMapCopNode} from '../../nodes/cop/EnvMap';\nimport {FileCopNode} from '../../nodes/cop/File';\nimport {NullCopNode} from '../../nodes/cop/Null';\nimport {SwitchCopNode} from '../../nodes/cop/Switch';\n\nexport interface CopNodeChildrenMap {\n\tbuilder: BuilderCopNode;\n\tenv_map: EnvMapCopNode;\n\tfile: FileCopNode;\n\tnull: NullCopNode;\n\tswitch: SwitchCopNode;\n}\n\nimport {Poly} from '../../Poly';\nexport class CopRegister {\n\tstatic run(poly: Poly) {\n\t\tpoly.register_node(BuilderCopNode, CATEGORY_COP.ADVANCED);\n\t\tpoly.register_node(EnvMapCopNode, CATEGORY_COP.INPUT);\n\t\tpoly.register_node(FileCopNode, CATEGORY_COP.INPUT);\n\t\tpoly.register_node(NullCopNode, CATEGORY_COP.MISC);\n\t\tpoly.register_node(SwitchCopNode, CATEGORY_COP.MISC);\n\t}\n}\n"],"sourceRoot":""}