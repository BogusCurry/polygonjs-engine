(window.webpackJsonpPOLY=window.webpackJsonpPOLY||[]).push([["Gl"],{335:function(t,n,e){"use strict";e.d(n,"a",(function(){return o}));var i=e(373);function o(t){this.manager=void 0!==t?t:i.a,this.crossOrigin="anonymous",this.path="",this.resourcePath=""}Object.assign(o.prototype,{load:function(){},parse:function(){},setCrossOrigin:function(t){return this.crossOrigin=t,this},setPath:function(t){return this.path=t,this},setResourcePath:function(t){return this.resourcePath=t,this}})},346:function(t,n,e){"use strict";e.d(n,"a",(function(){return s}));var i=e(4),o=e(83);function s(t,n,e,s,c,r,a,_,l){o.a.call(this,t,n,e,s,c,r,a,_,l),this.format=void 0!==a?a:i.dc,this.minFilter=void 0!==r?r:i.R,this.magFilter=void 0!==c?c:i.R,this.generateMipmaps=!1}s.prototype=Object.assign(Object.create(o.a.prototype),{constructor:s,isVideoTexture:!0,update:function(){var t=this.image;t.readyState>=t.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}})},349:function(t,n,e){"use strict";e.d(n,"a",(function(){return i}));var i={enabled:!1,files:{},add:function(t,n){!1!==this.enabled&&(this.files[t]=n)},get:function(t){if(!1!==this.enabled)return this.files[t]},remove:function(t){delete this.files[t]},clear:function(){this.files={}}}},372:function(t,n,e){"use strict";e.d(n,"a",(function(){return s}));var i=e(349),o=e(335);function s(t){o.a.call(this,t)}s.prototype=Object.assign(Object.create(o.a.prototype),{constructor:s,load:function(t,n,e,o){void 0!==this.path&&(t=this.path+t),t=this.manager.resolveURL(t);var s=this,c=i.a.get(t);if(void 0!==c)return s.manager.itemStart(t),setTimeout((function(){n&&n(c),s.manager.itemEnd(t)}),0),c;var r=document.createElementNS("http://www.w3.org/1999/xhtml","img");function a(){r.removeEventListener("load",a,!1),r.removeEventListener("error",_,!1),i.a.add(t,this),n&&n(this),s.manager.itemEnd(t)}function _(n){r.removeEventListener("load",a,!1),r.removeEventListener("error",_,!1),o&&o(n),s.manager.itemError(t),s.manager.itemEnd(t)}return r.addEventListener("load",a,!1),r.addEventListener("error",_,!1),"data:"!==t.substr(0,5)&&void 0!==this.crossOrigin&&(r.crossOrigin=this.crossOrigin),s.manager.itemStart(t),r.src=t,r}})},373:function(t,n,e){"use strict";function i(t,n,e){var i=this,o=!1,s=0,c=0,r=void 0,a=[];this.onStart=void 0,this.onLoad=t,this.onProgress=n,this.onError=e,this.itemStart=function(t){c++,!1===o&&void 0!==i.onStart&&i.onStart(t,s,c),o=!0},this.itemEnd=function(t){s++,void 0!==i.onProgress&&i.onProgress(t,s,c),s===c&&(o=!1,void 0!==i.onLoad&&i.onLoad())},this.itemError=function(t){void 0!==i.onError&&i.onError(t)},this.resolveURL=function(t){return r?r(t):t},this.setURLModifier=function(t){return r=t,this},this.addHandler=function(t,n){return a.push(t,n),this},this.removeHandler=function(t){var n=a.indexOf(t);return-1!==n&&a.splice(n,2),this},this.getHandler=function(t){for(var n=0,e=a.length;n<e;n+=2){var i=a[n],o=a[n+1];if(i.global&&(i.lastIndex=0),i.test(t))return o}return null}}e.d(n,"a",(function(){return o})),e.d(n,"b",(function(){return i}));var o=new i},379:function(t,n,e){"use strict";e.d(n,"a",(function(){return r}));var i=e(4),o=e(372),s=e(83),c=e(335);function r(t){c.a.call(this,t)}r.prototype=Object.assign(Object.create(c.a.prototype),{constructor:r,load:function(t,n,e,c){var r=new s.a,a=new o.a(this.manager);return a.setCrossOrigin(this.crossOrigin),a.setPath(this.path),a.load(t,(function(e){r.image=e;var o=t.search(/\.jpe?g($|\?)/i)>0||0===t.search(/^data\:image\/jpeg/);r.format=o?i.dc:i.Db,r.needsUpdate=!0,void 0!==n&&n(r)}),e,c),r}})},436:function(t,n,e){"use strict";e.d(n,"a",(function(){return u}));var i=e(334),o=e(332),s=e(45),c=e(44),r=e(348);function a(t){return{visible_if:{type:s.e.indexOf(t)}}}class _ extends c.a{constructor(){super(...arguments),this.type=c.b.INTEGER(s.e.indexOf(s.c.FLOAT),{menu:{entries:s.e.map((t,n)=>({name:t,value:n}))}}),this.bool=c.b.BOOLEAN(0,a(s.c.BOOL)),this.int=c.b.INTEGER(0,a(s.c.INT)),this.float=c.b.FLOAT(0,a(s.c.FLOAT)),this.vec2=c.b.VECTOR2([0,0],a(s.c.VEC2)),this.vec3=c.b.VECTOR3([0,0,0],a(s.c.VEC3)),this.vec4=c.b.VECTOR4([0,0,0,0],a(s.c.VEC4))}}const l=new _;class u extends i.b{constructor(){super(...arguments),this.params_config=l,this.gl_connections_controller=new r.a(this),this._allow_inputs_created_from_params=!1}static type(){return"constant"}initialize_node(){this.gl_connections_controller.initialize_node(),this.gl_connections_controller.set_output_name_function(t=>u.OUTPUT_NAME),this.gl_connections_controller.set_expected_input_types_function(()=>[]),this.gl_connections_controller.set_expected_output_types_function(()=>[this._current_connection_type])}set_lines(t){const n=this._current_param;if(n){const e=this._current_connection_type,i=o.a.any(n.value),s=`${e} ${this._current_var_name} = ${i}`;t.add_body_lines(this,[s])}else console.warn(`no param found for constant node for type '${this.pv.type}'`)}get _current_connection_type(){null==this.pv.type&&console.warn("constant gl node type if not valid");const t=s.e[this.pv.type];return null==t&&console.warn("constant gl node type if not valid"),t}get _current_param(){this._params_by_type=this._params_by_type||new Map([[s.c.BOOL,this.p.bool],[s.c.INT,this.p.int],[s.c.FLOAT,this.p.float],[s.c.VEC2,this.p.vec2],[s.c.VEC3,this.p.vec3],[s.c.VEC4,this.p.vec4]]);const t=s.e[this.pv.type];return this._params_by_type.get(t)}get _current_var_name(){return this.gl_var_name(u.OUTPUT_NAME)}}u.OUTPUT_NAME="val"},616:function(t,n,e){"use strict";e.r(n),e.d(n,"GlRegister",(function(){return Qe}));var i=e(352),o=e(334),s=e(332),c=e(118),r=e(45),a=e(44);class _ extends a.a{constructor(){super(...arguments),this.float=a.b.FLOAT(0)}}const l=new _;class u extends o.b{constructor(){super(...arguments),this.params_config=l}static type(){return"float_to_int"}initialize_node(){this.io.outputs.set_named_output_connection_points([new c.a("int",r.c.INT)])}set_lines(t){const n=this.variable_for_input("float"),e=`int ${this.gl_var_name("int")} = int(${s.a.float(n)})`;t.add_body_lines(this,[e])}}class p extends a.a{constructor(){super(...arguments),this.int=a.b.INTEGER(0)}}const g=new p;class d extends o.b{constructor(){super(...arguments),this.params_config=g}static type(){return"int_to_float"}initialize_node(){this.io.outputs.set_named_output_connection_points([new c.a("float",r.c.FLOAT)])}set_lines(t){const n=this.variable_for_input("int"),e=`float ${this.gl_var_name("float")} = float(${s.a.int(n)})`;t.add_body_lines(this,[e])}}class x extends a.a{constructor(){super(...arguments),this.x=a.b.FLOAT(0),this.y=a.b.FLOAT(0)}}const v=new x;class f extends o.b{constructor(){super(...arguments),this.params_config=v}static type(){return"float_to_vec2"}initialize_node(){this.io.outputs.set_named_output_connection_points([new c.a(f.OUTPUT_NAME,r.c.VEC2)])}set_lines(t){const n=this.variable_for_input("x"),e=this.variable_for_input("y"),i=`vec2 ${this.gl_var_name(f.OUTPUT_NAME)} = ${s.a.float2(n,e)}`;t.add_body_lines(this,[i])}}f.OUTPUT_NAME="vec2";class m extends a.a{constructor(){super(...arguments),this.x=a.b.FLOAT(0),this.y=a.b.FLOAT(0),this.z=a.b.FLOAT(0)}}const h=new m;class y extends o.b{constructor(){super(...arguments),this.params_config=h}static type(){return"float_to_vec3"}initialize_node(){this.io.outputs.set_named_output_connection_points([new c.a(y.OUTPUT_NAME,r.c.VEC3)])}set_lines(t){const n=this.variable_for_input("x"),e=this.variable_for_input("y"),i=this.variable_for_input("z"),o=`vec3 ${this.gl_var_name(y.OUTPUT_NAME)} = ${s.a.float3(n,e,i)}`;t.add_body_lines(this,[o])}}y.OUTPUT_NAME="vec3";class z extends a.a{constructor(){super(...arguments),this.x=a.b.FLOAT(0),this.y=a.b.FLOAT(0),this.z=a.b.FLOAT(0),this.w=a.b.FLOAT(0)}}const w=new z;class b extends o.b{constructor(){super(...arguments),this.params_config=w}static type(){return"float_to_vec4"}initialize_node(){this.io.outputs.set_named_output_connection_points([new c.a(b.OUTPUT_NAME,r.c.VEC4)])}set_lines(t){const n=this.variable_for_input("x"),e=this.variable_for_input("y"),i=this.variable_for_input("z"),o=this.variable_for_input("w"),c=`vec4 ${this.gl_var_name(b.OUTPUT_NAME)} = ${s.a.float4(n,e,i,o)}`;t.add_body_lines(this,[c])}}b.OUTPUT_NAME="vec4";var P=e(0);class O extends a.a{}const E=new O;class T extends o.b{constructor(){super(...arguments),this.params_config=E}}function A(t,n){const e=n.components,i=n.param_type;return class extends T{static type(){return t}initialize_node(){this.io.outputs.set_named_output_connection_points(e.map(t=>new c.a(t,r.c.FLOAT)))}create_params(){this.add_param(i,"vec",e.map(t=>0))}set_lines(t){const n=[],e=this.variable_for_input("vec");this.io.outputs.used_output_names().forEach(t=>{const i=this.gl_var_name(t);n.push(`float ${i} = ${e}.${t}`)}),t.add_body_lines(this,n)}}}const I=["x","y","z","w"];class C extends(A("vec2_to_float",{components:["x","y"],param_type:P.a.VECTOR2})){}class L extends(A("vec3_to_float",{components:["x","y","z"],param_type:P.a.VECTOR3})){}class q extends(A("vec4_to_float",{components:I,param_type:P.a.VECTOR4})){}class S extends T{static type(){return"vec4_to_vector"}initialize_node(){this.io.outputs.set_named_output_connection_points([new c.a(S.OUTPUT_NAME_VEC3,r.c.VEC3),new c.a(S.OUTPUT_NAME_W,r.c.FLOAT)])}create_params(){this.add_param(P.a.VECTOR4,S.INPUT_NAME_VEC4,I.map(t=>0))}set_lines(t){const n=[],e=S.INPUT_NAME_VEC4,i=S.OUTPUT_NAME_VEC3,o=S.OUTPUT_NAME_W,s=this.variable_for_input(e),c=this.io.outputs.used_output_names();if(c.indexOf(i)>=0){const t=this.gl_var_name(i);n.push(`vec3 ${t} = ${s}.xyz`)}if(c.indexOf(o)>=0){const t=this.gl_var_name(o);n.push(`float ${t} = ${s}.w`)}t.add_body_lines(this,n)}}S.INPUT_NAME_VEC4="vec4",S.OUTPUT_NAME_VEC3="vec3",S.OUTPUT_NAME_W="w";var $=e(121),N=e.n($),V=e(27),F=e.n(V),R=e(348);a.a;class M extends o.b{constructor(){super(...arguments),this.gl_connections_controller=new R.a(this)}initialize_node(){super.initialize_node(),this.gl_connections_controller.initialize_node()}}class D extends a.a{}const U=new D;class G extends M{constructor(){super(...arguments),this.params_config=U}gl_method_name(){return""}gl_function_definitions(){return[]}initialize_node(){super.initialize_node(),this.gl_connections_controller.set_expected_input_types_function(this._expected_input_types.bind(this)),this.gl_connections_controller.set_expected_output_types_function(this._expected_output_types.bind(this)),this.gl_connections_controller.set_input_name_function(this._gl_input_name.bind(this))}_expected_input_types(){const t=this.gl_connections_controller.first_input_connection_type()||r.c.FLOAT;if(this.io.connections.first_input_connection()){let n=Math.max(F()(this.io.connections.input_connections()).length+1,2);return N()(n).map(n=>t)}return N()(2).map(n=>t)}_expected_output_types(){return[this._expected_input_types()[0]]}_gl_input_name(t){return"in"}set_lines(t){const n=this.io.outputs.named_output_connection_points[0].type,e=this.io.inputs.named_input_connection_points.map((t,n)=>{const e=t.name;return s.a.any(this.variable_for_input(e))}).join(", "),i=`${n} ${this.gl_var_name(this.gl_connections_controller.output_name(0))} = ${this.gl_method_name()}(${e})`;t.add_body_lines(this,[i]),t.add_definitions(this,this.gl_function_definitions())}}class H extends G{_gl_input_name(t){return"in"}_expected_input_types(){return[this.gl_connections_controller.first_input_connection_type()||r.c.FLOAT]}}class k extends G{_expected_input_types(){const t=this.gl_connections_controller.first_input_connection_type()||r.c.FLOAT;return[t,t]}}class j extends G{_expected_input_types(){const t=this.gl_connections_controller.first_input_connection_type()||r.c.FLOAT;return[t,t,t]}}class Y extends G{_expected_input_types(){const t=this.gl_connections_controller.first_input_connection_type()||r.c.FLOAT;return[t,t,t,t]}}class B extends G{_expected_input_types(){const t=this.gl_connections_controller.first_input_connection_type()||r.c.FLOAT;return[t,t,t,t,t]}}function Q(t,n={}){const e=n.method||t,i=n.out||"val",o=n.in||"in";return class extends H{static type(){return t}initialize_node(){super.initialize_node(),this.gl_connections_controller.set_input_name_function(this._gl_input_name.bind(this)),this.gl_connections_controller.set_output_name_function(this._gl_output_name.bind(this))}_gl_input_name(t){return o}_gl_output_name(t){return i}gl_method_name(){return e}}}class X extends(Q("abs")){}class K extends(Q("acos",{out:"radians"})){}class Z extends(Q("asin",{out:"radians"})){}class W extends(Q("atan",{out:"radians"})){}class J extends(Q("ceil")){}class tt extends(Q("cos",{in:"radians"})){}class nt extends(Q("degrees",{in:"radians",out:"degrees"})){}class et extends(Q("exp")){}class it extends(Q("exp2")){}class ot extends(Q("floor")){}class st extends(Q("fract")){}class ct extends(Q("inverse_sqrt",{method:"inversesqrt"})){}class rt extends(Q("log")){}class at extends(Q("log2")){}class _t extends(Q("normalize",{out:"normalized"})){}class lt extends(Q("radians",{in:"degrees",out:"radians"})){}class ut extends(Q("sign")){}class pt extends(Q("sin",{in:"radians"})){}class gt extends(Q("sqrt")){}class dt extends(Q("tan")){}var xt=e(331);function vt(t,n={}){const e=n.method||t,i=n.out||"val",o=n.in||["in0","in1"],s=n.default_in_type,c=n.allowed_in_types,a=n.out_type,_=n.functions||[];return class extends k{static type(){return t}initialize_node(){super.initialize_node(),this.gl_connections_controller.set_input_name_function(this._gl_input_name.bind(this)),this.gl_connections_controller.set_output_name_function(this._gl_output_name.bind(this)),this.gl_connections_controller.set_expected_input_types_function(this._expected_input_types.bind(this)),a&&this.gl_connections_controller.set_expected_output_types_function(()=>[a])}_gl_input_name(t){return o[t]}_gl_output_name(t){return i}gl_method_name(){return e}gl_function_definitions(){return a?_.map(t=>new xt.b(this,a,t)):[]}_expected_input_types(){let t=this.gl_connections_controller.first_input_connection_type();if(t&&c&&!c.includes(t)){const n=this.io.inputs.named_input_connection_points[0];t=n?n.type:s}const n=t||s||r.c.FLOAT;return[n,n]}}}class ft extends(vt("distance",{in:["p0","p1"],default_in_type:r.c.VEC3,allowed_in_types:[r.c.VEC2,r.c.VEC3,r.c.VEC4],out_type:r.c.FLOAT})){}class mt extends(vt("dot",{in:["vec0","vec1"],default_in_type:r.c.VEC3,allowed_in_types:[r.c.VEC2,r.c.VEC3,r.c.VEC4],out_type:r.c.FLOAT})){}class ht extends(vt("max")){}class yt extends(vt("min")){}class zt extends(vt("mod")){}class wt extends(vt("pow",{in:["x","y"]})){}class bt extends(vt("reflect",{in:["I","N"],default_in_type:r.c.VEC3})){}class Pt extends(vt("step",{in:["edge","x"]})){}function Ot(t,n){const e=n.in_prefix||t,i=n.out||"val",o=n.operation,c=n.allowed_in_types;return class extends k{static type(){return t}initialize_node(){super.initialize_node(),this.gl_connections_controller.set_input_name_function(this._gl_input_name.bind(this)),this.gl_connections_controller.set_output_name_function(this._gl_output_name.bind(this)),this.gl_connections_controller.set_expected_input_types_function(this._expected_input_types.bind(this)),this.gl_connections_controller.set_expected_output_types_function(this._expected_output_types.bind(this))}set_lines(t){const n=this.io.outputs.named_output_connection_points[0].type,e=this.io.inputs.named_input_connection_points.map((t,n)=>{const e=t.name,i=this.variable_for_input(e);if(i)return s.a.any(i)}).join(` ${this.gl_operation()} `),i=`${n} ${this.gl_var_name(this.gl_connections_controller.output_name(0))} = ${this.gl_method_name()}(${e})`;t.add_body_lines(this,[i])}_gl_input_name(t){return`${e}${t}`}_gl_output_name(t){return i}gl_operation(){return o}_expected_input_types(){let t=this.gl_connections_controller.first_input_connection_type();if(t&&c&&!c.includes(t)){const n=this.io.inputs.named_input_connection_points[0];n&&(t=n.type)}const n=t||r.c.FLOAT,e=this.io.connections.input_connections(),i=e?Math.max(e.length+1,2):2,o=[];for(let t=0;t<i;t++)o.push(n);return o}_expected_output_types(){return[this._expected_input_types()[0]]}}}class Et extends(Ot("add",{in_prefix:"add",out:"sum",operation:"+"})){}class Tt extends(Ot("divide",{in_prefix:"div",out:"divide",operation:"/"})){}class At extends(Ot("substract",{in_prefix:"sub",out:"substract",operation:"-"})){}class It extends(Ot("mult",{in_prefix:"mult",out:"product",operation:"*"})){static type(){return"mult"}gl_input_default_value(t){return 1}initialize_node(){super.initialize_node(),this.gl_connections_controller.set_expected_input_types_function(this._expected_input_types.bind(this)),this.gl_connections_controller.set_expected_output_types_function(this._expected_output_types.bind(this))}_expected_output_type(){const t=this._expected_input_types();return[t[t.length-1]]}_expected_input_types(){const t=this.io.connections.input_connections();if(t){const n=t[0];if(n){const e=this.io.inputs.named_input_connection_points[n.input_index].type,i=t?t.length+1:2,o=new Array(i);if(e==r.c.FLOAT){const n=t?t[1]:null;if(n){const t=this.io.inputs.named_input_connection_points[n.input_index].type;return t==r.c.FLOAT?o.map(t=>e):[e,t]}return[e,e]}return o.map(()=>e)}}return[r.c.FLOAT,r.c.FLOAT]}}class Ct extends k{initialize_node(){super.initialize_node(),this.gl_connections_controller.set_expected_input_types_function(this._expected_input_types.bind(this)),this.gl_connections_controller.set_expected_output_types_function(this._expected_output_types.bind(this))}_expected_input_types(){return[r.c.BOOL,r.c.BOOL]}_expected_output_types(){return[r.c.BOOL]}set_lines(t){const n=this.io.inputs.named_input_connection_points.map((t,n)=>{const e=t.name;return s.a.any(this.variable_for_input(e))}).join(` ${this.boolean_operation()} `),e=`bool ${this.gl_var_name(this.gl_connections_controller.output_name(0))} = ${n}`;t.add_body_lines(this,[e])}}function Lt(t,n){return class extends Ct{static type(){return t}initialize_node(){super.initialize_node(),this.gl_connections_controller.set_input_name_function(this._gl_input_name.bind(this)),this.gl_connections_controller.set_output_name_function(this._gl_output_name.bind(this))}boolean_operation(){return n.op}_gl_output_name(n){return t}_gl_input_name(n=0){return`${t}${n}`}}}class qt extends(Lt("and",{op:"&&"})){}class St extends(Lt("or",{op:"||"})){}var $t,Nt='\n\n// https://github.com/mattatz/ShibuyaCrowd/blob/master/source/shaders/common/quaternion.glsl\nvec4 quat_mult(vec4 q1, vec4 q2)\n{\n\treturn vec4(\n\tq1.w * q2.x + q1.x * q2.w + q1.z * q2.y - q1.y * q2.z,\n\tq1.w * q2.y + q1.y * q2.w + q1.x * q2.z - q1.z * q2.x,\n\tq1.w * q2.z + q1.z * q2.w + q1.y * q2.x - q1.x * q2.y,\n\tq1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z\n\t);\n}\n// http://glmatrix.net/docs/quat.js.html#line97\n//   let ax = a[0], ay = a[1], az = a[2], aw = a[3];\n\n//   let bx = b[0], by = b[1], bz = b[2], bw = b[3];\n\n//   out[0] = ax * bw + aw * bx + ay * bz - az * by;\n\n//   out[1] = ay * bw + aw * by + az * bx - ax * bz;\n\n//   out[2] = az * bw + aw * bz + ax * by - ay * bx;\n\n//   out[3] = aw * bw - ax * bx - ay * by - az * bz;\n\n//   return out\n\n\n\n// http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n\taxis = normalize(axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat oc = 1.0 - c;\n\n \treturn mat4(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, 0.0, oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s,  0.0, oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c, 0.0, 0.0, 0.0, 0.0, 1.0);\n}\n\n// https://www.geeks3d.com/20141201/how-to-rotate-a-vertex-by-a-quaternion-in-glsl/\nvec4 quat_from_axis_angle(vec3 axis, float angle)\n{\n\tvec4 qr;\n\tfloat half_angle = (angle * 0.5); // * 3.14159 / 180.0;\n\tfloat sin_half_angle = sin(half_angle);\n\tqr.x = axis.x * sin_half_angle;\n\tqr.y = axis.y * sin_half_angle;\n\tqr.z = axis.z * sin_half_angle;\n\tqr.w = cos(half_angle);\n\treturn qr;\n}\nvec3 rotate_with_axis_angle(vec3 position, vec3 axis, float angle)\n{\n\tvec4 q = quat_from_axis_angle(axis, angle);\n\tvec3 v = position.xyz;\n\treturn v + 2.0 * cross(q.xyz, cross(q.xyz, v) + q.w * v);\n}\n// vec3 applyQuaternionToVector( vec4 q, vec3 v ){\n// \treturn v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w * v );\n// }\nvec3 rotate_with_quat( vec3 v, vec4 q )\n{\n\t// vec4 qv = multQuat( quat, vec4(vec, 0.0) );\n\t// return multQuat( qv, vec4(-quat.x, -quat.y, -quat.z, quat.w) ).xyz;\n\treturn v + 2.0 * cross( q.xyz, cross( q.xyz, v ) + q.w * v );\n}\n// https://github.com/glslify/glsl-look-at/blob/gh-pages/index.glsl\n// mat3 rotation_matrix(vec3 origin, vec3 target, float roll) {\n// \tvec3 rr = vec3(sin(roll), cos(roll), 0.0);\n// \tvec3 ww = normalize(target - origin);\n// \tvec3 uu = normalize(cross(ww, rr));\n// \tvec3 vv = normalize(cross(uu, ww));\n\n// \treturn mat3(uu, vv, ww);\n// }\n// mat3 rotation_matrix(vec3 target, float roll) {\n// \tvec3 rr = vec3(sin(roll), cos(roll), 0.0);\n// \tvec3 ww = normalize(target);\n// \tvec3 uu = normalize(cross(ww, rr));\n// \tvec3 vv = normalize(cross(uu, ww));\n\n// \treturn mat3(uu, vv, ww);\n// }\n\nfloat vector_angle(vec3 start, vec3 dest){\n\tstart = normalize(start);\n\tdest = normalize(dest);\n\n\tfloat cosTheta = dot(start, dest);\n\tvec3 c1 = cross(start, dest);\n\t// We use the dot product of the cross with the Y axis.\n\t// This is a little arbitrary, but can still give a good sense of direction\n\tvec3 y_axis = vec3(0.0, 1.0, 0.0);\n\tfloat d1 = dot(c1, y_axis);\n\tfloat angle = acos(cosTheta) * sign(d1);\n\treturn angle;\n}\n\n// http://www.opengl-tutorial.org/intermediate-tutorials/tutorial-17-quaternions/#i-need-an-equivalent-of-glulookat-how-do-i-orient-an-object-towards-a-point-\nvec4 vector_align(vec3 start, vec3 dest){\n\tstart = normalize(start);\n\tdest = normalize(dest);\n\n\tfloat cosTheta = dot(start, dest);\n\tvec3 axis;\n\n\t// if (cosTheta < -1 + 0.001f){\n\t// \t// special case when vectors in opposite directions:\n\t// \t// there is no "ideal" rotation axis\n\t// \t// So guess one; any will do as long as it\'s perpendicular to start\n\t// \taxis = cross(vec3(0.0f, 0.0f, 1.0f), start);\n\t// \tif (length2(axis) < 0.01 ) // bad luck, they were parallel, try again!\n\t// \t\taxis = cross(vec3(1.0f, 0.0f, 0.0f), start);\n\n\t// \taxis = normalize(axis);\n\t// \treturn gtx::quaternion::angleAxis(glm::radians(180.0f), axis);\n\t// }\n\tif(cosTheta > (1.0 - 0.0001) || cosTheta < (-1.0 + 0.0001) ){\n\t\taxis = normalize(cross(start, vec3(0.0, 1.0, 0.0)));\n\t\tif (length(axis) < 0.001 ){ // bad luck, they were parallel, try again!\n\t\t\taxis = normalize(cross(start, vec3(1.0, 0.0, 0.0)));\n\t\t}\n\t} else {\n\t\taxis = normalize(cross(start, dest));\n\t}\n\n\tfloat angle = acos(cosTheta);\n\n\treturn quat_from_axis_angle(axis, angle);\n}\nvec4 vector_align_with_up(vec3 start, vec3 dest, vec3 up){\n\tvec4 rot1 = vector_align(start, dest);\n\tup = normalize(up);\n\n\t// Recompute desiredUp so that it\'s perpendicular to the direction\n\t// You can skip that part if you really want to force desiredUp\n\t// vec3 right = normalize(cross(dest, up));\n\t// up = normalize(cross(right, dest));\n\n\t// Because of the 1rst rotation, the up is probably completely screwed up.\n\t// Find the rotation between the "up" of the rotated object, and the desired up\n\tvec3 newUp = rotate_with_quat(vec3(0.0, 1.0, 0.0), rot1);//rot1 * vec3(0.0, 1.0, 0.0);\n\tvec4 rot2 = vector_align(up, newUp);\n\n\t// return rot1;\n\treturn rot2;\n\t// return multQuat(rot1, rot2);\n\t// return rot2 * rot1;\n\n}\n\n// https://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm\nfloat quat_to_angle(vec4 q){\n\treturn 2.0 * acos(q.w);\n}\nvec3 quat_to_axis(vec4 q){\n\treturn vec3(\n\t\tq.x / sqrt(1.0-q.w*q.w),\n\t\tq.y / sqrt(1.0-q.w*q.w),\n\t\tq.z / sqrt(1.0-q.w*q.w)\n\t);\n}\n\nvec4 align(vec3 dir, vec3 up){\n\tvec3 start_dir = vec3(0.0, 0.0, 1.0);\n\tvec3 start_up = vec3(0.0, 1.0, 0.0);\n\tvec4 rot1 = vector_align(start_dir, dir);\n\tup = normalize(up);\n\n\t// Recompute desiredUp so that it\'s perpendicular to the direction\n\t// You can skip that part if you really want to force desiredUp\n\tvec3 right = normalize(cross(dir, up));\n\tif(length(right)<0.001){\n\t\tright = vec3(1.0, 0.0, 0.0);\n\t}\n\tup = normalize(cross(right, dir));\n\n\t// Because of the 1rst rotation, the up is probably completely screwed up.\n\t// Find the rotation between the "up" of the rotated object, and the desired up\n\tvec3 newUp = rotate_with_quat(start_up, rot1);//rot1 * vec3(0.0, 1.0, 0.0);\n\tvec4 rot2 = vector_align(normalize(newUp), up);\n\n\t// return rot1;\n\treturn quat_mult(rot1, rot2);\n\t// return rot2 * rot1;\n\n}';!function(t){t.DIR="dir",t.UP="up"}($t||($t={}));const Vt=[$t.DIR,$t.UP],Ft={[$t.DIR]:[0,0,1],[$t.UP]:[0,1,0]};class Rt extends k{static type(){return"align"}initialize_node(){super.initialize_node(),this.gl_connections_controller.set_input_name_function(t=>Vt[t]),this.gl_connections_controller.set_expected_input_types_function(()=>[r.c.VEC3,r.c.VEC3]),this.gl_connections_controller.set_expected_output_types_function(()=>[r.c.VEC4])}gl_input_default_value(t){return Ft[t]}gl_method_name(){return"align"}gl_function_definitions(){return[new xt.b(this,r.c.VEC4,Nt)]}}var Mt=e(359),Dt=e(436);class Ut extends H{static type(){return"complement"}gl_method_name(){return"complement"}gl_function_definitions(){return[new xt.b(this,this.gl_connections_controller.first_input_connection_type()||r.c.FLOAT,"float complement(float x){return 1.0-x;}\nvec2 complement(vec2 x){return vec2(1.0-x.x, 1.0-x.y);}\nvec3 complement(vec3 x){return vec3(1.0-x.x, 1.0-x.y, 1.0-x.z);}\nvec4 complement(vec4 x){return vec4(1.0-x.x, 1.0-x.y, 1.0-x.z, 1.0-x.w);}\n")]}}class Gt extends a.a{constructor(){super(...arguments),this.x=a.b.VECTOR3([0,0,1]),this.y=a.b.VECTOR3([0,1,0])}}const Ht=new Gt;class kt extends o.b{constructor(){super(...arguments),this.params_config=Ht}static type(){return"cross"}initialize_node(){super.initialize_node(),this.io.outputs.set_named_output_connection_points([new c.a("cross",r.c.VEC3)])}set_lines(t){const n=s.a.float(this.variable_for_input("x")),e=s.a.float(this.variable_for_input("y")),i=`vec3 ${this.gl_var_name("cross")} = cross(${n}, ${e})`;t.add_body_lines(this,[i])}}function jt(t,n={}){const e=n.method||t,i=n.out||"val",o=n.in||["in0","in1","in2"],s=n.default||{},c=n.out_type||r.c.FLOAT,a=n.functions||[];return class extends j{static type(){return t}initialize_node(){super.initialize_node(),this.gl_connections_controller.set_input_name_function(this._gl_input_name.bind(this)),this.gl_connections_controller.set_output_name_function(this._gl_output_name.bind(this)),this.gl_connections_controller.set_expected_output_types_function(this._expected_output_types.bind(this))}_gl_input_name(t){return o[t]}_gl_output_name(t){return i}gl_method_name(){return e}_expected_output_types(){return[c]}gl_input_default_value(t){return s[t]}gl_function_definitions(){return a.map(t=>new xt.b(this,c,t))}}}jt("clamp",{in:["value","min","max"],default:{max:1}});jt("face_forward",{in:["N","I","Nref"]});jt("smoothstep",{in:["edge0","edge1","x"]});class Yt extends(jt("cycle",{in:["in","min","max"],default:{max:1},functions:["float cycle(float val, float val_min, float val_max){\n\tif(val >= val_min && val < val_max){\n\t\treturn val;\n\t} else {\n\t\tfloat range = val_max - val_min;\n\t\tif(val >= val_max){\n\t\t\tfloat delta = (val - val_max);\n\t\t\treturn val_min + mod(delta, range);\n\t\t} else {\n\t\t\tfloat delta = (val_min - val);\n\t\t\treturn val_max - mod(delta, range);\n\t\t}\n\t}\n}"]})){}class Bt extends a.a{constructor(){super(...arguments),this.position=a.b.VECTOR2([0,0]),this.center=a.b.VECTOR2([0,0]),this.radius=a.b.FLOAT(1),this.feather=a.b.FLOAT(.1)}}const Qt=new Bt;class Xt extends o.b{constructor(){super(...arguments),this.params_config=Qt}static type(){return"disk"}initialize_node(){super.initialize_node(),this.io.outputs.set_named_output_connection_points([new c.a("float",r.c.FLOAT)])}set_lines(t){const n=s.a.vector2(this.variable_for_input("position")),e=s.a.vector2(this.variable_for_input("center")),i=s.a.float(this.variable_for_input("radius")),o=s.a.float(this.variable_for_input("feather")),c=`float ${this.gl_var_name("float")} = disk(${n}, ${e}, ${i}, ${o})`;t.add_body_lines(this,[c]),t.add_definitions(this,[new xt.b(this,r.c.FLOAT,"float disk(vec2 pos, vec2 center, float radius, float feather){\n\tfloat dist = distance(pos, center);\n\tif(feather <= 0.0){\n\t\tif(dist < radius){return 1.0;}else{return 0.0;}\n\t} else {\n\t\tfloat half_feather = feather * 0.5;\n\t\tif(dist < (radius - half_feather)){\n\t\t\treturn 1.0;\n\t\t} else {\n\t\t\tif(dist > (radius + half_feather)){\n\t\t\t\treturn 0.0;\n\t\t\t} else {\n\t\t\t\tfloat feather_start = (radius - half_feather);\n\t\t\t\tfloat blend = 1.0 - (dist - feather_start) / feather;\n\t\t\t\treturn blend;\n\t\t\t}\n\t\t}\n\t}\n}")])}}var Kt="\nfloat bounceOut(float t) {\n  const float a = 4.0 / 11.0;\n  const float b = 8.0 / 11.0;\n  const float c = 9.0 / 10.0;\n\n  const float ca = 4356.0 / 361.0;\n  const float cb = 35442.0 / 1805.0;\n  const float cc = 16061.0 / 1805.0;\n\n  float t2 = t * t;\n\n  return t < a\n    ? 7.5625 * t2\n    : t < b\n      ? 9.075 * t2 - 9.9 * t + 3.4\n      : t < c\n        ? ca * t2 - cb * t + cc\n        : 10.8 * t * t - 20.52 * t + 10.72;\n}\n\n";const Zt=["back-in-out","back-in","back-out","bounce-in-out","bounce-in","bounce-out","circular-in-out","circular-in","circular-out","cubic-in-out","cubic-in","cubic-out","elastic-in-out","elastic-in","elastic-out","exponential-in-out","exponential-in","exponential-out","linear","quadratic-in-out","quadratic-in","quadratic-out","sine-in-out","sine-in","sine-out"],Wt={"circular-in-out":"float circularInOut(float t) {\n  return t < 0.5\n    ? 0.5 * (1.0 - sqrt(1.0 - 4.0 * t * t))\n    : 0.5 * (sqrt((3.0 - 2.0 * t) * (2.0 * t - 1.0)) + 1.0);\n}\n\n","exponential-in-out":"float exponentialInOut(float t) {\n  return t == 0.0 || t == 1.0\n    ? t\n    : t < 0.5\n      ? +0.5 * pow(2.0, (20.0 * t) - 10.0)\n      : -0.5 * pow(2.0, 10.0 - (t * 20.0)) + 1.0;\n}\n\n","circular-in":"float circularIn(float t) {\n  return 1.0 - sqrt(1.0 - t * t);\n}\n\n","elastic-out":"#ifndef HALF_PI\n#define HALF_PI 1.5707963267948966\n#endif\n\nfloat elasticOut(float t) {\n  return sin(-13.0 * (t + 1.0) * HALF_PI) * pow(2.0, -10.0 * t) + 1.0;\n}\n\n","cubic-in":"float cubicIn(float t) {\n  return t * t * t;\n}\n\n","exponential-out":"float exponentialOut(float t) {\n  return t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\n","quintic-out":"float quinticOut(float t) {\n  return 1.0 - (pow(t - 1.0, 5.0));\n}\n\n","elastic-in-out":"#ifndef HALF_PI\n#define HALF_PI 1.5707963267948966\n#endif\n\nfloat elasticInOut(float t) {\n  return t < 0.5\n    ? 0.5 * sin(+13.0 * HALF_PI * 2.0 * t) * pow(2.0, 10.0 * (2.0 * t - 1.0))\n    : 0.5 * sin(-13.0 * HALF_PI * ((2.0 * t - 1.0) + 1.0)) * pow(2.0, -10.0 * (2.0 * t - 1.0)) + 1.0;\n}\n\n",linear:"float linear(float t) {\n  return t;\n}\n\n","circular-out":"float circularOut(float t) {\n  return sqrt((2.0 - t) * t);\n}\n\n","back-in-out":"\nfloat backInOut(float t) {\n  float f = t < 0.5\n    ? 2.0 * t\n    : 1.0 - (2.0 * t - 1.0);\n\n  float g = pow(f, 3.0) - f * sin(f * PI);\n\n  return t < 0.5\n    ? 0.5 * g\n    : 0.5 * (1.0 - g) + 0.5;\n}\n\n","back-in":"\nfloat backIn(float t) {\n  return pow(t, 3.0) - t * sin(t * PI);\n}\n\n","sine-in":"#ifndef HALF_PI\n#define HALF_PI 1.5707963267948966\n#endif\n\nfloat sineIn(float t) {\n  return sin((t - 1.0) * HALF_PI) + 1.0;\n}\n\n","back-out":"\nfloat backOut(float t) {\n  float f = 1.0 - t;\n  return 1.0 - (pow(f, 3.0) - f * sin(f * PI));\n}\n\n","quartic-in-out":"float quarticInOut(float t) {\n  return t < 0.5\n    ? +8.0 * pow(t, 4.0)\n    : -8.0 * pow(t - 1.0, 4.0) + 1.0;\n}\n\n","quadratic-in":"float quadraticIn(float t) {\n  return t * t;\n}\n\n","cubic-in-out":"float cubicInOut(float t) {\n  return t < 0.5\n    ? 4.0 * t * t * t\n    : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\n}\n\n","elastic-in":"#ifndef HALF_PI\n#define HALF_PI 1.5707963267948966\n#endif\n\nfloat elasticIn(float t) {\n  return sin(13.0 * t * HALF_PI) * pow(2.0, 10.0 * (t - 1.0));\n}\n\n","bounce-out":Kt,"quadratic-in-out":"float quadraticInOut(float t) {\n  float p = 2.0 * t * t;\n  return t < 0.5 ? p : -p + (4.0 * t) - 1.0;\n}\n\n","exponential-in":"float exponentialIn(float t) {\n  return t == 0.0 ? t : pow(2.0, 10.0 * (t - 1.0));\n}\n\n","quintic-in-out":"float quinticInOut(float t) {\n  return t < 0.5\n    ? +16.0 * pow(t, 5.0)\n    : -0.5 * pow(2.0 * t - 2.0, 5.0) + 1.0;\n}\n\n","sine-in-out":"\nfloat sineInOut(float t) {\n  return -0.5 * (cos(PI * t) - 1.0);\n}\n\n","cubic-out":"float cubicOut(float t) {\n  float f = t - 1.0;\n  return f * f * f + 1.0;\n}\n\n","quadratic-out":"float quadraticOut(float t) {\n  return -t * (t - 2.0);\n}\n\n","bounce-in-out":"\nfloat bounceInOut(float t) {\n  return t < 0.5\n    ? 0.5 * (1.0 - bounceOut(1.0 - t * 2.0))\n    : 0.5 * bounceOut(t * 2.0 - 1.0) + 0.5;\n}\n\n\n\n","quintic-in":"float quinticIn(float t) {\n  return pow(t, 5.0);\n}\n\n","quartic-in":"float quarticIn(float t) {\n  return pow(t, 4.0);\n}\n\n","quartic-out":"float quarticOut(float t) {\n  return pow(t - 1.0, 3.0) * (1.0 - t) + 1.0;\n}\n\n","bounce-in":"\nfloat bounceIn(float t) {\n  return 1.0 - bounceOut(1.0 - t);\n}\n\n","sine-out":"#ifndef HALF_PI\n#define HALF_PI 1.5707963267948966\n#endif\n\nfloat sineOut(float t) {\n  return sin(t * HALF_PI);\n}\n\n"},Jt={"bounce-in":[Kt],"bounce-in-out":[Kt]},tn={"circular-in-out":"circularInOut","exponential-in-out":"exponentialInOut","circular-in":"circularIn","elastic-out":"elasticOut","cubic-in":"cubicIn","exponential-out":"exponentialOut","quintic-out":"quinticOut","elastic-in-out":"elasticInOut",linear:"linear","circular-out":"circularOut","back-in-out":"backInOut","back-in":"backIn","sine-in":"sineIn","back-out":"backOut","quartic-in-out":"quarticInOut","quadratic-in":"quadraticIn","cubic-in-out":"cubicInOut","elastic-in":"elasticIn","bounce-out":"bounceOut","quadratic-in-out":"quadraticInOut","exponential-in":"exponentialIn","quintic-in-out":"quinticInOut","sine-in-out":"sineInOut","cubic-out":"cubicOut","quadratic-out":"quadraticOut","bounce-in-out":"bounceInOut","quintic-in":"quinticIn","quartic-in":"quarticIn","quartic-out":"quarticOut","bounce-in":"bounceIn","sine-out":"sineOut"},nn=Zt.indexOf("sine-in-out");class en extends a.a{constructor(){super(...arguments),this.type=a.b.INTEGER(nn,{menu:{entries:Zt.map((t,n)=>({name:t,value:n}))}}),this.input=a.b.FLOAT(0)}}const on=new en;class sn extends o.b{constructor(){super(...arguments),this.params_config=on}static type(){return"easing"}initialize_node(){super.initialize_node(),this.spare_params_controller.set_inputless_param_names(["type"]),this.io.outputs.set_named_output_connection_points([new c.a("out",r.c.FLOAT)])}set_lines(t){const n=Zt[this.pv.type],e=tn[n],i=Wt[n];let o=[new xt.b(this,r.c.FLOAT,i)];const c=(Jt[n]||[]).map(t=>new xt.b(this,r.c.FLOAT,t));c&&(o=c.concat(o));const a=s.a.float(this.variable_for_input("input")),_=`float ${this.gl_var_name("out")} = ${e}(${a})`;t.add_definitions(this,o),t.add_body_lines(this,[_])}}var cn="\nfloat fit01(float val, float src_min, float src_max){\n\tfloat size = src_max - src_min;\n\treturn (val - src_min) / size;\n}\nvec2 fit01(vec2 val, vec2 src_min, vec2 src_max){\n\treturn vec2(\n\t\tfit01(val.x, src_min.x, src_max.x),\n\t\tfit01(val.y, src_min.y, src_max.y)\n\t);\n}\nvec3 fit01(vec3 val, vec3 src_min, vec3 src_max){\n\treturn vec3(\n\t\tfit01(val.x, src_min.x, src_max.x),\n\t\tfit01(val.y, src_min.y, src_max.y),\n\t\tfit01(val.z, src_min.z, src_max.z)\n\t);\n}\nvec4 fit01(vec4 val, vec4 src_min, vec4 src_max){\n\treturn vec4(\n\t\tfit01(val.x, src_min.x, src_max.x),\n\t\tfit01(val.y, src_min.y, src_max.y),\n\t\tfit01(val.z, src_min.z, src_max.z),\n\t\tfit01(val.w, src_min.w, src_max.w)\n\t);\n}\n\nfloat fit(float val, float src_min, float src_max, float dest_min, float dest_max){\n\tfloat  src_range = src_max - src_min;\n\tfloat dest_range = dest_max - dest_min;\n\n\tfloat r = (val - src_min) / src_range;\n\treturn (r * dest_range) + dest_min;\n}\nvec2 fit(vec2 val, vec2 src_min, vec2 src_max, vec2 dest_min, vec2 dest_max){\n\treturn vec2(\n\t\tfit(val.x, src_min.x, src_max.x, dest_min.x, dest_max.x),\n\t\tfit(val.y, src_min.y, src_max.y, dest_min.y, dest_max.y)\n\t);\n}\nvec3 fit(vec3 val, vec3 src_min, vec3 src_max, vec3 dest_min, vec3 dest_max){\n\treturn vec3(\n\t\tfit(val.x, src_min.x, src_max.x, dest_min.x, dest_max.x),\n\t\tfit(val.y, src_min.y, src_max.y, dest_min.y, dest_max.y),\n\t\tfit(val.z, src_min.z, src_max.z, dest_min.z, dest_max.z)\n\t);\n}\nvec4 fit(vec4 val, vec4 src_min, vec4 src_max, vec4 dest_min, vec4 dest_max){\n\treturn vec4(\n\t\tfit(val.x, src_min.x, src_max.x, dest_min.x, dest_max.x),\n\t\tfit(val.y, src_min.y, src_max.y, dest_min.y, dest_max.y),\n\t\tfit(val.z, src_min.z, src_max.z, dest_min.z, dest_max.z),\n\t\tfit(val.w, src_min.w, src_max.w, dest_min.w, dest_max.w)\n\t);\n}\n";const rn={src_min:0,src_max:1};class an extends B{static type(){return"fit"}_gl_input_name(t){return["val","src_min","src_max","dest_min","dest_max"][t]}gl_input_default_value(t){return rn[t]}gl_method_name(){return"fit"}gl_function_definitions(){return[new xt.b(this,r.c.FLOAT,cn)]}}const _n={src_min:0,src_max:1};class ln extends j{static type(){return"fit01"}gl_input_name(t){return["val","src_min","src_max"][t]}gl_input_default_value(t){return _n[t]}gl_method_name(){return"fit01"}gl_function_definitions(){return[new xt.b(this,r.c.FLOAT,cn)]}}var un=e(387);class pn extends a.a{constructor(){super(...arguments),this.hsv=a.b.VECTOR3([1,1,1])}}const gn=new pn;class dn extends o.b{constructor(){super(...arguments),this.params_config=gn}static type(){return"hsv_to_rgb"}initialize_node(){super.initialize_node(),this.io.outputs.set_named_output_connection_points([new c.a("rgb",r.c.VEC3)])}set_lines(t){const n=[],e=[];n.push(new xt.b(this,r.c.VEC3,"// https://github.com/hughsk/glsl-hsv2rgb\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 hsv2rgb(vec3 c) {\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}"));const i=s.a.vector3(this.variable_for_input(this.p.hsv.name)),o=this.gl_var_name("rgb");e.push(`vec3 ${o} = hsv2rgb(${i})`),t.add_definitions(this,n),t.add_body_lines(this,e)}}const xn="position",vn="normal",fn="instancePosition",mn="instanceOrientation",hn="instanceScale";class yn extends a.a{constructor(){super(...arguments),this.position=a.b.VECTOR3([0,0,0]),this.normal=a.b.VECTOR3([0,0,1]),this.instance_position=a.b.VECTOR3([0,0,0]),this.instance_orientation=a.b.VECTOR4([0,0,0,0]),this.instance_scale=a.b.VECTOR3([1,1,1])}}const zn=new yn;class wn extends o.b{constructor(){super(...arguments),this.params_config=zn}static type(){return"instance_transform"}initialize_node(){super.initialize_node(),this.io.outputs.set_named_output_connection_points([new c.a(this.gl_output_name_position(),r.c.VEC3),new c.a(this.gl_output_name_normal(),r.c.VEC3)])}set_lines(t){const n=[],e=[];e.push(new xt.b(this,r.c.VEC4,Nt));const i=this.io.inputs.named_input(this.p.position.name)?s.a.float(this.variable_for_input(this.p.position.name)):this._default_position(),o=this.io.inputs.named_input(this.p.normal.name)?s.a.float(this.variable_for_input(this.p.normal.name)):this._default_normal(),c=this.io.inputs.named_input(this.p.instance_position.name)?s.a.float(this.variable_for_input(this.p.instance_position.name)):this._default_instance_position(t),a=this.io.inputs.named_input(this.p.instance_orientation.name)?s.a.float(this.variable_for_input(this.p.instance_orientation.name)):this._default_input_instance_orientation(t),_=this.io.inputs.named_input(this.p.instance_scale.name)?s.a.float(this.variable_for_input(this.p.instance_scale.name)):this._default_input_instance_scale(t),l=this.gl_var_name(this.gl_output_name_position()),u=this.gl_var_name(this.gl_output_name_normal());n.push(`vec3 ${l} = vec3(${i})`),n.push(`${l} *= ${_}`),n.push(`${l} = rotate_with_quat( ${l}, ${a} )`),n.push(`${l} += ${c}`),n.push(`vec3 ${u} = vec3(${o})`),n.push(`${u} = rotate_with_quat( ${u}, ${a} )`),t.add_body_lines(this,n),t.add_definitions(this,e)}gl_output_name_position(){return"position"}gl_output_name_normal(){return"normal"}_default_position(){return xn}_default_normal(){return vn}_default_instance_position(t){var n,e;return null===(e=null===(n=this.material_node)||void 0===n?void 0:n.assembler_controller.assembler.globals_handler)||void 0===e?void 0:e.read_attribute(this,r.c.VEC3,fn,t)}_default_input_instance_orientation(t){var n,e;return null===(e=null===(n=this.material_node)||void 0===n?void 0:n.assembler_controller.assembler.globals_handler)||void 0===e?void 0:e.read_attribute(this,r.c.VEC4,mn,t)}_default_input_instance_scale(t){var n,e;return null===(e=null===(n=this.material_node)||void 0===n?void 0:n.assembler_controller.assembler.globals_handler)||void 0===e?void 0:e.read_attribute(this,r.c.VEC3,hn,t)}}class bn extends H{static type(){return"length"}initialize_node(){super.initialize_node(),this.gl_connections_controller.set_input_name_function(this._gl_input_name.bind(this)),this.gl_connections_controller.set_expected_output_types_function(this._expected_output_types.bind(this))}_gl_input_name(t){return["x"][t]}gl_method_name(){return"length"}_expected_output_types(){return[r.c.FLOAT]}}class Pn extends a.a{constructor(){super(...arguments),this.hsv=a.b.VECTOR3([1,1,1])}}const On=new Pn;class En extends o.b{constructor(){super(...arguments),this.params_config=On}static type(){return"luminance"}initialize_node(){super.initialize_node(),this.io.outputs.set_named_output_connection_points([new c.a("lum",r.c.FLOAT)])}set_lines(t){const n=s.a.vector3(this.variable_for_input("color")),e=`float ${this.gl_var_name("lum")} = linearToRelativeLuminance(${n})`;t.add_body_lines(this,[e])}}class Tn extends G{static type(){return"mix"}initialize_node(){super.initialize_node(),this.gl_connections_controller.set_input_name_function(t=>["value0","value1","blend"][t]),this.gl_connections_controller.set_output_name_function(this._gl_output_name.bind(this)),this.gl_connections_controller.set_expected_input_types_function(this._expected_input_types.bind(this)),this.gl_connections_controller.set_expected_output_types_function(this._expected_output_types.bind(this))}_gl_output_name(){return"mix"}_expected_input_types(){const t=this.gl_connections_controller.first_input_connection_type()||r.c.FLOAT;return[t,t,r.c.FLOAT]}_expected_output_types(){return[this._expected_input_types()[0]]}}const An={mult:1};var In;!function(t){t.VALUE="value",t.PRE_ADD="pre_add",t.MULT="mult",t.POST_ADD="post_add"}(In||(In={}));class Cn extends Y{static type(){return"mult_add"}_gl_input_name(t){return[In.VALUE,In.PRE_ADD,In.MULT,In.POST_ADD][t]}gl_input_default_value(t){return An[t]}set_lines(t){const n=s.a.any(this.variable_for_input(In.VALUE)),e=s.a.any(this.variable_for_input(In.PRE_ADD)),i=s.a.any(this.variable_for_input(In.MULT)),o=s.a.any(this.variable_for_input(In.POST_ADD)),c=this._expected_output_types()[0],r=this.io.outputs.named_output_connection_points[0].name,a=`${c} ${this.gl_var_name(r)} = (${i}*(${n} + ${e})) + ${o}`;t.add_body_lines(this,[a])}}class Ln extends H{static type(){return"negate"}initialize_node(){super.initialize_node(),this.gl_connections_controller.set_input_name_function(t=>["in"][t])}_gl_input_name(t){return["in"][t]}set_lines(t){const n=s.a.any(this.variable_for_input(this._gl_input_name(0))),e=`${this.io.inputs.named_input_connection_points[0].type} ${this.gl_var_name(this.gl_connections_controller.output_name(0))} = -1.0 * ${n}`;t.add_body_lines(this,[e])}}var qn;!function(t){t.CLASSIC_PERLIN_2D="Classic Perlin 2D",t.CLASSIC_PERLIN_3D="Classic Perlin 3D",t.CLASSIC_PERLIN_4D="Classic Perlin 4D",t.NOISE_2D="noise2D",t.NOISE_3D="noise3D",t.NOISE_4D="noise4D"}(qn||(qn={}));const Sn=[qn.CLASSIC_PERLIN_2D,qn.CLASSIC_PERLIN_3D,qn.CLASSIC_PERLIN_4D,qn.NOISE_2D,qn.NOISE_3D,qn.NOISE_4D],$n={[qn.CLASSIC_PERLIN_2D]:'//\n// GLSL textureless classic 2D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/stegu/webgl-noise\n//\n\n\n// Classic Perlin noise\nfloat cnoise(vec2 P)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod289(Pi); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;  \n  g01 *= norm.y;  \n  g10 *= norm.z;  \n  g11 *= norm.w;  \n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec2 P, vec2 rep)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, rep.xyxy); // To create noise with explicit period\n  Pi = mod289(Pi);        // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;  \n  g01 *= norm.y;  \n  g10 *= norm.z;  \n  g11 *= norm.w;  \n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n',[qn.CLASSIC_PERLIN_3D]:'//\n// GLSL textureless classic 3D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/stegu/webgl-noise\n//\n\n// Classic Perlin noise\nfloat cnoise(vec3 P)\n{\n  vec3 Pi0 = floor(P); // Integer part for indexing\n  vec3 Pi1 = Pi0 + vec3(1.0); // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec3 P, vec3 rep)\n{\n  vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n  vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x); \n  return 2.2 * n_xyz;\n}\n',[qn.CLASSIC_PERLIN_4D]:'//\n// GLSL textureless classic 4D noise "cnoise",\n// with an RSL-style periodic variant "pnoise".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/stegu/webgl-noise\n//\n\n\n\n// Classic Perlin noise\nfloat cnoise(vec4 P)\n{\n  vec4 Pi0 = floor(P); // Integer part for indexing\n  vec4 Pi1 = Pi0 + 1.0; // Integer part + 1\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec4 Pf0 = fract(P); // Fractional part for interpolation\n  vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = vec4(Pi0.zzzz);\n  vec4 iz1 = vec4(Pi1.zzzz);\n  vec4 iw0 = vec4(Pi0.wwww);\n  vec4 iw1 = vec4(Pi1.wwww);\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n  vec4 ixy00 = permute(ixy0 + iw0);\n  vec4 ixy01 = permute(ixy0 + iw1);\n  vec4 ixy10 = permute(ixy1 + iw0);\n  vec4 ixy11 = permute(ixy1 + iw1);\n\n  vec4 gx00 = ixy00 * (1.0 / 7.0);\n  vec4 gy00 = floor(gx00) * (1.0 / 7.0);\n  vec4 gz00 = floor(gy00) * (1.0 / 6.0);\n  gx00 = fract(gx00) - 0.5;\n  gy00 = fract(gy00) - 0.5;\n  gz00 = fract(gz00) - 0.5;\n  vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n  vec4 sw00 = step(gw00, vec4(0.0));\n  gx00 -= sw00 * (step(0.0, gx00) - 0.5);\n  gy00 -= sw00 * (step(0.0, gy00) - 0.5);\n\n  vec4 gx01 = ixy01 * (1.0 / 7.0);\n  vec4 gy01 = floor(gx01) * (1.0 / 7.0);\n  vec4 gz01 = floor(gy01) * (1.0 / 6.0);\n  gx01 = fract(gx01) - 0.5;\n  gy01 = fract(gy01) - 0.5;\n  gz01 = fract(gz01) - 0.5;\n  vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n  vec4 sw01 = step(gw01, vec4(0.0));\n  gx01 -= sw01 * (step(0.0, gx01) - 0.5);\n  gy01 -= sw01 * (step(0.0, gy01) - 0.5);\n\n  vec4 gx10 = ixy10 * (1.0 / 7.0);\n  vec4 gy10 = floor(gx10) * (1.0 / 7.0);\n  vec4 gz10 = floor(gy10) * (1.0 / 6.0);\n  gx10 = fract(gx10) - 0.5;\n  gy10 = fract(gy10) - 0.5;\n  gz10 = fract(gz10) - 0.5;\n  vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n  vec4 sw10 = step(gw10, vec4(0.0));\n  gx10 -= sw10 * (step(0.0, gx10) - 0.5);\n  gy10 -= sw10 * (step(0.0, gy10) - 0.5);\n\n  vec4 gx11 = ixy11 * (1.0 / 7.0);\n  vec4 gy11 = floor(gx11) * (1.0 / 7.0);\n  vec4 gz11 = floor(gy11) * (1.0 / 6.0);\n  gx11 = fract(gx11) - 0.5;\n  gy11 = fract(gy11) - 0.5;\n  gz11 = fract(gz11) - 0.5;\n  vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n  vec4 sw11 = step(gw11, vec4(0.0));\n  gx11 -= sw11 * (step(0.0, gx11) - 0.5);\n  gy11 -= sw11 * (step(0.0, gy11) - 0.5);\n\n  vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\n  vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\n  vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\n  vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\n  vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\n  vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\n  vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\n  vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\n  vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\n  vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\n  vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\n  vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\n  vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\n  vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\n  vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\n  vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\n\n  vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\n  g0000 *= norm00.x;\n  g0100 *= norm00.y;\n  g1000 *= norm00.z;\n  g1100 *= norm00.w;\n\n  vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\n  g0001 *= norm01.x;\n  g0101 *= norm01.y;\n  g1001 *= norm01.z;\n  g1101 *= norm01.w;\n\n  vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\n  g0010 *= norm10.x;\n  g0110 *= norm10.y;\n  g1010 *= norm10.z;\n  g1110 *= norm10.w;\n\n  vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\n  g0011 *= norm11.x;\n  g0111 *= norm11.y;\n  g1011 *= norm11.z;\n  g1111 *= norm11.w;\n\n  float n0000 = dot(g0000, Pf0);\n  float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\n  float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\n  float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\n  float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\n  float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n  float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\n  float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\n  float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\n  float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\n  float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n  float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\n  float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\n  float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\n  float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\n  float n1111 = dot(g1111, Pf1);\n\n  vec4 fade_xyzw = fade(Pf0);\n  vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n  vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n  vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\n  vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\n  float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n  return 2.2 * n_xyzw;\n}\n\n// Classic Perlin noise, periodic version\nfloat pnoise(vec4 P, vec4 rep)\n{\n  vec4 Pi0 = mod(floor(P), rep); // Integer part modulo rep\n  vec4 Pi1 = mod(Pi0 + 1.0, rep); // Integer part + 1 mod rep\n  Pi0 = mod289(Pi0);\n  Pi1 = mod289(Pi1);\n  vec4 Pf0 = fract(P); // Fractional part for interpolation\n  vec4 Pf1 = Pf0 - 1.0; // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = vec4(Pi0.zzzz);\n  vec4 iz1 = vec4(Pi1.zzzz);\n  vec4 iw0 = vec4(Pi0.wwww);\n  vec4 iw1 = vec4(Pi1.wwww);\n\n  vec4 ixy = permute(permute(ix) + iy);\n  vec4 ixy0 = permute(ixy + iz0);\n  vec4 ixy1 = permute(ixy + iz1);\n  vec4 ixy00 = permute(ixy0 + iw0);\n  vec4 ixy01 = permute(ixy0 + iw1);\n  vec4 ixy10 = permute(ixy1 + iw0);\n  vec4 ixy11 = permute(ixy1 + iw1);\n\n  vec4 gx00 = ixy00 * (1.0 / 7.0);\n  vec4 gy00 = floor(gx00) * (1.0 / 7.0);\n  vec4 gz00 = floor(gy00) * (1.0 / 6.0);\n  gx00 = fract(gx00) - 0.5;\n  gy00 = fract(gy00) - 0.5;\n  gz00 = fract(gz00) - 0.5;\n  vec4 gw00 = vec4(0.75) - abs(gx00) - abs(gy00) - abs(gz00);\n  vec4 sw00 = step(gw00, vec4(0.0));\n  gx00 -= sw00 * (step(0.0, gx00) - 0.5);\n  gy00 -= sw00 * (step(0.0, gy00) - 0.5);\n\n  vec4 gx01 = ixy01 * (1.0 / 7.0);\n  vec4 gy01 = floor(gx01) * (1.0 / 7.0);\n  vec4 gz01 = floor(gy01) * (1.0 / 6.0);\n  gx01 = fract(gx01) - 0.5;\n  gy01 = fract(gy01) - 0.5;\n  gz01 = fract(gz01) - 0.5;\n  vec4 gw01 = vec4(0.75) - abs(gx01) - abs(gy01) - abs(gz01);\n  vec4 sw01 = step(gw01, vec4(0.0));\n  gx01 -= sw01 * (step(0.0, gx01) - 0.5);\n  gy01 -= sw01 * (step(0.0, gy01) - 0.5);\n\n  vec4 gx10 = ixy10 * (1.0 / 7.0);\n  vec4 gy10 = floor(gx10) * (1.0 / 7.0);\n  vec4 gz10 = floor(gy10) * (1.0 / 6.0);\n  gx10 = fract(gx10) - 0.5;\n  gy10 = fract(gy10) - 0.5;\n  gz10 = fract(gz10) - 0.5;\n  vec4 gw10 = vec4(0.75) - abs(gx10) - abs(gy10) - abs(gz10);\n  vec4 sw10 = step(gw10, vec4(0.0));\n  gx10 -= sw10 * (step(0.0, gx10) - 0.5);\n  gy10 -= sw10 * (step(0.0, gy10) - 0.5);\n\n  vec4 gx11 = ixy11 * (1.0 / 7.0);\n  vec4 gy11 = floor(gx11) * (1.0 / 7.0);\n  vec4 gz11 = floor(gy11) * (1.0 / 6.0);\n  gx11 = fract(gx11) - 0.5;\n  gy11 = fract(gy11) - 0.5;\n  gz11 = fract(gz11) - 0.5;\n  vec4 gw11 = vec4(0.75) - abs(gx11) - abs(gy11) - abs(gz11);\n  vec4 sw11 = step(gw11, vec4(0.0));\n  gx11 -= sw11 * (step(0.0, gx11) - 0.5);\n  gy11 -= sw11 * (step(0.0, gy11) - 0.5);\n\n  vec4 g0000 = vec4(gx00.x,gy00.x,gz00.x,gw00.x);\n  vec4 g1000 = vec4(gx00.y,gy00.y,gz00.y,gw00.y);\n  vec4 g0100 = vec4(gx00.z,gy00.z,gz00.z,gw00.z);\n  vec4 g1100 = vec4(gx00.w,gy00.w,gz00.w,gw00.w);\n  vec4 g0010 = vec4(gx10.x,gy10.x,gz10.x,gw10.x);\n  vec4 g1010 = vec4(gx10.y,gy10.y,gz10.y,gw10.y);\n  vec4 g0110 = vec4(gx10.z,gy10.z,gz10.z,gw10.z);\n  vec4 g1110 = vec4(gx10.w,gy10.w,gz10.w,gw10.w);\n  vec4 g0001 = vec4(gx01.x,gy01.x,gz01.x,gw01.x);\n  vec4 g1001 = vec4(gx01.y,gy01.y,gz01.y,gw01.y);\n  vec4 g0101 = vec4(gx01.z,gy01.z,gz01.z,gw01.z);\n  vec4 g1101 = vec4(gx01.w,gy01.w,gz01.w,gw01.w);\n  vec4 g0011 = vec4(gx11.x,gy11.x,gz11.x,gw11.x);\n  vec4 g1011 = vec4(gx11.y,gy11.y,gz11.y,gw11.y);\n  vec4 g0111 = vec4(gx11.z,gy11.z,gz11.z,gw11.z);\n  vec4 g1111 = vec4(gx11.w,gy11.w,gz11.w,gw11.w);\n\n  vec4 norm00 = taylorInvSqrt(vec4(dot(g0000, g0000), dot(g0100, g0100), dot(g1000, g1000), dot(g1100, g1100)));\n  g0000 *= norm00.x;\n  g0100 *= norm00.y;\n  g1000 *= norm00.z;\n  g1100 *= norm00.w;\n\n  vec4 norm01 = taylorInvSqrt(vec4(dot(g0001, g0001), dot(g0101, g0101), dot(g1001, g1001), dot(g1101, g1101)));\n  g0001 *= norm01.x;\n  g0101 *= norm01.y;\n  g1001 *= norm01.z;\n  g1101 *= norm01.w;\n\n  vec4 norm10 = taylorInvSqrt(vec4(dot(g0010, g0010), dot(g0110, g0110), dot(g1010, g1010), dot(g1110, g1110)));\n  g0010 *= norm10.x;\n  g0110 *= norm10.y;\n  g1010 *= norm10.z;\n  g1110 *= norm10.w;\n\n  vec4 norm11 = taylorInvSqrt(vec4(dot(g0011, g0011), dot(g0111, g0111), dot(g1011, g1011), dot(g1111, g1111)));\n  g0011 *= norm11.x;\n  g0111 *= norm11.y;\n  g1011 *= norm11.z;\n  g1111 *= norm11.w;\n\n  float n0000 = dot(g0000, Pf0);\n  float n1000 = dot(g1000, vec4(Pf1.x, Pf0.yzw));\n  float n0100 = dot(g0100, vec4(Pf0.x, Pf1.y, Pf0.zw));\n  float n1100 = dot(g1100, vec4(Pf1.xy, Pf0.zw));\n  float n0010 = dot(g0010, vec4(Pf0.xy, Pf1.z, Pf0.w));\n  float n1010 = dot(g1010, vec4(Pf1.x, Pf0.y, Pf1.z, Pf0.w));\n  float n0110 = dot(g0110, vec4(Pf0.x, Pf1.yz, Pf0.w));\n  float n1110 = dot(g1110, vec4(Pf1.xyz, Pf0.w));\n  float n0001 = dot(g0001, vec4(Pf0.xyz, Pf1.w));\n  float n1001 = dot(g1001, vec4(Pf1.x, Pf0.yz, Pf1.w));\n  float n0101 = dot(g0101, vec4(Pf0.x, Pf1.y, Pf0.z, Pf1.w));\n  float n1101 = dot(g1101, vec4(Pf1.xy, Pf0.z, Pf1.w));\n  float n0011 = dot(g0011, vec4(Pf0.xy, Pf1.zw));\n  float n1011 = dot(g1011, vec4(Pf1.x, Pf0.y, Pf1.zw));\n  float n0111 = dot(g0111, vec4(Pf0.x, Pf1.yzw));\n  float n1111 = dot(g1111, Pf1);\n\n  vec4 fade_xyzw = fade(Pf0);\n  vec4 n_0w = mix(vec4(n0000, n1000, n0100, n1100), vec4(n0001, n1001, n0101, n1101), fade_xyzw.w);\n  vec4 n_1w = mix(vec4(n0010, n1010, n0110, n1110), vec4(n0011, n1011, n0111, n1111), fade_xyzw.w);\n  vec4 n_zw = mix(n_0w, n_1w, fade_xyzw.z);\n  vec2 n_yzw = mix(n_zw.xy, n_zw.zw, fade_xyzw.y);\n  float n_xyzw = mix(n_yzw.x, n_yzw.y, fade_xyzw.x);\n  return 2.2 * n_xyzw;\n}\n',[qn.NOISE_2D]:"//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n",[qn.NOISE_3D]:"//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\n\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n",[qn.NOISE_4D]:"//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : stegu\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//               https://github.com/stegu/webgl-noise\n// \n\n\n\n\n\n\n\nvec4 grad4(float j, vec4 ip)\n  {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \n\n  return p;\n  }\n\t\t\t\t\t\t\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat snoise(vec4 v)\n  {\n  const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                       -0.447213595499958); // -1 + 4 * G4\n\n// First corner\n  vec4 i  = floor(v + dot(v, vec4(F4)) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n  //  x1 = x0 - i1  + 1.0 * C.xxxx\n  //  x2 = x0 - i2  + 2.0 * C.xxxx\n  //  x3 = x0 - i3  + 3.0 * C.xxxx\n  //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n\n// Permutations\n  i = mod289(i); \n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n  }\n"},Nn={[qn.CLASSIC_PERLIN_2D]:r.c.VEC2,[qn.CLASSIC_PERLIN_3D]:r.c.VEC3,[qn.CLASSIC_PERLIN_4D]:r.c.VEC4,[qn.NOISE_2D]:r.c.VEC2,[qn.NOISE_3D]:r.c.VEC3,[qn.NOISE_4D]:r.c.VEC4},Vn={[qn.CLASSIC_PERLIN_2D]:r.c.FLOAT,[qn.CLASSIC_PERLIN_3D]:r.c.FLOAT,[qn.CLASSIC_PERLIN_4D]:r.c.FLOAT,[qn.NOISE_2D]:r.c.FLOAT,[qn.NOISE_3D]:r.c.FLOAT,[qn.NOISE_4D]:r.c.FLOAT},Fn={[qn.CLASSIC_PERLIN_2D]:"cnoise",[qn.CLASSIC_PERLIN_3D]:"cnoise",[qn.CLASSIC_PERLIN_4D]:"cnoise",[qn.NOISE_2D]:"snoise",[qn.NOISE_3D]:"snoise",[qn.NOISE_4D]:"snoise"};var Rn;!function(t){t[t.NoChange=0]="NoChange",t[t.Float=1]="Float",t[t.Vec2=2]="Vec2",t[t.Vec3=3]="Vec3",t[t.Vec4=4]="Vec4"}(Rn||(Rn={}));const Mn=[Rn.NoChange,Rn.Float,Rn.Vec2,Rn.Vec3,Rn.Vec4],Dn={[Rn.NoChange]:"Same as noise",[Rn.Float]:"Float",[Rn.Vec2]:"Vec2",[Rn.Vec3]:"Vec3",[Rn.Vec4]:"Vec4"},Un={[Rn.NoChange]:r.c.FLOAT,[Rn.Float]:r.c.FLOAT,[Rn.Vec2]:r.c.VEC2,[Rn.Vec3]:r.c.VEC3,[Rn.Vec4]:r.c.VEC4},Gn=["x","y","z","w"],Hn=Sn.indexOf(qn.NOISE_3D),kn=Rn.NoChange,jn={amp:1,freq:1};var Yn;!function(t){t.AMP="amp",t.POSITION="position",t.FREQ="freq",t.OFFSET="offset"}(Yn||(Yn={}));class Bn extends a.a{constructor(){super(...arguments),this.type=a.b.INTEGER(Hn,{menu:{entries:Sn.map((t,n)=>({name:`${t} (output: ${Vn[t]})`,value:n}))}}),this.output_type=a.b.INTEGER(kn,{menu:{entries:Mn.map(t=>{const n=Mn[t];return{name:Dn[n],value:n}})}}),this.octaves=a.b.INTEGER(3,{range:[1,10],range_locked:[!0,!1]}),this.amp_attenuation=a.b.FLOAT(.5,{range:[0,1]}),this.freq_increase=a.b.FLOAT(2,{range:[0,10]}),this.separator=a.b.SEPARATOR()}}const Qn=new Bn;class Xn extends o.b{constructor(){super(...arguments),this.params_config=Qn,this.gl_connections_controller=new R.a(this)}static type(){return"noise"}initialize_node(){super.initialize_node(),this.gl_connections_controller.initialize_node(),this.spare_params_controller.set_inputless_param_names(["octaves","amp_attenuation","freq_increase"]),this.io.outputs.set_named_output_connection_points([new c.a("noise",r.c.FLOAT)]),this.gl_connections_controller.set_expected_input_types_function(this._expected_input_types.bind(this)),this.gl_connections_controller.set_expected_output_types_function(this._expected_output_types.bind(this))}_gl_input_name(t){return[Yn.AMP,Yn.POSITION,Yn.FREQ,Yn.OFFSET][t]}gl_input_default_value(t){return jn[t]}_expected_input_types(){const t=Sn[this.pv.type],n=Nn[t];return[n,n,n,n]}_expected_output_types(){const t=Sn[this.pv.type],n=Mn[this.pv.output_type];return n==Rn.NoChange?[Vn[t]]:[Un[n]]}set_lines(t){const n=[],e=[],i=Sn[this.pv.type],o=$n[i],c=Vn[i];n.push(new xt.b(this,c,"// Modulo 289 without a division (only multiplications)\nfloat mod289(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n// Modulo 7 without a division\nvec3 mod7(vec3 x) {\n  return x - floor(x * (1.0 / 7.0)) * 7.0;\n}\n\n// Permutation polynomial: (34x^2 + x) mod 289\nfloat permute(float x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\nvec3 permute(vec3 x) {\n  return mod289((34.0 * x + 1.0) * x);\n}\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat taylorInvSqrt(float r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec2 fade(vec2 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\nvec3 fade(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\nvec4 fade(vec4 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}")),n.push(new xt.b(this,c,o)),n.push(new xt.b(this,c,this.fbm_function()));const a=this._expected_output_types()[0];if(a==c){const t=this.single_noise_line();e.push(t)}else{const t=r.a[a],n=[],o=this.gl_var_name("noise");for(let c=0;c<t;c++){const t=Gn[c];n.push(`${o}${t}`);const a=Nn[i],_=r.a[a],l=`${a}(${N()(_).map(t=>s.a.float(1e3*c)).join(", ")})`,u=this.single_noise_line(t,t,l);e.push(u)}const c=`vec${t} ${o} = vec${t}(${n.join(", ")})`;e.push(c)}t.add_definitions(this,n),t.add_body_lines(this,e)}fbm_method_name(){const t=Sn[this.pv.type];return`fbm_${Fn[t]}_${this.name}`}fbm_function(){const t=Sn[this.pv.type],n=Fn[t],e=Nn[t];return`\nfloat ${this.fbm_method_name()} (in ${e} st) {\n\tfloat value = 0.0;\n\tfloat amplitude = 1.0;\n\tfor (int i = 0; i < ${s.a.int(this.pv.octaves)}; i++) {\n\t\tvalue += amplitude * ${n}(st);\n\t\tst *= ${s.a.float(this.pv.freq_increase)};\n\t\tamplitude *= ${s.a.float(this.pv.amp_attenuation)};\n\t}\n\treturn value;\n}\n`}single_noise_line(t,n,e){const i=Sn[this.pv.type],o=this.fbm_method_name(),c=s.a.any(this.variable_for_input(Yn.AMP)),r=s.a.any(this.variable_for_input(Yn.POSITION)),a=s.a.any(this.variable_for_input(Yn.FREQ));let _=s.a.any(this.variable_for_input(Yn.OFFSET));e&&(_=`(${_}+${e})`);const l=[`(${r}*${a})+${_}`].join(", "),u=this.gl_var_name("noise"),p=`${c}*${o}(${l})`;if(n)return`float ${u}${t} = (${p}).${n}`;return`${Vn[i]} ${u} = ${p}`}}class Kn extends H{static type(){return"null"}set_lines(t){const n=s.a.any(this.variable_for_input("in")),e=`${this.io.inputs.named_input_connection_points[0].type} ${this.gl_var_name("value")} = ${n}`;t.add_body_lines(this,[e])}}class Zn extends a.a{}const Wn=new Zn;class Jn extends o.b{constructor(){super(...arguments),this.params_config=Wn}static type(){return"output"}initialize_node(){super.initialize_node(),this.add_post_dirty_hook("_set_mat_to_recompile",this._set_mat_to_recompile.bind(this))}create_params(){var t;null===(t=this.material_node)||void 0===t||t.assembler_controller.add_output_params(this)}set_lines(t){var n;null===(n=this.material_node)||void 0===n||n.assembler_controller.assembler.set_node_lines_output(this,t)}}var te=e(3),ne=e.n(te),ee=e(376);class ie extends a.a{constructor(){super(...arguments),this.name=a.b.STRING(""),this.type=a.b.INTEGER(r.e.indexOf(r.c.FLOAT),{menu:{entries:r.e.map((t,n)=>({name:t,value:n}))}}),this.as_color=a.b.BOOLEAN(0,{visible_if:{type:r.e.indexOf(r.c.VEC3)}})}}const oe=new ie;class se extends o.b{constructor(){super(...arguments),this.params_config=oe,this._allow_inputs_created_from_params=!1,this._on_create_set_name_if_none_bound=this._on_create_set_name_if_none.bind(this),this.gl_connections_controller=new R.a(this)}static type(){return"param"}initialize_node(){this.add_post_dirty_hook("_set_mat_to_recompile",this._set_mat_to_recompile.bind(this)),this.lifecycle.add_on_create_hook(this._on_create_set_name_if_none_bound),this.gl_connections_controller.initialize_node(),this.gl_connections_controller.set_expected_input_types_function(()=>[]),this.gl_connections_controller.set_expected_output_types_function(()=>[r.e[this.pv.type]])}set_lines(t){const n=[],e=r.e[this.pv.type],i=this.uniform_name();n.push(new xt.d(this,e,i)),t.add_definitions(this,n)}set_param_configs(){const t=r.e[this.pv.type],n=r.b[t];let e=r.d[t];this._param_configs_controller=this._param_configs_controller||new ee.a,this._param_configs_controller.reset(),e==P.a.VECTOR3&&this.p.as_color.value&&ne()(n)&&3==n.length?this._param_configs_controller.create_and_push(P.a.COLOR,this.pv.name,n,this.uniform_name()):this._param_configs_controller.create_and_push(e,this.pv.name,n,this.uniform_name())}uniform_name(){const t=this.io.outputs.named_output_connection_points[0];return this.gl_var_name(t.name)}_on_create_set_name_if_none(){""==this.pv.name&&this.p.name.set(this.name)}}class ce extends G{static type(){return"refract"}initialize_node(){super.initialize_node(),this.gl_connections_controller.set_input_name_function(t=>["I","N","eta"][t]),this.gl_connections_controller.set_output_name_function(t=>"refract"),this.gl_connections_controller.set_expected_input_types_function(this._expected_input_types.bind(this)),this.gl_connections_controller.set_expected_output_types_function(this._expected_output_types.bind(this))}gl_method_name(){return"refract"}_expected_input_types(){const t=this.gl_connections_controller.first_input_connection_type()||r.c.VEC3;return[t,t,r.c.FLOAT]}_expected_output_types(){return[this._expected_input_types()[0]]}}class re extends H{static type(){return"quat_mult"}initialize_node(){super.initialize_node(),this.gl_connections_controller.set_input_name_function(t=>["quat0","quat1"][t]),this.gl_connections_controller.set_expected_input_types_function(()=>[r.c.VEC4,r.c.VEC4]),this.gl_connections_controller.set_expected_output_types_function(()=>[r.c.VEC4])}gl_method_name(){return"quat_mult"}gl_function_definitions(){return[new xt.b(this,r.c.VEC4,Nt)]}}var ae;!function(t){t.AXIS="axis",t.ANGLE="angle"}(ae||(ae={}));const _e=[ae.AXIS,ae.ANGLE],le={[ae.AXIS]:[0,0,1],[ae.ANGLE]:0};class ue extends k{static type(){return"quat_from_axis_angle"}initialize_node(){super.initialize_node(),this.gl_connections_controller.set_input_name_function(t=>_e[t]),this.gl_connections_controller.set_expected_input_types_function(()=>[r.c.VEC3,r.c.FLOAT]),this.gl_connections_controller.set_expected_output_types_function(()=>[r.c.VEC4])}gl_input_default_value(t){return le[t]}gl_method_name(){return"quat_from_axis_angle"}gl_function_definitions(){return[new xt.b(this,r.c.VEC4,Nt)]}}class pe extends H{static type(){return"quat_to_angle"}initialize_node(){super.initialize_node(),this.gl_connections_controller.set_input_name_function(t=>["quat"][t]),this.gl_connections_controller.set_expected_input_types_function(()=>[r.c.VEC4]),this.gl_connections_controller.set_expected_output_types_function(()=>[r.c.FLOAT])}gl_method_name(){return"quat_to_angle"}gl_function_definitions(){return[new xt.b(this,r.c.FLOAT,Nt)]}}class ge extends H{static type(){return"quat_to_axis"}initialize_node(){super.initialize_node(),this.gl_connections_controller.set_input_name_function(t=>["quat"][t]),this.gl_connections_controller.set_expected_input_types_function(()=>[r.c.VEC4]),this.gl_connections_controller.set_expected_output_types_function(()=>[r.c.VEC3])}gl_method_name(){return"quat_to_axis"}gl_function_definitions(){return[new xt.b(this,r.c.VEC3,Nt)]}}var de=e(28);class xe extends a.a{constructor(){super(...arguments),this.name=a.b.STRING("ramp"),this.input=a.b.FLOAT(0)}}const ve=new xe;class fe extends o.b{constructor(){super(...arguments),this.params_config=ve}static type(){return"ramp"}initialize(){super.initialize_node(),this.io.outputs.set_named_output_connection_points([new c.a("val",r.c.FLOAT)])}set_lines(t){const n=r.c.FLOAT,e=this._uniform_name(),i=this.gl_var_name("val"),o=new xt.d(this,r.c.SAMPLER_2D,e);t.add_definitions(this,[o]);const s=this.variable_for_input(this.p.input.name),c=`${n} ${i} = texture2D(${this._uniform_name()}, vec2(${s}, 0.0)).x`;t.add_body_lines(this,[c])}set_param_configs(){this._param_configs_controller=this._param_configs_controller||new ee.a,this._param_configs_controller.reset(),this._param_configs_controller.create_and_push(P.a.RAMP,this.pv.name,de.a.DEFAULT_VALUE,this._uniform_name())}_uniform_name(){return"ramp_texture_"+this.gl_var_name("val")}}class me extends a.a{constructor(){super(...arguments),this.seed=a.b.VECTOR2([1,1])}}const he=new me;class ye extends o.b{constructor(){super(...arguments),this.params_config=he}static type(){return"random"}initialize_node(){super.initialize_node(),this.io.outputs.set_named_output_connection_points([new c.a("rand",r.c.FLOAT)])}set_lines(t){const n=this.io.inputs.named_input_connection_points[0].name,e=s.a.vector2(this.variable_for_input(n)),i=`float ${this.gl_var_name("rand")} = rand(${e})`;t.add_body_lines(this,[i])}}class ze extends a.a{constructor(){super(...arguments),this.rgb=a.b.VECTOR3([1,1,1])}}const we=new ze;class be extends o.b{constructor(){super(...arguments),this.params_config=we}static type(){return"rgb_to_hsv"}initialize_node(){super.initialize_node(),this.io.outputs.set_named_output_connection_points([new c.a("hsv",r.c.VEC3)])}set_lines(t){const n=[],e=[];n.push(new xt.b(this,r.c.VEC3,"// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\nvec3 rgb2hsv(vec3 c)\n{\n\tvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\tvec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n\tvec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n\tfloat d = q.x - min(q.w, q.y);\n\tfloat e = 1.0e-10;\n\treturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}"));const i=s.a.vector3(this.variable_for_input("rgb")),o=this.gl_var_name("hsv");e.push(`vec3 ${o} = rgb2hsv(${i})`),t.add_definitions(this,n),t.add_body_lines(this,e)}}var Pe;!function(t){t[t.AXIS=0]="AXIS",t[t.QUAT=1]="QUAT"}(Pe||(Pe={}));const Oe=[Pe.AXIS,Pe.QUAT],Ee={[Pe.AXIS]:"from axis + angle",[Pe.QUAT]:"from quaternion"},Te={[Pe.AXIS]:["vector","axis","angle"],[Pe.QUAT]:["vector","quat"]},Ae={[Pe.AXIS]:"rotate_with_axis_angle",[Pe.QUAT]:"rotate_with_quat"},Ie={[Pe.AXIS]:[r.c.VEC3,r.c.VEC3,r.c.FLOAT],[Pe.QUAT]:[r.c.VEC3,r.c.VEC4]},Ce={vector:[0,0,1],axis:[0,1,0]};class Le extends a.a{constructor(){super(...arguments),this.signature=a.b.INTEGER(Pe.AXIS,{menu:{entries:Oe.map((t,n)=>({name:Ee[t],value:n}))}})}}const qe=new Le;class Se extends M{constructor(){super(...arguments),this.params_config=qe}static type(){return"rotate"}initialize_node(){super.initialize_node(),this.gl_connections_controller.set_expected_input_types_function(this._expected_input_types.bind(this)),this.gl_connections_controller.set_expected_output_types_function(this._expected_output_types.bind(this)),this.gl_connections_controller.set_input_name_function(this._gl_input_name.bind(this))}_gl_input_name(t){const n=Oe[this.pv.signature];return Te[n][t]}gl_input_default_value(t){return Ce[t]}gl_method_name(){const t=Oe[this.pv.signature];return Ae[t]}_expected_input_types(){const t=Oe[this.pv.signature];return Ie[t]}_expected_output_types(){return[r.c.VEC3]}gl_function_definitions(){const t=this._expected_output_types()[0];return[new xt.b(this,t,Nt)]}set_lines(t){const n=this.io.outputs.named_output_connection_points[0].type,e=this.io.inputs.named_input_connection_points.map((t,n)=>{const e=t.name;return s.a.any(this.variable_for_input(e))}).join(", "),i=`${n} ${this.gl_var_name(this.gl_connections_controller.output_name(0))} = ${this.gl_method_name()}(${e})`;t.add_body_lines(this,[i]),t.add_definitions(this,this.gl_function_definitions())}}const $e=["x","y","z","w"];class Ne extends H{static type(){return"round"}set_lines(t){const n=this.io.inputs.named_input_connection_points[0],e=s.a.vector2(this.variable_for_input(n.name)),i=this.io.outputs.named_output_connection_points[0],o=this.gl_var_name(i.name),c=[];if(1==r.a[i.type])c.push(`${i.type} ${o} = ${this._simple_line(e)}`);else{const t=$e.map(t=>this._simple_line(`${e}.${t}`));c.push(`${i.type} ${o} = ${i.type}(${t.join(",")})`)}t.add_body_lines(this,c)}_simple_line(t){return`sign(${t})*floor(abs(${t})+0.5)`}}var Ve=e(351);class Fe extends a.a{constructor(){super(...arguments),this.param_name=a.b.STRING("texture_map"),this.default_value=a.b.STRING(Ve.a.DEFAULT_NODE_PATH.UV),this.uv=a.b.VECTOR2([0,0])}}const Re=new Fe;class Me extends o.b{constructor(){super(...arguments),this.params_config=Re}static type(){return"texture"}initialize_node(){super.initialize_node(),this.io.outputs.set_named_output_connection_points([new c.a(Me.OUTPUT_NAME,r.c.VEC4)])}set_lines(t){const n=s.a.vector2(this.variable_for_input(this.p.uv.name)),e=this.gl_var_name(Me.OUTPUT_NAME),i=this._uniform_name(),o=new xt.d(this,r.c.SAMPLER_2D,i),c=`vec4 ${e} = texture2D(${i}, ${n})`;t.add_definitions(this,[o]),t.add_body_lines(this,[c])}set_param_configs(){this._param_configs_controller=this._param_configs_controller||new ee.a,this._param_configs_controller.reset(),this._param_configs_controller.create_and_push(P.a.OPERATOR_PATH,this.pv.param_name,this.pv.default_value,this._uniform_name())}_uniform_name(){return this.gl_var_name(this.pv.param_name)}}Me.OUTPUT_NAME="rgba";var De;!function(t){t.CONDITION="condition",t.IF_TRUE="if_true",t.IF_FALSE="if_false"}(De||(De={}));const Ue=[De.CONDITION,De.IF_TRUE,De.IF_FALSE];class Ge extends o.a{constructor(){super(...arguments),this.gl_connections_controller=new R.a(this)}static type(){return"two_way_switch"}initialize_node(){super.initialize_node(),this.gl_connections_controller.initialize_node(),this.gl_connections_controller.set_expected_input_types_function(this._expected_input_types.bind(this)),this.gl_connections_controller.set_expected_output_types_function(this._expected_output_types.bind(this)),this.gl_connections_controller.set_input_name_function(this._gl_input_name.bind(this)),this.gl_connections_controller.set_output_name_function(this._gl_output_name.bind(this))}_gl_input_name(t){return Ue[t]}_gl_output_name(){return"value"}_expected_input_types(){const t=this.io.connections.input_connection(1)||this.io.connections.input_connection(2),n=t?this.gl_connections_controller.connection_type_from_connection(t):r.c.FLOAT;return[r.c.BOOL,n,n]}_expected_output_types(){return[this._expected_input_types()[1]]}set_lines(t){const n=[],e=this.gl_var_name("value"),i=s.a.bool(this.variable_for_input(De.CONDITION)),o=s.a.any(this.variable_for_input(De.IF_TRUE)),c=s.a.any(this.variable_for_input(De.IF_FALSE)),r=this._expected_output_types()[1];n.push(`${r} ${e}`),n.push(`if(${i}){`),n.push(`${e} = ${o}`),n.push("} else {"),n.push(`${e} = ${c}`),n.push("}"),t.add_body_lines(this,n)}}const He={start:[0,0,1],end:[1,0,0],up:[0,1,0]};class ke extends(jt("vector_align",{in:["start","end","up"],method:"vector_align_with_up",functions:[Nt]})){_expected_input_types(){const t=r.c.VEC3;return[t,t,t]}_expected_output_types(){return[r.c.VEC4]}gl_input_default_value(t){return He[t]}}const je={start:[0,0,1],end:[1,0,0]};class Ye extends(vt("vector_angle",{in:["start","end"],method:"vector_angle",functions:[Nt]})){_expected_input_types(){const t=r.c.VEC3;return[t,t]}_expected_output_types(){return[r.c.FLOAT]}gl_input_default_value(t){return je[t]}}var Be=e(35);class Qe{static run(t){t.register_node(X,i.c.MATH),t.register_node(K,i.c.TRIGO),t.register_node(Et,i.c.MATH),t.register_node(Rt,i.c.TRIGO),t.register_node(qt,i.c.LOGIC),t.register_node(Z,i.c.TRIGO),t.register_node(W,i.c.TRIGO),t.register_node(Mt.a,i.c.GLOBALS,{except:[`${Be.a.COP}/builder`]}),t.register_node(J,i.c.MATH),t.register_node(tt,i.c.TRIGO),t.register_node(Dt.a,i.c.GLOBALS),t.register_node(Ut,i.c.MATH),t.register_node(kt,i.c.GEOMETRY),t.register_node(Yt,i.c.MATH),t.register_node(nt,i.c.CONVERSION),t.register_node(Xt,i.c.GEOMETRY),t.register_node(ft,i.c.GEOMETRY),t.register_node(Tt,i.c.MATH),t.register_node(mt,i.c.GEOMETRY),t.register_node(sn,i.c.MATH),t.register_node(et,i.c.MATH),t.register_node(it,i.c.MATH),t.register_node(an,i.c.MATH),t.register_node(ln,i.c.MATH),t.register_node(u,i.c.CONVERSION),t.register_node(f,i.c.CONVERSION),t.register_node(y,i.c.CONVERSION),t.register_node(b,i.c.CONVERSION),t.register_node(ot,i.c.MATH),t.register_node(st,i.c.MATH),t.register_node(un.a,i.c.GLOBALS),t.register_node(dn,i.c.COLOR),t.register_node(d,i.c.CONVERSION),t.register_node(ct,i.c.MATH),t.register_node(wn,i.c.GEOMETRY),t.register_node(bn,i.c.GEOMETRY),t.register_node(En,i.c.COLOR),t.register_node(Ln,i.c.MATH),t.register_node(rt,i.c.MATH),t.register_node(at,i.c.MATH),t.register_node(ht,i.c.MATH),t.register_node(yt,i.c.MATH),t.register_node(zt,i.c.MATH),t.register_node(Tn,i.c.MATH),t.register_node(It,i.c.MATH),t.register_node(Cn,i.c.MATH),t.register_node(Kn,i.c.UTIL),t.register_node(Xn,i.c.GEOMETRY),t.register_node(_t,i.c.MATH),t.register_node(St,i.c.LOGIC),t.register_node(Jn,i.c.GLOBALS),t.register_node(se,i.c.GLOBALS),t.register_node(wt,i.c.MATH),t.register_node(re,i.c.QUAT),t.register_node(ue,i.c.QUAT),t.register_node(pe,i.c.QUAT),t.register_node(ge,i.c.QUAT),t.register_node(fe,i.c.GLOBALS),t.register_node(ye,i.c.GLOBALS),t.register_node(lt,i.c.CONVERSION),t.register_node(bt,i.c.GEOMETRY),t.register_node(ce,i.c.GEOMETRY),t.register_node(be,i.c.COLOR),t.register_node(Se,i.c.GEOMETRY),t.register_node(Ne,i.c.MATH),t.register_node(ut,i.c.MATH),t.register_node(pt,i.c.TRIGO),t.register_node(gt,i.c.MATH),t.register_node(Pt,i.c.GEOMETRY),t.register_node(At,i.c.MATH),t.register_node(dt,i.c.TRIGO),t.register_node(Me,i.c.COLOR),t.register_node(Ge,i.c.TRIGO),t.register_node(C,i.c.CONVERSION),t.register_node(L,i.c.CONVERSION),t.register_node(q,i.c.CONVERSION),t.register_node(S,i.c.CONVERSION),t.register_node(ke,i.c.GEOMETRY),t.register_node(Ye,i.c.GEOMETRY)}}}}]);
//# sourceMappingURL=Gl.bundle.js.map