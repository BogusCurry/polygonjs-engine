{"version":3,"sources":["webpack://POLY/./src/engine/nodes/utils/shaders/ShaderName.ts","webpack://POLY/./node_modules/three/src/loaders/Loader.js","webpack://POLY/./src/engine/containers/Material.ts","webpack://POLY/./src/engine/nodes/mat/_Base.ts","webpack://POLY/./src/engine/nodes/gl/code/assemblers/materials/_BaseMaterial.ts","webpack://POLY/./src/engine/nodes/gl/code/globals/Geometry.ts","webpack://POLY/./node_modules/three/src/textures/VideoTexture.js","webpack://POLY/./node_modules/three/src/loaders/Cache.js","webpack://POLY/./src/engine/nodes/mat/utils/_BaseController.ts","webpack://POLY/./src/engine/nodes/mat/utils/SideController.ts","webpack://POLY/./src/engine/nodes/gl/code/configs/ShaderConfig.ts","webpack://POLY/./src/engine/nodes/gl/code/configs/VariableConfig.ts","webpack://POLY/./src/engine/nodes/mat/utils/SkinningController.ts","webpack://POLY/./src/engine/nodes/mat/utils/TextureMapController.ts","webpack://POLY/./src/engine/nodes/mat/utils/TextureAlphaMapController.ts","webpack://POLY/./src/engine/io/json/export/Scene.ts","webpack://POLY/./src/engine/io/json/export/Node.ts","webpack://POLY/./src/engine/io/json/export/Param.ts","webpack://POLY/./src/engine/io/json/export/param/Numeric.ts","webpack://POLY/./src/engine/io/json/export/param/OperatorPath.ts","webpack://POLY/./src/engine/io/json/export/param/String.ts","webpack://POLY/./src/engine/io/json/export/param/Ramp.ts","webpack://POLY/./src/engine/io/json/export/Dispatcher.ts","webpack://POLY/./src/engine/nodes/gl/code/Controller.ts","webpack://POLY/./src/engine/nodes/gl/code/utils/LineType.ts","webpack://POLY/./src/engine/nodes/gl/code/utils/LinesController.ts","webpack://POLY/./src/engine/nodes/gl/code/utils/ShadersCollectionController.ts","webpack://POLY/./src/engine/nodes/gl/code/utils/CodeFormatter.ts","webpack://POLY/./src/engine/nodes/gl/code/utils/CodeBuilder.ts","webpack://POLY/./src/engine/nodes/gl/code/assemblers/_Base.ts","webpack://POLY/./src/engine/nodes/utils/shaders/BaseAssembler.ts","webpack://POLY/./node_modules/lodash/_assignMergeValue.js","webpack://POLY/./node_modules/lodash/_safeGet.js","webpack://POLY/./node_modules/three/src/loaders/ImageLoader.js","webpack://POLY/./node_modules/three/src/loaders/LoadingManager.js","webpack://POLY/./node_modules/three/src/materials/PointsMaterial.js","webpack://POLY/./node_modules/three/src/loaders/TextureLoader.js","webpack://POLY/./node_modules/three/src/materials/MeshStandardMaterial.js","webpack://POLY/./node_modules/lodash/intersection.js","webpack://POLY/./src/engine/nodes/gl/code/globals/_Base.ts","webpack://POLY/./src/engine/nodes/utils/shaders/NodeTraverser.ts","webpack://POLY/./src/engine/nodes/gl/code/utils/NodeFinder.ts","webpack://POLY/./src/engine/nodes/mat/utils/_BaseTextureController.ts","webpack://POLY/./src/engine/nodes/mat/utils/UniformsColorsController.ts","webpack://POLY/./src/engine/nodes/mat/_BaseBuilder.ts","webpack://POLY/./node_modules/three/src/materials/MeshLambertMaterial.js","webpack://POLY/./node_modules/lodash/merge.js","webpack://POLY/./node_modules/lodash/_baseMerge.js","webpack://POLY/./node_modules/lodash/_baseMergeDeep.js","webpack://POLY/./node_modules/lodash/isPlainObject.js","webpack://POLY/./node_modules/lodash/toPlainObject.js","webpack://POLY/./node_modules/lodash/_createAssigner.js","webpack://POLY/./node_modules/lodash/_baseIntersection.js","webpack://POLY/./node_modules/lodash/_castArrayLikeObject.js","webpack://POLY/./src/engine/nodes/gl/code/templates/CustomMeshDepthDOF.frag.glsl","webpack://POLY/./src/engine/nodes/gl/code/assemblers/materials/CustomPointsDepth.ts","webpack://POLY/./src/engine/nodes/gl/code/templates/CustomPointsDepth.vert.glsl","webpack://POLY/./src/engine/nodes/gl/code/assemblers/materials/CustomPointsDistance.ts","webpack://POLY/./src/engine/nodes/gl/code/templates/CustomPointsDistance.vert.glsl","webpack://POLY/./src/engine/nodes/gl/code/templates/CustomPointsDepthDOF.vert.glsl","webpack://POLY/./src/engine/nodes/gl/code/assemblers/materials/CustomPointsDepthDOF.ts","webpack://POLY/./src/engine/nodes/gl/code/assemblers/materials/Points.ts","webpack://POLY/./src/engine/nodes/mat/PointsBuilder.ts","webpack://POLY/./src/engine/nodes/mat/utils/ColorsController.ts","webpack://POLY/./src/engine/nodes/mat/MeshBasic.ts","webpack://POLY/./src/engine/nodes/gl/code/assemblers/materials/CustomMeshDistance.ts","webpack://POLY/./src/engine/nodes/gl/code/assemblers/materials/CustomMeshDepth.ts","webpack://POLY/./src/engine/nodes/gl/code/templates/CustomMeshDepthDOF.vert.glsl","webpack://POLY/./src/engine/nodes/gl/code/assemblers/materials/CustomMeshDepthDOF.ts","webpack://POLY/./src/engine/nodes/gl/code/assemblers/materials/_BaseMesh.ts","webpack://POLY/./src/engine/nodes/gl/code/assemblers/materials/Basic.ts","webpack://POLY/./src/engine/nodes/mat/MeshBasicBuilder.ts","webpack://POLY/./src/engine/nodes/mat/MeshLambert.ts","webpack://POLY/./src/engine/nodes/gl/code/assemblers/materials/Lambert.ts","webpack://POLY/./src/engine/nodes/mat/MeshLambertBuilder.ts","webpack://POLY/./src/engine/nodes/mat/utils/TextureEnvMapController.ts","webpack://POLY/./src/engine/nodes/mat/MeshStandard.ts","webpack://POLY/./src/engine/nodes/gl/code/assemblers/materials/Standard.ts","webpack://POLY/./src/engine/nodes/gl/gl/ShaderLib/ShaderChunk/metalnessmap_fragment.glsl","webpack://POLY/./src/engine/nodes/gl/gl/ShaderLib/ShaderChunk/roughnessmap_fragment.glsl","webpack://POLY/./src/engine/nodes/mat/MeshStandardBuilder.ts","webpack://POLY/./src/engine/nodes/mat/Points.ts","webpack://POLY/./src/engine/poly/registers/Mat.ts"],"names":["ShaderName","ParticleShaderNames","PARTICLES_0","PARTICLES_1","PARTICLES_2","PARTICLES_3","PARTICLES_4","PARTICLES_5","PARTICLES_6","PARTICLES_7","PARTICLES_8","PARTICLES_9","Loader","manager","this","undefined","crossOrigin","path","resourcePath","Object","assign","prototype","load","parse","setCrossOrigin","setPath","setResourcePath","content","super","set_content","material","_content","dispose","has_content","container_controller","_cook_main_without_inputs_when_dirty_bound","_cook_main_without_inputs_when_dirty","bind","NodeContext","MAT","initialize_base_node","name_controller","add_post_set_full_path_hook","set_material_name","add_post_dirty_hook","name","node_sibbling","cook_controller","cook_main_without_inputs","_material","full_path","create_material","set_container","object","CustomMaterialName","ShaderAssemblerMaterial","_assemblers_by_custom_name","Map","class_by_custom_name","custom_assembler_class_by_custom_name","forEach","assembler_class","custom_name","_add_custom_material","custom_assembler","get","_gl_parent_node","set","custom_materials","_code_builder","assembler","set_root_nodes","_root_nodes","set_param_configs_owner","set_shader_configs","shader_configs","set_variable_configs","variable_configs","custom_material","compile_material","compile_allowed","output_nodes","find_output_nodes","length","states","error","_update_shaders","new_vertex_shader","_shaders_by_name","VERTEX","new_fragment_shader","FRAGMENT","vertexShader","fragmentShader","add_uniforms","uniforms","needsUpdate","scene","uniforms_time_dependent","uniforms_controller","add_time_dependent_uniform_owner","uuid","remove_time_dependent_uniform_owner","compile_custom_materials","_lines","shader_name","shader_names","template","_template_shader_for_shader_name","split","build_code_from_nodes","_build_lines","lines","join","output_node","shaders_collection_controller","input_name","input","io","inputs","named_input","var_input","variable_for_input","variable_config","new_var","vector3","default_from_attribute","connection_point","named_input_connection_points_by_name","gl_type","type","attr_read","globals_handler","read_attribute","variable_config_default","default","prefix","suffix","if_condition","add_body_lines","current_shader_name","input_names","shader_config","add_output_body_line","attribute_node","attribute_name","var_name","gl_var_name","output_name","body_lines","push","globals_node","dependencies","definitions_by_shader_name","body_lines_by_shader_name","definition","body_line","outputs","used_output_names","globals_shader_name","FLOAT","push_on_array_at_entry","dependency","set_uniforms_time_dependent","handle_gl_FragCoord","handle_resolution","VEC2","set_resolution_dependent","handle_globals_node","definitions","add_definitions","VARIABLE_CONFIG_DEFAULT_BY_NAME","position","GlobalsGeometryHandler","named_output_connection_points_by_name","material_node","assembler_controller","variable_name","node","attrib_name","PRE_DEFINED_ATTRIBUTES","indexOf","varying_definition","set_varying_body_line","IF_RULE","uv","VideoTexture","video","mapping","wrapS","wrapT","magFilter","minFilter","format","anisotropy","call","generateMipmaps","create","constructor","isVideoTexture","update","image","readyState","HAVE_CURRENT_DATA","Cache","enabled","files","add","key","file","remove","clear","BaseController","SideParamConfig","Base","double_sided","BOOLEAN","front","visible_if","SideController","single_side","pv","new_side","side","ShaderConfig","_name","_input_names","_dependencies","VariableConfig","_options","SkinningParamConfig","skinning","SkinningController","new_skinning","TextureMapParamConfig","use_map","TextureMapController","map","OPERATOR_PATH","DEFAULT_NODE_PATH","UV","_update_options","add_hooks","p","_update","texture_map_controller","TextureAlphaMapParamConfig","use_alpha_map","TextureAlphaMapController","alpha_map","texture_alpha_map_controller","_scene","_data","nodes_controller","reset_node_context_signatures","root_exporter","dispatch_node","root","nodes_data","data","ui_data","properties","frame","frame_range","frame_range_locked","time_controller","master_camera_node_path","cameras_controller","ui","word","replace","escape_line_breaks","_node","is_root","register_node_context_signature","keys","context","children_controller","params_data","inputs_data","flags","has_bypass","bypass","active","has_display","display","children_allowed","selection","children","selected_children","selected_ids","selected_node","nodes","graph_node_id","child","n","override_clonable_state_allowed","override","override_clonable_state","add_custom","toArray","comment","sanitize_string","node_exporter","parent","input_index","connection","connections","input_connection","has_named_inputs","named_input_connection_points","output_index","named_output_connection_points","output","param_name","params","names","param","parent_param","param_exporter","dispatch_param","required","ParamJsonExporter","_param","_complex_data","is_spare_and_not_component","options","is_spare","value_changed","is_default","console","warn","_require_data_complex","_data_complex","_data_simple","raw_input_serialized","default_value_serialized","current","add_main","has_options_overridden","overridden_options","options_overridden","option_name","option_value","JSON","stringify","val","raw_input","OperatorPath","Ramp","_globals_handler","_compile_required","_deleted_params_data","_assembler","id","set_compilation_required_and_dirty","reset_configs","output_child","add_output_params","add_globals_params","allow_attribute_exports","globals","create_node","set_position","Vector2","new_state","trigger_node","set_compilation_required","set_dirty","create_spare_parameters","param_config","param_configs","set_uniform_value","current_spare_param_names","spare_names","assembler_param_names","c","spare_param_names_to_add","spare_param_names_to_remove","params_update_options","current_param_names","spare_params_with_same_name_as_params","error_message","names_to_delete","param_options","spare","cook","to_add","init_value","default_value","update_params","LineType","_shader_name","_definitions_by_node_id","_body_lines_by_node_id","MapUtils","line","_shader_names","_current_shader_name","_lines_controller_by_shader_name","lines_controller","LINE_SUFFIXES","FUNCTION_DECLARATION","DEFINE","BODY","LINE_PREFIXES","line_type","add_suffix","_param_configs_controller","ParamConfigsController","_param_configs_set_allowed","_function_declared","root_nodes","node_traverser","traverse","nodes_by_shader_name","nodes_for_shader_name","sorted_nodes","root_nodes_for_shader","root_nodes_by_shader_name","root_node","sorted_node_ids","reset_code","eval_all","_shaders_collection_controller","reset","set_current_shader_name","set_param_configs","set_lines","set_code_lines","lines_map","list","add_code_lines","GLDefinition","FUNCTION","UNIFORM","VARYING","ATTRIBUTE","add_code_line_for_nodes_and_line_type","definition_type","node_definitions","filter","d","collection","uniq_definitions","uniq","errored","definitions_by_node_id","node_ids","node_id","has","lines_for_shader","boolean","first_definition","node_comment","line_wrap","separator","post_line_separator","nodes_count","i","is_last","add_code_line_for_node_and_line_type","INSERT_DEFINE_AFTER_MAP","INSERT_BODY_AFTER_MAP","LINES_TO_REMOVE_MAP","_leaf_nodes","_uniforms_time_dependent","_resolution_dependent","_template_shader","_replace_template","current_uniforms","uniform_name","uniform","value","time","resolution_dependent","Globals","Attribute","code_builder","build_from_nodes","allow_new_param_configs","disallow_new_param_configs","all_lines","_param_config_owner","param_config_owner","add_param","ParamType","VECTOR3","hidden","COLOR","VECTOR2","ConnectionPointType","VEC3","VEC4","create_globals_node_output_connections","set_named_output_connection_points","_reset_shader_configs","_reset_variable_configs","_reset_uniforms_time_dependency","_reset_resolution_dependency","_shader_configs","create_shader_configs","sc","_variable_configs","create_variable_configs","vc","if","function_declaration","builder_lines","define","body","template_lines","new_lines","line_before_define","insert_define_after","line_before_body","insert_body_after","lines_to_remove","line_before_define_found","line_before_body_found","template_line","_insert_lines","line_remove_required","line_to_remove","lines_to_add","line_to_add","baseAssignValue","eq","module","exports","ImageLoader","url","onLoad","onProgress","onError","resolveURL","scope","cached","itemStart","setTimeout","itemEnd","document","createElementNS","onImageLoad","removeEventListener","onImageError","event","itemError","addEventListener","substr","src","LoadingManager","isLoading","itemsLoaded","itemsTotal","urlModifier","handlers","onStart","setURLModifier","transform","addHandler","regex","loader","removeHandler","index","splice","getHandler","l","global","lastIndex","test","DefaultLoadingManager","PointsMaterial","parameters","color","alphaMap","size","sizeAttenuation","morphTargets","setValues","isPointsMaterial","copy","source","TextureLoader","texture","isJPEG","search","MeshStandardMaterial","defines","roughness","metalness","lightMap","lightMapIntensity","aoMap","aoMapIntensity","emissive","emissiveIntensity","emissiveMap","bumpMap","bumpScale","normalMap","normalMapType","normalScale","displacementMap","displacementScale","displacementBias","roughnessMap","metalnessMap","envMap","envMapIntensity","refractionRatio","wireframe","wireframeLinewidth","wireframeLinecap","wireframeLinejoin","morphNormals","vertexTangents","isMeshStandardMaterial","arrayMap","baseIntersection","baseRest","castArrayLikeObject","intersection","arrays","mapped","GlobalsBaseController","_id","__next_id","TypedNodeTraverser","_leaves_graph_id","_graph_ids_by_shader_name","_outputs_by_graph_id","_depth_by_graph_id","_graph_id_by_depth","_graph","graph","input_names_for_shader_name","find_leaves_from_root_node","set_nodes_depth","depth","graph_id","LEAVES_FROM_NODES_SHADER","find_leaves","nodes_from_ids","depths","sort","a","b","graph_ids_for_depth","node_from_id","ids","unique_inputs","booleans_by_graph_id","set_node_depth","current_depth","Math","max","output_ids","output_id","GlNodeFinder","nodes_by_type","is_exporting","BooleanParamOptions","controller_class","callback","OperatorPathOptions","controller","use_map_name","node_selection","COP","BaseTextureMapController","use_map_param","path_param","mat_attrib_name","shader_material","attr_name","_update_texture_on_uniforms","direct_params","mat","_update_texture_on_material","_update_required_attribute","_apply_texture_on_uniforms","_remove_texture_from_uniforms","has_texture","new_texture_is_different","_do_update_define","define_name","_define_name","toUpperCase","_apply_texture_on_material","_remove_texture_from_material","texture_owner","update_callback","remove_callback","is_dirty","compute","found_node","node_context","texture_node","request_container","ColorParamConfig","transparent","opacity","alpha_test","use_fog","ColorsController","depthTest","alphaTest","fog","TypedBuilderMatNode","_children_controller_context","GL","lifecycle","add_on_create_hook","on_create","init","_assembler_controller","_create_assembler_controller","compile_required","_compile","post_compile","MeshLambertMaterial","specularMap","combine","reflectivity","isMeshLambertMaterial","baseMerge","merge","createAssigner","srcIndex","Stack","assignMergeValue","baseFor","baseMergeDeep","isObject","keysIn","safeGet","customizer","stack","srcValue","newValue","cloneBuffer","cloneTypedArray","copyArray","initCloneObject","isArguments","isArray","isArrayLikeObject","isBuffer","isFunction","isPlainObject","isTypedArray","toPlainObject","mergeFunc","objValue","stacked","isCommon","isArr","isBuff","isTyped","baseGetTag","getPrototype","isObjectLike","funcProto","Function","objectProto","funcToString","toString","hasOwnProperty","objectCtorString","proto","Ctor","copyObject","isIterateeCall","assigner","sources","guard","SetCache","arrayIncludes","arrayIncludesWith","baseUnary","cacheHas","nativeMin","min","iteratee","comparator","includes","othLength","othIndex","caches","Array","maxLength","Infinity","result","array","seen","outer","computed","cache","ShaderLib","UniformsUtils","clone","template_shader","ShaderMaterial","USE_SIZEATTENUATION","DEPTH_PACKING","distanceRGBA","scale","mNear","mFar","CUSTOM_ASSEMBLER_MAP","DISTANCE","DEPTH","DEPTH_DOF","points","_add_custom_materials","concat","params_config","compile_if_required","set_material","use_vertex_colors","Material","new_vertex_color","vertexColors","MeshBasicMaterial","set_post_create_params_hook","initialize_node","ASSEMBLER_MAP","basic","lights","lambert","TextureEnvMapParamConfig","use_env_map","env_map","File","ENV_MAP","env_map_intensity","texture_env_map_controller","SHADER_DEFAULTS","is_physical","physical","standard","extensions","derivatives","onBeforeCompile","shader","_update_metalness","_update_roughness","size_attenuation","PointsParamConfig","poly","register_node","MESH","ADVANCED","POINTS","PointsBuilder"],"mappings":"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","file":"Mat.bundle.js","sourcesContent":["export enum ShaderName {\n\tVERTEX = 'vertex',\n\tFRAGMENT = 'fragment',\n\tLEAVES_FROM_NODES_SHADER = 'leaves_from_nodes_shader',\n\tPARTICLES_0 = 'particles_0',\n\tPARTICLES_1 = 'particles_1',\n\tPARTICLES_2 = 'particles_2',\n\tPARTICLES_3 = 'particles_3',\n\tPARTICLES_4 = 'particles_4',\n\tPARTICLES_5 = 'particles_5',\n\tPARTICLES_6 = 'particles_6',\n\tPARTICLES_7 = 'particles_7',\n\tPARTICLES_8 = 'particles_8',\n\tPARTICLES_9 = 'particles_9',\n}\nexport const ParticleShaderNames: Array<ShaderName> = [\n\tShaderName.PARTICLES_0,\n\tShaderName.PARTICLES_1,\n\tShaderName.PARTICLES_2,\n\tShaderName.PARTICLES_3,\n\tShaderName.PARTICLES_4,\n\tShaderName.PARTICLES_5,\n\tShaderName.PARTICLES_6,\n\tShaderName.PARTICLES_7,\n\tShaderName.PARTICLES_8,\n\tShaderName.PARTICLES_9,\n];\n","import { DefaultLoadingManager } from './LoadingManager.js';\n\n/**\n * @author alteredq / http://alteredqualia.com/\n */\n\nfunction Loader( manager ) {\n\n\tthis.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;\n\n\tthis.crossOrigin = 'anonymous';\n\tthis.path = '';\n\tthis.resourcePath = '';\n\n}\n\nObject.assign( Loader.prototype, {\n\n\tload: function ( /* url, onLoad, onProgress, onError */ ) {},\n\n\tparse: function ( /* data */ ) {},\n\n\tsetCrossOrigin: function ( crossOrigin ) {\n\n\t\tthis.crossOrigin = crossOrigin;\n\t\treturn this;\n\n\t},\n\n\tsetPath: function ( path ) {\n\n\t\tthis.path = path;\n\t\treturn this;\n\n\t},\n\n\tsetResourcePath: function ( resourcePath ) {\n\n\t\tthis.resourcePath = resourcePath;\n\t\treturn this;\n\n\t}\n\n} );\n\nexport { Loader };\n","import {Material} from 'three/src/materials/Material';\nimport {TypedContainer} from './_Base';\nimport {ContainableMap} from './utils/ContainableMap';\n\nexport class MaterialContainer extends TypedContainer<ContainableMap['MATERIAL']> {\n\tset_content(content: ContainableMap['MATERIAL']) {\n\t\tsuper.set_content(content);\n\t}\n\tset_material(material: Material) {\n\t\tif (this._content != null) {\n\t\t\tthis._content.dispose();\n\t\t}\n\t\tthis.set_content(material);\n\t}\n\thas_material() {\n\t\treturn this.has_content();\n\t}\n\tmaterial() {\n\t\treturn this.content();\n\t}\n}\n","import {TypedNode} from '../_Base';\n\nimport {Material} from 'three/src/materials/Material';\n\n// import DisplayFlag from '../Concerns/DisplayFlag';\n\nimport {MaterialContainer} from '../../containers/Material';\nimport {Object3D} from 'three/src/core/Object3D';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {TypedContainerController} from '../utils/ContainerController';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\n// type RenderHook = (object: Object3D) => void;\n\nexport abstract class TypedMatNode<M extends Material, K extends NodeParamsConfig> extends TypedNode<\n\t'MATERIAL',\n\tBaseMatNodeType,\n\tK\n> {\n\tcontainer_controller: TypedContainerController<MaterialContainer> = new TypedContainerController<MaterialContainer>(\n\t\tthis,\n\t\tMaterialContainer\n\t);\n\tstatic node_context(): NodeContext {\n\t\treturn NodeContext.MAT;\n\t}\n\n\tprotected _material: M | undefined;\n\t// protected _update_methods: RenderHook[] = [];\n\n\tinitialize_base_node() {\n\t\tsuper.initialize_base_node();\n\t\t// this._update_methods = [];\n\n\t\t// this._init_bypass_flag({\n\t\t// \thas_bypass_flag: false,\n\t\t// });\n\t\t// this._init_display_flag({\n\t\t// \thas_display_flag: false,\n\t\t// });\n\n\t\t// this.set_inputs_count_to_zero();\n\t\t// this._init_outputs({has_outputs: false});\n\n\t\t// this.container_controller.init(MaterialContainer);\n\n\t\tthis.name_controller.add_post_set_full_path_hook(this.set_material_name.bind(this));\n\n\t\tthis.add_post_dirty_hook(\n\t\t\t'_cook_main_without_inputs_when_dirty',\n\t\t\tthis._cook_main_without_inputs_when_dirty_bound\n\t\t);\n\n\t\t// it's probably good not to have to create any material in the constructor\n\t\t// but only on request\n\t\t// this._material = this.create_material();\n\t\t// this.set_material(this._material);\n\t}\n\tnode_sibbling(name: string): BaseMatNodeType | null {\n\t\treturn super.node_sibbling(name) as BaseMatNodeType | null;\n\t}\n\tprivate _cook_main_without_inputs_when_dirty_bound = this._cook_main_without_inputs_when_dirty.bind(this);\n\tprivate async _cook_main_without_inputs_when_dirty() {\n\t\tawait this.cook_controller.cook_main_without_inputs();\n\t}\n\n\tprivate set_material_name() {\n\t\t// ensures the material has a full path set\n\t\t// allowing the render hook to be set\n\t\t//this.set_material(@_material)\n\t\tif (this._material) {\n\t\t\tthis._material.name = this.full_path();\n\t\t}\n\t}\n\n\tabstract create_material(): M;\n\tget material() {\n\t\treturn (this._material = this._material || this.create_material());\n\t}\n\t//\n\n\tset_material(material: Material) {\n\t\tthis.set_container(material);\n\t}\n\n\t// add_update_method(method, arg?: any) {\n\t// \tthis._update_methods.push([method.bind(this), arg]);\n\t// }\n\n\t//run_update_methods: ->\n\n\tadd_render_hook(object: Object3D) {}\n}\n//delete object.onBeforeRender\n\nexport type BaseMatNodeType = TypedMatNode<Material, any>;\nexport class BaseMatNodeClass extends TypedMatNode<Material, any> {\n\tcreate_material() {\n\t\treturn new Material();\n\t}\n}\n","import {BaseGlShaderAssembler} from '../_Base';\n\nimport {ThreeToGl} from '../../../../../../core/ThreeToGl';\nimport {OutputGlNode} from '../../../Output';\nimport {AttributeGlNode} from '../../../Attribute';\nimport {ShaderName} from '../../../../utils/shaders/ShaderName';\nimport {GlobalsGlNode} from '../../../Globals';\nimport {BaseGLDefinition, UniformGLDefinition} from '../../../utils/GLDefinition';\nimport {ConnectionPointType} from '../../../../utils/connections/ConnectionPointType';\nimport {MapUtils} from '../../../../../../core/MapUtils';\nimport {ShaderMaterialWithCustomMaterials} from '../../../../../../core/geometry/Material';\nimport {ShadersCollectionController} from '../../utils/ShadersCollectionController';\nimport {ShaderMaterial} from 'three/src/materials/ShaderMaterial';\nimport {GlNodeFinder} from '../../utils/NodeFinder';\nimport {IUniformsWithTime} from '../../../../../scene/utils/UniformsController';\n// import {BaseNodeType} from '../../_Base';\n// import {GlobalsGeometryHandler} from './Globals/Geometry'\n\nexport enum CustomMaterialName {\n\tDISTANCE = 'customDistanceMaterial',\n\tDEPTH = 'customDepthMaterial',\n\tDEPTH_DOF = 'customDepthDOFMaterial',\n}\n// export type ShaderAssemblerRenderDerivated = {new (node: BaseNodeType): ShaderAssemblerRender};\n// type ShaderAssemblerRenderDerivatedClass = new (...args: any[]) => ShaderAssemblerRender;\nexport type CustomAssemblerMap = Map<CustomMaterialName, typeof ShaderAssemblerMaterial>;\n\nexport class ShaderAssemblerMaterial extends BaseGlShaderAssembler {\n\tprivate _assemblers_by_custom_name: Map<CustomMaterialName, ShaderAssemblerMaterial> = new Map();\n\n\tcreate_material(): ShaderMaterial {\n\t\treturn new ShaderMaterial();\n\t}\n\n\tcustom_assembler_class_by_custom_name(): CustomAssemblerMap | undefined {\n\t\treturn undefined;\n\t}\n\n\tprotected _add_custom_materials(material: ShaderMaterial) {\n\t\tconst class_by_custom_name = this.custom_assembler_class_by_custom_name();\n\t\tif (class_by_custom_name) {\n\t\t\tclass_by_custom_name.forEach(\n\t\t\t\t(assembler_class: typeof ShaderAssemblerMaterial, custom_name: CustomMaterialName) => {\n\t\t\t\t\tthis._add_custom_material(\n\t\t\t\t\t\tmaterial as ShaderMaterialWithCustomMaterials,\n\t\t\t\t\t\tcustom_name,\n\t\t\t\t\t\tassembler_class\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t}\n\tprivate _add_custom_material(\n\t\tmaterial: ShaderMaterialWithCustomMaterials,\n\t\tcustom_name: CustomMaterialName,\n\t\tassembler_class: typeof ShaderAssemblerMaterial\n\t) {\n\t\tlet custom_assembler: ShaderAssemblerMaterial | undefined = this._assemblers_by_custom_name.get(custom_name);\n\t\tif (!custom_assembler) {\n\t\t\tcustom_assembler = new assembler_class(this._gl_parent_node);\n\t\t\tthis._assemblers_by_custom_name.set(custom_name, custom_assembler);\n\t\t}\n\t\tmaterial.custom_materials = material.custom_materials || {};\n\t\tmaterial.custom_materials[custom_name] = custom_assembler.create_material();\n\t}\n\n\tasync compile_custom_materials(material: ShaderMaterialWithCustomMaterials): Promise<void> {\n\t\t// const custom_materials_by_name: Map<CustomMaterialName, ShaderMaterial> = new Map();\n\t\t// this._assemblers_by_custom_name.clear();\n\n\t\tconst class_by_custom_name = this.custom_assembler_class_by_custom_name();\n\t\tif (class_by_custom_name) {\n\t\t\tclass_by_custom_name.forEach(\n\t\t\t\tasync (assembler_class: typeof ShaderAssemblerMaterial, custom_name: CustomMaterialName) => {\n\t\t\t\t\tif (this._code_builder) {\n\t\t\t\t\t\tlet assembler: ShaderAssemblerMaterial | undefined = this._assemblers_by_custom_name.get(\n\t\t\t\t\t\t\tcustom_name\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (!assembler) {\n\t\t\t\t\t\t\tassembler = new assembler_class(this._gl_parent_node);\n\t\t\t\t\t\t\tthis._assemblers_by_custom_name.set(custom_name, assembler);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tassembler.set_root_nodes(this._root_nodes);\n\t\t\t\t\t\tassembler.set_param_configs_owner(this._code_builder);\n\t\t\t\t\t\tassembler.set_shader_configs(this.shader_configs);\n\t\t\t\t\t\tassembler.set_variable_configs(this.variable_configs());\n\n\t\t\t\t\t\tconst custom_material = material.custom_materials[custom_name];\n\t\t\t\t\t\tif (custom_material) {\n\t\t\t\t\t\t\tawait assembler.compile_material(custom_material);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// if (material) {\n\t\t\t\t\t\t// \t// add needsUpdate = true, as we always get the same material\n\t\t\t\t\t\t// \t// material.needsUpdate = true;\n\t\t\t\t\t\t// \tcustom_materials_by_name.set(custom_name, material);\n\t\t\t\t\t\t// }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\n\t\t// for (let custom_name of Object.keys(class_by_custom_name)) {\n\t\t// \tconst assembler_class = class_by_custom_name[custom_name];\n\t\t// \t// const assembler = new assembler_class(this._gl_parent_node)\n\n\t\t// }\n\n\t\t// return custom_materials_by_name;\n\t}\n\tasync compile_material(material: ShaderMaterial) {\n\t\t// no need to compile if the globals handler has not been declared\n\t\tif (!this.compile_allowed()) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst output_nodes = GlNodeFinder.find_output_nodes(this._gl_parent_node);\n\t\tif (output_nodes.length > 1) {\n\t\t\tthis._gl_parent_node.states.error.set('only one output node allowed');\n\t\t}\n\t\tthis.set_root_nodes(output_nodes);\n\t\tawait this._update_shaders();\n\n\t\tconst new_vertex_shader = this._shaders_by_name.get(ShaderName.VERTEX);\n\t\tconst new_fragment_shader = this._shaders_by_name.get(ShaderName.FRAGMENT);\n\t\tif (new_vertex_shader && new_fragment_shader) {\n\t\t\tmaterial.vertexShader = new_vertex_shader;\n\t\t\tmaterial.fragmentShader = new_fragment_shader;\n\t\t\t// if (this._template_shader && this._template_shader.uniforms) {\n\t\t\tthis.add_uniforms(material.uniforms);\n\t\t\t// }\n\t\t\tmaterial.needsUpdate = true;\n\t\t}\n\n\t\tconst scene = this._gl_parent_node.scene;\n\t\tif (this.uniforms_time_dependent()) {\n\t\t\t// make sure not to use this._gl_parent_node.graph_node_id() as the id,\n\t\t\t// as we need several materials:\n\t\t\t// - the visible one\n\t\t\t// - the multiple shadow ones\n\t\t\t// - and possibly a depth one\n\t\t\tscene.uniforms_controller.add_time_dependent_uniform_owner(\n\t\t\t\tmaterial.uuid,\n\t\t\t\tmaterial.uniforms as IUniformsWithTime\n\t\t\t);\n\t\t} else {\n\t\t\tscene.uniforms_controller.remove_time_dependent_uniform_owner(material.uuid);\n\t\t}\n\n\t\t// const material = await this._assembler.get_material();\n\t\t// if (material) {\n\t\t// this._shaders_by_name.set(ShaderName.VERTEX, this._template_shader!.vertexShader!);\n\t\t// this._shaders_by_name.set(ShaderName.FRAGMENT, this._template_shader!.fragmentShader!);\n\n\t\t// assign custom materials\n\t\tif ((material as ShaderMaterialWithCustomMaterials).custom_materials) {\n\t\t\tawait this.compile_custom_materials(material as ShaderMaterialWithCustomMaterials);\n\t\t}\n\t\t// const custom_materials = await this.get_custom_materials();\n\t\t// const material_with_custom_materials = material as ShaderMaterialWithCustomMaterials;\n\t\t// material_with_custom_materials.custom_materials = {};\n\t\t// custom_materials.forEach((custom_material, shader_name) => {\n\t\t// \tmaterial_with_custom_materials.custom_materials[shader_name] = custom_material;\n\t\t// });\n\n\t\t// material.needsUpdate = true;\n\t\t// }\n\n\t\t// this.create_spare_parameters();\n\t}\n\tprivate async _update_shaders() {\n\t\tthis._shaders_by_name = new Map();\n\t\tthis._lines = new Map();\n\t\tfor (let shader_name of this.shader_names) {\n\t\t\tconst template = this._template_shader_for_shader_name(shader_name);\n\t\t\tif (template) {\n\t\t\t\tthis._lines.set(shader_name, template.split('\\n'));\n\t\t\t}\n\t\t}\n\t\tif (this._root_nodes.length > 0) {\n\t\t\t// this._output_node.set_assembler(this)\n\t\t\tawait this.build_code_from_nodes(this._root_nodes);\n\n\t\t\tthis._build_lines();\n\t\t}\n\t\t// this._material.uniforms = this.build_uniforms(template_shader)\n\t\tfor (let shader_name of this.shader_names) {\n\t\t\tconst lines = this._lines.get(shader_name);\n\t\t\tif (lines) {\n\t\t\t\tthis._shaders_by_name.set(shader_name, lines.join('\\n'));\n\t\t\t}\n\t\t}\n\t}\n\n\tshadow_assembler_class_by_custom_name() {\n\t\treturn {};\n\t}\n\n\tadd_output_body_line(\n\t\toutput_node: OutputGlNode,\n\t\tshaders_collection_controller: ShadersCollectionController,\n\t\tinput_name: string\n\t) {\n\t\tconst input = output_node.io.inputs.named_input(input_name);\n\t\tconst var_input = output_node.variable_for_input(input_name);\n\t\tconst variable_config = this.variable_config(input_name);\n\n\t\tlet new_var: string | null = null;\n\t\tif (input) {\n\t\t\tnew_var = ThreeToGl.vector3(var_input);\n\t\t} else {\n\t\t\tif (variable_config.default_from_attribute()) {\n\t\t\t\tconst connection_point = output_node.io.inputs.named_input_connection_points_by_name(input_name);\n\t\t\t\tif (connection_point) {\n\t\t\t\t\tconst gl_type = connection_point.type;\n\t\t\t\t\tconst attr_read = this.globals_handler?.read_attribute(\n\t\t\t\t\t\toutput_node,\n\t\t\t\t\t\tgl_type,\n\t\t\t\t\t\tinput_name,\n\t\t\t\t\t\tshaders_collection_controller\n\t\t\t\t\t);\n\t\t\t\t\tif (attr_read) {\n\t\t\t\t\t\tnew_var = attr_read;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst variable_config_default = variable_config.default();\n\t\t\t\tif (variable_config_default) {\n\t\t\t\t\tnew_var = variable_config_default;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// const default_value = variable_config.default()\n\t\t\t// new_var = default_value\n\t\t\t// const definition_configs = variable_config.required_definitions() || []\n\t\t\t// for(let definition_config of definition_configs){\n\t\t\t// \tconst definition = definition_config.create_definition(output_node)\n\t\t\t// \toutput_node.add_definitions([definition])\n\t\t\t// }\n\t\t}\n\t\tif (new_var) {\n\t\t\tconst prefix = variable_config.prefix();\n\t\t\tconst suffix = variable_config.suffix();\n\t\t\tconst if_condition = variable_config.if_condition();\n\t\t\tif (if_condition) {\n\t\t\t\tshaders_collection_controller.add_body_lines(output_node, [`#if ${if_condition}`]);\n\t\t\t}\n\t\t\tshaders_collection_controller.add_body_lines(output_node, [`${prefix}${new_var}${suffix}`]);\n\t\t\tif (if_condition) {\n\t\t\t\tshaders_collection_controller.add_body_lines(output_node, [`#endif`]);\n\t\t\t}\n\t\t}\n\t}\n\n\tset_node_lines_output(output_node: OutputGlNode, shaders_collection_controller: ShadersCollectionController) {\n\t\t// const body_lines = [];\n\t\tconst shader_name = shaders_collection_controller.current_shader_name;\n\t\tconst input_names = this.shader_config(shader_name)?.input_names();\n\t\tif (input_names) {\n\t\t\t// shaders_collection_controller.set_body_lines([], shader_name);\n\t\t\tfor (let input_name of input_names) {\n\t\t\t\tthis.add_output_body_line(output_node, shaders_collection_controller, input_name);\n\t\t\t}\n\t\t}\n\t}\n\tset_node_lines_attribute(\n\t\tattribute_node: AttributeGlNode,\n\t\tshaders_collection_controller: ShadersCollectionController\n\t) {\n\t\t// const named_output = attribute_node.connected_output()\n\t\t// const named_connection = attribute_node.connected_input()\n\t\tconst gl_type = attribute_node.gl_type();\n\t\tconst new_var = this.globals_handler?.read_attribute(\n\t\t\tattribute_node,\n\t\t\tgl_type,\n\t\t\tattribute_node.attribute_name,\n\t\t\tshaders_collection_controller\n\t\t);\n\t\tconst var_name = attribute_node.gl_var_name(attribute_node.output_name);\n\t\tshaders_collection_controller.add_body_lines(attribute_node, [`${gl_type} ${var_name} = ${new_var}`]);\n\t\t// this.add_output_body_line(\n\t\t// \tattribute_node,\n\t\t// \tshader_name,\n\t\t// \tinput_name\n\t\t// \t)\n\n\t\t// const vertex_definitions = []\n\t\t// const vertex_body_lines = []\n\t\t// const fragment_definitions = []\n\n\t\t// const named_output = attribute_node.named_outputs()[0]\n\t\t// const gl_type = named_output.type()\n\t\t// const var_name = attribute_node.gl_var_name(named_output.name())\n\n\t\t// const attribute_name = attribute_node.attribute_name()\n\t\t// // TODO: I should probably raise an error in the node\n\t\t// // maybe when doint the initial eval of all nodes and check for errors?\n\t\t// if(!attribute_name){\n\t\t// \tconsole.error(attribute_node.full_path())\n\t\t// \tthrow new Error(\"empty attr name\")\n\t\t// }\n\t\t// if(GlobalsGeometryHandler.PRE_DEFINED_ATTRIBUTES.indexOf(attribute_name) < 0){\n\t\t// \tvertex_definitions.push(new Definition.Attribute(attribute_node, gl_type, attribute_name))\n\t\t// }\n\t\t// vertex_definitions.push(new Definition.Varying(attribute_node, gl_type, var_name))\n\t\t// vertex_body_lines.push( `${var_name} = ${attribute_name}` )\n\t\t// fragment_definitions.push(new Definition.Varying(attribute_node, gl_type, var_name))\n\n\t\t// attribute_node.set_definitions(vertex_definitions, 'vertex')\n\t\t// attribute_node.set_definitions(fragment_definitions, 'fragment')\n\t\t// attribute_node.add_body_lines(vertex_body_lines, 'vertex')\n\t}\n\n\thandle_gl_FragCoord(body_lines: string[], shader_name: ShaderName, var_name: string) {\n\t\tif (shader_name == ShaderName.FRAGMENT) {\n\t\t\tbody_lines.push(`vec4 ${var_name} = gl_FragCoord`);\n\t\t}\n\t}\n\thandle_resolution(body_lines: string[], shader_name: ShaderName, var_name: string) {\n\t\tif (shader_name == ShaderName.FRAGMENT) {\n\t\t\tbody_lines.push(`vec2 ${var_name} = resolution`);\n\t\t}\n\t}\n\n\tset_node_lines_globals(globals_node: GlobalsGlNode, shaders_collection_controller: ShadersCollectionController) {\n\t\t// const vertex_definitions = [];\n\t\t// const fragment_definitions = [];\n\t\t// const definitions = [];\n\t\t// const vertex_body_lines = []\n\t\t// const fragment_body_lines = [];\n\t\tconst body_lines = [];\n\t\tconst shader_name = shaders_collection_controller.current_shader_name;\n\t\tconst shader_config = this.shader_config(shader_name);\n\t\tif (!shader_config) {\n\t\t\treturn;\n\t\t}\n\t\tconst dependencies = shader_config.dependencies();\n\n\t\tconst definitions_by_shader_name: Map<ShaderName, BaseGLDefinition[]> = new Map();\n\t\t// definitions_by_shader_nameshader_name] = [];\n\t\t// for (let dependency of dependencies) {\n\t\t// \tdefinitions_by_shader_name[dependency] = [];\n\t\t// }\n\n\t\tconst body_lines_by_shader_name: Map<ShaderName, string[]> = new Map();\n\t\t// body_lines_by_shader_name[shader_name] = [];\n\t\t// for (let dependency of dependencies) {\n\t\t// \tbody_lines_by_shader_name[dependency] = [];\n\t\t// }\n\n\t\tlet definition;\n\t\tlet body_line;\n\t\tfor (let output_name of globals_node.io.outputs.used_output_names()) {\n\t\t\tconst var_name = globals_node.gl_var_name(output_name);\n\t\t\tconst globals_shader_name = shaders_collection_controller.current_shader_name;\n\n\t\t\tswitch (output_name) {\n\t\t\t\tcase 'time':\n\t\t\t\t\tdefinition = new UniformGLDefinition(globals_node, ConnectionPointType.FLOAT, output_name);\n\t\t\t\t\tif (globals_shader_name) {\n\t\t\t\t\t\tMapUtils.push_on_array_at_entry(definitions_by_shader_name, globals_shader_name, definition);\n\t\t\t\t\t}\n\n\t\t\t\t\tbody_line = `float ${var_name} = ${output_name}`;\n\t\t\t\t\tfor (let dependency of dependencies) {\n\t\t\t\t\t\tMapUtils.push_on_array_at_entry(definitions_by_shader_name, dependency, definition);\n\t\t\t\t\t\tMapUtils.push_on_array_at_entry(body_lines_by_shader_name, dependency, body_line);\n\t\t\t\t\t}\n\n\t\t\t\t\t// vertex_body_lines.push(`float ${var_name} = ${output_name}`)\n\t\t\t\t\tbody_lines.push(body_line);\n\t\t\t\t\tthis.set_uniforms_time_dependent();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'gl_FragCoord':\n\t\t\t\t\tthis.handle_gl_FragCoord(body_lines, shader_name, var_name);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'resolution':\n\t\t\t\t\tthis.handle_resolution(body_lines, shader_name, var_name);\n\t\t\t\t\tdefinition = new UniformGLDefinition(globals_node, ConnectionPointType.VEC2, output_name);\n\t\t\t\t\tif (globals_shader_name) {\n\t\t\t\t\t\tMapUtils.push_on_array_at_entry(definitions_by_shader_name, globals_shader_name, definition);\n\t\t\t\t\t}\n\t\t\t\t\tfor (let dependency of dependencies) {\n\t\t\t\t\t\tMapUtils.push_on_array_at_entry(definitions_by_shader_name, dependency, definition);\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.set_resolution_dependent();\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'gl_PointCoord':\n\t\t\t\t\tif (shader_name == ShaderName.FRAGMENT) {\n\t\t\t\t\t\tbody_lines.push(`vec2 ${var_name} = gl_PointCoord`);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t// const named_output = globals_node.named_output_by_name(output_name)\n\t\t\t\t\t// const gl_type = named_output.gl_type()\n\t\t\t\t\t// const new_var = this.globals_handler().read_attribute(\n\t\t\t\t\t// \tglobals_node,\n\t\t\t\t\t// \tgl_type,\n\t\t\t\t\t// \toutput_name\n\t\t\t\t\t// )\n\t\t\t\t\t// const body_line = `${var_name} = ${new_var}`\n\t\t\t\t\t// globals_node.add_body_lines([body_line])\n\t\t\t\t\tthis.globals_handler?.handle_globals_node(\n\t\t\t\t\t\tglobals_node,\n\t\t\t\t\t\toutput_name,\n\t\t\t\t\t\tshaders_collection_controller\n\t\t\t\t\t\t// definitions_by_shader_name,\n\t\t\t\t\t\t// body_lines_by_shader_name,\n\t\t\t\t\t\t// body_lines,\n\t\t\t\t\t\t// dependencies,\n\t\t\t\t\t\t// shader_name\n\t\t\t\t\t);\n\t\t\t\t// const named_output = globals_node.named_output_by_name(output_name)\n\t\t\t\t// const gl_type = named_output.gl_type()\n\t\t\t\t// definition = new Definition.Varying(globals_node, gl_type, var_name)\n\t\t\t\t// definitions_by_shader_name[shader_name].push(definition)\n\t\t\t\t// throw \"debug\"\n\n\t\t\t\t// body_line = `${var_name} = vec3(${output_name})`\n\t\t\t\t// for(let dependency of dependencies){\n\t\t\t\t// \tdefinitions_by_shader_name[dependency].push(definition)\n\t\t\t\t// \tbody_lines_by_shader_name[dependency].push(body_line)\n\t\t\t\t// }\n\t\t\t\t// if(dependencies.length == 0){\n\t\t\t\t// \tbody_lines.push(body_line)\n\t\t\t\t// }\n\t\t\t}\n\t\t}\n\t\t// this.set_vertex_definitions(vertex_definitions)\n\t\t// this.set_fragment_definitions(fragment_definitions)\n\t\tdefinitions_by_shader_name.forEach((definitions, shader_name) => {\n\t\t\tshaders_collection_controller.add_definitions(globals_node, definitions, shader_name);\n\t\t});\n\t\tbody_lines_by_shader_name.forEach((body_lines, shader_name) => {\n\t\t\tshaders_collection_controller.add_body_lines(globals_node, body_lines, shader_name);\n\t\t});\n\t\t// this.add_definitions(definitions)\n\t\t// this.set_vertex_body_lines(vertex_body_lines)\n\t\t// this.set_fragment_body_lines(fragment_body_lines)\n\n\t\tshaders_collection_controller.add_body_lines(globals_node, body_lines);\n\t}\n}\n","import {GlobalsBaseController} from './_Base';\nimport {GlobalsGlNode} from '../../Globals';\nimport {AttributeGlNode} from '../../Attribute';\n// import {Definition} from '../../Definition/_Module';\n// import {DefinitionBaseConfig} from '../Config/DefinitionBaseConfig';\n// import {BaseGlNodeType} from '../../_Base';\nimport {VaryingGLDefinition, AttributeGLDefinition} from '../../utils/GLDefinition';\nimport {ConnectionPointType} from '../../../utils/connections/ConnectionPointType';\n// import {TypeAssert} from '../../../../poly/Assert';\nimport {MapUtils} from '../../../../../core/MapUtils';\nimport {ShaderName} from '../../../utils/shaders/ShaderName';\nimport {BaseGlNodeType} from '../../_Base';\nimport {ShadersCollectionController} from '../utils/ShadersCollectionController';\n\nconst VARIABLE_CONFIG_DEFAULT_BY_NAME: Dictionary<string> = {\n\tposition: 'vec3( position )',\n};\n\nexport class GlobalsGeometryHandler extends GlobalsBaseController {\n\tstatic PRE_DEFINED_ATTRIBUTES = [\n\t\t'position',\n\t\t'color',\n\t\t'normal',\n\t\t'uv',\n\t\t'uv2',\n\t\t'morphTarget0',\n\t\t'morphTarget1',\n\t\t'morphTarget2',\n\t\t'morphTarget3',\n\t\t'skinIndex',\n\t\t'skinWeight',\n\t];\n\n\tstatic IF_RULE = {\n\t\tuv:\n\t\t\t'defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )',\n\t};\n\n\thandle_globals_node(\n\t\tglobals_node: GlobalsGlNode,\n\t\toutput_name: string,\n\t\tshaders_collection_controller: ShadersCollectionController\n\t\t// definitions_by_shader_name: Map<ShaderName, BaseGLDefinition[]>,\n\t\t// body_lines_by_shader_name: Map<ShaderName, string[]>,\n\t\t// body_lines: string[],\n\t\t// dependencies: ShaderName[],\n\t\t// shader_name: ShaderName\n\t): void {\n\t\tconst connection_point = globals_node.io.outputs.named_output_connection_points_by_name(output_name);\n\t\tif (!connection_point) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst var_name = globals_node.gl_var_name(output_name);\n\t\tconst gl_type = connection_point.type;\n\t\tconst definition = new VaryingGLDefinition(globals_node, gl_type, var_name);\n\n\t\t// MapUtils.push_on_array_at_entry(definitions_by_shader_name, shader_name, definition);\n\t\tshaders_collection_controller.add_definitions(globals_node, [definition]);\n\t\t// definitions_by_shader_name.get(shader_name)!.push(definition);\n\t\tconst assembler = globals_node.material_node?.assembler_controller.assembler;\n\t\tif (!assembler) {\n\t\t\treturn;\n\t\t}\n\t\tconst shader_config = assembler.shader_config(shaders_collection_controller.current_shader_name);\n\t\tif (!shader_config) {\n\t\t\treturn;\n\t\t}\n\t\tconst dependencies = shader_config.dependencies();\n\n\t\tconst body_line = `${var_name} = ${gl_type}(${output_name})`;\n\t\tfor (let dependency of dependencies) {\n\t\t\t// MapUtils.push_on_array_at_entry(definitions_by_shader_name, dependency, definition);\n\t\t\t// MapUtils.push_on_array_at_entry(body_lines_by_shader_name, dependency, body_line);\n\t\t\tshaders_collection_controller.add_definitions(globals_node, [definition], dependency);\n\t\t\tshaders_collection_controller.add_body_lines(globals_node, [body_line], dependency);\n\t\t}\n\t\tif (dependencies.length == 0) {\n\t\t\t// body_lines.push(body_line);\n\t\t\tshaders_collection_controller.add_body_lines(globals_node, [body_line]);\n\t\t}\n\t}\n\n\tstatic variable_config_default(variable_name: string): string | undefined {\n\t\treturn VARIABLE_CONFIG_DEFAULT_BY_NAME[variable_name];\n\t}\n\tvariable_config_default(variable_name: string): string | undefined {\n\t\treturn GlobalsGeometryHandler.variable_config_default(variable_name);\n\t}\n\t// variable_config_required_definitions(variable_name:string):DefinitionBaseConfig[]{\n\t// \treturn null\n\t// }\n\tread_attribute(\n\t\tnode: BaseGlNodeType,\n\t\tgl_type: ConnectionPointType,\n\t\tattrib_name: string,\n\t\tshaders_collection_controller: ShadersCollectionController\n\t) {\n\t\treturn GlobalsGeometryHandler.read_attribute(node, gl_type, attrib_name, shaders_collection_controller);\n\t}\n\n\tstatic read_attribute(\n\t\tnode: BaseGlNodeType,\n\t\tgl_type: ConnectionPointType,\n\t\tattrib_name: string,\n\t\tshaders_collection_controller: ShadersCollectionController\n\t): string | undefined {\n\t\tif (GlobalsGeometryHandler.PRE_DEFINED_ATTRIBUTES.indexOf(attrib_name) < 0) {\n\t\t\tshaders_collection_controller.add_definitions(\n\t\t\t\tnode,\n\t\t\t\t[new AttributeGLDefinition(node, gl_type, attrib_name)],\n\t\t\t\tShaderName.VERTEX\n\t\t\t);\n\t\t} else {\n\t\t\t// const if_rule = GlobalsGeometryHandler.IF_RULE[attrib_name]\n\t\t\t// if(if_rule){\n\t\t\t// \tconst definition = new Definition.Attribute(node, gl_type, attrib_name)\n\t\t\t// \tdefinition.set_if_rule(if_rule)\n\t\t\t// \tnode.add_definitions([definition])\n\t\t\t// }\n\t\t}\n\n\t\t// if (!shader_name) {\n\t\t// \tthrow 'no shader name';\n\t\t// }\n\t\tconst shader_name = shaders_collection_controller.current_shader_name;\n\t\tswitch (shader_name) {\n\t\t\tcase ShaderName.VERTEX: {\n\t\t\t\treturn attrib_name;\n\t\t\t}\n\t\t\tcase ShaderName.FRAGMENT: {\n\t\t\t\t// let's assume it can only be an attribute gl node\n\t\t\t\tif (!(node instanceof AttributeGlNode)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst var_name = 'varying_' + node.gl_var_name(node.output_name);\n\t\t\t\tconst varying_definition = new VaryingGLDefinition(node, gl_type, var_name);\n\n\t\t\t\tconst definitions_by_shader_name: Map<ShaderName, VaryingGLDefinition[]> = new Map();\n\t\t\t\t// definitions_by_shader_name.set(ShaderName.VERTEX, [])\n\t\t\t\tdefinitions_by_shader_name.set(ShaderName.FRAGMENT, []);\n\t\t\t\t// {\n\t\t\t\t// \t[ShaderName.VERTEX]: [],\n\t\t\t\t// \t[ShaderName.FRAGMENT]: [],\n\t\t\t\t// };\n\t\t\t\tconst body_lines_by_shader_name: Map<ShaderName, string[]> = new Map();\n\t\t\t\t// body_lines_by_shader_name.set(ShaderName.VERTEX, [])\n\t\t\t\tbody_lines_by_shader_name.set(ShaderName.FRAGMENT, []);\n\t\t\t\tMapUtils.push_on_array_at_entry(definitions_by_shader_name, shader_name, varying_definition);\n\n\t\t\t\tconst set_varying_body_line = `${var_name} = ${gl_type}(${attrib_name})`;\n\n\t\t\t\tconst shader_config = node.material_node?.assembler_controller.assembler.shader_config(shader_name);\n\t\t\t\tif (shader_config) {\n\t\t\t\t\tconst dependencies = shader_config.dependencies();\n\t\t\t\t\tfor (let dependency of dependencies) {\n\t\t\t\t\t\tMapUtils.push_on_array_at_entry(definitions_by_shader_name, dependency, varying_definition);\n\t\t\t\t\t\tMapUtils.push_on_array_at_entry(body_lines_by_shader_name, dependency, set_varying_body_line);\n\t\t\t\t\t}\n\t\t\t\t\tdefinitions_by_shader_name.forEach((definitions, shader_name) => {\n\t\t\t\t\t\tshaders_collection_controller.add_definitions(node, definitions, shader_name);\n\t\t\t\t\t});\n\t\t\t\t\tbody_lines_by_shader_name.forEach((body_lines, shader_name) => {\n\t\t\t\t\t\tshaders_collection_controller.add_body_lines(node, body_lines, shader_name);\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\treturn var_name;\n\t\t\t}\n\t\t}\n\t\t// TypeAssert.unreachable(shader_name);\n\n\t\t// const shader_name = node._shader_name // TODO: this is hack\n\t\t// const varying_definition = new Definition.Varying(node, gl_type, attrib_name)\n\t\t// const var_name = varying_definition.name()\n\t\t// definitions_by_shader_name[shader_name].push(varying_definition)\n\t\t// const shader_config = node.shader_config(shader_name)\n\t\t// const dependencies = shader_config.dependencies()\n\t\t// const body_line = `${var_name} = ${gl_type}(${attrib_name})`\n\t\t// for(let dependency of dependencies){\n\t\t// \tdefinitions_by_shader_name[dependency].push(varying_definition)\n\t\t// \tbody_lines_by_shader_name[dependency].push(body_line)\n\t\t// }\n\t\t// // if(dependencies.length == 0){\n\t\t// \t// body_lines.push(body_line)\n\t\t// \tnode.add_body_lines([body_line])\n\t\t// // }\n\t\t// for(let shader_name of Object.keys(definitions_by_shader_name)){\n\t\t// \tnode.add_definitions(definitions_by_shader_name[shader_name], shader_name)\n\t\t// }\n\t\t// for(let shader_name of Object.keys(body_lines_by_shader_name)){\n\t\t// \tnode.add_body_lines(body_lines_by_shader_name[shader_name], shader_name)\n\t\t// }\n\t\t// node.add_body_lines(body_lines)\n\t}\n\thandle_attribute_node(\n\t\tnode: AttributeGlNode,\n\t\tgl_type: ConnectionPointType,\n\t\tattrib_name: string,\n\t\tshaders_collection_controller: ShadersCollectionController\n\t) {\n\t\treturn GlobalsGeometryHandler.read_attribute(node, gl_type, attrib_name, shaders_collection_controller);\n\t}\n}\n","/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nimport { RGBFormat, LinearFilter } from '../constants.js';\nimport { Texture } from './Texture.js';\n\nfunction VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {\n\n\tTexture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );\n\n\tthis.format = format !== undefined ? format : RGBFormat;\n\n\tthis.minFilter = minFilter !== undefined ? minFilter : LinearFilter;\n\tthis.magFilter = magFilter !== undefined ? magFilter : LinearFilter;\n\n\tthis.generateMipmaps = false;\n\n}\n\nVideoTexture.prototype = Object.assign( Object.create( Texture.prototype ), {\n\n\tconstructor: VideoTexture,\n\n\tisVideoTexture: true,\n\n\tupdate: function () {\n\n\t\tvar video = this.image;\n\n\t\tif ( video.readyState >= video.HAVE_CURRENT_DATA ) {\n\n\t\t\tthis.needsUpdate = true;\n\n\t\t}\n\n\t}\n\n} );\n\n\nexport { VideoTexture };\n","/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nvar Cache = {\n\n\tenabled: false,\n\n\tfiles: {},\n\n\tadd: function ( key, file ) {\n\n\t\tif ( this.enabled === false ) return;\n\n\t\t// console.log( 'THREE.Cache', 'Adding key:', key );\n\n\t\tthis.files[ key ] = file;\n\n\t},\n\n\tget: function ( key ) {\n\n\t\tif ( this.enabled === false ) return;\n\n\t\t// console.log( 'THREE.Cache', 'Checking key:', key );\n\n\t\treturn this.files[ key ];\n\n\t},\n\n\tremove: function ( key ) {\n\n\t\tdelete this.files[ key ];\n\n\t},\n\n\tclear: function () {\n\n\t\tthis.files = {};\n\n\t}\n\n};\n\n\nexport { Cache };\n","import {BaseMatNodeType} from '../_Base';\n\nexport class BaseController {\n\tconstructor(protected node: BaseMatNodeType) {}\n\tadd_params() {}\n\n\tupdate() {}\n\n\tget material() {\n\t\treturn this.node.material;\n\t}\n}\n","import {BaseController} from './_BaseController';\n\nimport {FrontSide} from 'three/src/constants';\nimport {DoubleSide} from 'three/src/constants';\nimport {BackSide} from 'three/src/constants';\nimport {Material} from 'three/src/materials/Material';\nimport {TypedMatNode} from '../_Base';\n\nimport {NodeParamsConfig, ParamConfig} from '../../utils/params/ParamsConfig';\nexport function SideParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\tdouble_sided = ParamConfig.BOOLEAN(0);\n\t\tfront = ParamConfig.BOOLEAN(1, {visible_if: {double_sided: false}});\n\t};\n}\n\nclass SidedMaterial extends Material {\n\tside!: number;\n}\nclass SideParamsConfig extends SideParamConfig(NodeParamsConfig) {}\nclass SideMatNode extends TypedMatNode<SidedMaterial, SideParamsConfig> {\n\tcreate_material() {\n\t\treturn new SidedMaterial();\n\t}\n}\n\nexport class SideController extends BaseController {\n\tstatic update(node: SideMatNode) {\n\t\tconst single_side = node.pv.front ? FrontSide : BackSide;\n\t\tconst new_side = node.pv.double_sided ? DoubleSide : single_side;\n\t\tif (new_side != node.material.side) {\n\t\t\tnode.material.side = new_side;\n\t\t\tnode.material.needsUpdate = true;\n\t\t}\n\t}\n}\n","import {ShaderName} from '../../../utils/shaders/ShaderName';\n\nexport class ShaderConfig {\n\tconstructor(private _name: ShaderName, private _input_names: string[], private _dependencies: ShaderName[]) {}\n\n\tname() {\n\t\treturn this._name;\n\t}\n\tinput_names() {\n\t\treturn this._input_names;\n\t}\n\tdependencies() {\n\t\treturn this._dependencies;\n\t}\n}\n","interface VariableConfigOptions {\n\t// asset refererences\n\tdefault_from_attribute?: boolean;\n\tdefault?: string;\n\tif?: string;\n\tprefix?: string;\n\tsuffix?: string;\n}\n\nexport class VariableConfig {\n\tconstructor(private _name: string, private _options: VariableConfigOptions = {}) {}\n\n\tname() {\n\t\treturn this._name;\n\t}\n\tdefault_from_attribute() {\n\t\treturn this._options['default_from_attribute'] || false;\n\t}\n\tdefault() {\n\t\treturn this._options['default'];\n\t}\n\tif_condition() {\n\t\treturn this._options['if'];\n\t}\n\t// required_definitions(){\n\t// \treturn this._options['required_definitions']\n\t// }\n\tprefix() {\n\t\treturn this._options['prefix'] || '';\n\t}\n\tsuffix() {\n\t\treturn this._options['suffix'] || '';\n\t}\n}\n","import {BaseController} from './_BaseController';\nimport {Material} from 'three/src/materials/Material';\nimport {NodeParamsConfig, ParamConfig} from '../../utils/params/ParamsConfig';\nimport {TypedMatNode} from '../_Base';\nexport function SkinningParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\tskinning = ParamConfig.BOOLEAN(0);\n\t};\n}\n\nclass SkinnedMaterial extends Material {\n\tskinning!: boolean;\n}\nclass SkinningParamsConfig extends SkinningParamConfig(NodeParamsConfig) {}\nclass SkinningMatNode extends TypedMatNode<SkinnedMaterial, SkinningParamsConfig> {\n\tcreate_material() {\n\t\treturn new SkinnedMaterial();\n\t}\n}\n\nexport class SkinningController extends BaseController {\n\tstatic update(node: SkinningMatNode) {\n\t\tconst new_skinning = node.pv.skinning;\n\t\tif (new_skinning != node.material.skinning) {\n\t\t\tnode.material.skinning = new_skinning;\n\t\t\tnode.material.needsUpdate = true;\n\t\t}\n\t}\n}\n","import {Material} from 'three/src/materials/Material';\nimport {Texture} from 'three/src/textures/Texture';\nimport {FileCopNode} from '../../cop/File';\nimport {TypedMatNode} from '../_Base';\nimport {\n\tBaseTextureMapController,\n\tBooleanParamOptions,\n\tOperatorPathOptions,\n\tUpdateOptions,\n} from './_BaseTextureController';\nimport {ShaderMaterial} from 'three/src/materials/ShaderMaterial';\n\nimport {NodeParamsConfig, ParamConfig} from '../../utils/params/ParamsConfig';\nexport function TextureMapParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\tuse_map = ParamConfig.BOOLEAN(0, BooleanParamOptions(TextureMapController));\n\t\tmap = ParamConfig.OPERATOR_PATH(\n\t\t\tFileCopNode.DEFAULT_NODE_PATH.UV,\n\t\t\tOperatorPathOptions(TextureMapController, 'use_map')\n\t\t);\n\t};\n}\nclass TextureMapMaterial extends Material {\n\tmap!: Texture | null;\n}\ntype CurrentMaterial = TextureMapMaterial | ShaderMaterial;\nclass TextureMapParamsConfig extends TextureMapParamConfig(NodeParamsConfig) {}\nabstract class TextureMapMatNode extends TypedMatNode<CurrentMaterial, TextureMapParamsConfig> {\n\ttexture_map_controller!: TextureMapController;\n\tabstract create_material(): CurrentMaterial;\n}\n\nexport class TextureMapController extends BaseTextureMapController {\n\tconstructor(node: TextureMapMatNode, _update_options: UpdateOptions) {\n\t\tsuper(node, _update_options);\n\t}\n\tinitialize_node() {\n\t\tthis.add_hooks(this.node.p.use_map, this.node.p.map);\n\t}\n\tasync update() {\n\t\tthis._update(this.node.material, 'map', this.node.p.use_map, this.node.p.map);\n\t}\n\tstatic async update(node: TextureMapMatNode) {\n\t\tnode.texture_map_controller.update();\n\t}\n}\n","import {Material} from 'three/src/materials/Material';\nimport {Texture} from 'three/src/textures/Texture';\nimport {FileCopNode} from '../../cop/File';\nimport {TypedMatNode} from '../_Base';\nimport {\n\tBaseTextureMapController,\n\tBooleanParamOptions,\n\tOperatorPathOptions,\n\tUpdateOptions,\n} from './_BaseTextureController';\nimport {ShaderMaterial} from 'three/src/materials/ShaderMaterial';\n\nimport {NodeParamsConfig, ParamConfig} from '../../utils/params/ParamsConfig';\n// import {NodeContext} from '../../../poly/NodeContext';\n// import {BaseCopNodeType} from '../../cop/_Base';\nexport function TextureAlphaMapParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\tuse_alpha_map = ParamConfig.BOOLEAN(0, BooleanParamOptions(TextureAlphaMapController));\n\t\talpha_map = ParamConfig.OPERATOR_PATH(\n\t\t\tFileCopNode.DEFAULT_NODE_PATH.UV,\n\t\t\tOperatorPathOptions(TextureAlphaMapController, 'use_alpha_map')\n\t\t);\n\t};\n}\nclass TextureAlphaMaterial extends Material {\n\talphaMap!: Texture | null;\n}\ntype CurrentMaterial = TextureAlphaMaterial | ShaderMaterial;\nclass TextureAlphaMapParamsConfig extends TextureAlphaMapParamConfig(NodeParamsConfig) {}\nabstract class TextureAlphaMapMatNode extends TypedMatNode<CurrentMaterial, TextureAlphaMapParamsConfig> {\n\ttexture_alpha_map_controller!: TextureAlphaMapController;\n\tabstract create_material(): CurrentMaterial;\n}\n\nexport class TextureAlphaMapController extends BaseTextureMapController {\n\tconstructor(node: TextureAlphaMapMatNode, _update_options: UpdateOptions) {\n\t\tsuper(node, _update_options);\n\t}\n\tinitialize_node() {\n\t\tthis.add_hooks(this.node.p.use_alpha_map, this.node.p.alpha_map);\n\t}\n\tasync update() {\n\t\tthis._update(this.node.material, 'alphaMap', this.node.p.use_alpha_map, this.node.p.alpha_map);\n\t}\n\tstatic async update(node: TextureAlphaMapMatNode) {\n\t\tnode.texture_alpha_map_controller.update();\n\t}\n}\n","import {PolyScene} from '../../../scene/PolyScene';\n// import {JsonExporterVisitor} from './Visitor';\nimport {CoreString} from '../../../../core/String';\nimport {NodeJsonExporterData, NodeJsonExporterUIData} from './Node';\nimport {JsonExportDispatcher} from './Dispatcher';\n\nexport interface SceneJsonExporterData {\n\tproperties?: {\n\t\tframe: number;\n\t\tframe_range: Number2;\n\t\tframe_range_locked: Boolean2;\n\t\t// fps: number;\n\t\tmaster_camera_node_path: string | null;\n\t};\n\troot?: NodeJsonExporterData;\n\tui?: NodeJsonExporterUIData;\n}\n\nexport class SceneJsonExporter {\n\tprivate _data: SceneJsonExporterData = {};\n\tconstructor(private _scene: PolyScene) {}\n\n\tdata(): SceneJsonExporterData {\n\t\tthis._scene.nodes_controller.reset_node_context_signatures();\n\t\tconst root_exporter = JsonExportDispatcher.dispatch_node(this._scene.root);\n\t\tconst nodes_data = root_exporter.data();\n\t\tconst ui_data = root_exporter.ui_data();\n\n\t\tthis._data = {\n\t\t\t// __js_version: this._scene.js_version(),\n\t\t\tproperties: {\n\t\t\t\t// name: this._scene.name(), // this conflicts with saving the name from the admin page\n\t\t\t\tframe: this._scene.frame || 1,\n\t\t\t\tframe_range: this._scene.frame_range,\n\t\t\t\tframe_range_locked: this._scene.time_controller.frame_range_locked,\n\t\t\t\t// fps: this._scene.time_controller.fps,\n\t\t\t\tmaster_camera_node_path: this._scene.cameras_controller.master_camera_node_path,\n\t\t\t},\n\t\t\troot: nodes_data,\n\t\t\tui: ui_data,\n\t\t};\n\n\t\treturn this._data;\n\t}\n\n\tstatic sanitize_string(word: string): string {\n\t\tword = word.replace(/'/g, \"'\"); // escapes ' (used to be with 2 /, but now only one to have Ian's Mediation saved and loaded correctly - but is actually 2 in Code Exporter)\n\t\tword = CoreString.escape_line_breaks(word);\n\t\treturn word;\n\t}\n}\n","import {BaseNodeType} from '../../../nodes/_Base';\nimport {SceneJsonExporter} from './Scene';\n// import {JsonExporterVisitor} from './Visitor';\nimport {NodeContext} from '../../../poly/NodeContext';\nimport {JsonExportDispatcher} from './Dispatcher';\nimport {ParamJsonExporterData} from './Param';\nimport {ParamType} from '../../../poly/ParamType';\n\ninterface NamedInputData {\n\tname: string;\n\tnode: string;\n\toutput: string;\n}\ntype IndexedInputData = string | null;\nexport type InputData = NamedInputData | IndexedInputData;\n\ninterface FlagsData {\n\tbypass?: boolean;\n\tdisplay?: boolean;\n}\n\nexport interface NodeJsonExporterData {\n\ttype: string;\n\tnodes: Dictionary<NodeJsonExporterData>;\n\tchildren_context: NodeContext;\n\tparams?: Dictionary<ParamJsonExporterData<ParamType>>;\n\tinputs?: InputData[];\n\tselection?: string[];\n\tflags?: FlagsData;\n\toverride_clonable_state: boolean;\n}\n\nexport interface NodeJsonExporterUIData {\n\tpos?: Number2;\n\tcomment?: string;\n\tnodes: Dictionary<NodeJsonExporterUIData>;\n}\n\nexport class NodeJsonExporter<T extends BaseNodeType> {\n\tprivate _data: NodeJsonExporterData | undefined; // = {} as NodeJsonExporterData;\n\tconstructor(protected _node: T) {}\n\n\tdata(): NodeJsonExporterData {\n\t\tif (!this.is_root()) {\n\t\t\tthis._node.scene.nodes_controller.register_node_context_signature(this._node);\n\t\t}\n\t\tthis._data = {\n\t\t\ttype: this._node.type,\n\t\t} as NodeJsonExporterData;\n\n\t\t// const required_imports = this._node.required_imports()\n\t\t// if(required_imports){\n\t\t// \tthis._data['required_imports'] = required_imports\n\t\t// }\n\n\t\tconst nodes_data = this.nodes_data();\n\t\tif (Object.keys(nodes_data).length > 0) {\n\t\t\tthis._data['nodes'] = nodes_data;\n\n\t\t\t// required by the Store::Scene::Exporter.rb\n\t\t\tconst context = this._node.children_controller?.context;\n\t\t\tif (context) {\n\t\t\t\tthis._data['children_context'] = context;\n\t\t\t}\n\t\t}\n\n\t\tif (!this.is_root()) {\n\t\t\tthis._data['params'] = this.params_data();\n\t\t\t//data['custom'] = []\n\t\t\tthis._data['inputs'] = this.inputs_data();\n\t\t}\n\n\t\t// TODO: does that create flags automatically? it should not\n\t\tif (this._node.flags) {\n\t\t\tthis._data['flags'] = {};\n\t\t\tif (this._node.flags.has_bypass()) {\n\t\t\t\tif (this._node.flags.bypass?.active) {\n\t\t\t\t\tthis._data['flags']['bypass'] = this._node.flags.bypass.active;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (this._node.flags.has_display()) {\n\t\t\t\tthis._data['flags']['display'] = this._node.flags.display?.active;\n\t\t\t}\n\t\t}\n\n\t\tif (this._node.children_allowed()) {\n\t\t\tconst selection = this._node.children_controller?.selection;\n\t\t\tif (selection && this._node.children().length > 0) {\n\t\t\t\t// only save the nodes that are still present, in case the selection just got deleted\n\t\t\t\tconst selected_children: BaseNodeType[] = [];\n\t\t\t\tconst selected_ids: Dictionary<boolean> = {};\n\t\t\t\tfor (let selected_node of selection.nodes()) {\n\t\t\t\t\tselected_ids[selected_node.graph_node_id] = true;\n\t\t\t\t}\n\t\t\t\tfor (let child of this._node.children()) {\n\t\t\t\t\tif (child.graph_node_id in selected_ids) {\n\t\t\t\t\t\tselected_children.push(child);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis._data['selection'] = selected_children.map((n) => n.name);\n\t\t\t}\n\t\t}\n\n\t\t// inputs clone\n\t\tif (this._node.io.inputs.override_clonable_state_allowed()) {\n\t\t\tconst override = this._node.io.inputs.override_clonable_state();\n\t\t\tif (override) {\n\t\t\t\tthis._data['override_clonable_state'] = override;\n\t\t\t}\n\t\t}\n\n\t\t// custom\n\t\tthis.add_custom();\n\n\t\treturn this._data;\n\t}\n\n\tui_data(): NodeJsonExporterUIData {\n\t\tconst data: NodeJsonExporterUIData = {} as NodeJsonExporterUIData;\n\t\tif (!this.is_root()) {\n\t\t\tconst ui_data = this._node.ui_data;\n\t\t\tdata['pos'] = ui_data.position.toArray() as Number2;\n\t\t\tconst comment = ui_data.comment;\n\t\t\tif (comment) {\n\t\t\t\tdata['comment'] = SceneJsonExporter.sanitize_string(comment);\n\t\t\t}\n\t\t}\n\t\tconst children = this._node.children();\n\t\tif (children.length > 0) {\n\t\t\tdata['nodes'] = {};\n\t\t\tchildren.forEach((child) => {\n\t\t\t\tconst node_exporter = JsonExportDispatcher.dispatch_node(child); //.visit(JsonExporterVisitor); //.json_exporter()\n\t\t\t\tdata['nodes'][child.name] = node_exporter.ui_data();\n\t\t\t});\n\t\t}\n\n\t\treturn data;\n\t}\n\n\tprivate is_root() {\n\t\treturn this._node.parent === null && this._node.graph_node_id == this._node.root.graph_node_id;\n\t}\n\n\tprotected inputs_data() {\n\t\tconst data: InputData[] = [];\n\t\t// Object.keys(this._node.io.inputs.inputs()).forEach((input_index) => {\n\t\tthis._node.io.inputs.inputs().forEach((input, input_index) => {\n\t\t\t// const input = this._node.io.inputs.input(input_index);\n\t\t\tif (input) {\n\t\t\t\t// const connection_point = this._node.io.inputs.named_input_connection_points;\n\t\t\t\tconst connection = this._node.io.connections.input_connection(input_index)!;\n\t\t\t\tif (this._node.io.inputs.has_named_inputs) {\n\t\t\t\t\tconst input_name = this._node.io.inputs.named_input_connection_points[input_index].name;\n\t\t\t\t\t// const output_index = input_connections[input_index].output_index();\n\t\t\t\t\tconst output_index = connection.output_index;\n\t\t\t\t\tconst output_name = input.io.outputs.named_output_connection_points[output_index].name;\n\t\t\t\t\tdata.push({name: input_name, node: input.name, output: output_name});\n\t\t\t\t} else {\n\t\t\t\t\tdata.push(input.name);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn data;\n\t}\n\n\tprotected params_data() {\n\t\tconst data: Dictionary<ParamJsonExporterData<ParamType>> = {};\n\n\t\tfor (let param_name of this._node.params.names) {\n\t\t\tconst param = this._node.params.get(param_name);\n\t\t\tif (param && !param.parent_param) {\n\t\t\t\tconst param_exporter = JsonExportDispatcher.dispatch_param(param); //.visit(JsonExporterVisitor); //.json_exporter()\n\t\t\t\tif (param_exporter.required) {\n\t\t\t\t\tconst params_data = param_exporter.data();\n\t\t\t\t\tdata[param.name] = params_data;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn data;\n\t}\n\n\tprotected nodes_data() {\n\t\tconst data: Dictionary<NodeJsonExporterData> = {};\n\t\tfor (let child of this._node.children()) {\n\t\t\tconst node_exporter = JsonExportDispatcher.dispatch_node(child); //.json_exporter()\n\t\t\tdata[child.name] = node_exporter.data();\n\t\t}\n\t\treturn data;\n\t}\n\n\tprotected add_custom() {}\n}\n","// import lodash_isArray from 'lodash/isArray'\n// import lodash_isString from 'lodash/isString'\nimport {BaseParamType} from '../../../params/_Base';\nimport {ParamType} from '../../../poly/ParamType';\nimport {ParamInitValueSerializedTypeMap} from '../../../params/types/ParamInitValueSerializedTypeMap';\n\nimport {ParamOptions} from '../../../params/utils/OptionsController';\n\ntype OverridenOptions = Dictionary<string>;\n\nexport type SimpleParamJsonExporterData<T extends ParamType> = ParamInitValueSerializedTypeMap[T];\n\nexport interface ComplexParamJsonExporterData<T extends ParamType> {\n\ttype?: T;\n\tdefault_value?: ParamInitValueSerializedTypeMap[T];\n\traw_input?: ParamInitValueSerializedTypeMap[T];\n\toptions?: ParamOptions;\n\toverriden_options?: OverridenOptions;\n\t// components?: ParamJsonExporterDataByName;\n\t// expression?: string;\n}\nexport type ParamJsonExporterData<T extends ParamType> =\n\t| SimpleParamJsonExporterData<T>\n\t| ComplexParamJsonExporterData<T>;\nexport type ParamJsonExporterDataByName = Dictionary<ParamJsonExporterData<ParamType>>;\n\nexport class ParamJsonExporter<T extends BaseParamType> {\n\t// protected _simple_data: SimpleParamJsonExporterData<ParamType>=0;\n\tprotected _complex_data: ComplexParamJsonExporterData<ParamType> = {};\n\tconstructor(protected _param: T) {}\n\n\tget required(): boolean {\n\t\tconst is_spare_and_not_component = this._param.options.is_spare && !this._param.parent_param;\n\n\t\t// we should not need to check if it has an expression anymore,\n\t\t// as it could have an expression AND be of default value\n\t\tconst value_changed = !this._param.is_default; //|| this._param.has_expression();\n\t\t// const referencing_asset = this._param.is_referencing_asset()\n\t\treturn is_spare_and_not_component || value_changed; // || referencing_asset\n\t}\n\n\tdata() {\n\t\tif (this._param.parent_param) {\n\t\t\tconsole.warn('no component should be saved');\n\t\t\tthrow 'no component should be saved';\n\t\t}\n\n\t\tif (this._require_data_complex()) {\n\t\t\treturn this._data_complex();\n\t\t} else {\n\t\t\treturn this._data_simple();\n\t\t}\n\t}\n\n\tprivate _data_simple() {\n\t\treturn this._param.raw_input_serialized;\n\t}\n\n\tprivate _data_complex() {\n\t\tthis._complex_data = {};\n\n\t\tif (this._param.options.is_spare && !this._param.parent_param) {\n\t\t\tthis._complex_data['type'] = this._param.type;\n\t\t\tthis._complex_data['default_value'] = this._param.default_value_serialized;\n\t\t\tthis._complex_data['raw_input'] = this._param.raw_input_serialized;\n\t\t\tthis._complex_data['options'] = this._param.options.current;\n\t\t}\n\n\t\tif (!this._param.is_default) {\n\t\t\tthis.add_main();\n\t\t}\n\n\t\t// if(this._param.is_referencing_asset()){\n\t\t// \t// console.log(\"this._param.is_referencing_asset()\", this._param.is_referencing_asset())\n\t\t// \tthis._data['referenced_asset'] = this._param.referenced_asset()\n\t\t// }\n\n\t\tif (this._param.options.has_options_overridden) {\n\t\t\tconst overridden_options: OverridenOptions = {};\n\t\t\tconst options_overridden = this._param.options.overridden_options;\n\t\t\tfor (let option_name of Object.keys(options_overridden)) {\n\t\t\t\tconst option_value = options_overridden[option_name as keyof ParamOptions];\n\t\t\t\toverridden_options[option_name] = JSON.stringify(option_value);\n\t\t\t}\n\t\t\tthis._complex_data['overriden_options'] = overridden_options;\n\t\t}\n\t\treturn this._complex_data;\n\t}\n\n\tprotected _require_data_complex() {\n\t\tif (this._param.options.is_spare) {\n\t\t\treturn true;\n\t\t}\n\t\tif (this._param.options.has_options_overridden) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t// default_value(): ParamValueSerialized {\n\t// \treturn this._param.default_value_serialized;\n\t// }\n\n\t// cannot remember why this is useful, but it messes up\n\t// with gl nodes like the noise node, as the default value\n\t// gets saved as a string '[1,1]' instead of an array [1,1] (should be without quotes)\n\t// protected default_value(){\n\t// \tlet default_value = this._param.default_value()\n\t// \tif(lodash_isString(default_value)){\n\t// \t\tdefault_value = `'${default_value}'`\n\t// \t}\n\t// \tif (lodash_isArray(default_value)){\n\t// \t\tdefault_value = `[${default_value}]`\n\t// \t}\n\t// \treturn default_value\n\t// }\n\n\tprotected add_main() {}\n}\n","import {ParamJsonExporter} from '../Param';\nimport {TypedNumericParam} from '../../../../params/_Numeric';\nimport {ParamType} from '../../../../poly/ParamType';\n\nexport class ParamNumericJsonExporter extends ParamJsonExporter<TypedNumericParam<ParamType>> {\n\tadd_main() {\n\t\t// if (this._param.has_expression() && this._param.expression_controller?.expression) {\n\t\t// \t// const escaped_expression = this._param.expression().replace(/'/g, \"\\\\'\");\n\t\t// \tthis._data['expression'] = this._param.expression_controller?.expression;\n\t\t// } else {\n\t\tif (this._require_data_complex()) {\n\t\t\tthis._complex_data['raw_input'] = this._param.raw_input_serialized;\n\t\t} else {\n\t\t\treturn this._param.raw_input_serialized;\n\t\t}\n\t\t// }\n\t}\n}\n","import {ParamJsonExporter} from '../Param';\nimport {OperatorPathParam} from '../../../../params/OperatorPath';\nimport {SceneJsonExporter} from '../Scene';\n\nexport class ParamOperatorPathJsonExporter extends ParamJsonExporter<OperatorPathParam> {\n\tadd_main() {\n\t\tlet val = this._param.raw_input;\n\t\t// val = val.replace(/'/g, \"\\\\'\");\n\t\tval = SceneJsonExporter.sanitize_string(val);\n\n\t\tif (this._require_data_complex()) {\n\t\t\tthis._complex_data['raw_input'] = val;\n\t\t} else {\n\t\t\treturn val;\n\t\t}\n\t}\n}\n","// import lodash_isString from 'lodash/isString'\nimport {ParamJsonExporter} from '../Param';\nimport {SceneJsonExporter} from '../Scene';\nimport {StringParam} from '../../../../params/String';\n\nexport class ParamStringJsonExporter extends ParamJsonExporter<StringParam> {\n\tadd_main() {\n\t\t// let val = this._param.input_value();\n\t\tlet val = this._param.raw_input;\n\t\t// if (lodash_isString(val)){\n\t\tval = SceneJsonExporter.sanitize_string(val);\n\t\t// }\n\t\tif (this._require_data_complex()) {\n\t\t\tthis._complex_data['raw_input'] = val;\n\t\t} else {\n\t\t\treturn val;\n\t\t}\n\t}\n}\n","import {ParamJsonExporter} from '../Param';\nimport {RampParam} from '../../../../params/Ramp';\n\nexport class ParamRampJsonExporter extends ParamJsonExporter<RampParam> {\n\tadd_main() {\n\t\tif (this._require_data_complex()) {\n\t\t\tthis._complex_data['raw_input'] = this._param.raw_input_serialized;\n\t\t} else {\n\t\t\treturn this._param.raw_input_serialized;\n\t\t}\n\t}\n}\n","import {BaseNodeType} from '../../../nodes/_Base';\nimport {BaseParamType} from '../../../params/_Base';\n\nimport {NodeJsonExporter} from './Node';\n// import {BaseNodeObjJsonExporter} from './node/Obj';\n// import {BaseNodeSopSubnetworkJsonExporter} from './node/Subnetwork';\n\nimport {ParamJsonExporter} from './Param';\n// import {ParamMultipleJsonExporter} from './param/Multiple';\nimport {ParamNumericJsonExporter} from './param/Numeric';\nimport {ParamOperatorPathJsonExporter} from './param/OperatorPath';\nimport {ParamStringJsonExporter} from './param/String';\nimport {ParamRampJsonExporter} from './param/Ramp';\n// import {TypedObjNode} from '../../../nodes/obj/_Base';\n// import {TypedMultipleParam} from '../../../params/_Multiple';\nimport {TypedNumericParam} from '../../../params/_Numeric';\nimport {OperatorPathParam} from '../../../params/OperatorPath';\nimport {StringParam} from '../../../params/String';\nimport {RampParam} from '../../../params/Ramp';\n\nexport class JsonExportDispatcher {\n\tstatic dispatch_node(node: BaseNodeType) {\n\t\t// if (node instanceof TypedObjNode) {\n\t\t// \treturn new BaseNodeObjJsonExporter(node);\n\t\t// }\n\t\treturn new NodeJsonExporter(node);\n\t}\n\n\tstatic dispatch_param(param: BaseParamType) {\n\t\t// if (param instanceof TypedMultipleParam) {\n\t\t// \treturn new ParamMultipleJsonExporter(param);\n\t\t// }\n\t\tif (param instanceof TypedNumericParam) {\n\t\t\treturn new ParamNumericJsonExporter(param);\n\t\t}\n\t\tif (param instanceof OperatorPathParam) {\n\t\t\treturn new ParamOperatorPathJsonExporter(param);\n\t\t}\n\t\tif (param instanceof StringParam) {\n\t\t\treturn new ParamStringJsonExporter(param);\n\t\t}\n\t\tif (param instanceof RampParam) {\n\t\t\treturn new ParamRampJsonExporter(param);\n\t\t}\n\t\treturn new ParamJsonExporter(param);\n\t}\n}\n","import lodash_merge from 'lodash/merge';\nimport lodash_intersection from 'lodash/intersection';\nimport lodash_difference from 'lodash/difference';\nimport {Vector2} from 'three/src/math/Vector2';\nimport {BaseNodeType, TypedNode} from '../../_Base';\n\nimport {BaseGlShaderAssembler} from './assemblers/_Base';\nimport {GlobalsBaseController} from './globals/_Base';\nimport {GlobalsGeometryHandler} from './globals/Geometry';\n\nimport {JsonExportDispatcher} from '../../../io/json/export/Dispatcher';\n// import {NodeEvent} from '../../../poly/NodeEvent';\nimport {OutputGlNode} from '../Output';\nimport {GlobalsGlNode} from '../Globals';\n// import {BaseParamType} from '../../../params/_Base';\nimport {ParamJsonExporterData} from '../../../io/json/export/Param';\nimport {GlNodeChildrenMap} from '../../../poly/registers/Gl';\nimport {BaseGlNodeType} from '../_Base';\nimport {ParamType} from '../../../poly/ParamType';\nimport {ParamsUpdateOptions} from '../../utils/params/ParamsController';\n\n// interface BaseShaderAssemblerConstructor {\n// \tnew (): BaseGlShaderAssembler;\n// }\n// interface GlobalsBaseControllerConstructor {\n// \tnew (): GlobalsBaseController;\n// }\n\n// export function AssemblerOwner<TBase extends Constructor>(Base: TBase) {\n// \treturn class Mixin extends Base {\n// \t\tprotected self: BaseNode = (<unknown>this) as BaseNode;\n// \t\tchildren_context() {\n// \t\t\treturn NodeContext.GL;\n// \t\t}\n\nexport class AssemblerControllerNode extends TypedNode<any, BaseNodeType, any> {\n\tcreate_node<K extends keyof GlNodeChildrenMap>(type: K): GlNodeChildrenMap[K] {\n\t\treturn super.create_node(type) as GlNodeChildrenMap[K];\n\t}\n\tchildren() {\n\t\treturn super.children() as BaseGlNodeType[];\n\t}\n\tnodes_by_type<K extends keyof GlNodeChildrenMap>(type: K): GlNodeChildrenMap[K][] {\n\t\treturn super.nodes_by_type(type) as GlNodeChildrenMap[K][];\n\t}\n\n\tassembler_controller!: GlAssemblerController<BaseGlShaderAssembler>;\n\t// set_compilation_required_and_dirty() {\n\t// \tthis.assembler_controller.set_compilation_required_and_dirty();\n\t// }\n}\n\ntype BaseGlShaderAssemblerConstructor<A extends BaseGlShaderAssembler> = new (...args: any[]) => A;\nexport class GlAssemblerController<A extends BaseGlShaderAssembler> {\n\tprotected _assembler!: A;\n\tprivate _globals_handler: GlobalsBaseController | undefined = new GlobalsGeometryHandler();\n\tprivate _compile_required: boolean = true;\n\t// private _requester: BaseNodeSop;\n\t// private _recompiled: boolean = false;\n\t// private _shaders_by_name: Map<ShaderName, string> = new Map();\n\n\tprivate _deleted_params_data: Map<string, ParamJsonExporterData<ParamType>> = new Map();\n\t// private _new_params: BaseParamType[] = [];\n\n\tconstructor(private node: AssemblerControllerNode, assembler_class: BaseGlShaderAssemblerConstructor<A>) {\n\t\t// if (assembler_class) {\n\t\tthis._assembler = new assembler_class(this.node);\n\t\t// }\n\t\t// this._shadow_depth_assembler = new ShaderAssemblerDepth()\n\t\t// this._shadow_distance_assembler = new ShaderAssemblerDistance()\n\n\t\t// this.self._init_hierarchy_children_owner();\n\n\t\t// let has_display_flag = false;\n\t\t// if (options['has_display_flag']) {\n\t\t// \thas_display_flag = options['has_display_flag'];\n\t\t// }\n\n\t\t// this.self._init_display_flag({\n\t\t// \thas_display_flag: has_display_flag,\n\t\t// \tmultiple_display_flags_allowed: false,\n\t\t// \taffects_hierarchy: true,\n\t\t// });\n\n\t\t// this ensures that material re evaluate their uniforms\n\t\t// without having the SOP/Material recook\n\t\t// which can be a killer in an animation\n\t\t// But this should be tweaked so that it can recook all params of a node\n\t\t// this.self.add_post_dirty_hook(this.eval_params_and_assign_uniform_values.bind(this))\n\t\t// - UPDATE: this seems to work at the moment. The only issue is that\n\t\t// the particle system now updates 2x when recreating the shaders\n\t\t// but that's fixed with update_on_dirty\n\t\t// - UPDATE 2: now that the params have been refactored, let's try without this\n\t\t// if (options['update_on_dirty'] != false) {\n\t\t// \tthis.self.add_post_dirty_hook(this.cook_main_if_scene_loaded.bind(this));\n\t\t// }\n\t}\n\tset_assembler_globals_handler(globals_handler: GlobalsBaseController) {\n\t\tconst current_id = this._globals_handler ? this._globals_handler.id() : null;\n\t\tconst new_id = globals_handler ? globals_handler.id() : null;\n\n\t\tif (current_id != new_id) {\n\t\t\tthis._globals_handler = globals_handler;\n\t\t\tthis.set_compilation_required_and_dirty();\n\t\t\tthis._assembler.reset_configs();\n\t\t}\n\t}\n\tget assembler() {\n\t\treturn this._assembler;\n\t}\n\t// get shaders_by_name() {\n\t// \treturn this._shaders_by_name;\n\t// }\n\tget globals_handler() {\n\t\treturn this._globals_handler;\n\t}\n\n\t// gltf_supported_material() {\n\t// \treturn this._assembler.constructor.convert_material_to_gltf_supported(this._material);\n\t// }\n\n\tadd_output_params(output_child: OutputGlNode) {\n\t\tthis._assembler.add_output_params(output_child);\n\t}\n\tadd_globals_params(globals_node: GlobalsGlNode) {\n\t\tthis._assembler.add_globals_params(globals_node);\n\t}\n\tallow_attribute_exports() {\n\t\treturn this._assembler.allow_attribute_exports();\n\t}\n\n\ton_create() {\n\t\tconst globals = this.node.create_node('globals');\n\t\tconst output = this.node.create_node('output');\n\n\t\tglobals.ui_data.set_position(new Vector2(-200, 0));\n\t\toutput.ui_data.set_position(new Vector2(200, 0));\n\t}\n\n\t// async compile_if_required() {\n\t// \t// this._recompiled = false;\n\t// \tif (this.compile_required()) {\n\t// \t\t// && !this._param_locked){\n\t// \t\tconst new_material = await this.run_assembler();\n\t// \t\tif (new_material) {\n\t// \t\t\tawait this.node.params.eval_params(this._new_params);\n\t// \t\t\tthis._material = new_material;\n\t// \t\t\t// this._recompiled = true;\n\t// \t\t} else {\n\t// \t\t\tconsole.error(`${this.node.full_path()} failed to generate a material`);\n\t// \t\t}\n\t// \t}\n\t// \tawait this.assign_uniform_values();\n\t// }\n\tset_compilation_required(new_state = true) {\n\t\tthis._compile_required = new_state;\n\t}\n\tset_compilation_required_and_dirty(trigger_node?: BaseGlNodeType) {\n\t\tthis.set_compilation_required();\n\t\tthis.node.set_dirty(trigger_node);\n\t}\n\tcompile_required(): boolean {\n\t\treturn this._compile_required;\n\t}\n\n\t// set_root_nodes(nodes: BaseGlNodeType[]) {\n\t// \tthis.assembler.set_root_nodes(nodes);\n\t// }\n\t// set_node_lines_globals(globals_node: GlobalsGlNode, shader_name: ShaderName) {\n\t// \tthis.assembler.set_node_lines_globals(globals_node, shader_name);\n\t// }\n\t// set_node_lines_output(output_node: OutputGlNode, shader_name: ShaderName) {\n\t// \tthis.assembler.set_node_lines_output(output_node, shader_name);\n\t// }\n\t// set_node_lines_attribute(attribute_node: AttributeGlNode, shader_name: ShaderName) {\n\t// \tthis.assembler.set_node_lines_attribute(attribute_node, shader_name);\n\t// }\n\n\tasync post_compile() {\n\t\t// if (!this.compile_required()) {\n\t\t// \treturn;\n\t\t// }\n\t\t// this.assembler.compile_for_node(this._gl);\n\t\tthis.create_spare_parameters();\n\t\tthis.set_compilation_required(false);\n\t}\n\n\t// private async run_assembler() {\n\t// \tconst output_node = this.find_output_node();\n\t// \tif (output_node) {\n\t// \t\tthis._assembler.set_root_nodes([output_node]);\n\t// \t}\n\t// \tthis.assembler.compile();\n\t// \tconst material = await this._assembler.get_material();\n\t// \tif (material) {\n\t// \t\tthis._shaders_by_name.set(ShaderName.VERTEX, material.vertexShader);\n\t// \t\tthis._shaders_by_name.set(ShaderName.FRAGMENT, material.fragmentShader);\n\n\t// \t\t// assign custom materials\n\t// \t\tconst custom_materials = await this._assembler.get_custom_materials();\n\t// \t\tconst material_with_custom_materials = material as ShaderMaterialWithCustomMaterials;\n\t// \t\tmaterial_with_custom_materials.custom_materials = {};\n\t// \t\tcustom_materials.forEach((custom_material, shader_name) => {\n\t// \t\t\tmaterial_with_custom_materials.custom_materials[shader_name] = custom_material;\n\t// \t\t});\n\n\t// \t\tmaterial.needsUpdate = true;\n\t// \t}\n\n\t// \tthis.create_spare_parameters();\n\n\t// \tthis._compile_required = false;\n\t// \treturn material;\n\t// }\n\n\t// find_output_node() {\n\t// \tconst nodes = this.node.nodes_by_type('output');\n\t// \tif (nodes.length > 1) {\n\t// \t\tthis.node.states.error.set('only one output node allowed');\n\t// \t}\n\t// \treturn nodes[0];\n\t// }\n\t// find_attribute_export_nodes() {\n\t// \tconst nodes = this.node.nodes_by_type('attribute');\n\t// \treturn nodes.filter((node) => {\n\t// \t\t// do not use attributes that are used as an input, as export\n\t// \t\t// return (node.used_output_names().length == 0) &&\n\t// \t\treturn node.is_exporting;\n\t// \t});\n\t// }\n\t// add_output_body_line(output_node, shader_name: ShaderName, input_name: string){\n\t// \tconst input = output_node.named_input(input_name)\n\t// \tconst var_input = output_node.variable_for_input(input_name)\n\t// \tconst variable_config = this.variable_config(input_name)\n\t// \tconst default_value = variable_config.default()\n\t// \tconst prefix = variable_config.prefix()\n\t// \tconst suffix = variable_config.suffix()\n\t// \tconst new_var = input ? ThreeToGl.vector3(var_input) : default_value\n\t// \tif(new_var){\n\t// \t\toutput_node.add_body_lines([`${prefix}${new_var}${suffix}`], shader_name)\n\t// \t}\n\t// }\n\t// set_output_node_lines(output_node){\n\t// \tfor(let shader_name of this.shader_names()){\n\t// \t\tconst body_lines = []\n\t// \t\tconst input_names = this.shader_config(shader_name).input_names()\n\t// \t\toutput_node.set_body_lines([], shader_name)\n\t// \t\tif(input_names){\n\t// \t\t\tfor(let input_name of input_names){\n\t// \t\t\t\tthis.add_output_body_line(output_node, shader_name, input_name)\n\n\t// \t\t\t}\n\t// \t\t}\n\t// \t}\n\n\t// \t// const vertex_body_lines = []\n\t// \t// const fragment_body_lines = []\n\n\t// \t// const named_input_position = this.named_input('position')\n\t// \t// const named_input_point_size = this.named_input('gl_PointSize')\n\t// \t// const named_input_normal = this.named_input('normal')\n\n\t// \t// const var_position = this.variable_for_input('position')\n\t// \t// const var_normal = this.variable_for_input('normal')\n\t// \t// const color = this.variable_for_input('color')\n\t// \t// const alpha = this.variable_for_input('alpha')\n\t// \t// const var_point_size = this.variable_for_input('gl_PointSize')\n\n\t// \t// fragment_body_lines.push( `${this._color_declaration} = ${ThreeToGl.vector3_float(color, alpha)}` )\n\t// \t// this.set_fragment_body_lines(fragment_body_lines)\n\n\t// \t// const new_position_var = named_input_position ? ThreeToGl.vector3(var_position) : 'vec3( position )'\n\t// \t// vertex_body_lines.push( `vec3 transformed = ${new_position_var}` )\n\n\t// \t// if(this.parent().is_point_material()){\n\t// \t// \tconst new_point_size_var = named_input_point_size ? ThreeToGl.float(var_point_size) : '1.0'\n\t// \t// \tvertex_body_lines.push( `float size2 = size * ${new_point_size_var}` )\n\t// \t// }\n\n\t// \t// if(named_input_normal){\n\t// \t// \tconst new_normal_var = ThreeToGl.vector3(var_normal)\n\t// \t// \tvertex_body_lines.push(`objectNormal = ${new_normal_var}`)\n\t// \t// }\n\n\t// \t// this.set_vertex_body_lines(vertex_body_lines)\n\t// \t// this.set_fragment_body_lines(fragment_body_lines)\n\t// }\n\t// private async eval_params_and_assign_uniform_values() {\n\t// \tif (!this.self.scene().loaded()) {\n\t// \t\treturn;\n\t// \t}\n\n\t// \tif (this._assembler) {\n\t// \t\tawait this.self.eval_all_params();\n\t// \t\tawait this.assign_uniform_values();\n\t// \t}\n\t// }\n\t// private async cook_main_if_scene_loaded() {\n\t// \tif (!this.self.scene().loaded()) {\n\t// \t\treturn;\n\t// \t}\n\t// \tif (this.self.params_referree().length > 0) {\n\t// \t\tawait this.self.cook_main();\n\t// \t}\n\t// \t// this.cook_main_without_inputs()\n\t// }\n\tasync assign_uniform_values() {\n\t\tif (this._assembler) {\n\t\t\tfor (let param_config of this._assembler.param_configs()) {\n\t\t\t\tawait param_config.set_uniform_value(this.node);\n\t\t\t}\n\t\t}\n\t}\n\n\t// process_uniforms(renderer, display_scene, camera, geometry, material, group) {\n\t// \tconst scene_frame = this.scene().frame()\n\n\t// \tconst material_frame = material.uniforms.frame\n\t// \tif(material_frame){ // check needed in case this method is given a post process material\n\t// \t\tmaterial.uniforms.frame.value = scene_frame\n\t// \t}\n\n\t// \tconst custom_materials = material.custom_materials\n\t// \tif(custom_materials){\n\t// \t\tfor(let custom_material_name of Object.keys(custom_materials)){\n\t// \t\t\tconst custom_material = custom_materials[custom_material_name]\n\t// \t\t\tcustom_material.uniforms.frame.value = scene_frame\n\t// \t\t}\n\t// \t}\n\t// }\n\n\t// create_material(){\n\t// \tconst template_shader = THREE.ShaderLib.basic\n\n\t// \tconst uniforms = THREE.UniformsUtils.clone( template_shader.uniforms )\n\t// \t// uniforms['frame'] = {\n\t// \t// \ttype: '1f',\n\t// \t// \tvalue: 1\n\t// \t// }\n\n\t// \tconst material = new THREE.ShaderMaterial({\n\t// \t\t// vertexColors: THREE.VertexColors,\n\t// \t\t// side: THREE.FrontSide,\n\t// \t\t// transparent: true,\n\t// \t\t// fog: true,\n\t// \t\t// lights: false,\n\t// \t\tuniforms: uniforms,\n\t// \t\tvertexShader: template_shader.vertexShader,\n\t// \t\tfragmentShader: template_shader.fragmentShader\n\t// \t})\n\t// \tthrow \"wtf\"\n\t// \treturn material\n\t// }\n\tcreate_spare_parameters() {\n\t\tconst current_spare_param_names: string[] = this.node.params.spare_names;\n\t\tconst param_configs = this._assembler.param_configs();\n\t\tconst assembler_param_names = param_configs.map((c) => c.name);\n\t\t// TODO: also remove the params that change type\n\t\tconst spare_param_names_to_add = lodash_difference(assembler_param_names, current_spare_param_names);\n\t\tconst spare_param_names_to_remove = lodash_difference(current_spare_param_names, assembler_param_names);\n\t\t// this._new_params = [];\n\t\tconst params_update_options: ParamsUpdateOptions = {};\n\n\t\t// check that param_names_to_add does not include any currently existing param names (that are not spare)\n\t\tconst current_param_names = this.node.params.names;\n\t\tconst spare_params_with_same_name_as_params = lodash_intersection(\n\t\t\tspare_param_names_to_add,\n\t\t\tcurrent_param_names\n\t\t);\n\t\tif (spare_params_with_same_name_as_params.length > 0) {\n\t\t\tconst error_message = `${this.node.full_path()} attempts to create spare params called '${spare_params_with_same_name_as_params.join(\n\t\t\t\t', '\n\t\t\t)}' with same name as params`;\n\t\t\tconsole.warn(error_message);\n\t\t\tthis.node.states.error.set(error_message);\n\t\t}\n\n\t\tspare_param_names_to_remove.forEach((param_name) => {\n\t\t\t// store the param data, in case it gets recreated later\n\t\t\t// this allows expressions to be kept in memory\n\t\t\tconst param = this.node.params.get(param_name);\n\t\t\tif (param) {\n\t\t\t\tconst param_exporter = JsonExportDispatcher.dispatch_param(param);\n\t\t\t\tif (param_exporter.required) {\n\t\t\t\t\tconst params_data = param_exporter.data();\n\t\t\t\t\tthis._deleted_params_data.set(param.name, params_data);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tparams_update_options.names_to_delete = params_update_options.names_to_delete || [];\n\t\t\tparams_update_options.names_to_delete.push(param_name);\n\t\t});\n\n\t\t// this.within_param_folder('spare_params', () => {\n\t\tfor (let param_config of param_configs) {\n\t\t\tif (spare_param_names_to_add.indexOf(param_config.name) >= 0) {\n\t\t\t\t// TODO: shouldn't it be cook: false ??\n\t\t\t\t// as there is no need to cook the node if I'm only changing the uniform\n\t\t\t\t// unless maybe for textures?\n\t\t\t\t// but if cook is false, there is no reason for it to be updated\n\t\t\t\tconst options = lodash_merge(param_config.param_options, {spare: true, cook: true});\n\n\t\t\t\t// const param = this.node.add_param(\n\t\t\t\t// \tparam_config.type,\n\t\t\t\t// \tparam_config.name,\n\t\t\t\t// \tparam_config.default_value,\n\t\t\t\t// \toptions\n\t\t\t\t// );\n\t\t\t\tparams_update_options.to_add = params_update_options.to_add || [];\n\t\t\t\tparams_update_options.to_add.push({\n\t\t\t\t\tname: param_config.name,\n\t\t\t\t\ttype: param_config.type,\n\t\t\t\t\tinit_value: param_config.default_value as any,\n\t\t\t\t\toptions: options,\n\t\t\t\t});\n\n\t\t\t\t// if (param) {\n\t\t\t\t// \t// restore saved state, like expressions\n\t\t\t\t// \tconst param_data = this._deleted_params_data.get(param.name);\n\t\t\t\t// \tif (param_data) {\n\t\t\t\t// \t\t// TODO: typescript\n\t\t\t\t// \t\t// JsonImportDispatcher.dispatch_param(param).process_data(param_data);\n\t\t\t\t// \t\t// looks like there are still some cases where the expression are not recreated\n\t\t\t\t// \t\t// so commenting this out now\n\t\t\t\t// \t\t// delete this._deleted_params_data[param.name()]\n\t\t\t\t// \t}\n\n\t\t\t\t// \tthis._new_params.push(param);\n\t\t\t\t// }\n\t\t\t}\n\t\t}\n\n\t\tthis.node.params.update_params(params_update_options);\n\t\t// if (spare_param_names_to_add.length > 0 || spare_param_names_to_remove.length > 0) {\n\t\t// \tthis.node.params.post_create_spare_params();\n\t\t// \tthis.node.emit(NodeEvent.PARAMS_UPDATED);\n\t\t// }\n\t}\n}\n","export enum LineType {\n\tFUNCTION_DECLARATION = 'function_declaration',\n\tDEFINE = 'define',\n\tBODY = 'body',\n}\n","import {ShaderName} from '../../../utils/shaders/ShaderName';\nimport {BaseGLDefinition} from '../../utils/GLDefinition';\nimport {BaseGlNodeType} from '../../_Base';\nimport {MapUtils} from '../../../../../core/MapUtils';\n\nexport class LinesController {\n\tprivate _definitions_by_node_id: Map<string, BaseGLDefinition[]> = new Map();\n\tprivate _body_lines_by_node_id: Map<string, string[]> = new Map();\n\n\tconstructor(private _shader_name: ShaderName) {}\n\n\tget shader_name() {\n\t\treturn this._shader_name;\n\t}\n\n\tadd_definitions(node: BaseGlNodeType, definitions: BaseGLDefinition[]) {\n\t\tfor (let definition of definitions) {\n\t\t\tMapUtils.push_on_array_at_entry(this._definitions_by_node_id, node.graph_node_id, definition);\n\t\t}\n\t}\n\tdefinitions(node: BaseGlNodeType): BaseGLDefinition[] | undefined {\n\t\treturn this._definitions_by_node_id.get(node.graph_node_id);\n\t}\n\n\tadd_body_lines(node: BaseGlNodeType, lines: string[]) {\n\t\tfor (let line of lines) {\n\t\t\tMapUtils.push_on_array_at_entry(this._body_lines_by_node_id, node.graph_node_id, line);\n\t\t}\n\t}\n\tbody_lines(node: BaseGlNodeType): string[] | undefined {\n\t\treturn this._body_lines_by_node_id.get(node.graph_node_id);\n\t}\n}\n","import {ShaderName} from '../../../utils/shaders/ShaderName';\nimport {BaseGLDefinition} from '../../utils/GLDefinition';\nimport {LinesController} from './LinesController';\nimport {BaseGlNodeType} from '../../_Base';\n\nexport class ShadersCollectionController {\n\tprivate _lines_controller_by_shader_name: Map<ShaderName, LinesController> = new Map();\n\tconstructor(private _shader_names: ShaderName[], private _current_shader_name: ShaderName) {\n\t\tfor (let shader_name of this._shader_names) {\n\t\t\tthis._lines_controller_by_shader_name.set(shader_name, new LinesController(shader_name));\n\t\t}\n\t}\n\n\tget shader_names() {\n\t\treturn this._shader_names;\n\t}\n\n\tset_current_shader_name(shader_name: ShaderName) {\n\t\tthis._current_shader_name = shader_name;\n\t}\n\tget current_shader_name() {\n\t\treturn this._current_shader_name;\n\t}\n\n\tadd_definitions(node: BaseGlNodeType, definitions: BaseGLDefinition[], shader_name?: ShaderName) {\n\t\tif (definitions.length == 0) {\n\t\t\treturn;\n\t\t}\n\t\tshader_name = shader_name || this._current_shader_name;\n\t\tconst lines_controller = this._lines_controller_by_shader_name.get(shader_name);\n\t\tif (lines_controller) {\n\t\t\tlines_controller.add_definitions(node, definitions);\n\t\t}\n\t}\n\tdefinitions(shader_name: ShaderName, node: BaseGlNodeType) {\n\t\tconst lines_controller = this._lines_controller_by_shader_name.get(shader_name);\n\t\tif (lines_controller) {\n\t\t\treturn lines_controller.definitions(node);\n\t\t}\n\t}\n\n\tadd_body_lines(node: BaseGlNodeType, lines: string[], shader_name?: ShaderName) {\n\t\tif (lines.length == 0) {\n\t\t\treturn;\n\t\t}\n\t\tshader_name = shader_name || this._current_shader_name;\n\t\tconst lines_controller = this._lines_controller_by_shader_name.get(shader_name);\n\t\tif (lines_controller) {\n\t\t\tlines_controller.add_body_lines(node, lines);\n\t\t}\n\t}\n\tbody_lines(shader_name: ShaderName, node: BaseGlNodeType) {\n\t\tconst lines_controller = this._lines_controller_by_shader_name.get(shader_name);\n\t\tif (lines_controller) {\n\t\t\treturn lines_controller.body_lines(node);\n\t\t}\n\t}\n}\n","import {BaseGlNodeType} from '../../_Base';\nimport {LineType} from './LineType';\n\nconst LINE_SUFFIXES = {\n\t[LineType.FUNCTION_DECLARATION]: '',\n\t[LineType.DEFINE]: ';',\n\t[LineType.BODY]: ';',\n};\n\nconst LINE_PREFIXES = {\n\t[LineType.FUNCTION_DECLARATION]: '',\n\t[LineType.DEFINE]: '',\n\t[LineType.BODY]: '\t',\n};\n\nexport class CodeFormatter {\n\tstatic node_comment(node: BaseGlNodeType, line_type: LineType): string {\n\t\tlet line = `// ${node.full_path()}`;\n\t\tif (line_type == LineType.BODY) {\n\t\t\tline = `\t${line}`;\n\t\t}\n\t\treturn line;\n\t}\n\tstatic line_wrap(line: string, line_type: LineType) {\n\t\tlet add_suffix = true;\n\t\tif (line.indexOf('#if') == 0 || line.indexOf('#endif') == 0) {\n\t\t\tadd_suffix = false;\n\t\t}\n\t\tif (add_suffix) {\n\t\t\treturn `${LINE_PREFIXES[line_type]}${line}${LINE_SUFFIXES[line_type]}`;\n\t\t} else {\n\t\t\treturn `${LINE_PREFIXES[line_type]}${line}`;\n\t\t}\n\t}\n\tstatic post_line_separator(line_type: LineType) {\n\t\treturn line_type == LineType.BODY ? '\t' : '';\n\t}\n}\n","import lodash_uniq from 'lodash/uniq';\nimport {BaseGlNodeType} from '../../_Base';\nimport {TypedNodeTraverser} from '../../../utils/shaders/NodeTraverser';\nimport {BaseNodeType} from '../../../_Base';\nimport {BaseGlShaderAssembler} from '../assemblers/_Base';\nimport {MapUtils} from '../../../../../core/MapUtils';\nimport {ShaderName} from '../../../utils/shaders/ShaderName';\nimport {GLDefinitionType, BaseGLDefinition} from '../../utils/GLDefinition';\nimport {TypedGLDefinitionCollection} from '../../utils/GLDefinitionCollection';\nimport {ParamConfigsController} from '../../../../nodes/utils/code/controllers/ParamConfigsController';\nimport {ShadersCollectionController} from './ShadersCollectionController';\nimport {CodeFormatter} from './CodeFormatter';\n\nimport {LineType} from './LineType';\n\nexport class CodeBuilder {\n\t_param_configs_controller: ParamConfigsController = new ParamConfigsController();\n\t_param_configs_set_allowed: boolean = true;\n\n\tprivate _shaders_collection_controller: ShadersCollectionController | undefined;\n\t_lines: Map<ShaderName, Map<LineType, string[]>> = new Map();\n\t_function_declared: Map<ShaderName, Map<string, boolean>> = new Map();\n\n\tconstructor(private _assembler: BaseGlShaderAssembler, private _gl_parent_node: BaseNodeType) {}\n\n\tasync build_from_nodes(root_nodes: BaseGlNodeType[]) {\n\t\tconst node_traverser = new TypedNodeTraverser<BaseGlNodeType>(this._assembler, this._gl_parent_node);\n\t\tnode_traverser.traverse(root_nodes);\n\n\t\tconst nodes_by_shader_name: Map<ShaderName, BaseGlNodeType[]> = new Map();\n\t\tfor (let shader_name of this.shader_names()) {\n\t\t\tnodes_by_shader_name.set(shader_name, node_traverser.nodes_for_shader_name(shader_name));\n\t\t}\n\t\tconst sorted_nodes = node_traverser.sorted_nodes();\n\t\tfor (let shader_name of this.shader_names()) {\n\t\t\tconst root_nodes_for_shader = this._assembler.root_nodes_by_shader_name(shader_name);\n\t\t\t// const leaf_nodes_for_shader = this._assembler.leaf_nodes_by_shader_name(shader_name);\n\n\t\t\t// keep track of which nodes are both leaf and root, and do not use their code twice\n\t\t\t// as this may happen with an attribute node, when used as both import and export\n\t\t\t// TODO: that seems useless, as I surely should be able to filter duplicates if needed\n\n\t\t\t// ensure nodes are unique\n\t\t\t// const node_ids: Map<string, boolean> = new Map();\n\t\t\t// nodes_by_shader_name.forEach((nodes, shader_name) => {\n\t\t\t// \tfor (let node of nodes) {\n\t\t\t// \t\tnode_ids.set(node.graph_node_id, true);\n\t\t\t// \t}\n\t\t\t// });\n\n\t\t\tfor (let root_node of root_nodes_for_shader) {\n\t\t\t\t// if(!both_leaf_and_root_nodes_by_id[root_node.graph_node_id()]){\n\t\t\t\t// if (!node_ids.get(root_node.graph_node_id)) {\n\t\t\t\tMapUtils.push_on_array_at_entry(nodes_by_shader_name, shader_name, root_node);\n\t\t\t\t// node_ids.set(root_node.graph_node_id, true);\n\t\t\t\t// }\n\t\t\t\t// }\n\t\t\t}\n\t\t\t// for (let leaf_node of leaf_nodes_for_shader) {\n\t\t\t// if(!both_leaf_and_root_nodes_by_id[leaf_node.graph_node_id()]){\n\t\t\t// if (!node_ids.get(leaf_node.graph_node_id)) {\n\t\t\t// MapUtils.unshift_on_array_at_entry(nodes_by_shader_name, shader_name, leaf_node);\n\t\t\t// }\n\t\t\t// }\n\t\t\t// }\n\t\t}\n\n\t\t// ensure nodes are not added if already present\n\t\tconst sorted_node_ids: Map<string, boolean> = new Map();\n\t\tfor (let node of sorted_nodes) {\n\t\t\tsorted_node_ids.set(node.graph_node_id, true);\n\t\t}\n\n\t\tfor (let root_node of root_nodes) {\n\t\t\tif (!sorted_node_ids.get(root_node.graph_node_id)) {\n\t\t\t\tsorted_nodes.push(root_node);\n\t\t\t\tsorted_node_ids.set(root_node.graph_node_id, true);\n\t\t\t}\n\t\t}\n\t\tfor (let node of sorted_nodes) {\n\t\t\t// node.set_assembler(this._assembler);\n\t\t\tnode.reset_code();\n\t\t}\n\t\tfor (let node of sorted_nodes) {\n\t\t\tawait node.params.eval_all();\n\t\t}\n\n\t\t// const param_promises = sorted_nodes.map(node=>{\n\t\t// \treturn node.eval_all_params()\n\t\t// })\n\t\t// await Promise.all(param_promises)\n\n\t\tthis._shaders_collection_controller = new ShadersCollectionController(\n\t\t\tthis.shader_names(),\n\t\t\tthis.shader_names()[0]\n\t\t);\n\t\tthis.reset();\n\t\tfor (let shader_name of this.shader_names()) {\n\t\t\tconst nodes = lodash_uniq(nodes_by_shader_name.get(shader_name));\n\t\t\tthis._shaders_collection_controller.set_current_shader_name(shader_name);\n\t\t\tif (nodes) {\n\t\t\t\tfor (let node of nodes) {\n\t\t\t\t\t// node.set_shader_name(shader_name);\n\t\t\t\t\tif (this._param_configs_set_allowed) {\n\t\t\t\t\t\tnode.set_param_configs();\n\t\t\t\t\t}\n\t\t\t\t\tnode.set_lines(this._shaders_collection_controller);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// fragment_nodes.forEach(node=>{\n\t\t// \tnode.set_shader_name(ShaderName.FRAGMENT)\n\t\t// \tnode.set_param_configs()\n\t\t// \tnode.set_lines()\n\t\t// })\n\t\tif (this._param_configs_set_allowed) {\n\t\t\tthis.set_param_configs(sorted_nodes);\n\t\t}\n\t\tthis.set_code_lines(sorted_nodes);\n\t}\n\n\tdisallow_new_param_configs() {\n\t\tthis._param_configs_set_allowed = false;\n\t}\n\tallow_new_param_configs() {\n\t\tthis._param_configs_set_allowed = true;\n\t}\n\n\tshader_names() {\n\t\treturn this._assembler.shader_names;\n\t}\n\n\tprivate reset() {\n\t\tfor (let shader_name of this.shader_names()) {\n\t\t\tconst lines_map = new Map();\n\t\t\t// for (let line_type of LINE_TYPES) {\n\t\t\t// \tlines_map.set(line_type, []);\n\t\t\t// }\n\t\t\tthis._lines.set(shader_name, lines_map);\n\t\t\tthis._function_declared.set(shader_name, new Map());\n\t\t}\n\t}\n\n\tparam_configs() {\n\t\treturn this._param_configs_controller.list || [];\n\t}\n\tlines(shader_name: ShaderName, line_type: LineType) {\n\t\treturn this._lines.get(shader_name)!.get(line_type);\n\t}\n\tall_lines() {\n\t\treturn this._lines;\n\t}\n\n\tset_param_configs(nodes: BaseGlNodeType[]) {\n\t\tthis._param_configs_controller.reset();\n\t\tfor (let node of nodes) {\n\t\t\tconst param_configs = node.param_configs();\n\t\t\tif (param_configs) {\n\t\t\t\tfor (let param_config of param_configs) {\n\t\t\t\t\tthis._param_configs_controller.push(param_config);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tset_code_lines(nodes: BaseGlNodeType[]) {\n\t\tfor (let shader_name of this.shader_names()) {\n\t\t\t// nodes.forEach((node, i)=>{\n\t\t\tthis.add_code_lines(nodes, shader_name);\n\t\t\t// })\n\t\t}\n\t}\n\n\tadd_code_lines(nodes: BaseGlNodeType[], shader_name: ShaderName) {\n\t\tthis.add_definitions(nodes, shader_name, GLDefinitionType.FUNCTION, LineType.FUNCTION_DECLARATION);\n\t\tthis.add_definitions(nodes, shader_name, GLDefinitionType.UNIFORM, LineType.DEFINE);\n\t\tthis.add_definitions(nodes, shader_name, GLDefinitionType.VARYING, LineType.DEFINE);\n\t\tthis.add_definitions(nodes, shader_name, GLDefinitionType.ATTRIBUTE, LineType.DEFINE);\n\n\t\tthis.add_code_line_for_nodes_and_line_type(nodes, shader_name, LineType.BODY);\n\t}\n\n\tprivate add_definitions(\n\t\tnodes: BaseGlNodeType[],\n\t\tshader_name: ShaderName,\n\t\tdefinition_type: GLDefinitionType,\n\t\tline_type: LineType\n\t) {\n\t\tif (!this._shaders_collection_controller) {\n\t\t\treturn;\n\t\t}\n\t\tconst definitions = [];\n\t\tfor (let node of nodes) {\n\t\t\tlet node_definitions = this._shaders_collection_controller.definitions(shader_name, node);\n\t\t\tif (node_definitions) {\n\t\t\t\tnode_definitions = node_definitions.filter((d) => d.definition_type == definition_type);\n\t\t\t\tfor (let definition of node_definitions) {\n\t\t\t\t\tdefinitions.push(definition);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (definitions.length > 0) {\n\t\t\tconst collection = new TypedGLDefinitionCollection<GLDefinitionType>(definitions);\n\t\t\tconst uniq_definitions = collection.uniq();\n\t\t\tif (collection.errored) {\n\t\t\t\t// TODO: handle error\n\t\t\t\tthrow `code builder error: ${collection.error_message}`;\n\t\t\t}\n\n\t\t\tconst definitions_by_node_id: Map<string, BaseGLDefinition[]> = new Map();\n\t\t\tconst node_ids: Map<string, boolean> = new Map();\n\t\t\tfor (let definition of uniq_definitions) {\n\t\t\t\tconst node_id = definition.node.graph_node_id;\n\t\t\t\tif (!node_ids.has(node_id)) {\n\t\t\t\t\tnode_ids.set(node_id, true);\n\t\t\t\t}\n\t\t\t\tMapUtils.push_on_array_at_entry(definitions_by_node_id, node_id, definition);\n\t\t\t}\n\t\t\tconst lines_for_shader = this._lines.get(shader_name)!;\n\t\t\tnode_ids.forEach((boolean: boolean, node_id: string) => {\n\t\t\t\tconst definitions = definitions_by_node_id.get(node_id);\n\t\t\t\tif (definitions) {\n\t\t\t\t\tconst first_definition = definitions[0];\n\n\t\t\t\t\tif (first_definition) {\n\t\t\t\t\t\tconst comment = CodeFormatter.node_comment(first_definition.node, line_type);\n\t\t\t\t\t\tMapUtils.push_on_array_at_entry(lines_for_shader, line_type, comment);\n\n\t\t\t\t\t\tfor (let definition of definitions) {\n\t\t\t\t\t\t\tconst line = CodeFormatter.line_wrap(definition.line, line_type);\n\t\t\t\t\t\t\tMapUtils.push_on_array_at_entry(lines_for_shader, line_type, line);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconst separator = CodeFormatter.post_line_separator(line_type);\n\t\t\t\t\t\tMapUtils.push_on_array_at_entry(lines_for_shader, line_type, separator);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\tadd_code_line_for_nodes_and_line_type(nodes: BaseGlNodeType[], shader_name: ShaderName, line_type: LineType) {\n\t\tnodes = nodes.filter((node) => {\n\t\t\tif (this._shaders_collection_controller) {\n\t\t\t\tconst lines = this._shaders_collection_controller.body_lines(shader_name, node);\n\t\t\t\treturn lines && lines.length > 0;\n\t\t\t}\n\t\t});\n\n\t\tvar nodes_count = nodes.length;\n\t\tfor (let i = 0; i < nodes_count; i++) {\n\t\t\tconst is_last = i == nodes.length - 1;\n\t\t\tthis.add_code_line_for_node_and_line_type(nodes[i], shader_name, line_type, is_last);\n\t\t}\n\t}\n\tadd_code_line_for_node_and_line_type(\n\t\tnode: BaseGlNodeType,\n\t\tshader_name: ShaderName,\n\t\tline_type: LineType,\n\t\tis_last: boolean\n\t): void {\n\t\tif (!this._shaders_collection_controller) {\n\t\t\treturn;\n\t\t}\n\t\tconst lines = this._shaders_collection_controller.body_lines(shader_name, node);\n\n\t\tif (lines && lines.length > 0) {\n\t\t\tconst lines_for_shader = this._lines.get(shader_name)!;\n\t\t\tconst comment = CodeFormatter.node_comment(node, line_type);\n\t\t\tMapUtils.push_on_array_at_entry(lines_for_shader, line_type, comment);\n\t\t\tlodash_uniq(lines).forEach((line) => {\n\t\t\t\tline = CodeFormatter.line_wrap(line, line_type);\n\t\t\t\tMapUtils.push_on_array_at_entry(lines_for_shader, line_type, line);\n\t\t\t});\n\t\t\tif (!(line_type == LineType.BODY && is_last)) {\n\t\t\t\tconst separator = CodeFormatter.post_line_separator(line_type);\n\t\t\t\tMapUtils.push_on_array_at_entry(lines_for_shader, line_type, separator);\n\t\t\t}\n\t\t}\n\t}\n}\n","// import {UniformsUtils} from 'three/src/renderers/shaders/UniformsUtils';\nimport {ShaderMaterial} from 'three/src/materials/ShaderMaterial';\n// import {ShaderChunk} from 'three/src/renderers/shaders/ShaderChunk';\n// import {Shader} from 'three/src/renderers/shaders/ShaderLib'\n// import {MeshStandardMaterial} from 'three/src/materials/MeshStandardMaterial';\n// import {MeshPhysicalMaterial} from 'three/src/materials/MeshPhysicalMaterial';\n// import {Material} from 'three/src/materials/Material';\nimport {Vector2} from 'three/src/math/Vector2';\n\n// import {Connection} from '../../../../../Engine/Node/Gl/GlData';\nimport {LineType} from '../utils/LineType';\n// import {Output} from '../../../../../Engine/Node/Gl/Output'\n\nimport {ShaderConfig} from '../configs/ShaderConfig';\nimport {VariableConfig} from '../configs/VariableConfig';\n// import {ThreeToGl} from '../../../../../core/ThreeToGl';\n// const BODY_SPLIT_LINE = 'void main() {'\n// export const BODY_SEPARATOR_LINES = lodash_range(3).map(i=>'\t')\nimport {CodeBuilder} from '../utils/CodeBuilder';\n// import {BaseNode} from '../../../../../Engine/Node/_Base';\nimport {BaseGlNodeType} from '../../_Base';\nimport {GlobalsGeometryHandler} from '../globals/Geometry';\nimport {TypedAssembler} from '../../../utils/shaders/BaseAssembler';\nimport {ShaderName} from '../../../utils/shaders/ShaderName';\n// import {IUniformsWithFrame, IUniformsWithResolution} from '../../../../scene/utils/UniformsController';\nimport {OutputGlNode} from '../../Output';\nimport {ParamType} from '../../../../poly/ParamType';\nimport {TypedNamedConnectionPoint} from '../../../utils/connections/NamedConnectionPoint';\nimport {ConnectionPointType} from '../../../utils/connections/ConnectionPointType';\nimport {GlobalsGlNode} from '../../Globals';\nimport {AttributeGlNode} from '../../Attribute';\nimport {AssemblerControllerNode} from '../Controller';\nimport {GlobalsBaseController} from '../globals/_Base';\nimport {CustomMaterialName} from './materials/_BaseMaterial';\nimport {ShadersCollectionController} from '../utils/ShadersCollectionController';\nimport {IUniforms} from '../../../../../core/geometry/Material';\n\ntype StringArrayByShaderName = Map<ShaderName, string[]>;\n\ninterface ITemplateShader {\n\tvertexShader?: string;\n\tfragmentShader?: string;\n\tuniforms?: IUniforms;\n}\n\nconst INSERT_DEFINE_AFTER_MAP: Map<ShaderName, string> = new Map([\n\t[ShaderName.VERTEX, '#include <common>'],\n\t[ShaderName.FRAGMENT, '#include <common>'],\n]);\nconst INSERT_BODY_AFTER_MAP: Map<ShaderName, string> = new Map([\n\t[ShaderName.VERTEX, '#include <color_vertex>'],\n\t[ShaderName.FRAGMENT, 'vec4 diffuseColor = vec4( diffuse, opacity );'],\n]);\nconst LINES_TO_REMOVE_MAP: Map<ShaderName, string[]> = new Map([\n\t[ShaderName.VERTEX, ['#include <begin_vertex>', '#include <beginnormal_vertex>']],\n\t[ShaderName.FRAGMENT, []],\n]);\n\nconst SPACED_LINES = 3;\n\nexport class BaseGlShaderAssembler extends TypedAssembler<BaseGlNodeType> {\n\tprotected _shaders_by_name: Map<ShaderName, string> = new Map();\n\tprotected _lines: StringArrayByShaderName = new Map();\n\tprotected _code_builder: CodeBuilder | undefined;\n\tprivate _param_config_owner: CodeBuilder | undefined;\n\tprotected _root_nodes: BaseGlNodeType[] = [];\n\tprotected _leaf_nodes: BaseGlNodeType[] = [];\n\tprotected _material: ShaderMaterial | undefined;\n\n\tprivate _shader_configs: ShaderConfig[] | undefined;\n\tprivate _variable_configs: VariableConfig[] | undefined;\n\n\tprivate _uniforms_time_dependent: boolean = false;\n\tprivate _resolution_dependent: boolean = false;\n\n\tconstructor(protected _gl_parent_node: AssemblerControllerNode) {\n\t\tsuper();\n\t}\n\n\tasync compile() {}\n\n\t// private get material() {\n\t// \treturn (this._material = this._material || this._create_material());\n\t// }\n\t// async get_material(/*master_assembler?: BaseGlShaderAssembler*/) {\n\t// \tthis._material = this._material || this._create_material();\n\n\t// \tawait this._update_material(/*master_assembler*/);\n\t// \treturn this._material;\n\t// }\n\tprotected _template_shader_for_shader_name(shader_name: ShaderName): string | undefined {\n\t\tswitch (shader_name) {\n\t\t\tcase ShaderName.VERTEX:\n\t\t\t\treturn this._template_shader?.vertexShader;\n\t\t\tcase ShaderName.FRAGMENT:\n\t\t\t\treturn this._template_shader?.fragmentShader;\n\t\t}\n\t}\n\n\tget globals_handler(): GlobalsBaseController | undefined {\n\t\treturn this._gl_parent_node.assembler_controller.globals_handler;\n\t}\n\tcompile_allowed(): boolean {\n\t\treturn this._gl_parent_node.assembler_controller.globals_handler != null;\n\t}\n\tshaders_by_name() {\n\t\treturn this._shaders_by_name;\n\t}\n\n\t// protected create_material(): ShaderMaterial | undefined {\n\t// \treturn undefined;\n\t// }\n\tprotected _build_lines() {\n\t\tfor (let shader_name of this.shader_names) {\n\t\t\tconst template = this._template_shader_for_shader_name(shader_name);\n\t\t\tif (template) {\n\t\t\t\tthis._replace_template(template, shader_name);\n\t\t\t}\n\t\t}\n\t}\n\n\t// protected _build_lines_for_shader_name(shader_name: ShaderName){\n\t// \tconst template = this._template_shader()\n\t// \tthis._replace_template(template[`${shader_name}Shader`], shader_name)\n\t// }\n\n\tset_root_nodes(root_nodes: BaseGlNodeType[]) {\n\t\tthis._root_nodes = root_nodes;\n\t}\n\tprotected get _template_shader(): ITemplateShader | undefined {\n\t\treturn undefined;\n\t} //Shader - could not find the import?\n\t// abstract _color_declaration(): string\n\t// private async _update_material(/*master_assembler?: BaseGlShaderAssembler*/) {\n\t// \tif (!this.material || !this._material) {\n\t// \t\treturn;\n\t// \t}\n\t// \tconst template_shader = this._template_shader;\n\t// \tif (!template_shader) {\n\t// \t\treturn;\n\t// \t}\n\t// \tthis._lines = new Map();\n\t// \tfor (let shader_name of this.shader_names) {\n\t// \t\tconst template = this._template_shader_for_shader_name(shader_name);\n\t// \t\tif (template) {\n\t// \t\t\tthis._lines.set(shader_name, template.split('\\n'));\n\t// \t\t}\n\t// \t}\n\t// \tif (this._root_nodes.length > 0) {\n\t// \t\t// this._output_node.set_color_declaration(this._color_declaration())\n\t// \t\t// if(!master_assembler){\n\t// \t\t// this._output_node.set_assembler(this)\n\t// \t\tawait this.build_code_from_nodes(this._root_nodes);\n\t// \t\t// }\n\n\t// \t\t(this._material as any).extensions = {derivatives: true};\n\t// \t\t// this._material?.derivatives = true;\n\t// \t\tthis._build_lines();\n\t// \t\t// this._lines[ShaderName.FRAGMENT].unshift('#extension GL_OES_standard_derivatives : enable')\n\t// \t}\n\n\t// \t// TODO: typescript - not sure that is still useful\n\t// \t// for (let param_config of this.param_configs()) {\n\t// \t// \tparam_config.material = this._material;\n\t// \t// }\n\n\t// \t// instead of replacing fully the uniforms,\n\t// \t// I simply add to them the new ones or replace the existing ones\n\t// \t// otherwise this would break the particles_system_gpu\n\t// \t// which would not reset correctly when going back to first frame.\n\t// \t// Not entirely sure why, but this seems to be due to the texture uniforms\n\t// \t// which are removed and then readded. This seems to mess up somewhere with how\n\t// \t// the material updates itself...\n\t// \t// this._material.uniforms = this.build_uniforms(template_shader)\n\t// \tconst new_uniforms = this.build_uniforms(template_shader.uniforms);\n\t// \tthis.material.uniforms = this.material.uniforms || {};\n\t// \tfor (let uniform_name of Object.keys(new_uniforms)) {\n\t// \t\tthis.material.uniforms[uniform_name] = new_uniforms[uniform_name];\n\t// \t}\n\n\t// \tfor (let shader_name of this.shader_names) {\n\t// \t\tconst lines = this._lines.get(shader_name);\n\t// \t\tif (lines) {\n\t// \t\t\tconst shader = lines.join('\\n');\n\t// \t\t\tswitch (shader_name) {\n\t// \t\t\t\tcase ShaderName.VERTEX: {\n\t// \t\t\t\t\tthis._material.vertexShader = shader;\n\t// \t\t\t\t\tbreak;\n\t// \t\t\t\t}\n\t// \t\t\t\tcase ShaderName.FRAGMENT: {\n\t// \t\t\t\t\tthis._material.fragmentShader = shader;\n\t// \t\t\t\t\tbreak;\n\t// \t\t\t\t}\n\t// \t\t\t}\n\t// \t\t}\n\t// \t}\n\n\t// \tconst scene = this._gl_parent_node.scene;\n\t// \t// const id = this._gl_parent_node.graph_node_id()\n\t// \tif (this.frame_dependent()) {\n\t// \t\t// make sure not to use this._gl_parent_node.graph_node_id() as the id,\n\t// \t\t// as we need several materials:\n\t// \t\t// - the visible one\n\t// \t\t// - the multiple shadow ones\n\t// \t\t// - and possibly a depth one\n\t// \t\tscene.uniforms_controller.add_frame_dependent_uniform_owner(\n\t// \t\t\tthis._material.uuid,\n\t// \t\t\tthis._material.uniforms as IUniformsWithFrame\n\t// \t\t);\n\t// \t} else {\n\t// \t\tscene.uniforms_controller.remove_frame_dependent_uniform_owner(this._material.uuid);\n\t// \t}\n\n\t// \tif (this.resolution_dependent()) {\n\t// \t\tscene.uniforms_controller.add_resolution_dependent_uniform_owner(\n\t// \t\t\tthis._material.uuid,\n\t// \t\t\tthis._material.uniforms as IUniformsWithResolution\n\t// \t\t);\n\t// \t} else {\n\t// \t\tscene.uniforms_controller.remove_resolution_dependent_uniform_owner(this._material.uuid);\n\t// \t}\n\t// }\n\n\tprotected add_uniforms(current_uniforms: IUniforms) {\n\t\t// const new_uniforms = UniformsUtils.clone(template_uniforms);\n\n\t\t// copy the new uniforms onto the old ones, only adding, not removing\n\t\t// for (let uniform_name of Object.keys(new_uniforms)) {\n\n\t\t// }\n\n\t\t// copy the values of the old uniform\n\t\t// for (let uniform_name of Object.keys(old_uniforms)) {\n\t\t// \tconst new_uniform = new_uniforms[uniform_name];\n\t\t// \tif (new_uniform) {\n\t\t// \t\tnew_uniform.value = old_uniforms[uniform_name].value;\n\t\t// \t}\n\t\t// }\n\n\t\tfor (let param_config of this.param_configs()) {\n\t\t\tcurrent_uniforms[param_config.uniform_name] = param_config.uniform;\n\t\t}\n\n\t\tif (this.uniforms_time_dependent()) {\n\t\t\tcurrent_uniforms['time'] = {\n\t\t\t\t// type: '1f',\n\t\t\t\tvalue: this._gl_parent_node.scene.time,\n\t\t\t};\n\t\t}\n\t\tif (this.resolution_dependent()) {\n\t\t\tcurrent_uniforms['resolution'] = {\n\t\t\t\tvalue: new Vector2(1000, 1000),\n\t\t\t};\n\t\t}\n\n\t\t// return new_uniforms;\n\t}\n\n\t//\n\t//\n\t// ROOT NODES AND SHADER NAMES\n\t//\n\t//\n\troot_nodes_by_shader_name(shader_name: ShaderName): BaseGlNodeType[] {\n\t\t// return this._root_nodes\n\t\tconst list = [];\n\t\tfor (let node of this._root_nodes) {\n\t\t\tswitch (node.type) {\n\t\t\t\tcase 'output': {\n\t\t\t\t\tlist.push(node);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase 'attribute': {\n\t\t\t\t\t// TODO: typescript - gl - why is there a texture allocation controller in the base assembler?\n\t\t\t\t\t// const attrib_name = (node as AttributeGlNode).attribute_name;\n\t\t\t\t\t// const variable = this._texture_allocations_controller.variable(attrib_name);\n\t\t\t\t\t// if (variable) {\n\t\t\t\t\t// \tconst allocation_shader_name = variable.allocation().shader_name();\n\t\t\t\t\t// \tif (allocation_shader_name == shader_name) {\n\t\t\t\t\t// \t\tlist.push(node);\n\t\t\t\t\t// \t}\n\t\t\t\t\t// }\n\t\t\t\t\t// break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n\tleaf_nodes_by_shader_name(shader_name: ShaderName): BaseGlNodeType[] {\n\t\tconst list = [];\n\t\tfor (let node of this._leaf_nodes) {\n\t\t\tswitch (node.type) {\n\t\t\t\tcase GlobalsGlNode.type(): {\n\t\t\t\t\tlist.push(node);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase AttributeGlNode.type(): {\n\t\t\t\t\t// TODO: typescript - gl - why is there a texture allocation controller in the base assembler? AND especially since there is no way to assign it?\n\t\t\t\t\t// const attrib_name: string = (node as AttributeGlNode).attribute_name;\n\t\t\t\t\t// const variable = this._texture_allocations_controller.variable(attrib_name);\n\t\t\t\t\t// if (variable) {\n\t\t\t\t\t// \tconst allocation_shader_name = variable.allocation().shader_name();\n\t\t\t\t\t// \tif (allocation_shader_name == shader_name) {\n\t\t\t\t\t// \t\tlist.push(node);\n\t\t\t\t\t// \t}\n\t\t\t\t\t// }\n\t\t\t\t\t// break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n\tset_node_lines_globals(globals_node: GlobalsGlNode, shaders_collection_controller: ShadersCollectionController) {}\n\tset_node_lines_output(output_node: OutputGlNode, shaders_collection_controller: ShadersCollectionController) {}\n\tset_node_lines_attribute(\n\t\tattribute_node: AttributeGlNode,\n\t\tshaders_collection_controller: ShadersCollectionController\n\t) {}\n\n\t//\n\t//\n\t// CHILDREN NODES PARAMS\n\t//\n\t//\n\tget code_builder() {\n\t\treturn (this._code_builder = this._code_builder || new CodeBuilder(this, this._gl_parent_node));\n\t}\n\tasync build_code_from_nodes(root_nodes: BaseGlNodeType[]) {\n\t\tawait this.code_builder.build_from_nodes(root_nodes);\n\t}\n\tallow_new_param_configs() {\n\t\tthis.code_builder.allow_new_param_configs();\n\t}\n\tdisallow_new_param_configs() {\n\t\tthis.code_builder.disallow_new_param_configs();\n\t}\n\tbuilder_param_configs() {\n\t\treturn this.code_builder.param_configs();\n\t}\n\tbuilder_lines(shader_name: ShaderName, line_type: LineType) {\n\t\treturn this.code_builder.lines(shader_name, line_type);\n\t}\n\tall_builder_lines() {\n\t\treturn this.code_builder.all_lines();\n\t}\n\tparam_configs() {\n\t\tconst code_builder = this._param_config_owner || this.code_builder;\n\t\treturn code_builder.param_configs();\n\t}\n\tset_param_configs_owner(param_config_owner: CodeBuilder) {\n\t\tthis._param_config_owner = param_config_owner;\n\t\tif (this._param_config_owner) {\n\t\t\tthis.code_builder.disallow_new_param_configs();\n\t\t} else {\n\t\t\tthis.code_builder.allow_new_param_configs();\n\t\t}\n\t}\n\n\t//\n\t//\n\t// CHILDREN NODES PARAMS\n\t//\n\t//\n\tstatic add_output_params(output_child: OutputGlNode) {\n\t\toutput_child.params.add_param(ParamType.VECTOR3, 'position', [0, 0, 0], {hidden: true});\n\t\toutput_child.params.add_param(ParamType.VECTOR3, 'normal', [0, 0, 0], {hidden: true});\n\t\toutput_child.params.add_param(ParamType.COLOR, 'color', [1, 1, 1], {hidden: true});\n\t\toutput_child.params.add_param(ParamType.FLOAT, 'alpha', 1, {hidden: true});\n\t\toutput_child.params.add_param(ParamType.VECTOR2, 'uv', [0, 0], {hidden: true});\n\t}\n\tadd_output_params(output_child: OutputGlNode) {\n\t\tBaseGlShaderAssembler.add_output_params(output_child);\n\t}\n\tstatic create_globals_node_output_connections() {\n\t\treturn [\n\t\t\tnew TypedNamedConnectionPoint('position', ConnectionPointType.VEC3),\n\t\t\tnew TypedNamedConnectionPoint('normal', ConnectionPointType.VEC3),\n\t\t\tnew TypedNamedConnectionPoint('color', ConnectionPointType.VEC3),\n\t\t\tnew TypedNamedConnectionPoint('uv', ConnectionPointType.VEC2),\n\t\t\tnew TypedNamedConnectionPoint('gl_FragCoord', ConnectionPointType.VEC4),\n\t\t\tnew TypedNamedConnectionPoint('resolution', ConnectionPointType.VEC2),\n\t\t\t// new Connection.Vec2('gl_PointCoord'),\n\t\t\t// new TypedConnectionVec2('uv'),\n\t\t\tnew TypedNamedConnectionPoint('time', ConnectionPointType.FLOAT),\n\t\t];\n\t}\n\tcreate_globals_node_output_connections() {\n\t\treturn BaseGlShaderAssembler.create_globals_node_output_connections();\n\t}\n\tadd_globals_params(globals_node: GlobalsGlNode) {\n\t\tglobals_node.io.outputs.set_named_output_connection_points(this.create_globals_node_output_connections());\n\t}\n\tallow_attribute_exports() {\n\t\treturn false;\n\t}\n\n\t//\n\t//\n\t// CONFIGS\n\t//\n\t//\n\treset_configs() {\n\t\tthis._reset_shader_configs();\n\t\tthis._reset_variable_configs();\n\t\tthis._reset_uniforms_time_dependency();\n\t\tthis._reset_resolution_dependency();\n\t}\n\tget shader_configs() {\n\t\treturn (this._shader_configs = this._shader_configs || this.create_shader_configs());\n\t}\n\tset_shader_configs(shader_configs: ShaderConfig[]) {\n\t\tthis._shader_configs = shader_configs;\n\t}\n\tget shader_names(): ShaderName[] {\n\t\treturn this.shader_configs?.map((sc) => sc.name()) || [];\n\t}\n\tprotected _reset_shader_configs() {\n\t\tthis._shader_configs = undefined;\n\t\t// this.shader_configs; // TODO: typescript - why do I need to re-initialize here?\n\t}\n\tcreate_shader_configs(): ShaderConfig[] {\n\t\treturn [\n\t\t\tnew ShaderConfig(ShaderName.VERTEX, ['position', 'normal', 'uv'], []),\n\t\t\tnew ShaderConfig(ShaderName.FRAGMENT, ['color', 'alpha'], [ShaderName.VERTEX]),\n\t\t];\n\t}\n\tshader_config(name: string): ShaderConfig | undefined {\n\t\treturn this.shader_configs?.filter((sc) => {\n\t\t\treturn sc.name() == name;\n\t\t})[0];\n\t}\n\tvariable_configs() {\n\t\treturn (this._variable_configs = this._variable_configs || this.create_variable_configs());\n\t}\n\tset_variable_configs(variable_configs: VariableConfig[]) {\n\t\tthis._variable_configs = variable_configs;\n\t}\n\tvariable_config(name: string) {\n\t\treturn this.variable_configs().filter((vc) => {\n\t\t\treturn vc.name() == name;\n\t\t})[0];\n\t}\n\tstatic create_variable_configs() {\n\t\treturn [\n\t\t\tnew VariableConfig('position', {\n\t\t\t\tdefault_from_attribute: true,\n\t\t\t\t// default: this.globals_handler().variable_config_default('position'),\n\t\t\t\t// required_definitions: this.globals_handler().variable_config_required_definitions('position'),\n\t\t\t\tprefix: 'vec3 transformed = ',\n\t\t\t}),\n\t\t\tnew VariableConfig('normal', {\n\t\t\t\tdefault_from_attribute: true,\n\t\t\t\tprefix: 'vec3 objectNormal = ',\n\t\t\t\t// post_lines: ['#ifdef USE_TANGENT', 'vec3 objectTangent = vec3( tangent.xyz );', '#endif'],\n\t\t\t}),\n\t\t\tnew VariableConfig('color', {\n\t\t\t\tprefix: 'diffuseColor.xyz = ',\n\t\t\t}),\n\t\t\tnew VariableConfig('alpha', {\n\t\t\t\tprefix: 'diffuseColor.a = ',\n\t\t\t}),\n\t\t\tnew VariableConfig('uv', {\n\t\t\t\t// default_from_attribute: true,\n\t\t\t\tprefix: 'vUv = ',\n\t\t\t\tif: GlobalsGeometryHandler.IF_RULE.uv,\n\t\t\t}),\n\t\t];\n\t}\n\tcreate_variable_configs(): VariableConfig[] {\n\t\treturn BaseGlShaderAssembler.create_variable_configs();\n\t}\n\tprotected _reset_variable_configs() {\n\t\tthis._variable_configs = undefined;\n\t\tthis.variable_configs();\n\t}\n\tinput_names_for_shader_name(root_node: BaseGlNodeType, shader_name: ShaderName) {\n\t\treturn this.shader_config(shader_name)?.input_names() || [];\n\t}\n\n\t// time dependency\n\tprotected _reset_uniforms_time_dependency() {\n\t\tthis._uniforms_time_dependent = false;\n\t}\n\tset_uniforms_time_dependent() {\n\t\tthis._uniforms_time_dependent = true;\n\t}\n\tuniforms_time_dependent(): boolean {\n\t\treturn this._uniforms_time_dependent;\n\t}\n\t// resolution dependency\n\tprotected _reset_resolution_dependency() {\n\t\tthis._resolution_dependent = false;\n\t}\n\tset_resolution_dependent() {\n\t\tthis._resolution_dependent = true;\n\t}\n\tresolution_dependent(): boolean {\n\t\treturn this._resolution_dependent;\n\t}\n\n\t//\n\t//\n\t// TEMPLATE HOOKS\n\t//\n\t//\n\tprotected insert_define_after(shader_name: ShaderName): string | undefined {\n\t\treturn INSERT_DEFINE_AFTER_MAP.get(shader_name);\n\t}\n\tprotected insert_body_after(shader_name: ShaderName): string | undefined {\n\t\treturn INSERT_BODY_AFTER_MAP.get(shader_name);\n\t}\n\tprotected lines_to_remove(shader_name: ShaderName): string[] | undefined {\n\t\treturn LINES_TO_REMOVE_MAP.get(shader_name);\n\t}\n\n\t//\n\t//\n\t// TEMPLATE CODE REPLACEMENT\n\t//\n\t//\n\n\tprivate _replace_template(template: string, shader_name: ShaderName) {\n\t\tconst function_declaration = this.builder_lines(shader_name, LineType.FUNCTION_DECLARATION);\n\t\tconst define = this.builder_lines(shader_name, LineType.DEFINE);\n\t\t// let all_define = function_declaration.concat(define);\n\t\tconst body = this.builder_lines(shader_name, LineType.BODY);\n\n\t\tlet template_lines = template.split('\\n');\n\t\t// const scene = this._gl_parent_node.scene;\n\t\tconst new_lines = [\n\t\t\t// `#define FPS ${ThreeToGl.float(scene.time_controller.fps)}`,\n\t\t\t// `#define TIME_INCREMENT (1.0/${ThreeToGl.float(scene.time_controller.fps)})`,\n\t\t\t// `#define FRAME_RANGE_START ${ThreeToGl.float(scene.time_controller.frame_range[0])}`,\n\t\t\t// `#define FRAME_RANGE_END ${ThreeToGl.float(scene.time_controller.frame_range[1])}`,\n\t\t];\n\n\t\tconst line_before_define = this.insert_define_after(shader_name);\n\t\tconst line_before_body = this.insert_body_after(shader_name);\n\t\tconst lines_to_remove = this.lines_to_remove(shader_name);\n\t\tlet line_before_define_found = false;\n\t\tlet line_before_body_found = false;\n\n\t\tfor (let template_line of template_lines) {\n\t\t\tif (line_before_define_found == true) {\n\t\t\t\tif (function_declaration) {\n\t\t\t\t\tthis._insert_lines(new_lines, function_declaration);\n\t\t\t\t}\n\t\t\t\tif (define) {\n\t\t\t\t\tthis._insert_lines(new_lines, define);\n\t\t\t\t}\n\t\t\t\tline_before_define_found = false;\n\t\t\t}\n\t\t\tif (line_before_body_found == true) {\n\t\t\t\t// this._insert_default_body_declarations(new_lines, shader_name)\n\t\t\t\tif (body) {\n\t\t\t\t\tthis._insert_lines(new_lines, body);\n\t\t\t\t}\n\t\t\t\tline_before_body_found = false;\n\t\t\t}\n\n\t\t\tlet line_remove_required = false;\n\t\t\tif (lines_to_remove) {\n\t\t\t\tfor (let line_to_remove of lines_to_remove) {\n\t\t\t\t\tif (template_line.indexOf(line_to_remove) >= 0) {\n\t\t\t\t\t\tline_remove_required = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!line_remove_required) {\n\t\t\t\tnew_lines.push(template_line);\n\t\t\t} else {\n\t\t\t\tnew_lines.push('// removed:');\n\t\t\t\tnew_lines.push(`//${template_line}`);\n\t\t\t}\n\n\t\t\tif (line_before_define && template_line.indexOf(line_before_define) >= 0) {\n\t\t\t\tline_before_define_found = true;\n\t\t\t}\n\t\t\tif (line_before_body && template_line.indexOf(line_before_body) >= 0) {\n\t\t\t\tline_before_body_found = true;\n\t\t\t}\n\n\t\t\t// if(template_line.indexOf('// INSERT DEFINE') >= 0){\n\t\t\t// } else {\n\t\t\t// \tif(template_line.indexOf('// INSERT BODY') >= 0){\n\t\t\t// \t\tif(body.length > 0){\n\t\t\t// \t\t\tlodash_times(3, ()=>new_lines.push('\t'))\n\t\t\t// \t\t\tbody.forEach(body_line=>{\n\t\t\t// \t\t\t\tnew_lines.push(body_line)\n\t\t\t// \t\t\t})\n\t\t\t// \t\t\tlodash_times(3, ()=>new_lines.push('\t'))\n\t\t\t// \t\t}\n\t\t\t// \t} else {\n\t\t\t// \t\tif(template_line.indexOf('// TO REMOVE') < 0){\n\t\t\t// \t\t\tnew_lines.push(template_line)\n\t\t\t// \t\t}\n\t\t\t// \t}\n\t\t\t// }\n\t\t}\n\t\tthis._lines.set(shader_name, new_lines);\n\t}\n\n\t// protected _insert_default_body_declarations(new_lines, shader_name){\n\t// \tnew_lines.push('float POLY_roughness = 1.0;')\n\t// }\n\n\tprivate _insert_lines(new_lines: string[], lines_to_add: string[]) {\n\t\tif (lines_to_add.length > 0) {\n\t\t\tfor (let i = 0; i < SPACED_LINES; i++) {\n\t\t\t\tnew_lines.push('');\n\t\t\t}\n\n\t\t\tfor (let line_to_add of lines_to_add) {\n\t\t\t\tnew_lines.push(line_to_add);\n\t\t\t}\n\t\t\tfor (let i = 0; i < SPACED_LINES; i++) {\n\t\t\t\tnew_lines.push('');\n\t\t\t}\n\t\t}\n\t}\n\n\tasync get_custom_materials(): Promise<Map<CustomMaterialName, ShaderMaterial>> {\n\t\treturn new Map<CustomMaterialName, ShaderMaterial>();\n\t}\n\n\t// protected expand_shader(shader_string: string) {\n\t// \tfunction parseIncludes(string: string) {\n\t// \t\tvar pattern = /^[ \\t]*#include +<([\\w\\d./]+)>/gm;\n\t// \t\tfunction replace(match: string, include: string) {\n\t// \t\t\tvar replace = ShaderChunk[include];\n\n\t// \t\t\tif (replace === undefined) {\n\t// \t\t\t\tthrow new Error('Can not resolve #include <' + include + '>');\n\t// \t\t\t}\n\n\t// \t\t\treturn parseIncludes(replace);\n\t// \t\t}\n\n\t// \t\treturn string.replace(pattern, replace);\n\t// \t}\n\t// \treturn parseIncludes(shader_string);\n\t// }\n\n\t//\n\t//\n\t// GLTF EXPORT\n\t//\n\t//\n\t// static convert_material_to_gltf_supported(material: ShaderMaterial): Material{\n\t// \tconst gltf_constructor = this.is_physical() ? MeshPhysicalMaterial : MeshStandardMaterial\n\t// \tconst options = {}\n\t// \tthis._match_uniform('color', options, material, 'diffuse')\n\t// \tthis._match_uniform('map', options, material)\n\t// \tthis._match_uniform('envMap', options, material)\n\t// \tthis._match_uniform('envMapIntensity', options, material)\n\t// \tthis._match_uniform('metalness', options, material)\n\t// \tthis._match_uniform('roughness', options, material)\n\t// \tconst gltf_material = new gltf_constructor(options)\n\t// \treturn gltf_material\n\t// }\n\t// static _match_uniform(name: string, options: object, material: ShaderMaterial, uniform_name?: string) {\n\t// \tuniform_name = uniform_name || name;\n\t// \toptions[name] = material.uniforms[uniform_name].value;\n\t// }\n}\n","import {TypedNode} from '../../_Base';\nimport {ShaderName} from './ShaderName';\n\nexport abstract class TypedAssembler<T extends TypedNode<any, any, any>> {\n\tabstract get shader_names(): ShaderName[];\n\tabstract input_names_for_shader_name(node: T, shader_name: ShaderName): string[];\n}\n","var baseAssignValue = require('./_baseAssignValue'),\n    eq = require('./eq');\n\n/**\n * This function is like `assignValue` except that it doesn't assign\n * `undefined` values.\n *\n * @private\n * @param {Object} object The object to modify.\n * @param {string} key The key of the property to assign.\n * @param {*} value The value to assign.\n */\nfunction assignMergeValue(object, key, value) {\n  if ((value !== undefined && !eq(object[key], value)) ||\n      (value === undefined && !(key in object))) {\n    baseAssignValue(object, key, value);\n  }\n}\n\nmodule.exports = assignMergeValue;\n","/**\n * Gets the value at `key`, unless `key` is \"__proto__\" or \"constructor\".\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction safeGet(object, key) {\n  if (key === 'constructor' && typeof object[key] === 'function') {\n    return;\n  }\n\n  if (key == '__proto__') {\n    return;\n  }\n\n  return object[key];\n}\n\nmodule.exports = safeGet;\n","/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nimport { Cache } from './Cache.js';\nimport { Loader } from './Loader.js';\n\nfunction ImageLoader( manager ) {\n\n\tLoader.call( this, manager );\n\n}\n\nImageLoader.prototype = Object.assign( Object.create( Loader.prototype ), {\n\n\tconstructor: ImageLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tif ( this.path !== undefined ) url = this.path + url;\n\n\t\turl = this.manager.resolveURL( url );\n\n\t\tvar scope = this;\n\n\t\tvar cached = Cache.get( url );\n\n\t\tif ( cached !== undefined ) {\n\n\t\t\tscope.manager.itemStart( url );\n\n\t\t\tsetTimeout( function () {\n\n\t\t\t\tif ( onLoad ) onLoad( cached );\n\n\t\t\t\tscope.manager.itemEnd( url );\n\n\t\t\t}, 0 );\n\n\t\t\treturn cached;\n\n\t\t}\n\n\t\tvar image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );\n\n\t\tfunction onImageLoad() {\n\n\t\t\timage.removeEventListener( 'load', onImageLoad, false );\n\t\t\timage.removeEventListener( 'error', onImageError, false );\n\n\t\t\tCache.add( url, this );\n\n\t\t\tif ( onLoad ) onLoad( this );\n\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t}\n\n\t\tfunction onImageError( event ) {\n\n\t\t\timage.removeEventListener( 'load', onImageLoad, false );\n\t\t\timage.removeEventListener( 'error', onImageError, false );\n\n\t\t\tif ( onError ) onError( event );\n\n\t\t\tscope.manager.itemError( url );\n\t\t\tscope.manager.itemEnd( url );\n\n\t\t}\n\n\t\timage.addEventListener( 'load', onImageLoad, false );\n\t\timage.addEventListener( 'error', onImageError, false );\n\n\t\tif ( url.substr( 0, 5 ) !== 'data:' ) {\n\n\t\t\tif ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;\n\n\t\t}\n\n\t\tscope.manager.itemStart( url );\n\n\t\timage.src = url;\n\n\t\treturn image;\n\n\t}\n\n} );\n\n\nexport { ImageLoader };\n","/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nfunction LoadingManager( onLoad, onProgress, onError ) {\n\n\tvar scope = this;\n\n\tvar isLoading = false;\n\tvar itemsLoaded = 0;\n\tvar itemsTotal = 0;\n\tvar urlModifier = undefined;\n\tvar handlers = [];\n\n\t// Refer to #5689 for the reason why we don't set .onStart\n\t// in the constructor\n\n\tthis.onStart = undefined;\n\tthis.onLoad = onLoad;\n\tthis.onProgress = onProgress;\n\tthis.onError = onError;\n\n\tthis.itemStart = function ( url ) {\n\n\t\titemsTotal ++;\n\n\t\tif ( isLoading === false ) {\n\n\t\t\tif ( scope.onStart !== undefined ) {\n\n\t\t\t\tscope.onStart( url, itemsLoaded, itemsTotal );\n\n\t\t\t}\n\n\t\t}\n\n\t\tisLoading = true;\n\n\t};\n\n\tthis.itemEnd = function ( url ) {\n\n\t\titemsLoaded ++;\n\n\t\tif ( scope.onProgress !== undefined ) {\n\n\t\t\tscope.onProgress( url, itemsLoaded, itemsTotal );\n\n\t\t}\n\n\t\tif ( itemsLoaded === itemsTotal ) {\n\n\t\t\tisLoading = false;\n\n\t\t\tif ( scope.onLoad !== undefined ) {\n\n\t\t\t\tscope.onLoad();\n\n\t\t\t}\n\n\t\t}\n\n\t};\n\n\tthis.itemError = function ( url ) {\n\n\t\tif ( scope.onError !== undefined ) {\n\n\t\t\tscope.onError( url );\n\n\t\t}\n\n\t};\n\n\tthis.resolveURL = function ( url ) {\n\n\t\tif ( urlModifier ) {\n\n\t\t\treturn urlModifier( url );\n\n\t\t}\n\n\t\treturn url;\n\n\t};\n\n\tthis.setURLModifier = function ( transform ) {\n\n\t\turlModifier = transform;\n\n\t\treturn this;\n\n\t};\n\n\tthis.addHandler = function ( regex, loader ) {\n\n\t\thandlers.push( regex, loader );\n\n\t\treturn this;\n\n\t};\n\n\tthis.removeHandler = function ( regex ) {\n\n\t\tvar index = handlers.indexOf( regex );\n\n\t\tif ( index !== - 1 ) {\n\n\t\t\thandlers.splice( index, 2 );\n\n\t\t}\n\n\t\treturn this;\n\n\t};\n\n\tthis.getHandler = function ( file ) {\n\n\t\tfor ( var i = 0, l = handlers.length; i < l; i += 2 ) {\n\n\t\t\tvar regex = handlers[ i ];\n\t\t\tvar loader = handlers[ i + 1 ];\n\n\t\t\tif ( regex.global ) regex.lastIndex = 0; // see #17920\n\n\t\t\tif ( regex.test( file ) ) {\n\n\t\t\t\treturn loader;\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn null;\n\n\t};\n\n}\n\nvar DefaultLoadingManager = new LoadingManager();\n\n\nexport { DefaultLoadingManager, LoadingManager };\n","import { Material } from './Material.js';\nimport { Color } from '../math/Color.js';\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *  map: new THREE.Texture( <Image> ),\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  size: <float>,\n *  sizeAttenuation: <bool>\n *\n *  morphTargets: <bool>\n * }\n */\n\nfunction PointsMaterial( parameters ) {\n\n\tMaterial.call( this );\n\n\tthis.type = 'PointsMaterial';\n\n\tthis.color = new Color( 0xffffff );\n\n\tthis.map = null;\n\n\tthis.alphaMap = null;\n\n\tthis.size = 1;\n\tthis.sizeAttenuation = true;\n\n\tthis.morphTargets = false;\n\n\tthis.setValues( parameters );\n\n}\n\nPointsMaterial.prototype = Object.create( Material.prototype );\nPointsMaterial.prototype.constructor = PointsMaterial;\n\nPointsMaterial.prototype.isPointsMaterial = true;\n\nPointsMaterial.prototype.copy = function ( source ) {\n\n\tMaterial.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\n\tthis.map = source.map;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.size = source.size;\n\tthis.sizeAttenuation = source.sizeAttenuation;\n\n\tthis.morphTargets = source.morphTargets;\n\n\treturn this;\n\n};\n\n\nexport { PointsMaterial };\n","/**\n * @author mrdoob / http://mrdoob.com/\n */\n\nimport { RGBAFormat, RGBFormat } from '../constants.js';\nimport { ImageLoader } from './ImageLoader.js';\nimport { Texture } from '../textures/Texture.js';\nimport { Loader } from './Loader.js';\n\nfunction TextureLoader( manager ) {\n\n\tLoader.call( this, manager );\n\n}\n\nTextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), {\n\n\tconstructor: TextureLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar texture = new Texture();\n\n\t\tvar loader = new ImageLoader( this.manager );\n\t\tloader.setCrossOrigin( this.crossOrigin );\n\t\tloader.setPath( this.path );\n\n\t\tloader.load( url, function ( image ) {\n\n\t\t\ttexture.image = image;\n\n\t\t\t// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.\n\t\t\tvar isJPEG = url.search( /\\.jpe?g($|\\?)/i ) > 0 || url.search( /^data\\:image\\/jpeg/ ) === 0;\n\n\t\t\ttexture.format = isJPEG ? RGBFormat : RGBAFormat;\n\t\t\ttexture.needsUpdate = true;\n\n\t\t\tif ( onLoad !== undefined ) {\n\n\t\t\t\tonLoad( texture );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t\treturn texture;\n\n\t}\n\n} );\n\n\nexport { TextureLoader };\n","import { TangentSpaceNormalMap } from '../constants.js';\nimport { Material } from './Material.js';\nimport { Vector2 } from '../math/Vector2.js';\nimport { Color } from '../math/Color.js';\n\n/**\n * @author WestLangley / http://github.com/WestLangley\n *\n * parameters = {\n *  color: <hex>,\n *  roughness: <float>,\n *  metalness: <float>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  emissive: <hex>,\n *  emissiveIntensity: <float>\n *  emissiveMap: new THREE.Texture( <Image> ),\n *\n *  bumpMap: new THREE.Texture( <Image> ),\n *  bumpScale: <float>,\n *\n *  normalMap: new THREE.Texture( <Image> ),\n *  normalMapType: THREE.TangentSpaceNormalMap,\n *  normalScale: <Vector2>,\n *\n *  displacementMap: new THREE.Texture( <Image> ),\n *  displacementScale: <float>,\n *  displacementBias: <float>,\n *\n *  roughnessMap: new THREE.Texture( <Image> ),\n *\n *  metalnessMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n *  envMapIntensity: <float>\n *\n *  refractionRatio: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nfunction MeshStandardMaterial( parameters ) {\n\n\tMaterial.call( this );\n\n\tthis.defines = { 'STANDARD': '' };\n\n\tthis.type = 'MeshStandardMaterial';\n\n\tthis.color = new Color( 0xffffff ); // diffuse\n\tthis.roughness = 1.0;\n\tthis.metalness = 0.0;\n\n\tthis.map = null;\n\n\tthis.lightMap = null;\n\tthis.lightMapIntensity = 1.0;\n\n\tthis.aoMap = null;\n\tthis.aoMapIntensity = 1.0;\n\n\tthis.emissive = new Color( 0x000000 );\n\tthis.emissiveIntensity = 1.0;\n\tthis.emissiveMap = null;\n\n\tthis.bumpMap = null;\n\tthis.bumpScale = 1;\n\n\tthis.normalMap = null;\n\tthis.normalMapType = TangentSpaceNormalMap;\n\tthis.normalScale = new Vector2( 1, 1 );\n\n\tthis.displacementMap = null;\n\tthis.displacementScale = 1;\n\tthis.displacementBias = 0;\n\n\tthis.roughnessMap = null;\n\n\tthis.metalnessMap = null;\n\n\tthis.alphaMap = null;\n\n\tthis.envMap = null;\n\tthis.envMapIntensity = 1.0;\n\n\tthis.refractionRatio = 0.98;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\tthis.morphNormals = false;\n\n\tthis.vertexTangents = false;\n\n\tthis.setValues( parameters );\n\n}\n\nMeshStandardMaterial.prototype = Object.create( Material.prototype );\nMeshStandardMaterial.prototype.constructor = MeshStandardMaterial;\n\nMeshStandardMaterial.prototype.isMeshStandardMaterial = true;\n\nMeshStandardMaterial.prototype.copy = function ( source ) {\n\n\tMaterial.prototype.copy.call( this, source );\n\n\tthis.defines = { 'STANDARD': '' };\n\n\tthis.color.copy( source.color );\n\tthis.roughness = source.roughness;\n\tthis.metalness = source.metalness;\n\n\tthis.map = source.map;\n\n\tthis.lightMap = source.lightMap;\n\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\tthis.aoMap = source.aoMap;\n\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\tthis.emissive.copy( source.emissive );\n\tthis.emissiveMap = source.emissiveMap;\n\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\tthis.bumpMap = source.bumpMap;\n\tthis.bumpScale = source.bumpScale;\n\n\tthis.normalMap = source.normalMap;\n\tthis.normalMapType = source.normalMapType;\n\tthis.normalScale.copy( source.normalScale );\n\n\tthis.displacementMap = source.displacementMap;\n\tthis.displacementScale = source.displacementScale;\n\tthis.displacementBias = source.displacementBias;\n\n\tthis.roughnessMap = source.roughnessMap;\n\n\tthis.metalnessMap = source.metalnessMap;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.envMap = source.envMap;\n\tthis.envMapIntensity = source.envMapIntensity;\n\n\tthis.refractionRatio = source.refractionRatio;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\tthis.wireframeLinecap = source.wireframeLinecap;\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\tthis.morphNormals = source.morphNormals;\n\n\tthis.vertexTangents = source.vertexTangents;\n\n\treturn this;\n\n};\n\n\nexport { MeshStandardMaterial };\n","var arrayMap = require('./_arrayMap'),\n    baseIntersection = require('./_baseIntersection'),\n    baseRest = require('./_baseRest'),\n    castArrayLikeObject = require('./_castArrayLikeObject');\n\n/**\n * Creates an array of unique values that are included in all given arrays\n * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons. The order and references of result values are\n * determined by the first array.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {...Array} [arrays] The arrays to inspect.\n * @returns {Array} Returns the new array of intersecting values.\n * @example\n *\n * _.intersection([2, 1], [2, 3]);\n * // => [2]\n */\nvar intersection = baseRest(function(arrays) {\n  var mapped = arrayMap(arrays, castArrayLikeObject);\n  return (mapped.length && mapped[0] === arrays[0])\n    ? baseIntersection(mapped)\n    : [];\n});\n\nmodule.exports = intersection;\n","import {GlobalsGlNode} from '../../Globals';\nimport {ConnectionPointType} from '../../../utils/connections/ConnectionPointType';\nimport {BaseGlNodeType} from '../../_Base';\nimport {ShadersCollectionController} from '../utils/ShadersCollectionController';\n\nexport abstract class GlobalsBaseController {\n\tprivate static __next_id: number = 0;\n\tprivate _id: number;\n\n\tconstructor() {\n\t\tthis._id = GlobalsBaseController.__next_id++;\n\t}\n\tid() {\n\t\treturn this._id;\n\t}\n\n\thandle_globals_node(\n\t\tglobals_node: GlobalsGlNode,\n\t\toutput_name: string,\n\t\tshaders_collection_controller: ShadersCollectionController\n\t\t// definitions_by_shader_name: Map<ShaderName, BaseGLDefinition[]>,\n\t\t// body_lines_by_shader_name: Map<ShaderName, string[]>,\n\t\t// body_lines: string[],\n\t\t// dependencies: ShaderName[],\n\t\t// shader_name: ShaderName\n\t): void {}\n\n\tabstract read_attribute(\n\t\tnode: BaseGlNodeType,\n\t\tgl_type: ConnectionPointType,\n\t\tattrib_name: string,\n\t\tshaders_collection_controller: ShadersCollectionController\n\t): string | undefined;\n}\n","import lodash_compact from 'lodash/compact';\nimport lodash_uniq from 'lodash/uniq';\n// import {BaseGlNodeType} from '../../gl/_Base';\n// import {OutputGlNode} from '../gl/Output';\nimport {CoreGraph} from '../../../../core/graph/CoreGraph';\nimport {BaseNodeType, TypedNode} from '../../_Base';\nimport {TypedAssembler} from './BaseAssembler';\nimport {MapUtils} from '../../../../core/MapUtils';\nimport {ShaderName} from './ShaderName';\n\ntype NumberByString = Map<string, number>;\ntype BooleanByString = Map<string, boolean>;\ntype BooleanByStringByShaderName = Map<ShaderName, BooleanByString>;\ntype StringArrayByString = Map<string, string[]>;\n\n// interface BaseNodeGlArrayByString {\n// \t[propName: string]: BaseNodeGl[]\n// }\n// interface StringArrayByString {\n// \t[propName: string]: string[]\n// }\n\n// import {LineType, LINE_TYPES} from './CodeBuilder'\n\n// const VERTEX_INPUT_NAMES = [\n// \t'position',\n// \t'normal',\n// \t'gl_PointSize'\n// ]\n// const FRAGMENT_INPUT_NAMES = [\n// \t'color',\n// \t'alpha'\n// ]\n\nexport class TypedNodeTraverser<T extends TypedNode<any, T, any>> {\n\tprivate _leaves_graph_id: BooleanByStringByShaderName = new Map();\n\tprivate _graph_ids_by_shader_name: BooleanByStringByShaderName = new Map();\n\tprivate _outputs_by_graph_id: StringArrayByString = new Map();\n\tprivate _depth_by_graph_id: NumberByString = new Map();\n\tprivate _graph_id_by_depth: Map<number, string[]> = new Map();\n\tprivate _graph: CoreGraph;\n\tprivate _shader_name!: ShaderName;\n\n\tconstructor(private _assembler: TypedAssembler<T>, private _gl_parent_node: BaseNodeType) {\n\t\tthis._graph = this._gl_parent_node.scene.graph;\n\t}\n\n\tprivate reset() {\n\t\tthis._leaves_graph_id.clear();\n\t\tthis._outputs_by_graph_id.clear();\n\t\tthis._depth_by_graph_id.clear();\n\t\tthis._graph_id_by_depth.clear();\n\n\t\tthis.shader_names().forEach((shader_name) => {\n\t\t\tthis._graph_ids_by_shader_name.set(shader_name, new Map());\n\t\t});\n\t}\n\n\tshader_names() {\n\t\treturn this._assembler.shader_names;\n\t}\n\tinput_names_for_shader_name(root_node: T, shader_name: ShaderName) {\n\t\treturn this._assembler.input_names_for_shader_name(root_node, shader_name);\n\t}\n\n\ttraverse(root_nodes: T[]) {\n\t\tthis.reset();\n\n\t\tfor (let shader_name of this.shader_names()) {\n\t\t\tthis._leaves_graph_id.set(shader_name, new Map());\n\t\t}\n\n\t\tfor (let shader_name of this.shader_names()) {\n\t\t\tthis._shader_name = shader_name;\n\t\t\tfor (let root_node of root_nodes) {\n\t\t\t\tthis.find_leaves_from_root_node(root_node);\n\t\t\t\tthis.set_nodes_depth();\n\t\t\t}\n\t\t}\n\n\t\t// graph_ids.forEach((graph_id) => {\n\t\tthis._depth_by_graph_id.forEach((depth: number, graph_id: string) => {\n\t\t\tif (depth != null) {\n\t\t\t\t// this._graph_id_by_depth.set(depth, this._graph_id_by_depth.get(depth) || []);\n\t\t\t\t// this._graph_id_by_depth.get(depth)?.push(graph_id);\n\t\t\t\tMapUtils.push_on_array_at_entry(this._graph_id_by_depth, depth, graph_id);\n\t\t\t}\n\t\t});\n\t}\n\n\tleaves_from_nodes(nodes: T[]) {\n\t\tthis._shader_name = ShaderName.LEAVES_FROM_NODES_SHADER;\n\t\tthis._graph_ids_by_shader_name.set(this._shader_name, new Map());\n\t\tthis._leaves_graph_id.set(this._shader_name, new Map());\n\t\tfor (let node of nodes) {\n\t\t\tthis.find_leaves(node);\n\t\t}\n\n\t\tconst node_ids: string[] = [];\n\t\tthis._leaves_graph_id.get(this._shader_name)?.forEach((value: boolean, key: string) => {\n\t\t\tnode_ids.push(key);\n\t\t});\n\t\treturn this._graph.nodes_from_ids(node_ids) as T[];\n\t}\n\n\tnodes_for_shader_name(shader_name: ShaderName) {\n\t\tconst depths: number[] = [];\n\t\tthis._graph_id_by_depth.forEach((value: string[], key: number) => {\n\t\t\tdepths.push(key);\n\t\t});\n\t\tdepths.sort((a, b) => a - b);\n\t\tconst nodes: T[] = [];\n\t\tdepths.forEach((depth) => {\n\t\t\tconst graph_ids_for_depth = this._graph_id_by_depth.get(depth);\n\t\t\tif (graph_ids_for_depth) {\n\t\t\t\tgraph_ids_for_depth.forEach((graph_id: string) => {\n\t\t\t\t\tconst is_present = this._graph_ids_by_shader_name.get(shader_name)?.get(graph_id);\n\t\t\t\t\tif (is_present) {\n\t\t\t\t\t\tconst node = this._graph.node_from_id(graph_id) as T;\n\t\t\t\t\t\tnodes.push(node);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\n\t\treturn nodes;\n\t}\n\tsorted_nodes() {\n\t\tconst depths: number[] = [];\n\t\tthis._graph_id_by_depth.forEach((ids: string[], depth: number) => {\n\t\t\tdepths.push(depth);\n\t\t});\n\t\tdepths.sort((a, b) => a - b);\n\t\tconst nodes: T[] = [];\n\t\tdepths.forEach((depth) => {\n\t\t\tconst graph_ids_for_depth = this._graph_id_by_depth.get(depth);\n\t\t\tif (graph_ids_for_depth) {\n\t\t\t\tfor (let graph_id of graph_ids_for_depth) {\n\t\t\t\t\tconst node = this._graph.node_from_id(graph_id) as T;\n\t\t\t\t\tif (node) {\n\t\t\t\t\t\tnodes.push(node);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn nodes;\n\t}\n\tprivate find_leaves_from_root_node(root_node: T) {\n\t\t// if(this._shader_name == ShaderName.VERTEX){\n\t\t// this._leaves_graph_id[this._shader_name] = {}\n\t\tthis._graph_ids_by_shader_name.get(this._shader_name)?.set(root_node.graph_node_id, true);\n\n\t\tconst input_names = this.input_names_for_shader_name(root_node, this._shader_name);\n\t\tif (input_names) {\n\t\t\tfor (let input_name of input_names) {\n\t\t\t\t// if (root_node.type == 'output') {\n\t\t\t\tconst input = root_node.io.inputs.named_input(input_name);\n\t\t\t\tif (input) {\n\t\t\t\t\tMapUtils.push_on_array_at_entry(\n\t\t\t\t\t\tthis._outputs_by_graph_id,\n\t\t\t\t\t\tinput.graph_node_id,\n\t\t\t\t\t\troot_node.graph_node_id\n\t\t\t\t\t);\n\t\t\t\t\tthis.find_leaves(input);\n\t\t\t\t}\n\t\t\t\t// TODO: typescript - GL - check that I dont need to consider the Attrib as a special case\n\t\t\t\t// } else {\n\t\t\t\t// \t// if attribute\n\t\t\t\t// \tconst input = root_node.io.inputs.connected_named_input();\n\t\t\t\t// \tif (input) {\n\t\t\t\t// \t\tthis.find_leaves(input);\n\t\t\t\t// \t}\n\t\t\t\t// }\n\t\t\t}\n\t\t}\n\t\t// const position_input = this._output.named_input('position')\n\t\t// const normal_input = this._output.named_input('normal')\n\t\t// const instancePosition_input = this._output.named_input('instancePosition')\n\t\t// if(position_input){ this.find_leaves(position_input) }\n\t\t// if(normal_input){ this.find_leaves(normal_input) }\n\t\t// if(instancePosition_input){ this.find_leaves(instancePosition_input) }\n\t\t// }\n\t\t// if(this._shader_name == ShaderName.FRAGMENT){\n\t\t// \tthis._leaves_graph_id[this._shader_name] = {}\n\t\t// \tFRAGMENT_INPUT_NAMES.forEach(name=>{\n\t\t// \t\tconst input = this._output.named_input(name)\n\t\t// \t\tif(input){\n\t\t// \t\t\tthis.find_leaves(input)\n\t\t// \t\t}\n\t\t// \t})\n\t\t// \t// const color_input = this._output.named_input('color')\n\t\t// \t// const alpha_input = this._output.named_input('alpha')\n\t\t// \t// if(color_input){ this.find_leaves(color_input) }\n\t\t// \t// if(alpha_input){ this.find_leaves(alpha_input) }\n\t\t// }\n\n\t\tthis._outputs_by_graph_id.forEach((outputs: string[], graph_id: string) => {\n\t\t\tthis._outputs_by_graph_id.set(graph_id, lodash_uniq(outputs));\n\t\t});\n\t}\n\n\tprivate find_leaves(node: T) {\n\t\tthis._graph_ids_by_shader_name.get(this._shader_name)?.set(node.graph_node_id, true);\n\n\t\tconst inputs = lodash_compact(node.io.inputs.inputs());\n\t\tconst input_graph_ids = lodash_uniq(inputs.map((n) => n.graph_node_id));\n\t\tconst unique_inputs = input_graph_ids.map((graph_id) => this._graph.node_from_id(graph_id)) as T[];\n\t\tif (unique_inputs.length > 0) {\n\t\t\t// const promises = unique_inputs.forEach((input)=>{\n\t\t\tfor (let input of unique_inputs) {\n\t\t\t\tMapUtils.push_on_array_at_entry(this._outputs_by_graph_id, input.graph_node_id, node.graph_node_id);\n\n\t\t\t\tthis.find_leaves(input);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._leaves_graph_id.get(this._shader_name)!.set(node.graph_node_id, true);\n\t\t}\n\t}\n\n\tprivate set_nodes_depth() {\n\t\tthis._leaves_graph_id.forEach((booleans_by_graph_id, shader_name) => {\n\t\t\tbooleans_by_graph_id.forEach((boolean, graph_id) => {\n\t\t\t\tthis.set_node_depth(graph_id);\n\t\t\t});\n\t\t});\n\t\t// const leave_ids = Object.keys(this._leaves_graph_id[this._shader_name]);\n\t\t// leave_ids.forEach((graph_id) => {\n\t\t// \tthis.set_node_depth(graph_id);\n\t\t// });\n\t}\n\n\tprivate set_node_depth(graph_id: string, depth: number = 0) {\n\t\tconst current_depth = this._depth_by_graph_id.get(graph_id);\n\t\tif (current_depth != null) {\n\t\t\tthis._depth_by_graph_id.set(graph_id, Math.max(current_depth, depth));\n\t\t} else {\n\t\t\tthis._depth_by_graph_id.set(graph_id, depth);\n\t\t}\n\n\t\t// const node = this._graph.node_from_id(graph_id);\n\n\t\tconst output_ids = this._outputs_by_graph_id.get(graph_id);\n\t\tif (output_ids) {\n\t\t\toutput_ids.forEach((output_id) => {\n\t\t\t\tthis.set_node_depth(output_id, depth + 1);\n\t\t\t});\n\t\t}\n\t}\n}\n","import {AssemblerControllerNode} from '../Controller';\n\nexport class GlNodeFinder {\n\tstatic find_output_nodes(node: AssemblerControllerNode) {\n\t\tconst nodes = node.nodes_by_type('output');\n\t\treturn nodes;\n\t\t// if (nodes.length > 1) {\n\t\t// \tnode.states.error.set('only one output node allowed');\n\t\t// }\n\t\t// return nodes[0];\n\t}\n\tstatic find_attribute_export_nodes(node: AssemblerControllerNode) {\n\t\tconst nodes = node.nodes_by_type('attribute');\n\t\treturn nodes.filter((node) => {\n\t\t\t// do not use attributes that are used as an input, as export\n\t\t\t// return (node.used_output_names().length == 0) &&\n\t\t\treturn node.is_exporting;\n\t\t});\n\t}\n}\n","import {BaseController} from './_BaseController';\nimport {Material} from 'three/src/materials/Material';\nimport {Texture} from 'three/src/textures/Texture';\nimport {FileCopNode} from '../../cop/File';\nimport {BaseMatNodeType} from '../_Base';\n\nimport {ParamConfig} from '../../utils/params/ParamsConfig';\nimport {NodeContext} from '../../../poly/NodeContext';\nimport {BaseCopNodeType} from '../../cop/_Base';\nimport {OperatorPathParam} from '../../../params/OperatorPath';\nimport {BooleanParam} from '../../../params/Boolean';\nimport {BaseNodeType} from '../../_Base';\nimport {BaseParamType} from '../../../params/_Base';\nimport {ShaderMaterial} from 'three/src/materials/ShaderMaterial';\nimport {IUniform} from 'three/src/renderers/shaders/UniformsLib';\nimport {IUniforms} from '../../../../core/geometry/Material';\n\nexport function TextureMapParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\tuse_map = ParamConfig.BOOLEAN(0);\n\t\tmap = ParamConfig.OPERATOR_PATH(FileCopNode.DEFAULT_NODE_PATH.UV, {visible_if: {use_map: 1}});\n\t};\n}\n// class TextureMapMaterial<T extends string> extends Material {\n// \t[T]!: Texture | null;\n// }\n// class TextureMapParamsConfig extends TextureMapParamConfig(NodeParamsConfig) {}\n// class TextureMapMatNode extends TypedMatNode<TextureMapMaterial, TextureMapParamsConfig> {\n// \tcreate_material() {\n// \t\treturn new TextureMapMaterial();\n// \t}\n// }\n\ntype FilterFlags<Base, Condition> = {\n\t[Key in keyof Base]: Base[Key] extends Condition ? Key : never;\n};\ntype AllowedNames<Base, Condition> = FilterFlags<Base, Condition>[keyof Base];\ntype SubType<Base, Condition> = Pick<Base, AllowedNames<Base, Condition>>;\n\n// type test = FilterFlags<MeshLambertMaterial, Texture|null>\n// type test2 = AllowedNames<MeshLambertMaterial, Texture|null>\n// type test3 = SubType<MeshLambertMaterial, Texture|null>\n\nexport function BooleanParamOptions(controller_class: typeof BaseTextureMapController) {\n\treturn {\n\t\tcook: false,\n\t\tcallback: (node: BaseNodeType, param: BaseParamType) => {\n\t\t\tcontroller_class.update(node as BaseMatNodeType);\n\t\t},\n\t};\n}\nexport function OperatorPathOptions(controller: typeof BaseTextureMapController, use_map_name: string) {\n\treturn {\n\t\tvisible_if: {[use_map_name]: 1},\n\t\tnode_selection: {context: NodeContext.COP},\n\t\tcook: false,\n\t\tcallback: (node: BaseNodeType, param: BaseParamType) => {\n\t\t\tcontroller.update(node as BaseMatNodeType);\n\t\t},\n\t};\n}\n\ntype TextureUpdateCallback<O extends Object> = (\n\tmaterial: Material,\n\tobject: O,\n\tmat_attrib_name: keyof SubType<O, Texture | null>,\n\ttexture: Texture\n) => void;\ntype TextureRemoveCallback<O extends Object> = (\n\tmaterial: Material,\n\tobject: O,\n\tmat_attrib_name: keyof SubType<O, Texture | null>\n) => void;\n\ntype CurrentMaterial = Material | ShaderMaterial;\n\nexport interface UpdateOptions {\n\tdirect_params?: boolean;\n\tuniforms?: boolean;\n\tdefine?: boolean;\n}\nexport class BaseTextureMapController extends BaseController {\n\tconstructor(protected node: BaseMatNodeType, protected _update_options: UpdateOptions) {\n\t\tsuper(node);\n\t\tif (this._update_options.define == null) {\n\t\t\tthis._update_options.define = true;\n\t\t}\n\t}\n\n\tprotected add_hooks(use_map_param: BooleanParam, path_param: OperatorPathParam) {\n\t\tuse_map_param.add_post_dirty_hook('TextureController', () => {\n\t\t\tthis.update();\n\t\t});\n\t\tpath_param.add_post_dirty_hook('TextureController', () => {\n\t\t\tthis.update();\n\t\t});\n\t}\n\tstatic update(node: BaseNodeType) {}\n\n\tasync _update<M extends CurrentMaterial>(\n\t\tmaterial: M,\n\t\tmat_attrib_name: string,\n\t\tuse_map_param: BooleanParam,\n\t\tpath_param: OperatorPathParam\n\t) {\n\t\tif (this._update_options.uniforms) {\n\t\t\tconst shader_material = material as ShaderMaterial;\n\t\t\tconst attr_name = mat_attrib_name as keyof SubType<IUniforms, Texture | null>;\n\t\t\tawait this._update_texture_on_uniforms(shader_material, attr_name, use_map_param, path_param);\n\t\t}\n\t\tif (this._update_options.direct_params) {\n\t\t\tconst mat = material as Material;\n\t\t\tconst attr_name = mat_attrib_name as keyof SubType<Material, Texture | null>;\n\t\t\tawait this._update_texture_on_material(mat, attr_name, use_map_param, path_param);\n\t\t}\n\t}\n\n\t//\n\t//\n\t// FOR CASES WHERE THE TEXTURE IS ON THE UNIFORMS\n\t//\n\t//\n\tasync _update_texture_on_uniforms<O extends IUniform>(\n\t\tmaterial: ShaderMaterial,\n\t\tmat_attrib_name: keyof SubType<O, Texture | null>,\n\t\tuse_map_param: BooleanParam,\n\t\tpath_param: OperatorPathParam\n\t) {\n\t\tthis._update_required_attribute(\n\t\t\tmaterial,\n\t\t\tmaterial.uniforms,\n\t\t\tmat_attrib_name as never,\n\t\t\tuse_map_param,\n\t\t\tpath_param,\n\t\t\tthis._apply_texture_on_uniforms.bind(this),\n\t\t\tthis._remove_texture_from_uniforms.bind(this)\n\t\t);\n\t}\n\tprivate _apply_texture_on_uniforms<O extends IUniforms>(\n\t\tmaterial: Material,\n\t\tuniforms: O,\n\t\tmat_attrib_name: keyof SubType<O, Texture | null>,\n\t\ttexture: Texture\n\t) {\n\t\tconst has_texture = uniforms[mat_attrib_name] != null && uniforms[mat_attrib_name].value != null;\n\t\tlet new_texture_is_different = false;\n\t\tif (has_texture) {\n\t\t\tconst current_texture: Texture = (<unknown>uniforms[mat_attrib_name].value) as Texture;\n\t\t\tif (current_texture.uuid != texture.uuid) {\n\t\t\t\tnew_texture_is_different = true;\n\t\t\t}\n\t\t}\n\t\tif (!has_texture || new_texture_is_different) {\n\t\t\tuniforms[mat_attrib_name].value = texture as any;\n\t\t\tif (this._do_update_define()) {\n\t\t\t\tconst define_name = this._define_name(`${mat_attrib_name}`);\n\t\t\t\tmaterial.defines[define_name] = 1;\n\t\t\t}\n\t\t\tmaterial.defines['USE_UV'] = 1;\n\t\t\tmaterial.needsUpdate = true;\n\t\t}\n\t}\n\tprivate _remove_texture_from_uniforms<U extends IUniforms>(\n\t\tmaterial: Material,\n\t\tuniforms: U,\n\t\tmat_attrib_name: keyof SubType<U, Texture | null>\n\t) {\n\t\tif (uniforms[mat_attrib_name].value) {\n\t\t\tuniforms[mat_attrib_name].value = null;\n\t\t\tif (this._do_update_define()) {\n\t\t\t\tconst define_name = this._define_name(`${mat_attrib_name}`);\n\t\t\t\tdelete material.defines[define_name];\n\t\t\t}\n\t\t\tmaterial.needsUpdate = true;\n\t\t}\n\t}\n\tprivate _define_name(mat_attrib_name: string): string {\n\t\treturn 'USE_' + mat_attrib_name.replace('_', '').toUpperCase();\n\t}\n\n\t//\n\t//\n\t// FOR CASES WHERE THE TEXTURE IS ON THE MATERIAL\n\t//\n\t//\n\tasync _update_texture_on_material<M extends Material>(\n\t\tmaterial: M,\n\t\tmat_attrib_name: keyof SubType<M, Texture | null>,\n\t\tuse_map_param: BooleanParam,\n\t\tpath_param: OperatorPathParam\n\t) {\n\t\tthis._update_required_attribute(\n\t\t\tmaterial,\n\t\t\tmaterial,\n\t\t\tmat_attrib_name,\n\t\t\tuse_map_param,\n\t\t\tpath_param,\n\t\t\tthis._apply_texture_on_material.bind(this),\n\t\t\tthis._remove_texture_from_material.bind(this)\n\t\t);\n\t}\n\tprivate _apply_texture_on_material<M extends Material>(\n\t\tmaterial: Material,\n\t\ttexture_owner: M,\n\t\tmat_attrib_name: keyof SubType<M, Texture | null>,\n\t\ttexture: Texture\n\t) {\n\t\tconst has_texture = texture_owner[mat_attrib_name] != null;\n\t\tlet new_texture_is_different = false;\n\t\tif (has_texture) {\n\t\t\tconst current_texture: Texture = (<unknown>texture_owner[mat_attrib_name]) as Texture;\n\t\t\tif (current_texture.uuid != texture.uuid) {\n\t\t\t\tnew_texture_is_different = true;\n\t\t\t}\n\t\t}\n\t\tif (!has_texture || new_texture_is_different) {\n\t\t\ttexture_owner[mat_attrib_name] = texture as any;\n\t\t\tmaterial.needsUpdate = true;\n\t\t}\n\t}\n\tprivate _remove_texture_from_material<M extends Material>(\n\t\tmaterial: Material,\n\t\ttexture_owner: M,\n\t\tmat_attrib_name: keyof SubType<M, Texture | null>\n\t) {\n\t\tif (texture_owner[mat_attrib_name]) {\n\t\t\ttexture_owner[mat_attrib_name] = null as any;\n\t\t\tmaterial.needsUpdate = true;\n\t\t}\n\t}\n\n\t//\n\t//\n\t// MAIN ALGO to decide if texture should be updated\n\t//\n\t//\n\tprivate async _update_required_attribute<O extends Object>(\n\t\tmaterial: Material,\n\t\ttexture_owner: O,\n\t\tmat_attrib_name: keyof SubType<O, Texture | null>,\n\t\tuse_map_param: BooleanParam,\n\t\tpath_param: OperatorPathParam,\n\t\tupdate_callback: TextureUpdateCallback<O>,\n\t\tremove_callback: TextureRemoveCallback<O>\n\t) {\n\t\tif (use_map_param.is_dirty) {\n\t\t\tawait use_map_param.compute();\n\t\t}\n\t\tconst use_map: boolean = use_map_param.value;\n\n\t\tif (use_map) {\n\t\t\tif (path_param.is_dirty) {\n\t\t\t\tawait path_param.compute();\n\t\t\t}\n\n\t\t\tconst found_node = path_param.found_node();\n\t\t\tif (found_node) {\n\t\t\t\tif (found_node.node_context() == NodeContext.COP) {\n\t\t\t\t\tconst texture_node = found_node as BaseCopNodeType;\n\n\t\t\t\t\tconst container = await texture_node.request_container();\n\t\t\t\t\tconst texture = container.texture();\n\n\t\t\t\t\tif (texture) {\n\t\t\t\t\t\tupdate_callback(material, texture_owner, mat_attrib_name, texture);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.node.states.error.set(`found node has no texture`);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthis.node.states.error.set(`found map node is not a COP node`);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.node.states.error.set(`could not find map node ${path_param.name} with path ${path_param.value}`);\n\t\t\t}\n\t\t}\n\t\t// this is not wrapped in an else clause after the \"if (use_map) {\"\n\t\t// as we should come here after any of the errors above, if any is triggered\n\t\tremove_callback(material, texture_owner, mat_attrib_name);\n\t}\n\n\tprivate _do_update_define(): boolean {\n\t\tif (this._update_options.define == null) {\n\t\t\treturn true;\n\t\t}\n\t\treturn this._update_options.define;\n\t}\n}\n","import {BaseController} from './_BaseController';\nimport {TypedMatNode} from '../_Base';\nimport {Material} from 'three/src/materials/Material';\nimport {NodeParamsConfig, ParamConfig} from '../../utils/params/ParamsConfig';\nimport {IUniforms} from '../../../../core/geometry/Material';\n\nexport function ColorParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\t// color = ParamConfig.COLOR([1, 1, 1]);\n\t\ttransparent = ParamConfig.BOOLEAN(0);\n\t\topacity = ParamConfig.FLOAT(1);\n\t\talpha_test = ParamConfig.FLOAT(0);\n\t\tuse_fog = ParamConfig.BOOLEAN(0);\n\t};\n}\n\nclass ColoredMaterial extends Material {\n\tvertexColors!: boolean;\n\ttransparent!: boolean;\n\tdepthTest!: boolean;\n\talphaTest!: number;\n\tfog!: boolean;\n\tuniforms!: IUniforms;\n}\nclass ColorParamsConfig extends ColorParamConfig(NodeParamsConfig) {}\n\nclass ColoredMatNode extends TypedMatNode<ColoredMaterial, ColorParamsConfig> {\n\tcreate_material() {\n\t\treturn new ColoredMaterial();\n\t}\n}\n\nexport class ColorsController extends BaseController {\n\tstatic update(node: ColoredMatNode) {\n\t\tconst material = node.material;\n\t\tconst pv = node.pv;\n\n\t\tif (material.uniforms.opacity) {\n\t\t\tmaterial.uniforms.opacity.value = pv.opacity;\n\t\t}\n\t\tmaterial.transparent = pv.transparent || pv.opacity < 1;\n\t\tmaterial.depthTest = true;\n\t\tmaterial.alphaTest = pv.alpha_test;\n\t\tmaterial.fog = pv.use_fog;\n\t}\n}\n","import {TypedMatNode} from './_Base';\nimport {GlAssemblerController} from '../gl/code/Controller';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {ShaderAssemblerMaterial} from '../gl/code/assemblers/materials/_BaseMaterial';\nimport {GlNodeChildrenMap} from '../../poly/registers/Gl';\nimport {BaseGlNodeType} from '../gl/_Base';\nimport {ShaderMaterialWithCustomMaterials} from '../../../core/geometry/Material';\nimport {NodeContext} from '../../poly/NodeContext';\n\nexport abstract class TypedBuilderMatNode<\n\tA extends ShaderAssemblerMaterial,\n\tK extends NodeParamsConfig\n> extends TypedMatNode<ShaderMaterialWithCustomMaterials, K> {\n\tprotected _assembler_controller: GlAssemblerController<A> | undefined;\n\tprotected _children_controller_context = NodeContext.GL;\n\tinitialize_base_node() {\n\t\tsuper.initialize_base_node();\n\n\t\tthis.lifecycle.add_on_create_hook(this.assembler_controller.on_create.bind(this.assembler_controller));\n\t\tthis.children_controller?.init();\n\t}\n\n\t//\n\t//\n\t// MATERIAL\n\t//\n\t//\n\tcreate_material() {\n\t\treturn this.assembler_controller.assembler.create_material() as ShaderMaterialWithCustomMaterials;\n\t}\n\t//\n\t//\n\t// ASSEMBLER\n\t//\n\t//\n\tget assembler_controller() {\n\t\treturn (this._assembler_controller = this._assembler_controller || this._create_assembler_controller());\n\t}\n\tprotected abstract _create_assembler_controller(): GlAssemblerController<A>;\n\n\tcreate_node<K extends keyof GlNodeChildrenMap>(type: K): GlNodeChildrenMap[K] {\n\t\treturn super.create_node(type) as GlNodeChildrenMap[K];\n\t}\n\tchildren() {\n\t\treturn super.children() as BaseGlNodeType[];\n\t}\n\tnodes_by_type<K extends keyof GlNodeChildrenMap>(type: K): GlNodeChildrenMap[K][] {\n\t\treturn super.nodes_by_type(type) as GlNodeChildrenMap[K][];\n\t}\n\n\t//\n\t//\n\t// COMPILATION\n\t//\n\t//\n\tasync compile_if_required() {\n\t\tif (this.assembler_controller.compile_required()) {\n\t\t\tthis._compile();\n\t\t}\n\t}\n\tprotected async _compile() {\n\t\tif (this.material) {\n\t\t\tawait this.assembler_controller.assembler.compile_material(this.material);\n\t\t\tawait this.assembler_controller.post_compile();\n\t\t}\n\t}\n}\n\nexport type BaseBuilderMatNodeType = TypedBuilderMatNode<ShaderAssemblerMaterial, NodeParamsConfig>;\n","import { Material } from './Material.js';\nimport { MultiplyOperation } from '../constants.js';\nimport { Color } from '../math/Color.js';\n\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author alteredq / http://alteredqualia.com/\n *\n * parameters = {\n *  color: <hex>,\n *  opacity: <float>,\n *\n *  map: new THREE.Texture( <Image> ),\n *\n *  lightMap: new THREE.Texture( <Image> ),\n *  lightMapIntensity: <float>\n *\n *  aoMap: new THREE.Texture( <Image> ),\n *  aoMapIntensity: <float>\n *\n *  emissive: <hex>,\n *  emissiveIntensity: <float>\n *  emissiveMap: new THREE.Texture( <Image> ),\n *\n *  specularMap: new THREE.Texture( <Image> ),\n *\n *  alphaMap: new THREE.Texture( <Image> ),\n *\n *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),\n *  combine: THREE.Multiply,\n *  reflectivity: <float>,\n *  refractionRatio: <float>,\n *\n *  wireframe: <boolean>,\n *  wireframeLinewidth: <float>,\n *\n *  skinning: <bool>,\n *  morphTargets: <bool>,\n *  morphNormals: <bool>\n * }\n */\n\nfunction MeshLambertMaterial( parameters ) {\n\n\tMaterial.call( this );\n\n\tthis.type = 'MeshLambertMaterial';\n\n\tthis.color = new Color( 0xffffff ); // diffuse\n\n\tthis.map = null;\n\n\tthis.lightMap = null;\n\tthis.lightMapIntensity = 1.0;\n\n\tthis.aoMap = null;\n\tthis.aoMapIntensity = 1.0;\n\n\tthis.emissive = new Color( 0x000000 );\n\tthis.emissiveIntensity = 1.0;\n\tthis.emissiveMap = null;\n\n\tthis.specularMap = null;\n\n\tthis.alphaMap = null;\n\n\tthis.envMap = null;\n\tthis.combine = MultiplyOperation;\n\tthis.reflectivity = 1;\n\tthis.refractionRatio = 0.98;\n\n\tthis.wireframe = false;\n\tthis.wireframeLinewidth = 1;\n\tthis.wireframeLinecap = 'round';\n\tthis.wireframeLinejoin = 'round';\n\n\tthis.skinning = false;\n\tthis.morphTargets = false;\n\tthis.morphNormals = false;\n\n\tthis.setValues( parameters );\n\n}\n\nMeshLambertMaterial.prototype = Object.create( Material.prototype );\nMeshLambertMaterial.prototype.constructor = MeshLambertMaterial;\n\nMeshLambertMaterial.prototype.isMeshLambertMaterial = true;\n\nMeshLambertMaterial.prototype.copy = function ( source ) {\n\n\tMaterial.prototype.copy.call( this, source );\n\n\tthis.color.copy( source.color );\n\n\tthis.map = source.map;\n\n\tthis.lightMap = source.lightMap;\n\tthis.lightMapIntensity = source.lightMapIntensity;\n\n\tthis.aoMap = source.aoMap;\n\tthis.aoMapIntensity = source.aoMapIntensity;\n\n\tthis.emissive.copy( source.emissive );\n\tthis.emissiveMap = source.emissiveMap;\n\tthis.emissiveIntensity = source.emissiveIntensity;\n\n\tthis.specularMap = source.specularMap;\n\n\tthis.alphaMap = source.alphaMap;\n\n\tthis.envMap = source.envMap;\n\tthis.combine = source.combine;\n\tthis.reflectivity = source.reflectivity;\n\tthis.refractionRatio = source.refractionRatio;\n\n\tthis.wireframe = source.wireframe;\n\tthis.wireframeLinewidth = source.wireframeLinewidth;\n\tthis.wireframeLinecap = source.wireframeLinecap;\n\tthis.wireframeLinejoin = source.wireframeLinejoin;\n\n\tthis.skinning = source.skinning;\n\tthis.morphTargets = source.morphTargets;\n\tthis.morphNormals = source.morphNormals;\n\n\treturn this;\n\n};\n\n\nexport { MeshLambertMaterial };\n","var baseMerge = require('./_baseMerge'),\n    createAssigner = require('./_createAssigner');\n\n/**\n * This method is like `_.assign` except that it recursively merges own and\n * inherited enumerable string keyed properties of source objects into the\n * destination object. Source properties that resolve to `undefined` are\n * skipped if a destination value exists. Array and plain object properties\n * are merged recursively. Other objects and value types are overridden by\n * assignment. Source objects are applied from left to right. Subsequent\n * sources overwrite property assignments of previous sources.\n *\n * **Note:** This method mutates `object`.\n *\n * @static\n * @memberOf _\n * @since 0.5.0\n * @category Object\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @example\n *\n * var object = {\n *   'a': [{ 'b': 2 }, { 'd': 4 }]\n * };\n *\n * var other = {\n *   'a': [{ 'c': 3 }, { 'e': 5 }]\n * };\n *\n * _.merge(object, other);\n * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }\n */\nvar merge = createAssigner(function(object, source, srcIndex) {\n  baseMerge(object, source, srcIndex);\n});\n\nmodule.exports = merge;\n","var Stack = require('./_Stack'),\n    assignMergeValue = require('./_assignMergeValue'),\n    baseFor = require('./_baseFor'),\n    baseMergeDeep = require('./_baseMergeDeep'),\n    isObject = require('./isObject'),\n    keysIn = require('./keysIn'),\n    safeGet = require('./_safeGet');\n\n/**\n * The base implementation of `_.merge` without support for multiple sources.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {number} srcIndex The index of `source`.\n * @param {Function} [customizer] The function to customize merged values.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n */\nfunction baseMerge(object, source, srcIndex, customizer, stack) {\n  if (object === source) {\n    return;\n  }\n  baseFor(source, function(srcValue, key) {\n    stack || (stack = new Stack);\n    if (isObject(srcValue)) {\n      baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);\n    }\n    else {\n      var newValue = customizer\n        ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)\n        : undefined;\n\n      if (newValue === undefined) {\n        newValue = srcValue;\n      }\n      assignMergeValue(object, key, newValue);\n    }\n  }, keysIn);\n}\n\nmodule.exports = baseMerge;\n","var assignMergeValue = require('./_assignMergeValue'),\n    cloneBuffer = require('./_cloneBuffer'),\n    cloneTypedArray = require('./_cloneTypedArray'),\n    copyArray = require('./_copyArray'),\n    initCloneObject = require('./_initCloneObject'),\n    isArguments = require('./isArguments'),\n    isArray = require('./isArray'),\n    isArrayLikeObject = require('./isArrayLikeObject'),\n    isBuffer = require('./isBuffer'),\n    isFunction = require('./isFunction'),\n    isObject = require('./isObject'),\n    isPlainObject = require('./isPlainObject'),\n    isTypedArray = require('./isTypedArray'),\n    safeGet = require('./_safeGet'),\n    toPlainObject = require('./toPlainObject');\n\n/**\n * A specialized version of `baseMerge` for arrays and objects which performs\n * deep merges and tracks traversed objects enabling objects with circular\n * references to be merged.\n *\n * @private\n * @param {Object} object The destination object.\n * @param {Object} source The source object.\n * @param {string} key The key of the value to merge.\n * @param {number} srcIndex The index of `source`.\n * @param {Function} mergeFunc The function to merge values.\n * @param {Function} [customizer] The function to customize assigned values.\n * @param {Object} [stack] Tracks traversed source values and their merged\n *  counterparts.\n */\nfunction baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {\n  var objValue = safeGet(object, key),\n      srcValue = safeGet(source, key),\n      stacked = stack.get(srcValue);\n\n  if (stacked) {\n    assignMergeValue(object, key, stacked);\n    return;\n  }\n  var newValue = customizer\n    ? customizer(objValue, srcValue, (key + ''), object, source, stack)\n    : undefined;\n\n  var isCommon = newValue === undefined;\n\n  if (isCommon) {\n    var isArr = isArray(srcValue),\n        isBuff = !isArr && isBuffer(srcValue),\n        isTyped = !isArr && !isBuff && isTypedArray(srcValue);\n\n    newValue = srcValue;\n    if (isArr || isBuff || isTyped) {\n      if (isArray(objValue)) {\n        newValue = objValue;\n      }\n      else if (isArrayLikeObject(objValue)) {\n        newValue = copyArray(objValue);\n      }\n      else if (isBuff) {\n        isCommon = false;\n        newValue = cloneBuffer(srcValue, true);\n      }\n      else if (isTyped) {\n        isCommon = false;\n        newValue = cloneTypedArray(srcValue, true);\n      }\n      else {\n        newValue = [];\n      }\n    }\n    else if (isPlainObject(srcValue) || isArguments(srcValue)) {\n      newValue = objValue;\n      if (isArguments(objValue)) {\n        newValue = toPlainObject(objValue);\n      }\n      else if (!isObject(objValue) || isFunction(objValue)) {\n        newValue = initCloneObject(srcValue);\n      }\n    }\n    else {\n      isCommon = false;\n    }\n  }\n  if (isCommon) {\n    // Recursively merge objects and arrays (susceptible to call stack limits).\n    stack.set(srcValue, newValue);\n    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);\n    stack['delete'](srcValue);\n  }\n  assignMergeValue(object, key, newValue);\n}\n\nmodule.exports = baseMergeDeep;\n","var baseGetTag = require('./_baseGetTag'),\n    getPrototype = require('./_getPrototype'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n    funcToString.call(Ctor) == objectCtorString;\n}\n\nmodule.exports = isPlainObject;\n","var copyObject = require('./_copyObject'),\n    keysIn = require('./keysIn');\n\n/**\n * Converts `value` to a plain object flattening inherited enumerable string\n * keyed properties of `value` to own properties of the plain object.\n *\n * @static\n * @memberOf _\n * @since 3.0.0\n * @category Lang\n * @param {*} value The value to convert.\n * @returns {Object} Returns the converted plain object.\n * @example\n *\n * function Foo() {\n *   this.b = 2;\n * }\n *\n * Foo.prototype.c = 3;\n *\n * _.assign({ 'a': 1 }, new Foo);\n * // => { 'a': 1, 'b': 2 }\n *\n * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));\n * // => { 'a': 1, 'b': 2, 'c': 3 }\n */\nfunction toPlainObject(value) {\n  return copyObject(value, keysIn(value));\n}\n\nmodule.exports = toPlainObject;\n","var baseRest = require('./_baseRest'),\n    isIterateeCall = require('./_isIterateeCall');\n\n/**\n * Creates a function like `_.assign`.\n *\n * @private\n * @param {Function} assigner The function to assign values.\n * @returns {Function} Returns the new assigner function.\n */\nfunction createAssigner(assigner) {\n  return baseRest(function(object, sources) {\n    var index = -1,\n        length = sources.length,\n        customizer = length > 1 ? sources[length - 1] : undefined,\n        guard = length > 2 ? sources[2] : undefined;\n\n    customizer = (assigner.length > 3 && typeof customizer == 'function')\n      ? (length--, customizer)\n      : undefined;\n\n    if (guard && isIterateeCall(sources[0], sources[1], guard)) {\n      customizer = length < 3 ? undefined : customizer;\n      length = 1;\n    }\n    object = Object(object);\n    while (++index < length) {\n      var source = sources[index];\n      if (source) {\n        assigner(object, source, index, customizer);\n      }\n    }\n    return object;\n  });\n}\n\nmodule.exports = createAssigner;\n","var SetCache = require('./_SetCache'),\n    arrayIncludes = require('./_arrayIncludes'),\n    arrayIncludesWith = require('./_arrayIncludesWith'),\n    arrayMap = require('./_arrayMap'),\n    baseUnary = require('./_baseUnary'),\n    cacheHas = require('./_cacheHas');\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMin = Math.min;\n\n/**\n * The base implementation of methods like `_.intersection`, without support\n * for iteratee shorthands, that accepts an array of arrays to inspect.\n *\n * @private\n * @param {Array} arrays The arrays to inspect.\n * @param {Function} [iteratee] The iteratee invoked per element.\n * @param {Function} [comparator] The comparator invoked per element.\n * @returns {Array} Returns the new array of shared values.\n */\nfunction baseIntersection(arrays, iteratee, comparator) {\n  var includes = comparator ? arrayIncludesWith : arrayIncludes,\n      length = arrays[0].length,\n      othLength = arrays.length,\n      othIndex = othLength,\n      caches = Array(othLength),\n      maxLength = Infinity,\n      result = [];\n\n  while (othIndex--) {\n    var array = arrays[othIndex];\n    if (othIndex && iteratee) {\n      array = arrayMap(array, baseUnary(iteratee));\n    }\n    maxLength = nativeMin(array.length, maxLength);\n    caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))\n      ? new SetCache(othIndex && array)\n      : undefined;\n  }\n  array = arrays[0];\n\n  var index = -1,\n      seen = caches[0];\n\n  outer:\n  while (++index < length && result.length < maxLength) {\n    var value = array[index],\n        computed = iteratee ? iteratee(value) : value;\n\n    value = (comparator || value !== 0) ? value : 0;\n    if (!(seen\n          ? cacheHas(seen, computed)\n          : includes(result, computed, comparator)\n        )) {\n      othIndex = othLength;\n      while (--othIndex) {\n        var cache = caches[othIndex];\n        if (!(cache\n              ? cacheHas(cache, computed)\n              : includes(arrays[othIndex], computed, comparator))\n            ) {\n          continue outer;\n        }\n      }\n      if (seen) {\n        seen.push(computed);\n      }\n      result.push(value);\n    }\n  }\n  return result;\n}\n\nmodule.exports = baseIntersection;\n","var isArrayLikeObject = require('./isArrayLikeObject');\n\n/**\n * Casts `value` to an empty array if it's not an array like object.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Array|Object} Returns the cast array-like object.\n */\nfunction castArrayLikeObject(value) {\n  return isArrayLikeObject(value) ? value : [];\n}\n\nmodule.exports = castArrayLikeObject;\n","export default \"uniform float mNear;\\nuniform float mFar;\\n\\nvarying float vViewZDepth;\\n\\nvoid main() {\\n\\n\\tfloat color = 1.0 - smoothstep( mNear, mFar, vViewZDepth );\\n\\tgl_FragColor = vec4( vec3( color ), 1.0 );\\n\\n}\\n\"","import {UniformsUtils} from 'three/src/renderers/shaders/UniformsUtils';\nimport {ShaderMaterial} from 'three/src/materials/ShaderMaterial';\nimport {ShaderLib} from 'three/src/renderers/shaders/ShaderLib';\nimport {RGBADepthPacking} from 'three/src/constants';\nimport {BasicDepthPacking} from 'three/src/constants';\n\nimport {ShaderAssemblerMaterial} from './_BaseMaterial';\n\nimport TemplateVertex from '../../templates/CustomPointsDepth.vert.glsl';\nimport {ShaderName} from '../../../../utils/shaders/ShaderName';\n\nconst INSERT_DEFINE_AFTER_MAP: Map<ShaderName, string> = new Map([[ShaderName.VERTEX, '// INSERT DEFINES']]);\nconst INSERT_BODY_AFTER_MAP: Map<ShaderName, string> = new Map([[ShaderName.VERTEX, '// INSERT BODY']]);\n\nexport class ShaderAssemblerCustomPointsDepth extends ShaderAssemblerMaterial {\n\t// _color_declaration() { return 'vec4 diffuseColor' }\n\t// _template_shader(){ return ShaderLib.standard }\n\tget _template_shader() {\n\t\tconst template = ShaderLib.depth;\n\n\t\tconst uniforms = UniformsUtils.clone(template.uniforms);\n\t\tuniforms['size'] = {value: 1};\n\t\tuniforms['scale'] = {value: 1};\n\n\t\treturn {\n\t\t\tvertexShader: TemplateVertex,\n\t\t\tfragmentShader: template.fragmentShader, //TemplateFragment,\n\t\t\tuniforms: uniforms,\n\t\t};\n\t}\n\tprotected insert_define_after(shader_name: ShaderName) {\n\t\treturn INSERT_DEFINE_AFTER_MAP.get(shader_name);\n\t}\n\tprotected insert_body_after(shader_name: ShaderName) {\n\t\treturn INSERT_BODY_AFTER_MAP.get(shader_name);\n\t}\n\n\tcreate_material() {\n\t\tconst template_shader = this._template_shader;\n\t\treturn new ShaderMaterial({\n\t\t\t// vertexColors: VertexColors,\n\t\t\t// side: FrontSide,\n\t\t\t// transparent: true,\n\t\t\t// fog: true,\n\t\t\t// lights: true,\n\t\t\tdefines: {\n\t\t\t\tUSE_SIZEATTENUATION: 1,\n\t\t\t\tDEPTH_PACKING: [RGBADepthPacking, BasicDepthPacking][0],\n\t\t\t},\n\n\t\t\tuniforms: UniformsUtils.clone(template_shader.uniforms),\n\t\t\tvertexShader: template_shader.vertexShader,\n\t\t\tfragmentShader: template_shader.fragmentShader,\n\t\t});\n\t}\n}\n","export default \"uniform float size;\\nuniform float scale;\\n#include <common>\\n#include <clipping_planes_pars_vertex>\\nvarying float vViewZDepth;\\n\\n// INSERT DEFINES\\n\\n\\n\\nvoid main() {\\n\\n\\t// INSERT BODY\\n\\n\\n\\t#include <project_vertex>\\n\\t#include <logdepthbuf_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\n\\tvViewZDepth = - mvPosition.z;\\n\\t#ifdef USE_SIZEATTENUATION\\n\\t\\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\\n\\t\\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\\n\\t#endif\\n\\n}\\n\\n\\n\"","import {UniformsUtils} from 'three/src/renderers/shaders/UniformsUtils';\nimport {ShaderMaterial} from 'three/src/materials/ShaderMaterial';\nimport {ShaderLib} from 'three/src/renderers/shaders/ShaderLib';\nimport {RGBADepthPacking} from 'three/src/constants';\nimport {BasicDepthPacking} from 'three/src/constants';\n\nimport {ShaderAssemblerMaterial} from './_BaseMaterial';\n\nimport TemplateVertex from '../../templates/CustomPointsDistance.vert.glsl';\n\nimport {ShaderName} from '../../../../utils/shaders/ShaderName';\n\nconst INSERT_DEFINE_AFTER_MAP: Map<ShaderName, string> = new Map([[ShaderName.VERTEX, '// INSERT DEFINES']]);\nconst INSERT_BODY_AFTER_MAP: Map<ShaderName, string> = new Map([[ShaderName.VERTEX, '// INSERT BODY']]);\n\nexport class ShaderAssemblerCustomPointsDistance extends ShaderAssemblerMaterial {\n\t// _color_declaration() { return 'vec4 diffuseColor' }\n\t// _template_shader(){ return ShaderLib.standard }\n\tget _template_shader() {\n\t\tconst template = ShaderLib.distanceRGBA;\n\n\t\tconst uniforms = UniformsUtils.clone(template.uniforms);\n\t\tuniforms['size'] = {value: 1};\n\t\tuniforms['scale'] = {value: 1};\n\n\t\treturn {\n\t\t\tvertexShader: TemplateVertex,\n\t\t\tfragmentShader: template.fragmentShader, //TemplateFragment,\n\t\t\tuniforms: uniforms,\n\t\t};\n\t}\n\tprotected insert_define_after(shader_name: ShaderName) {\n\t\treturn INSERT_DEFINE_AFTER_MAP.get(shader_name);\n\t}\n\tprotected insert_body_after(shader_name: ShaderName) {\n\t\treturn INSERT_BODY_AFTER_MAP.get(shader_name);\n\t}\n\n\tcreate_material() {\n\t\tconst template_shader = this._template_shader;\n\t\treturn new ShaderMaterial({\n\t\t\t// vertexColors: VertexColors,\n\t\t\t// side: FrontSide,\n\t\t\t// transparent: true,\n\t\t\t// fog: true,\n\t\t\t// lights: true,\n\t\t\tdefines: {\n\t\t\t\tUSE_SIZEATTENUATION: 1,\n\t\t\t\tDEPTH_PACKING: [RGBADepthPacking, BasicDepthPacking][0],\n\t\t\t},\n\n\t\t\tuniforms: UniformsUtils.clone(template_shader.uniforms),\n\t\t\tvertexShader: template_shader.vertexShader,\n\t\t\tfragmentShader: template_shader.fragmentShader,\n\t\t});\n\t}\n}\n","export default \"uniform float size;\\nuniform float scale;\\n#define DISTANCE\\nvarying vec3 vWorldPosition;\\n#include <common>\\n#include <clipping_planes_pars_vertex>\\nvarying float vViewZDepth;\\n\\n// INSERT DEFINES\\n\\n\\n\\nvoid main() {\\n\\n\\t// INSERT BODY\\n\\n\\n\\t#include <project_vertex>\\n\\t#include <worldpos_vertex>\\n\\t#include <clipping_planes_vertex>\\n\\n\\t#ifdef USE_SIZEATTENUATION\\n\\t\\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\\n\\t\\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\\n\\t#endif\\n\\tvWorldPosition = worldPosition.xyz;\\n}\\n\\n// #define DISTANCE\\n// varying vec3 vWorldPosition;\\n// #include <common>\\n// #include <uv_pars_vertex>\\n// #include <displacementmap_pars_vertex>\\n// #include <morphtarget_pars_vertex>\\n// #include <skinning_pars_vertex>\\n// #include <clipping_planes_pars_vertex>\\n// void main() {\\n// \\t#include <uv_vertex>\\n// \\t#include <skinbase_vertex>\\n// \\t#ifdef USE_DISPLACEMENTMAP\\n// \\t\\t#include <beginnormal_vertex>\\n// \\t\\t#include <morphnormal_vertex>\\n// \\t\\t#include <skinnormal_vertex>\\n// \\t#endif\\n// \\t#include <begin_vertex>\\n// \\t#include <morphtarget_vertex>\\n// \\t#include <skinning_vertex>\\n// \\t#include <displacementmap_vertex>\\n// \\t#include <project_vertex>\\n// \\t#include <worldpos_vertex>\\n// \\t#include <clipping_planes_vertex>\\n// \\tvWorldPosition = worldPosition.xyz;\\n// }\\n\\n\\n\"","export default \"uniform float size;\\nuniform float scale;\\n#include <common>\\n\\nvarying float vViewZDepth;\\n\\n// INSERT DEFINES\\n\\n\\n\\nvoid main() {\\n\\n\\t// INSERT BODY\\n\\n\\n\\t#include <project_vertex>\\n\\n\\tvViewZDepth = - mvPosition.z;\\n\\t#ifdef USE_SIZEATTENUATION\\n\\t\\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\\n\\t\\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\\n\\t#endif\\n\\n}\\n\\n\"","import {UniformsUtils} from 'three/src/renderers/shaders/UniformsUtils';\nimport {ShaderMaterial} from 'three/src/materials/ShaderMaterial';\n// import {ShaderLib} from 'three/src/renderers/shaders/ShaderLib'\n// import {RGBADepthPacking} from 'three/src/constants'\n// import {BasicDepthPacking} from 'three/src/constants'\n\nimport {ShaderAssemblerMaterial} from './_BaseMaterial';\n\nimport TemplateVertex from '../../templates/CustomPointsDepthDOF.vert.glsl';\nimport TemplateFragment from '../../templates/CustomMeshDepthDOF.frag.glsl';\nimport {ShaderName} from '../../../../utils/shaders/ShaderName';\n\nconst INSERT_DEFINE_AFTER_MAP: Map<ShaderName, string> = new Map([[ShaderName.VERTEX, '// INSERT DEFINES']]);\nconst INSERT_BODY_AFTER_MAP: Map<ShaderName, string> = new Map([[ShaderName.VERTEX, '// INSERT BODY']]);\n\nexport class ShaderAssemblerCustomPointsDepthDOF extends ShaderAssemblerMaterial {\n\t// _color_declaration() { return 'vec4 diffuseColor' }\n\t// _template_shader(){ return ShaderLib.standard }\n\tget _template_shader() {\n\t\treturn {\n\t\t\tvertexShader: TemplateVertex,\n\t\t\tfragmentShader: TemplateFragment,\n\t\t\tuniforms: {\n\t\t\t\tsize: {value: 1},\n\t\t\t\tscale: {value: 1},\n\t\t\t\tmNear: {value: 0},\n\t\t\t\tmFar: {value: 10},\n\t\t\t},\n\t\t};\n\t}\n\tprotected insert_define_after(shader_name: ShaderName) {\n\t\treturn INSERT_DEFINE_AFTER_MAP.get(shader_name);\n\t}\n\tprotected insert_body_after(shader_name: ShaderName) {\n\t\treturn INSERT_BODY_AFTER_MAP.get(shader_name);\n\t}\n\n\tcreate_material() {\n\t\tconst template_shader = this._template_shader;\n\t\treturn new ShaderMaterial({\n\t\t\t// defines: {\n\t\t\t// \tDEPTH_PACKING: [RGBADepthPacking, BasicDepthPacking][0]\n\t\t\t// },\n\t\t\tdepthTest: true,\n\t\t\tdefines: {\n\t\t\t\tUSE_SIZEATTENUATION: 1,\n\t\t\t},\n\n\t\t\tuniforms: UniformsUtils.clone(template_shader.uniforms),\n\t\t\tvertexShader: template_shader.vertexShader,\n\t\t\tfragmentShader: template_shader.fragmentShader,\n\t\t});\n\t}\n}\n","import {UniformsUtils} from 'three/src/renderers/shaders/UniformsUtils';\nimport {ShaderMaterial} from 'three/src/materials/ShaderMaterial';\nimport {ShaderLib} from 'three/src/renderers/shaders/ShaderLib';\n\nimport {ShaderAssemblerMaterial, CustomAssemblerMap, CustomMaterialName} from './_BaseMaterial';\n\nimport {ShaderConfig} from '../../configs/ShaderConfig';\nimport {VariableConfig} from '../../configs/VariableConfig';\n\nimport {BaseGlShaderAssembler} from '../_Base';\nimport {ShaderAssemblerCustomPointsDepth} from './CustomPointsDepth';\nimport {ShaderAssemblerCustomPointsDistance} from './CustomPointsDistance';\nimport {ShaderAssemblerCustomPointsDepthDOF} from './CustomPointsDepthDOF';\nimport {OutputGlNode} from '../../../Output';\nimport {ParamType} from '../../../../../poly/ParamType';\nimport {TypedNamedConnectionPoint} from '../../../../utils/connections/NamedConnectionPoint';\nimport {ConnectionPointType} from '../../../../utils/connections/ConnectionPointType';\nimport {ShaderName} from '../../../../utils/shaders/ShaderName';\n\nconst LINES_TO_REMOVE_MAP: Map<ShaderName, string[]> = new Map([\n\t[ShaderName.VERTEX, ['#include <begin_vertex>', 'gl_PointSize = size;']],\n\t[ShaderName.FRAGMENT, []],\n]);\n\nconst CUSTOM_ASSEMBLER_MAP: CustomAssemblerMap = new Map();\nCUSTOM_ASSEMBLER_MAP.set(CustomMaterialName.DISTANCE, ShaderAssemblerCustomPointsDistance);\nCUSTOM_ASSEMBLER_MAP.set(CustomMaterialName.DEPTH, ShaderAssemblerCustomPointsDepth);\nCUSTOM_ASSEMBLER_MAP.set(CustomMaterialName.DEPTH_DOF, ShaderAssemblerCustomPointsDepthDOF);\n\nexport class ShaderAssemblerPoints extends ShaderAssemblerMaterial {\n\t// _color_declaration() { return 'diffuseColor' }\n\tcustom_assembler_class_by_custom_name(): CustomAssemblerMap {\n\t\treturn CUSTOM_ASSEMBLER_MAP;\n\t}\n\n\tget _template_shader() {\n\t\tconst template = ShaderLib.points;\n\t\treturn {\n\t\t\tvertexShader: template.vertexShader, //TemplateVertex,\n\t\t\tfragmentShader: template.fragmentShader, //TemplateFragment,\n\t\t\tuniforms: template.uniforms,\n\t\t};\n\t}\n\tcreate_material() {\n\t\tconst template_shader = this._template_shader;\n\n\t\t// const uniforms = UniformsUtils.clone( template_shader.uniforms )\n\t\t// uniforms.size.value = 10\n\n\t\tconst material = new ShaderMaterial({\n\t\t\ttransparent: true,\n\t\t\tfog: true,\n\n\t\t\t// size: 10,\n\t\t\t// //blending: AdditiveBlending\n\t\t\t// depthTest: true,\n\t\t\t// depthwrite: true,\n\t\t\t// alphaTest: 0.5,\n\t\t\tdefines: {\n\t\t\t\t// ALPHATEST: 0.5,\n\t\t\t\tUSE_SIZEATTENUATION: 1,\n\t\t\t},\n\n\t\t\tuniforms: UniformsUtils.clone(template_shader.uniforms),\n\t\t\tvertexShader: template_shader.vertexShader,\n\t\t\tfragmentShader: template_shader.fragmentShader,\n\t\t});\n\t\tthis._add_custom_materials(material);\n\t\treturn material;\n\t}\n\t// protected insert_body_after(shader_name){\n\t// \treturn {\n\t// \t\tvertex: 'gl_PointSize = size;',\n\t// \t\tfragment: 'vec4 diffuseColor = vec4( diffuse, opacity );'\n\t// \t}[shader_name]\n\t// }\n\t// those shadow shaders should ideally be overriden\n\t// to properly take into account point size\n\n\tadd_output_params(output_child: OutputGlNode) {\n\t\tBaseGlShaderAssembler.add_output_params(output_child);\n\t\toutput_child.add_param(ParamType.FLOAT, 'gl_PointSize', 1);\n\t}\n\tcreate_globals_node_output_connections() {\n\t\treturn BaseGlShaderAssembler.create_globals_node_output_connections().concat([\n\t\t\tnew TypedNamedConnectionPoint('gl_PointCoord', ConnectionPointType.VEC2),\n\t\t]);\n\t}\n\n\t// add_globals_params(globals_node){\n\t// \tBaseShaderAssembler.add_globals_params(globals_node)\n\t// \tglobals_node.set_named_outputs([\n\t// \t\tnew Connection.Vec3('position'),\n\t// \t\tnew Connection.Vec3('color'),\n\t// \t\tnew Connection.Vec3('normal'),\n\t// \t\tnew Connection.Vec4('gl_FragCoord'),\n\t// \t\tnew Connection.Vec2('gl_PointCoord'),\n\t// \t\t// new TypedConnectionVec2('uv'),\n\t// \t\tnew Connection.Float('frame')\n\t// \t])\n\t// }\n\tcreate_shader_configs() {\n\t\treturn [\n\t\t\tnew ShaderConfig(ShaderName.VERTEX, ['position', 'normal', 'uv', 'gl_PointSize'], []),\n\t\t\tnew ShaderConfig(ShaderName.FRAGMENT, ['color', 'alpha'], [ShaderName.VERTEX]),\n\t\t];\n\t}\n\tcreate_variable_configs() {\n\t\treturn BaseGlShaderAssembler.create_variable_configs().concat([\n\t\t\tnew VariableConfig('gl_PointSize', {\n\t\t\t\tdefault: '1.0',\n\t\t\t\tprefix: 'gl_PointSize = ',\n\t\t\t\tsuffix: ' * size * 10.0', // currently using 10 as 1 seems really small\n\t\t\t}),\n\t\t]);\n\t\t// \tnew VariableConfig('position', {\n\t\t// \t\tdefault_from_attribute: true,\n\t\t// \t\t// default: this.globals_handler().variable_config_default('position'),\n\t\t// \t\t// required_definitions: this.globals_handler().variable_config_required_definitions('position'),\n\t\t// \t\tprefix: 'vec3 transformed = '\n\t\t// \t}),\n\t\t// \tnew VariableConfig('normal', {\n\t\t// \t\tprefix: 'objectNormal = '\n\t\t// \t}),\n\t\t// \tnew VariableConfig('color', {\n\t\t// \t\tprefix: 'diffuseColor.xyz = '\n\t\t// \t}),\n\t\t// \tnew VariableConfig('alpha', {\n\t\t// \t\tprefix: 'diffuseColor.w = '\n\t\t// \t}),\n\t\t// \tnew VariableConfig('uv', {\n\t\t// \t\tdefault_from_attribute: true,\n\t\t// \t\tprefix: 'vUv = ',\n\t\t// \t\tif: 'defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )'\n\t\t// \t}),\n\t\t// \tnew VariableConfig('gl_PointSize', {\n\t\t// \t\tdefault: '1.0',\n\t\t// \t\tprefix: 'gl_PointSize = ',\n\t\t// \t\tsuffix: ' * size',\n\t\t// \t}),\n\t\t// ]\n\t}\n\tprotected lines_to_remove(shader_name: ShaderName) {\n\t\treturn LINES_TO_REMOVE_MAP.get(shader_name);\n\t}\n}\n","import {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {ColorParamConfig, ColorsController} from './utils/UniformsColorsController';\nimport {SideParamConfig, SideController} from './utils/SideController';\nimport {SkinningParamConfig, SkinningController} from './utils/SkinningController';\nimport {TextureMapParamConfig} from './utils/TextureMapController';\nimport {TextureAlphaMapParamConfig} from './utils/TextureAlphaMapController';\nimport {ShaderAssemblerPoints} from '../gl/code/assemblers/materials/Points';\nimport {TypedBuilderMatNode} from './_BaseBuilder';\nimport {GlAssemblerController} from '../gl/code/Controller';\nclass PointsMatParamsConfig extends TextureAlphaMapParamConfig(\n\tTextureMapParamConfig(SkinningParamConfig(SideParamConfig(ColorParamConfig(NodeParamsConfig))))\n) {}\nconst ParamsConfig = new PointsMatParamsConfig();\n\nexport class PointsBuilderMatNode extends TypedBuilderMatNode<ShaderAssemblerPoints, PointsMatParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'points_builder';\n\t}\n\n\tinitialize_node() {}\n\n\tprotected _create_assembler_controller() {\n\t\treturn new GlAssemblerController<ShaderAssemblerPoints>(this, ShaderAssemblerPoints);\n\t}\n\n\tasync cook() {\n\t\tawait this.compile_if_required();\n\n\t\tColorsController.update(this);\n\t\tSideController.update(this);\n\t\tSkinningController.update(this);\n\n\t\tthis.set_material(this.material);\n\t}\n}\n","import {BaseController} from './_BaseController';\nimport {TypedMatNode} from '../_Base';\nimport {Material} from 'three/src/materials/Material';\nimport {Color} from 'three/src/math/Color';\n\nimport {NodeParamsConfig, ParamConfig} from '../../utils/params/ParamsConfig';\n\nexport function ColorParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\tcolor = ParamConfig.COLOR([1, 1, 1]);\n\t\tuse_vertex_colors = ParamConfig.BOOLEAN(0);\n\t\ttransparent = ParamConfig.BOOLEAN(0);\n\t\topacity = ParamConfig.FLOAT(1);\n\t\talpha_test = ParamConfig.FLOAT(0);\n\t\tuse_fog = ParamConfig.BOOLEAN(0);\n\t};\n}\n\nclass ColoredMaterial extends Material {\n\tpublic color!: Color;\n\tvertexColors!: boolean;\n\ttransparent!: boolean;\n\tdepthTest!: boolean;\n\talphaTest!: number;\n\tfog!: boolean;\n}\nclass ColorParamsConfig extends ColorParamConfig(NodeParamsConfig) {}\nclass ColoredMatNode extends TypedMatNode<ColoredMaterial, ColorParamsConfig> {\n\tcreate_material() {\n\t\treturn new ColoredMaterial();\n\t}\n}\n\nexport class ColorsController extends BaseController {\n\tstatic update(node: ColoredMatNode) {\n\t\tconst material = node.material;\n\t\tconst pv = node.pv;\n\t\tmaterial.color.copy(pv.color);\n\t\tconst new_vertex_color = pv.use_vertex_colors; // ? VertexColors : NoColors;\n\t\tif (new_vertex_color != material.vertexColors) {\n\t\t\tmaterial.vertexColors = new_vertex_color;\n\t\t\tmaterial.needsUpdate = true;\n\t\t}\n\n\t\tmaterial.opacity = pv.opacity;\n\t\tmaterial.transparent = pv.transparent || pv.opacity < 1;\n\t\tmaterial.depthTest = true;\n\t\tmaterial.alphaTest = pv.alpha_test;\n\t\tmaterial.fog = pv.use_fog;\n\t}\n}\n","import {MeshBasicMaterial} from 'three/src/materials/MeshBasicMaterial';\nimport {FrontSide} from 'three/src/constants';\nimport {TypedMatNode} from './_Base';\n\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {ColorsController, ColorParamConfig} from './utils/ColorsController';\nimport {SideController, SideParamConfig} from './utils/SideController';\nimport {SkinningController, SkinningParamConfig} from './utils/SkinningController';\nimport {TextureMapController, TextureMapParamConfig} from './utils/TextureMapController';\nimport {TextureAlphaMapController, TextureAlphaMapParamConfig} from './utils/TextureAlphaMapController';\nclass MeshBasicMatParamsConfig extends TextureAlphaMapParamConfig(\n\tTextureMapParamConfig(SkinningParamConfig(SideParamConfig(ColorParamConfig(NodeParamsConfig))))\n) {}\nconst ParamsConfig = new MeshBasicMatParamsConfig();\n\nexport class MeshBasicMatNode extends TypedMatNode<MeshBasicMaterial, MeshBasicMatParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'mesh_basic';\n\t}\n\n\tcreate_material() {\n\t\treturn new MeshBasicMaterial({\n\t\t\tvertexColors: false,\n\t\t\tside: FrontSide,\n\t\t\tcolor: 0xffffff,\n\t\t\topacity: 1,\n\t\t});\n\t}\n\treadonly texture_map_controller: TextureMapController = new TextureMapController(this, {direct_params: true});\n\treadonly texture_alpha_map_controller: TextureAlphaMapController = new TextureAlphaMapController(this, {\n\t\tdirect_params: true,\n\t});\n\tinitialize_node() {\n\t\tthis.params.set_post_create_params_hook(() => {\n\t\t\tthis.texture_map_controller.initialize_node();\n\t\t\tthis.texture_alpha_map_controller.initialize_node();\n\t\t});\n\t}\n\tasync cook() {\n\t\tColorsController.update(this);\n\t\tSideController.update(this);\n\t\tSkinningController.update(this);\n\t\tthis.texture_map_controller.update();\n\t\tthis.texture_alpha_map_controller.update();\n\n\t\tthis.set_material(this.material);\n\t}\n}\n","import {UniformsUtils} from 'three/src/renderers/shaders/UniformsUtils';\nimport {ShaderMaterial} from 'three/src/materials/ShaderMaterial';\nimport {ShaderLib} from 'three/src/renderers/shaders/ShaderLib';\nimport {RGBADepthPacking} from 'three/src/constants';\nimport {BasicDepthPacking} from 'three/src/constants';\n\nimport {ShaderAssemblerMaterial} from './_BaseMaterial';\nimport {ShaderName} from '../../../../utils/shaders/ShaderName';\n\nconst INSERT_BODY_AFTER_MAP: Map<ShaderName, string> = new Map([\n\t[ShaderName.VERTEX, '#include <begin_vertex>'],\n\t[ShaderName.FRAGMENT, 'vec4 diffuseColor = vec4( 1.0 );'],\n]);\n\nexport class ShaderAssemblerCustomMeshDistance extends ShaderAssemblerMaterial {\n\t// _color_declaration() { return 'vec4 diffuseColor' }\n\t// _template_shader(){ return ShaderLib.standard }\n\tget _template_shader() {\n\t\tconst template = ShaderLib.distanceRGBA;\n\t\treturn {\n\t\t\tvertexShader: template.vertexShader, //TemplateVertex,\n\t\t\tfragmentShader: template.fragmentShader, //TemplateFragment,\n\t\t\tuniforms: template.uniforms,\n\t\t};\n\t}\n\tprotected insert_body_after(shader_name: ShaderName) {\n\t\treturn INSERT_BODY_AFTER_MAP.get(shader_name);\n\t}\n\n\tcreate_material() {\n\t\tconst template_shader = this._template_shader;\n\t\treturn new ShaderMaterial({\n\t\t\t// vertexColors: VertexColors,\n\t\t\t// side: FrontSide,\n\t\t\t// transparent: true,\n\t\t\t// fog: true,\n\t\t\t// lights: true,\n\t\t\tdefines: {\n\t\t\t\tDEPTH_PACKING: [RGBADepthPacking, BasicDepthPacking][0],\n\t\t\t},\n\n\t\t\tuniforms: UniformsUtils.clone(template_shader.uniforms),\n\t\t\tvertexShader: template_shader.vertexShader,\n\t\t\tfragmentShader: template_shader.fragmentShader,\n\t\t});\n\t}\n}\n","import {UniformsUtils} from 'three/src/renderers/shaders/UniformsUtils';\nimport {ShaderMaterial} from 'three/src/materials/ShaderMaterial';\nimport {ShaderLib} from 'three/src/renderers/shaders/ShaderLib';\nimport {RGBADepthPacking} from 'three/src/constants';\nimport {BasicDepthPacking} from 'three/src/constants';\n\nimport {ShaderAssemblerMaterial} from './_BaseMaterial';\nimport {ShaderName} from '../../../../utils/shaders/ShaderName';\n\nconst INSERT_BODY_AFTER_MAP: Map<ShaderName, string> = new Map([\n\t[ShaderName.VERTEX, '#include <begin_vertex>'],\n\t[ShaderName.FRAGMENT, 'vec4 diffuseColor = vec4( 1.0 );'],\n]);\n\nexport class ShaderAssemblerCustomMeshDepth extends ShaderAssemblerMaterial {\n\t// _color_declaration() { return 'vec4 diffuseColor' }\n\t// _template_shader(){ return ShaderLib.standard }\n\tget _template_shader() {\n\t\tconst template = ShaderLib.depth;\n\t\treturn {\n\t\t\tvertexShader: template.vertexShader, //TemplateVertex,\n\t\t\tfragmentShader: template.fragmentShader, //TemplateFragment,\n\t\t\tuniforms: template.uniforms,\n\t\t};\n\t}\n\tprotected insert_body_after(shader_name: ShaderName) {\n\t\treturn INSERT_BODY_AFTER_MAP.get(shader_name);\n\t}\n\n\tcreate_material() {\n\t\tconst template_shader = this._template_shader;\n\t\treturn new ShaderMaterial({\n\t\t\t// vertexColors: VertexColors,\n\t\t\t// side: FrontSide,\n\t\t\t// transparent: true,\n\t\t\t// fog: true,\n\t\t\t// lights: true,\n\t\t\tdefines: {\n\t\t\t\tDEPTH_PACKING: [RGBADepthPacking, BasicDepthPacking][0],\n\t\t\t},\n\n\t\t\tuniforms: UniformsUtils.clone(template_shader.uniforms),\n\t\t\tvertexShader: template_shader.vertexShader,\n\t\t\tfragmentShader: template_shader.fragmentShader,\n\t\t});\n\t}\n}\n","export default \"#include <common>\\n\\nvarying float vViewZDepth;\\n\\n// INSERT DEFINES\\n\\n\\n\\nvoid main() {\\n\\n\\t// INSERT BODY\\n\\n\\n\\t#include <project_vertex>\\n\\n\\tvViewZDepth = - mvPosition.z;\\n}\"","import {UniformsUtils} from 'three/src/renderers/shaders/UniformsUtils';\nimport {ShaderMaterial} from 'three/src/materials/ShaderMaterial';\n// import {ShaderLib} from 'three/src/renderers/shaders/ShaderLib';\n// import {RGBADepthPacking} from 'three/src/constants';\n// import {BasicDepthPacking} from 'three/src/constants';\n\nimport {ShaderAssemblerMaterial} from './_BaseMaterial';\n\nimport TemplateVertex from '../../templates/CustomMeshDepthDOF.vert.glsl';\nimport TemplateFragment from '../../templates/CustomMeshDepthDOF.frag.glsl';\nimport {ShaderName} from '../../../../utils/shaders/ShaderName';\n\nconst INSERT_DEFINE_AFTER_MAP: Map<ShaderName, string> = new Map([[ShaderName.VERTEX, '// INSERT DEFINES']]);\nconst INSERT_BODY_AFTER_MAP: Map<ShaderName, string> = new Map([[ShaderName.VERTEX, '// INSERT BODY']]);\n// fragment: 'vec4 diffuseColor = vec4( 1.0 );' // do not change? unless there is a texture lookup\n\nexport class ShaderAssemblerCustomMeshDepthDOF extends ShaderAssemblerMaterial {\n\t// _color_declaration() { return 'vec4 diffuseColor' }\n\t// _template_shader(){ return ShaderLib.standard }\n\tget _template_shader() {\n\t\treturn {\n\t\t\tvertexShader: TemplateVertex,\n\t\t\tfragmentShader: TemplateFragment,\n\t\t\tuniforms: {\n\t\t\t\tmNear: {value: 0},\n\t\t\t\tmFar: {value: 10},\n\t\t\t},\n\t\t};\n\t}\n\tprotected insert_define_after(shader_name: ShaderName) {\n\t\treturn INSERT_DEFINE_AFTER_MAP.get(shader_name);\n\t}\n\tprotected insert_body_after(shader_name: ShaderName) {\n\t\treturn INSERT_BODY_AFTER_MAP.get(shader_name);\n\t}\n\n\tcreate_material() {\n\t\tconst template_shader = this._template_shader;\n\t\treturn new ShaderMaterial({\n\t\t\t// defines: {\n\t\t\t// \tDEPTH_PACKING: [RGBADepthPacking, BasicDepthPacking][0]\n\t\t\t// },\n\n\t\t\tuniforms: UniformsUtils.clone(template_shader.uniforms),\n\t\t\tvertexShader: template_shader.vertexShader,\n\t\t\tfragmentShader: template_shader.fragmentShader,\n\t\t});\n\t}\n}\n","import {ShaderAssemblerMaterial, CustomAssemblerMap, CustomMaterialName} from './_BaseMaterial';\n\nimport {ShaderAssemblerCustomMeshDistance} from './CustomMeshDistance';\nimport {ShaderAssemblerCustomMeshDepth} from './CustomMeshDepth';\nimport {ShaderAssemblerCustomMeshDepthDOF} from './CustomMeshDepthDOF';\n\nconst ASSEMBLER_MAP: CustomAssemblerMap = new Map([\n\t// [CustomMaterialName.DISTANCE, ShaderAssemblerCustomMeshDistance],\n\t// [CustomMaterialName.DEPTH, ShaderAssemblerCustomMeshDepth],\n\t// [CustomMaterialName.DEPTH_DOF, ShaderAssemblerCustomMeshDepthDOF],\n]);\nASSEMBLER_MAP.set(CustomMaterialName.DISTANCE, ShaderAssemblerCustomMeshDistance);\nASSEMBLER_MAP.set(CustomMaterialName.DEPTH, ShaderAssemblerCustomMeshDepth);\nASSEMBLER_MAP.set(CustomMaterialName.DEPTH_DOF, ShaderAssemblerCustomMeshDepthDOF);\n\nexport abstract class ShaderAssemblerMesh extends ShaderAssemblerMaterial {\n\t// TODO: I've noticed a case where instances would not display when those shadow shaders were exported\n\t// But the objects display fine if those are not assigned\n\t// so it could be a bug at render time (not sure if my code, threejs or hardware)\n\tcustom_assembler_class_by_custom_name(): CustomAssemblerMap {\n\t\treturn ASSEMBLER_MAP;\n\t}\n}\n","// import {VertexColors} from 'three/src/constants';\nimport {UniformsUtils} from 'three/src/renderers/shaders/UniformsUtils';\nimport {ShaderMaterial} from 'three/src/materials/ShaderMaterial';\nimport {ShaderLib} from 'three/src/renderers/shaders/ShaderLib';\n// import {FrontSide} from 'three/src/constants';\nimport {ShaderAssemblerMesh} from './_BaseMesh';\n\nexport class ShaderAssemblerBasic extends ShaderAssemblerMesh {\n\tget _template_shader() {\n\t\tconst template = ShaderLib.basic;\n\t\treturn {\n\t\t\tvertexShader: template.vertexShader,\n\t\t\tfragmentShader: template.fragmentShader,\n\t\t\tuniforms: template.uniforms,\n\t\t};\n\t}\n\tcreate_material() {\n\t\tconst template_shader = this._template_shader;\n\n\t\tconst material = new ShaderMaterial({\n\t\t\t// vertexColors: VertexColors,\n\t\t\t// side: FrontSide,\n\t\t\t// transparent: true,\n\t\t\t// fog: true,\n\t\t\tlights: false,\n\t\t\t// depthTest: true,\n\t\t\t// alphaTest: 0.5,\n\n\t\t\tuniforms: UniformsUtils.clone(template_shader.uniforms),\n\t\t\tvertexShader: template_shader.vertexShader,\n\t\t\tfragmentShader: template_shader.fragmentShader,\n\t\t});\n\t\tthis._add_custom_materials(material);\n\t\treturn material;\n\t}\n}\n","import {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {ColorParamConfig, ColorsController} from './utils/UniformsColorsController';\nimport {SideParamConfig, SideController} from './utils/SideController';\nimport {SkinningParamConfig, SkinningController} from './utils/SkinningController';\nimport {TextureMapParamConfig, TextureMapController} from './utils/TextureMapController';\nimport {TextureAlphaMapParamConfig, TextureAlphaMapController} from './utils/TextureAlphaMapController';\nimport {ShaderAssemblerBasic} from '../gl/code/assemblers/materials/Basic';\nimport {TypedBuilderMatNode} from './_BaseBuilder';\nimport {GlAssemblerController} from '../gl/code/Controller';\nclass MeshBasicMatParamsConfig extends TextureAlphaMapParamConfig(\n\tTextureMapParamConfig(SkinningParamConfig(SideParamConfig(ColorParamConfig(NodeParamsConfig))))\n) {}\nconst ParamsConfig = new MeshBasicMatParamsConfig();\n\nexport class MeshBasicBuilderMatNode extends TypedBuilderMatNode<ShaderAssemblerBasic, MeshBasicMatParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'mesh_basic_builder';\n\t}\n\n\treadonly texture_map_controller: TextureMapController = new TextureMapController(this, {uniforms: true});\n\treadonly texture_alpha_map_controller: TextureAlphaMapController = new TextureAlphaMapController(this, {\n\t\tuniforms: true,\n\t});\n\tinitialize_node() {\n\t\tthis.params.set_post_create_params_hook(() => {\n\t\t\tthis.texture_map_controller.initialize_node();\n\t\t\tthis.texture_alpha_map_controller.initialize_node();\n\t\t});\n\t}\n\n\tprotected _create_assembler_controller() {\n\t\treturn new GlAssemblerController<ShaderAssemblerBasic>(this, ShaderAssemblerBasic);\n\t}\n\n\tasync cook() {\n\t\tawait this.compile_if_required();\n\n\t\tColorsController.update(this);\n\t\tSideController.update(this);\n\t\tSkinningController.update(this);\n\t\tawait TextureMapController.update(this);\n\t\tawait TextureAlphaMapController.update(this);\n\n\t\tthis.set_material(this.material);\n\t}\n}\n","import {MeshLambertMaterial} from 'three/src/materials/MeshLambertMaterial';\nimport {FrontSide} from 'three/src/constants';\nimport {TypedMatNode} from './_Base';\n\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {ColorsController, ColorParamConfig} from './utils/ColorsController';\nimport {SideController, SideParamConfig} from './utils/SideController';\nimport {SkinningController, SkinningParamConfig} from './utils/SkinningController';\nimport {TextureMapController, TextureMapParamConfig} from './utils/TextureMapController';\nimport {TextureAlphaMapController, TextureAlphaMapParamConfig} from './utils/TextureAlphaMapController';\nclass MeshLambertMatParamsConfig extends TextureAlphaMapParamConfig(\n\tTextureMapParamConfig(SkinningParamConfig(SideParamConfig(ColorParamConfig(NodeParamsConfig))))\n) {}\nconst ParamsConfig = new MeshLambertMatParamsConfig();\n\nexport class MeshLambertMatNode extends TypedMatNode<MeshLambertMaterial, MeshLambertMatParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'mesh_lambert';\n\t}\n\n\tcreate_material() {\n\t\treturn new MeshLambertMaterial({\n\t\t\tvertexColors: false,\n\t\t\tside: FrontSide,\n\t\t\tcolor: 0xffffff,\n\t\t\topacity: 1,\n\t\t});\n\t}\n\treadonly texture_map_controller: TextureMapController = new TextureMapController(this, {direct_params: true});\n\treadonly texture_alpha_map_controller: TextureAlphaMapController = new TextureAlphaMapController(this, {\n\t\tdirect_params: true,\n\t});\n\tinitialize_node() {\n\t\tthis.params.set_post_create_params_hook(() => {\n\t\t\tthis.texture_map_controller.initialize_node();\n\t\t\tthis.texture_alpha_map_controller.initialize_node();\n\t\t});\n\t}\n\tasync cook() {\n\t\tColorsController.update(this);\n\t\tSideController.update(this);\n\t\tSkinningController.update(this);\n\t\tthis.texture_map_controller.update();\n\t\tthis.texture_alpha_map_controller.update();\n\n\t\tthis.set_material(this.material);\n\t}\n}\n","// import {VertexColors} from 'three/src/constants';\nimport {UniformsUtils} from 'three/src/renderers/shaders/UniformsUtils';\nimport {ShaderMaterial} from 'three/src/materials/ShaderMaterial';\nimport {ShaderLib} from 'three/src/renderers/shaders/ShaderLib';\n// import {FrontSide} from 'three/src/constants';\nimport {ShaderAssemblerMesh} from './_BaseMesh';\n\nexport class ShaderAssemblerLambert extends ShaderAssemblerMesh {\n\tget _template_shader() {\n\t\tconst template = ShaderLib.lambert;\n\t\treturn {\n\t\t\tvertexShader: template.vertexShader,\n\t\t\tfragmentShader: template.fragmentShader,\n\t\t\tuniforms: template.uniforms,\n\t\t};\n\t}\n\tcreate_material() {\n\t\tconst template_shader = this._template_shader;\n\t\tconst material = new ShaderMaterial({\n\t\t\tlights: true,\n\n\t\t\tuniforms: UniformsUtils.clone(template_shader.uniforms),\n\t\t\tvertexShader: template_shader.vertexShader,\n\t\t\tfragmentShader: template_shader.fragmentShader,\n\t\t});\n\t\tthis._add_custom_materials(material);\n\t\treturn material;\n\t}\n}\n","import {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {ColorParamConfig, ColorsController} from './utils/UniformsColorsController';\nimport {SideParamConfig, SideController} from './utils/SideController';\nimport {SkinningParamConfig, SkinningController} from './utils/SkinningController';\nimport {TextureMapParamConfig, TextureMapController} from './utils/TextureMapController';\nimport {TextureAlphaMapParamConfig, TextureAlphaMapController} from './utils/TextureAlphaMapController';\nimport {TypedBuilderMatNode} from './_BaseBuilder';\nimport {GlAssemblerController} from '../gl/code/Controller';\nimport {ShaderAssemblerLambert} from '../gl/code/assemblers/materials/Lambert';\n\nclass MeshLambertMatParamsConfig extends TextureAlphaMapParamConfig(\n\tTextureMapParamConfig(SkinningParamConfig(SideParamConfig(ColorParamConfig(NodeParamsConfig))))\n) {}\nconst ParamsConfig = new MeshLambertMatParamsConfig();\n\nexport class MeshLambertBuilderMatNode extends TypedBuilderMatNode<ShaderAssemblerLambert, MeshLambertMatParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'mesh_lambert_builder';\n\t}\n\n\treadonly texture_map_controller: TextureMapController = new TextureMapController(this, {uniforms: true});\n\treadonly texture_alpha_map_controller: TextureAlphaMapController = new TextureAlphaMapController(this, {\n\t\tuniforms: true,\n\t});\n\tinitialize_node() {\n\t\tthis.params.set_post_create_params_hook(() => {\n\t\t\tthis.texture_map_controller.initialize_node();\n\t\t\tthis.texture_alpha_map_controller.initialize_node();\n\t\t});\n\t}\n\n\tprotected _create_assembler_controller() {\n\t\treturn new GlAssemblerController<ShaderAssemblerLambert>(this, ShaderAssemblerLambert);\n\t}\n\n\tasync cook() {\n\t\tawait this.compile_if_required();\n\n\t\tColorsController.update(this);\n\t\tSideController.update(this);\n\t\tSkinningController.update(this);\n\t\tawait TextureMapController.update(this);\n\t\tawait TextureAlphaMapController.update(this);\n\n\t\tthis.set_material(this.material);\n\t}\n}\n","import {Material} from 'three/src/materials/Material';\nimport {Texture} from 'three/src/textures/Texture';\nimport {FileCopNode} from '../../cop/File';\nimport {TypedMatNode} from '../_Base';\nimport {\n\tBaseTextureMapController,\n\tBooleanParamOptions,\n\tOperatorPathOptions,\n\tUpdateOptions,\n} from './_BaseTextureController';\nimport {ShaderMaterial} from 'three/src/materials/ShaderMaterial';\n\nimport {NodeParamsConfig, ParamConfig} from '../../utils/params/ParamsConfig';\nexport function TextureEnvMapParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\tuse_env_map = ParamConfig.BOOLEAN(0, BooleanParamOptions(TextureEnvMapController));\n\t\tenv_map = ParamConfig.OPERATOR_PATH(\n\t\t\tFileCopNode.DEFAULT_NODE_PATH.ENV_MAP,\n\t\t\tOperatorPathOptions(TextureEnvMapController, 'use_env_map')\n\t\t);\n\t\tenv_map_intensity = ParamConfig.FLOAT(1, {visible_if: {use_env_map: 1}});\n\t};\n}\nclass TextureEnvMaterial extends Material {\n\tenvMap!: Texture | null;\n}\ntype CurrentMaterial = TextureEnvMaterial | ShaderMaterial;\nclass TextureEnvMapParamsConfig extends TextureEnvMapParamConfig(NodeParamsConfig) {}\nabstract class TextureEnvMapMatNode extends TypedMatNode<CurrentMaterial, TextureEnvMapParamsConfig> {\n\ttexture_env_map_controller!: TextureEnvMapController;\n\tabstract create_material(): CurrentMaterial;\n}\n\nexport class TextureEnvMapController extends BaseTextureMapController {\n\tconstructor(node: TextureEnvMapMatNode, _update_options: UpdateOptions) {\n\t\tsuper(node, _update_options);\n\t}\n\tinitialize_node() {\n\t\tthis.add_hooks(this.node.p.use_env_map, this.node.p.env_map);\n\t}\n\tasync update() {\n\t\tthis._update(this.node.material, 'envMap', this.node.p.use_env_map, this.node.p.env_map);\n\t}\n\tstatic async update(node: TextureEnvMapMatNode) {\n\t\tnode.texture_env_map_controller.update();\n\t}\n}\n","import {MeshStandardMaterial} from 'three/src/materials/MeshStandardMaterial';\nimport {FrontSide} from 'three/src/constants';\nimport {TypedMatNode} from './_Base';\n\nimport {ParamConfig, NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {ColorsController, ColorParamConfig} from './utils/ColorsController';\nimport {SideController, SideParamConfig} from './utils/SideController';\nimport {SkinningController, SkinningParamConfig} from './utils/SkinningController';\nimport {TextureMapController, TextureMapParamConfig} from './utils/TextureMapController';\nimport {TextureAlphaMapController, TextureAlphaMapParamConfig} from './utils/TextureAlphaMapController';\nimport {TextureEnvMapController, TextureEnvMapParamConfig} from './utils/TextureEnvMapController';\n\nexport const SHADER_DEFAULTS = {\n\tmetalness: 1,\n\troughness: 0.5,\n};\n\nclass MeshStandardMatParamsConfig extends TextureEnvMapParamConfig(\n\tTextureAlphaMapParamConfig(\n\t\tTextureMapParamConfig(SkinningParamConfig(SideParamConfig(ColorParamConfig(NodeParamsConfig))))\n\t)\n) {\n\tmetalness = ParamConfig.FLOAT(SHADER_DEFAULTS.metalness);\n\troughness = ParamConfig.FLOAT(SHADER_DEFAULTS.roughness);\n}\n// TODO: add the following texture params:\n// - aoMap+aoMapIntensity\n// - bumpMap+bumpScale\n// - displacementMap+displaycementScale+displacementBias\n// - emissiveMap\n// - envMap\n// - lightMap\n// - metalnessMap\n// - normalMap\n// - roughnessMap,\nconst ParamsConfig = new MeshStandardMatParamsConfig();\n\nexport class MeshStandardMatNode extends TypedMatNode<MeshStandardMaterial, MeshStandardMatParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'mesh_standard';\n\t}\n\n\tcreate_material() {\n\t\treturn new MeshStandardMaterial({\n\t\t\tvertexColors: false,\n\t\t\tside: FrontSide,\n\t\t\tcolor: 0xffffff,\n\t\t\topacity: 1,\n\t\t\tmetalness: 1,\n\t\t\troughness: 0,\n\t\t});\n\t}\n\n\treadonly texture_map_controller: TextureMapController = new TextureMapController(this, {direct_params: true});\n\treadonly texture_alpha_map_controller: TextureAlphaMapController = new TextureAlphaMapController(this, {\n\t\tdirect_params: true,\n\t});\n\treadonly texture_env_map_controller: TextureEnvMapController = new TextureEnvMapController(this, {\n\t\tdirect_params: true,\n\t});\n\tinitialize_node() {\n\t\tthis.params.set_post_create_params_hook(() => {\n\t\t\tthis.texture_map_controller.initialize_node();\n\t\t\tthis.texture_alpha_map_controller.initialize_node();\n\t\t\tthis.texture_env_map_controller.initialize_node();\n\t\t});\n\t}\n\n\tasync cook() {\n\t\tColorsController.update(this);\n\t\tSideController.update(this);\n\t\tSkinningController.update(this);\n\t\tthis.texture_map_controller.update();\n\t\tthis.texture_alpha_map_controller.update();\n\t\tthis.texture_env_map_controller.update();\n\n\t\tif (this._material) {\n\t\t\tthis._material.envMapIntensity = this.pv.env_map_intensity;\n\t\t\tthis._material.roughness = this.pv.roughness;\n\t\t\tthis._material.metalness = this.pv.metalness;\n\t\t}\n\n\t\tthis.set_material(this.material);\n\t}\n}\n","import {UniformsUtils} from 'three/src/renderers/shaders/UniformsUtils';\nimport {ShaderMaterial} from 'three/src/materials/ShaderMaterial';\nimport {ShaderLib} from 'three/src/renderers/shaders/ShaderLib';\n\nimport {ShaderAssemblerMesh} from './_BaseMesh';\nimport {BaseGlShaderAssembler} from '../_Base';\nimport {ShaderConfig} from '../../configs/ShaderConfig';\nimport {VariableConfig} from '../../configs/VariableConfig';\n\nimport metalnessmap_fragment from '../../../gl/ShaderLib/ShaderChunk/metalnessmap_fragment.glsl';\nimport roughnessmap_fragment from '../../../gl/ShaderLib/ShaderChunk/roughnessmap_fragment.glsl';\nimport {OutputGlNode} from '../../../Output';\nimport {ShaderName} from '../../../../utils/shaders/ShaderName';\nimport {ParamType} from '../../../../../poly/ParamType';\n\nexport class ShaderAssemblerStandard extends ShaderAssemblerMesh {\n\tis_physical() {\n\t\treturn false;\n\t}\n\n\tget _template_shader() {\n\t\tconst template = this.is_physical() ? ShaderLib.physical : ShaderLib.standard;\n\t\treturn {\n\t\t\tvertexShader: template.vertexShader, //TemplateVertex,\n\t\t\tfragmentShader: template.fragmentShader, //TemplateFragment,\n\t\t\tuniforms: template.uniforms,\n\t\t};\n\t}\n\n\tcreate_material() {\n\t\tconst template_shader = this._template_shader;\n\n\t\tconst options = {\n\t\t\tlights: true,\n\t\t\textensions: {\n\t\t\t\tderivatives: true,\n\t\t\t},\n\n\t\t\tuniforms: UniformsUtils.clone(template_shader.uniforms),\n\t\t\tvertexShader: template_shader.vertexShader,\n\t\t\tfragmentShader: template_shader.fragmentShader,\n\t\t};\n\t\t// if(this.constructor.is_physical()){\n\t\t// \toptions['defines'] = {\n\t\t// \t\tPHYSICAL: 1\n\t\t// \t}\n\t\t// }\n\n\t\tconst material = new ShaderMaterial(options);\n\n\t\t// replace some shader chunks\n\t\tmaterial.onBeforeCompile = function(shader) {\n\t\t\tshader.fragmentShader = shader.fragmentShader.replace(\n\t\t\t\t'#include <metalnessmap_fragment>',\n\t\t\t\tmetalnessmap_fragment\n\t\t\t);\n\t\t\tshader.fragmentShader = shader.fragmentShader.replace(\n\t\t\t\t'#include <roughnessmap_fragment>',\n\t\t\t\troughnessmap_fragment\n\t\t\t);\n\t\t};\n\t\tthis._add_custom_materials(material);\n\t\treturn material;\n\t}\n\n\t// static convert_material_to_gltf_supported(material: ShaderMaterial): Material {\n\t// \tconst gltf_constructor = this.is_physical() ? MeshPhysicalMaterial : MeshStandardMaterial;\n\t// \tconst options = {};\n\t// \tthis._match_uniform('color', options, material, 'diffuse');\n\t// \tthis._match_uniform('map', options, material);\n\t// \tthis._match_uniform('envMap', options, material);\n\t// \tthis._match_uniform('envMapIntensity', options, material);\n\t// \tthis._match_uniform('metalness', options, material);\n\t// \tthis._match_uniform('roughness', options, material);\n\t// \tconst gltf_material = new gltf_constructor(options);\n\t// \treturn gltf_material;\n\t// }\n\n\tadd_output_params(output_child: OutputGlNode) {\n\t\tBaseGlShaderAssembler.add_output_params(output_child);\n\t\t// those defaults should be 1. If they were 0, using the params\n\t\t// at the material level would appear not to work\n\t\toutput_child.add_param(ParamType.FLOAT, 'metalness', 1);\n\t\toutput_child.add_param(ParamType.FLOAT, 'roughness', 1);\n\t}\n\t// create_globals_node_output_connections(){\n\t// \treturn BaseShaderAssembler.create_globals_node_output_connections().concat([\n\t// \t\tnew Connection.Float('metalness'),\n\t// \t\tnew Connection.Float('roughness'),\n\t// \t])\n\t// }\n\tcreate_shader_configs() {\n\t\treturn [\n\t\t\tnew ShaderConfig(ShaderName.VERTEX, ['position', 'normal', 'uv'], []),\n\t\t\tnew ShaderConfig(ShaderName.FRAGMENT, ['color', 'alpha', 'metalness', 'roughness'], [ShaderName.VERTEX]),\n\t\t];\n\t}\n\tcreate_variable_configs() {\n\t\treturn BaseGlShaderAssembler.create_variable_configs().concat([\n\t\t\tnew VariableConfig('metalness', {\n\t\t\t\tdefault: '1.0',\n\t\t\t\tprefix: 'float POLY_metalness = ',\n\t\t\t}),\n\t\t\tnew VariableConfig('roughness', {\n\t\t\t\tdefault: '1.0',\n\t\t\t\tprefix: 'float POLY_roughness = ',\n\t\t\t}),\n\t\t]);\n\t}\n}\n","export default \"float metalnessFactor = metalness * POLY_metalness;\\n\\n#ifdef USE_METALNESSMAP\\n\\n\\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\\n\\n\\t// reads channel B, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\\n\\tmetalnessFactor *= texelMetalness.b;\\n\\n#endif\\n\"","export default \"float roughnessFactor = roughness * POLY_roughness;\\n\\n#ifdef USE_ROUGHNESSMAP\\n\\n\\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\\n\\n\\t// reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\\n\\troughnessFactor *= texelRoughness.g;\\n\\n#endif\\n\"","import {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nimport {ColorParamConfig, ColorsController} from './utils/UniformsColorsController';\nimport {SideParamConfig, SideController} from './utils/SideController';\nimport {SkinningParamConfig, SkinningController} from './utils/SkinningController';\nimport {TextureMapParamConfig, TextureMapController} from './utils/TextureMapController';\nimport {TextureAlphaMapParamConfig, TextureAlphaMapController} from './utils/TextureAlphaMapController';\nimport {TextureEnvMapController, TextureEnvMapParamConfig} from './utils/TextureEnvMapController';\nimport {TypedBuilderMatNode} from './_BaseBuilder';\nimport {GlAssemblerController} from '../gl/code/Controller';\nimport {ShaderAssemblerStandard} from '../gl/code/assemblers/materials/Standard';\nimport {BaseParamType} from '../../params/_Base';\nimport {BaseNodeType} from '../_Base';\n\nimport {SHADER_DEFAULTS} from './MeshStandard';\n\nclass MeshStandardMatParamsConfig extends TextureEnvMapParamConfig(\n\tTextureAlphaMapParamConfig(\n\t\tTextureMapParamConfig(SkinningParamConfig(SideParamConfig(ColorParamConfig(NodeParamsConfig))))\n\t)\n) {\n\tmetalness = ParamConfig.FLOAT(SHADER_DEFAULTS.metalness, {\n\t\tcook: false,\n\t\tcallback: (node: BaseNodeType, param: BaseParamType) =>\n\t\t\tMeshStandardBuilderMatNode._update_metalness(node as MeshStandardBuilderMatNode),\n\t});\n\troughness = ParamConfig.FLOAT(SHADER_DEFAULTS.roughness, {\n\t\tcook: false,\n\t\tcallback: (node: BaseNodeType, param: BaseParamType) =>\n\t\t\tMeshStandardBuilderMatNode._update_roughness(node as MeshStandardBuilderMatNode),\n\t});\n}\nconst ParamsConfig = new MeshStandardMatParamsConfig();\n\nexport class MeshStandardBuilderMatNode extends TypedBuilderMatNode<\n\tShaderAssemblerStandard,\n\tMeshStandardMatParamsConfig\n> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'mesh_standard_builder';\n\t}\n\n\treadonly texture_map_controller: TextureMapController = new TextureMapController(this, {uniforms: true});\n\treadonly texture_alpha_map_controller: TextureAlphaMapController = new TextureAlphaMapController(this, {\n\t\tuniforms: true,\n\t});\n\treadonly texture_env_map_controller: TextureEnvMapController = new TextureEnvMapController(this, {\n\t\tuniforms: true,\n\t\tdirect_params: true,\n\t\tdefine: false,\n\t});\n\tinitialize_node() {\n\t\tthis.params.set_post_create_params_hook(() => {\n\t\t\tthis.texture_map_controller.initialize_node();\n\t\t\tthis.texture_alpha_map_controller.initialize_node();\n\t\t\tthis.texture_env_map_controller.initialize_node();\n\t\t});\n\t}\n\n\tprotected _create_assembler_controller() {\n\t\treturn new GlAssemblerController<ShaderAssemblerStandard>(this, ShaderAssemblerStandard);\n\t}\n\n\tasync cook() {\n\t\tawait this.compile_if_required();\n\n\t\tColorsController.update(this);\n\t\tSideController.update(this);\n\t\tSkinningController.update(this);\n\t\tawait TextureMapController.update(this);\n\t\tawait TextureAlphaMapController.update(this);\n\t\tawait TextureEnvMapController.update(this);\n\n\t\tif (this._material) {\n\t\t\tthis._material.uniforms.envMapIntensity.value = this.pv.env_map_intensity;\n\t\t\tMeshStandardBuilderMatNode._update_metalness(this);\n\t\t\tMeshStandardBuilderMatNode._update_roughness(this);\n\t\t}\n\n\t\tthis.set_material(this.material);\n\t}\n\tstatic _update_metalness(node: MeshStandardBuilderMatNode) {\n\t\tnode.material.uniforms.metalness.value = node.pv.metalness;\n\t}\n\tstatic _update_roughness(node: MeshStandardBuilderMatNode) {\n\t\tnode.material.uniforms.roughness.value = node.pv.roughness;\n\t}\n}\n","import {PointsMaterial} from 'three/src/materials/PointsMaterial';\nimport {FrontSide} from 'three/src/constants';\nimport {TypedMatNode} from './_Base';\n\nimport {ColorsController, ColorParamConfig} from './utils/ColorsController';\nimport {SideController, SideParamConfig} from './utils/SideController';\n// import {TextureMapController, TextureMapParamConfig} from './utils/TextureMapController';\n// import {TextureAlphaMapController, TextureAlphaMapParamConfig} from './utils/TextureAlphaMapController';\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nexport function PointsParamConfig<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\tsize = ParamConfig.FLOAT(1);\n\t\tsize_attenuation = ParamConfig.BOOLEAN(1);\n\t};\n}\n\nclass PointsMatParamsConfig extends SideParamConfig(ColorParamConfig(PointsParamConfig(NodeParamsConfig))) {}\nconst ParamsConfig = new PointsMatParamsConfig();\n\nexport class PointsMatNode extends TypedMatNode<PointsMaterial, PointsMatParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'points';\n\t}\n\n\tcreate_material() {\n\t\treturn new PointsMaterial({\n\t\t\tvertexColors: false,\n\t\t\tside: FrontSide,\n\t\t\tcolor: 0xffffff,\n\t\t\topacity: 1,\n\t\t});\n\t}\n\n\tasync cook() {\n\t\tColorsController.update(this);\n\t\tSideController.update(this);\n\t\t// await TextureMapController.update(this);\n\t\t// await TextureAlphaMapController.update(this);\n\n\t\tthis.material.size = this.pv.size;\n\t\tthis.material.sizeAttenuation = this.pv.size_attenuation;\n\n\t\tthis.set_material(this.material);\n\t}\n}\n","import {CATEGORY_MAT} from './Category';\n\nimport {MeshBasicMatNode} from '../../nodes/mat/MeshBasic';\nimport {MeshBasicBuilderMatNode} from '../../nodes/mat/MeshBasicBuilder';\nimport {MeshLambertMatNode} from '../../nodes/mat/MeshLambert';\nimport {MeshLambertBuilderMatNode} from '../../nodes/mat/MeshLambertBuilder';\nimport {MeshStandardMatNode} from '../../nodes/mat/MeshStandard';\nimport {MeshStandardBuilderMatNode} from '../../nodes/mat/MeshStandardBuilder';\nimport {PointsMatNode} from '../../nodes/mat/Points';\nimport {PointsBuilderMatNode} from '../../nodes/mat/PointsBuilder';\n\nexport interface MatNodeChildrenMap {\n\tmesh_basic: MeshBasicMatNode;\n\tmesh_basic_builder: MeshBasicBuilderMatNode;\n\tmesh_lambert: MeshLambertMatNode;\n\tmesh_lambert_builder: MeshLambertBuilderMatNode;\n\tmesh_standard: MeshStandardMatNode;\n\tmesh_standard_builder: MeshStandardBuilderMatNode;\n\tpoints: PointsMatNode;\n\tpoints_builder: PointsBuilderMatNode;\n}\n\nimport {Poly} from '../../Poly';\nexport class MatRegister {\n\tstatic run(poly: Poly) {\n\t\tpoly.register_node(MeshBasicMatNode, CATEGORY_MAT.MESH);\n\t\tpoly.register_node(MeshBasicBuilderMatNode, CATEGORY_MAT.ADVANCED);\n\t\tpoly.register_node(MeshLambertMatNode, CATEGORY_MAT.MESH);\n\t\tpoly.register_node(MeshLambertBuilderMatNode, CATEGORY_MAT.ADVANCED);\n\t\tpoly.register_node(MeshStandardMatNode, CATEGORY_MAT.MESH);\n\t\tpoly.register_node(MeshStandardBuilderMatNode, CATEGORY_MAT.ADVANCED);\n\t\tpoly.register_node(PointsMatNode, CATEGORY_MAT.POINTS);\n\t\tpoly.register_node(PointsBuilderMatNode, CATEGORY_MAT.ADVANCED);\n\t}\n}\n"],"sourceRoot":""}