{"version":3,"sources":["webpack://POLY/./modules/three/examples/jsm/loaders/SVGLoader.js"],"names":["tempV2_1","tempV2_2","tempV2_3","tempV2_4","tempV2_5","tempV2_6","tempV2_7","lastPointL","lastPointR","point0L","point0R","currentPointL","currentPointR","nextPointL","nextPointR","innerPoint","outerPoint","SVGLoader","manager","call","this","defaultDPI","defaultUnit","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","text","parse","parseArcCommand","rx","ry","x_axis_rotation","large_arc_flag","sweep_flag","start","end","Math","PI","abs","dx2","x","dy2","y","x1p","cos","sin","y1p","rxs","rys","x1ps","y1ps","cr","s","sqrt","dq","pq","q","max","cxp","cyp","cx","cy","theta","svgAngle","delta","currentPath","absellipse","ux","uy","vx","vy","dot","len","ang","acos","min","parseStyle","node","style","stylesheetStyles","hasAttribute","classSelectors","getAttribute","split","filter","Boolean","map","i","trim","length","stylesheets","addStyle","svgName","jsName","adjustFunction","undefined","v","clamp","parseFloatWithUnits","positive","getReflection","a","b","parseFloats","string","array","number","indexOf","lastIndexOf","splice","units","unitConversion","theUnit","String","n","u","endsWith","substring","scale","parseFloat","getTransformScaleX","m","te","elements","getTransformScaleY","paths","transformStack","tempTransform0","tempTransform1","tempTransform2","tempTransform3","tempV2","tempV3","currentTransform","xml","DOMParser","parseFromString","parseNode","nodeType","transform","transformsTexts","tIndex","transformText","openParPos","closeParPos","transformType","substr","identity","tx","ty","translate","angle","rotate","multiplyMatrices","scaleX","scaleY","set","tan","premultiply","parseNodeTransform","copy","push","getNodeTransform","nodeName","sheet","cssRules","stylesheet","type","selectorList","selectorText","j","parseCSSStylesheet","point","control","firstPoint","isFirstPoint","doSetFirstPoint","commands","match","l","command","charAt","data","numbers","jl","moveTo","lineTo","bezierCurveTo","quadraticCurveTo","clone","autoClose","curves","currentPoint","console","warn","parsePathNode","w","h","parseRectNode","iterator","index","replace","parsePolygonNode","parsePolylineNode","r","subpath","absarc","subPaths","parseCircleNode","parseEllipseNode","x1","y1","x2","y2","parseLineNode","fill","color","setStyle","transfVec2","v2","applyMatrix3","isRotated","isTransformRotated","curve","isLineCurve","v1","isCubicBezierCurve","v0","v3","isQuadraticBezierCurve","isEllipseCurve","aX","aY","xRadius","yRadius","transformPath","userData","nodes","childNodes","pop","documentElement","fillOpacity","strokeOpacity","strokeWidth","strokeLineJoin","strokeLineCap","strokeMiterLimit","getStrokeStyle","width","lineJoin","lineCap","miterLimit","strokeColor","pointsToStroke","points","arcDivisions","minDistance","vertices","normals","uvs","pointsToStrokeWithBuffers","geometry","setAttribute","vertexOffset","numPoints","dupPoints","distanceTo","newPoints","removeDuplicatedPoints","nextPoint","innerSideModified","joinIsOnLeftSide","isMiter","isClosed","equals","previousPoint","strokeWidth2","deltaU","u0","initialJoinIsOnLeftSide","numVertices","currentCoordinate","currentCoordinateUV","getNormal","multiplyScalar","sub","add","iPoint","normal1","u1","subVectors","normalize","miterSide","setLength","negate","miterLength2","segmentLengthPrev","divideScalar","segmentLengthNext","makeSegmentTriangles","makeSegmentWithBevelJoin","createSegmentTrianglesWithMiddleSection","makeCircularSector","miterFraction","addVertex","addCapGeometry","lastOuter","lastInner","toArray","p1","p2","result","position","center","il","rotateAround","addVectors","vl"],"mappings":"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","file":"8.bundle.js","sourcesContent":["import {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {FileLoader} from 'three/src/loaders/FileLoader';\nimport {Float32BufferAttribute} from 'three/src/core/BufferAttribute';\nimport {Loader} from 'three/src/loaders/Loader';\nimport {Matrix3} from 'three/src/math/Matrix3';\nimport {Path} from 'three/src/extras/core/Path';\nimport {ShapePath} from 'three/src/extras/core/ShapePath';\nimport {Vector2} from 'three/src/math/Vector2';\nimport {Vector3} from 'three/src/math/Vector3';\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author zz85 / http://joshuakoo.com/\n * @author yomboprime / https://yombo.org\n */\n\n\nvar SVGLoader = function ( manager ) {\n\n\tLoader.call( this, manager );\n\n\t// Default dots per inch\n\tthis.defaultDPI = 90;\n\n\t// Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px'\n\tthis.defaultUnit = \"px\";\n\n};\n\nSVGLoader.prototype = Object.assign( Object.create( Loader.prototype ), {\n\n\tconstructor: SVGLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tonLoad( scope.parse( text ) );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tparse: function ( text ) {\n\n\t\tvar scope = this;\n\n\t\tfunction parseNode( node, style ) {\n\n\t\t\tif ( node.nodeType !== 1 ) return;\n\n\t\t\tvar transform = getNodeTransform( node );\n\n\t\t\tvar path = null;\n\n\t\t\tswitch ( node.nodeName ) {\n\n\t\t\t\tcase 'svg':\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'style':\n\t\t\t\t\tparseCSSStylesheet( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'g':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'path':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tif ( node.hasAttribute( 'd' ) ) path = parsePathNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rect':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseRectNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'polygon':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parsePolygonNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'polyline':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parsePolylineNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'circle':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseCircleNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ellipse':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseEllipseNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'line':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseLineNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t// console.log( node );\n\n\t\t\t}\n\n\t\t\tif ( path ) {\n\n\t\t\t\tif ( style.fill !== undefined && style.fill !== 'none' ) {\n\n\t\t\t\t\tpath.color.setStyle( style.fill );\n\n\t\t\t\t}\n\n\t\t\t\ttransformPath( path, currentTransform );\n\n\t\t\t\tpaths.push( path );\n\n\t\t\t\tpath.userData = { node: node, style: style };\n\n\t\t\t}\n\n\t\t\tvar nodes = node.childNodes;\n\n\t\t\tfor ( var i = 0; i < nodes.length; i ++ ) {\n\n\t\t\t\tparseNode( nodes[ i ], style );\n\n\t\t\t}\n\n\t\t\tif ( transform ) {\n\n\t\t\t\ttransformStack.pop();\n\n\t\t\t\tif ( transformStack.length > 0 ) {\n\n\t\t\t\t\tcurrentTransform.copy( transformStack[ transformStack.length - 1 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcurrentTransform.identity();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parsePathNode( node ) {\n\n\t\t\tvar path = new ShapePath();\n\n\t\t\tvar point = new Vector2();\n\t\t\tvar control = new Vector2();\n\n\t\t\tvar firstPoint = new Vector2();\n\t\t\tvar isFirstPoint = true;\n\t\t\tvar doSetFirstPoint = false;\n\n\t\t\tvar d = node.getAttribute( 'd' );\n\n\t\t\t// console.log( d );\n\n\t\t\tvar commands = d.match( /[a-df-z][^a-df-z]*/ig );\n\n\t\t\tfor ( var i = 0, l = commands.length; i < l; i ++ ) {\n\n\t\t\t\tvar command = commands[ i ];\n\n\t\t\t\tvar type = command.charAt( 0 );\n\t\t\t\tvar data = command.substr( 1 ).trim();\n\n\t\t\t\tif ( isFirstPoint === true ) {\n\n\t\t\t\t\tdoSetFirstPoint = true;\n\t\t\t\t\tisFirstPoint = false;\n\n\t\t\t\t}\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase 'M':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\n\t\t\t\t\t\t\tif ( j === 0 ) {\n\n\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'H':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'V':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.y = numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'L':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'C':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 6 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 4 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 5 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 3 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 4 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 5 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'S':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\n\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Q':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'T':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tvar rx = getReflection( point.x, control.x );\n\t\t\t\t\t\t\tvar ry = getReflection( point.y, control.y );\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\trx,\n\t\t\t\t\t\t\t\try,\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = rx;\n\t\t\t\t\t\t\tcontrol.y = ry;\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'A':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 7 ) {\n\n\t\t\t\t\t\t\tvar start = point.clone();\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 5 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 6 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tparseArcCommand(\n\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'm':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\n\t\t\t\t\t\t\tif ( j === 0 ) {\n\n\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'h':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.y += numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'l':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 6 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 4 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 5 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 2 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 3 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 4 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 5 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 's':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\n\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'q':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tvar rx = getReflection( point.x, control.x );\n\t\t\t\t\t\t\tvar ry = getReflection( point.y, control.y );\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\trx,\n\t\t\t\t\t\t\t\try,\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = rx;\n\t\t\t\t\t\t\tcontrol.y = ry;\n\t\t\t\t\t\t\tpoint.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = point.y + numbers[ j + 1 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'a':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 7 ) {\n\n\t\t\t\t\t\t\tvar start = point.clone();\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 5 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 6 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tparseArcCommand(\n\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Z':\n\t\t\t\t\tcase 'z':\n\t\t\t\t\t\tpath.currentPath.autoClose = true;\n\n\t\t\t\t\t\tif ( path.currentPath.curves.length > 0 ) {\n\n\t\t\t\t\t\t\t// Reset point to beginning of Path\n\t\t\t\t\t\t\tpoint.copy( firstPoint );\n\t\t\t\t\t\t\tpath.currentPath.currentPoint.copy( point );\n\t\t\t\t\t\t\tisFirstPoint = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( command );\n\n\t\t\t\t}\n\n\t\t\t\t// console.log( type, parseFloats( data ), parseFloats( data ).length  )\n\n\t\t\t\tdoSetFirstPoint = false;\n\n\t\t\t}\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseCSSStylesheet( node ) {\n\n\t\t\tif ( ! node.sheet || ! node.sheet.cssRules || ! node.sheet.cssRules.length ) return;\n\n\t\t\tfor ( var i = 0; i < node.sheet.cssRules.length; i ++ ) {\n\n\t\t\t\tvar stylesheet = node.sheet.cssRules[ i ];\n\n\t\t\t\tif ( stylesheet.type !== 1 ) continue;\n\n\t\t\t\tvar selectorList = stylesheet.selectorText\n\t\t\t\t\t.split( /,/gm )\n\t\t\t\t\t.filter( Boolean )\n\t\t\t\t\t.map( i => i.trim() );\n\n\t\t\t\tfor ( var j = 0; j < selectorList.length; j ++ ) {\n\n\t\t\t\t\tstylesheets[ selectorList[ j ] ] = Object.assign(\n\t\t\t\t\t\tstylesheets[ selectorList[ j ] ] || {},\n\t\t\t\t\t\tstylesheet.style\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n\t\t * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\n\t\t * From\n\t\t * rx ry x-axis-rotation large-arc-flag sweep-flag x y\n\t\t * To\n\t\t * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation\n\t\t */\n\n\t\tfunction parseArcCommand( path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end ) {\n\n\t\t\tx_axis_rotation = x_axis_rotation * Math.PI / 180;\n\n\t\t\t// Ensure radii are positive\n\t\t\trx = Math.abs( rx );\n\t\t\try = Math.abs( ry );\n\n\t\t\t// Compute (x1′, y1′)\n\t\t\tvar dx2 = ( start.x - end.x ) / 2.0;\n\t\t\tvar dy2 = ( start.y - end.y ) / 2.0;\n\t\t\tvar x1p = Math.cos( x_axis_rotation ) * dx2 + Math.sin( x_axis_rotation ) * dy2;\n\t\t\tvar y1p = - Math.sin( x_axis_rotation ) * dx2 + Math.cos( x_axis_rotation ) * dy2;\n\n\t\t\t// Compute (cx′, cy′)\n\t\t\tvar rxs = rx * rx;\n\t\t\tvar rys = ry * ry;\n\t\t\tvar x1ps = x1p * x1p;\n\t\t\tvar y1ps = y1p * y1p;\n\n\t\t\t// Ensure radii are large enough\n\t\t\tvar cr = x1ps / rxs + y1ps / rys;\n\n\t\t\tif ( cr > 1 ) {\n\n\t\t\t\t// scale up rx,ry equally so cr == 1\n\t\t\t\tvar s = Math.sqrt( cr );\n\t\t\t\trx = s * rx;\n\t\t\t\try = s * ry;\n\t\t\t\trxs = rx * rx;\n\t\t\t\trys = ry * ry;\n\n\t\t\t}\n\n\t\t\tvar dq = ( rxs * y1ps + rys * x1ps );\n\t\t\tvar pq = ( rxs * rys - dq ) / dq;\n\t\t\tvar q = Math.sqrt( Math.max( 0, pq ) );\n\t\t\tif ( large_arc_flag === sweep_flag ) q = - q;\n\t\t\tvar cxp = q * rx * y1p / ry;\n\t\t\tvar cyp = - q * ry * x1p / rx;\n\n\t\t\t// Step 3: Compute (cx, cy) from (cx′, cy′)\n\t\t\tvar cx = Math.cos( x_axis_rotation ) * cxp - Math.sin( x_axis_rotation ) * cyp + ( start.x + end.x ) / 2;\n\t\t\tvar cy = Math.sin( x_axis_rotation ) * cxp + Math.cos( x_axis_rotation ) * cyp + ( start.y + end.y ) / 2;\n\n\t\t\t// Step 4: Compute θ1 and Δθ\n\t\t\tvar theta = svgAngle( 1, 0, ( x1p - cxp ) / rx, ( y1p - cyp ) / ry );\n\t\t\tvar delta = svgAngle( ( x1p - cxp ) / rx, ( y1p - cyp ) / ry, ( - x1p - cxp ) / rx, ( - y1p - cyp ) / ry ) % ( Math.PI * 2 );\n\n\t\t\tpath.currentPath.absellipse( cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation );\n\n\t\t}\n\n\t\tfunction svgAngle( ux, uy, vx, vy ) {\n\n\t\t\tvar dot = ux * vx + uy * vy;\n\t\t\tvar len = Math.sqrt( ux * ux + uy * uy ) * Math.sqrt( vx * vx + vy * vy );\n\t\t\tvar ang = Math.acos( Math.max( - 1, Math.min( 1, dot / len ) ) ); // floating point precision, slightly over values appear\n\t\t\tif ( ( ux * vy - uy * vx ) < 0 ) ang = - ang;\n\t\t\treturn ang;\n\n\t\t}\n\n\t\t/*\n\t\t* According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute\n\t\t* rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough\n\t\t*/\n\t\tfunction parseRectNode( node ) {\n\n\t\t\tvar x = parseFloatWithUnits( node.getAttribute( 'x' ) || 0 );\n\t\t\tvar y = parseFloatWithUnits( node.getAttribute( 'y' ) || 0 );\n\t\t\tvar rx = parseFloatWithUnits( node.getAttribute( 'rx' ) || 0 );\n\t\t\tvar ry = parseFloatWithUnits( node.getAttribute( 'ry' ) || 0 );\n\t\t\tvar w = parseFloatWithUnits( node.getAttribute( 'width' ) );\n\t\t\tvar h = parseFloatWithUnits( node.getAttribute( 'height' ) );\n\n\t\t\tvar path = new ShapePath();\n\t\t\tpath.moveTo( x + 2 * rx, y );\n\t\t\tpath.lineTo( x + w - 2 * rx, y );\n\t\t\tif ( rx !== 0 || ry !== 0 ) path.bezierCurveTo( x + w, y, x + w, y, x + w, y + 2 * ry );\n\t\t\tpath.lineTo( x + w, y + h - 2 * ry );\n\t\t\tif ( rx !== 0 || ry !== 0 ) path.bezierCurveTo( x + w, y + h, x + w, y + h, x + w - 2 * rx, y + h );\n\t\t\tpath.lineTo( x + 2 * rx, y + h );\n\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo( x, y + h, x, y + h, x, y + h - 2 * ry );\n\n\t\t\t}\n\n\t\t\tpath.lineTo( x, y + 2 * ry );\n\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo( x, y, x, y, x + 2 * rx, y );\n\n\t\t\t}\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parsePolygonNode( node ) {\n\n\t\t\tfunction iterator( match, a, b ) {\n\n\t\t\t\tvar x = parseFloatWithUnits( a );\n\t\t\t\tvar y = parseFloatWithUnits( b );\n\n\t\t\t\tif ( index === 0 ) {\n\n\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t}\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\tvar regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n\n\t\t\tvar path = new ShapePath();\n\n\t\t\tvar index = 0;\n\n\t\t\tnode.getAttribute( 'points' ).replace( regex, iterator );\n\n\t\t\tpath.currentPath.autoClose = true;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parsePolylineNode( node ) {\n\n\t\t\tfunction iterator( match, a, b ) {\n\n\t\t\t\tvar x = parseFloatWithUnits( a );\n\t\t\t\tvar y = parseFloatWithUnits( b );\n\n\t\t\t\tif ( index === 0 ) {\n\n\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t}\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\tvar regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n\n\t\t\tvar path = new ShapePath();\n\n\t\t\tvar index = 0;\n\n\t\t\tnode.getAttribute( 'points' ).replace( regex, iterator );\n\n\t\t\tpath.currentPath.autoClose = false;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseCircleNode( node ) {\n\n\t\t\tvar x = parseFloatWithUnits( node.getAttribute( 'cx' ) );\n\t\t\tvar y = parseFloatWithUnits( node.getAttribute( 'cy' ) );\n\t\t\tvar r = parseFloatWithUnits( node.getAttribute( 'r' ) );\n\n\t\t\tvar subpath = new Path();\n\t\t\tsubpath.absarc( x, y, r, 0, Math.PI * 2 );\n\n\t\t\tvar path = new ShapePath();\n\t\t\tpath.subPaths.push( subpath );\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseEllipseNode( node ) {\n\n\t\t\tvar x = parseFloatWithUnits( node.getAttribute( 'cx' ) );\n\t\t\tvar y = parseFloatWithUnits( node.getAttribute( 'cy' ) );\n\t\t\tvar rx = parseFloatWithUnits( node.getAttribute( 'rx' ) );\n\t\t\tvar ry = parseFloatWithUnits( node.getAttribute( 'ry' ) );\n\n\t\t\tvar subpath = new Path();\n\t\t\tsubpath.absellipse( x, y, rx, ry, 0, Math.PI * 2 );\n\n\t\t\tvar path = new ShapePath();\n\t\t\tpath.subPaths.push( subpath );\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseLineNode( node ) {\n\n\t\t\tvar x1 = parseFloatWithUnits( node.getAttribute( 'x1' ) );\n\t\t\tvar y1 = parseFloatWithUnits( node.getAttribute( 'y1' ) );\n\t\t\tvar x2 = parseFloatWithUnits( node.getAttribute( 'x2' ) );\n\t\t\tvar y2 = parseFloatWithUnits( node.getAttribute( 'y2' ) );\n\n\t\t\tvar path = new ShapePath();\n\t\t\tpath.moveTo( x1, y1 );\n\t\t\tpath.lineTo( x2, y2 );\n\t\t\tpath.currentPath.autoClose = false;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\t//\n\n\t\tfunction parseStyle( node, style ) {\n\n\t\t\tstyle = Object.assign( {}, style ); // clone style\n\n\t\t\tvar stylesheetStyles = {};\n\n\t\t\tif ( node.hasAttribute( 'class' ) ) {\n\n\t\t\t\tvar classSelectors = node.getAttribute( 'class' )\n\t\t\t\t\t.split( /\\s/ )\n\t\t\t\t\t.filter( Boolean )\n\t\t\t\t\t.map( i => i.trim() );\n\n\t\t\t\tfor ( var i = 0; i < classSelectors.length; i ++ ) {\n\n\t\t\t\t\tstylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '.' + classSelectors[ i ] ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( node.hasAttribute( 'id' ) ) {\n\n\t\t\t\tstylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '#' + node.getAttribute( 'id' ) ] );\n\n\t\t\t}\n\n\t\t\tfunction addStyle( svgName, jsName, adjustFunction ) {\n\n\t\t\t\tif ( adjustFunction === undefined ) adjustFunction = function copy( v ) {\n\n\t\t\t\t\treturn v;\n\n\t\t\t\t};\n\n\t\t\t\tif ( node.hasAttribute( svgName ) ) style[ jsName ] = adjustFunction( node.getAttribute( svgName ) );\n\t\t\t\tif ( stylesheetStyles[ svgName ] ) style[ jsName ] = adjustFunction( stylesheetStyles[ svgName ] );\n\t\t\t\tif ( node.style && node.style[ svgName ] !== '' ) style[ jsName ] = adjustFunction( node.style[ svgName ] );\n\n\t\t\t}\n\n\t\t\tfunction clamp( v ) {\n\n\t\t\t\treturn Math.max( 0, Math.min( 1, parseFloatWithUnits( v ) ) );\n\n\t\t\t}\n\n\t\t\tfunction positive( v ) {\n\n\t\t\t\treturn Math.max( 0, parseFloatWithUnits( v ) );\n\n\t\t\t}\n\n\t\t\taddStyle( 'fill', 'fill' );\n\t\t\taddStyle( 'fill-opacity', 'fillOpacity', clamp );\n\t\t\taddStyle( 'opacity', 'opacity', clamp );\n\t\t\taddStyle( 'stroke', 'stroke' );\n\t\t\taddStyle( 'stroke-opacity', 'strokeOpacity', clamp );\n\t\t\taddStyle( 'stroke-width', 'strokeWidth', positive );\n\t\t\taddStyle( 'stroke-linejoin', 'strokeLineJoin' );\n\t\t\taddStyle( 'stroke-linecap', 'strokeLineCap' );\n\t\t\taddStyle( 'stroke-miterlimit', 'strokeMiterLimit', positive );\n\t\t\taddStyle( 'visibility', 'visibility' );\n\n\t\t\treturn style;\n\n\t\t}\n\n\t\t// http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\n\n\t\tfunction getReflection( a, b ) {\n\n\t\t\treturn a - ( b - a );\n\n\t\t}\n\n\t\tfunction parseFloats( string ) {\n\n\t\t\tvar array = string.split( /[\\s,]+|(?=\\s?[+\\-])/ );\n\n\t\t\tfor ( var i = 0; i < array.length; i ++ ) {\n\n\t\t\t\tvar number = array[ i ];\n\n\t\t\t\t// Handle values like 48.6037.7.8\n\t\t\t\t// TODO Find a regex for this\n\n\t\t\t\tif ( number.indexOf( '.' ) !== number.lastIndexOf( '.' ) ) {\n\n\t\t\t\t\tvar split = number.split( '.' );\n\n\t\t\t\t\tfor ( var s = 2; s < split.length; s ++ ) {\n\n\t\t\t\t\t\tarray.splice( i + s - 1, 0, '0.' + split[ s ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tarray[ i ] = parseFloatWithUnits( number );\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\n\t\t}\n\n\t\t// Units\n\n\t\tvar units = [ 'mm', 'cm', 'in', 'pt', 'pc', 'px' ];\n\n\t\t// Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)\n\t\tvar unitConversion = {\n\n\t\t\t\"mm\": {\n\t\t\t\t\"mm\": 1,\n\t\t\t\t\"cm\": 0.1,\n\t\t\t\t\"in\": 1 / 25.4,\n\t\t\t\t\"pt\": 72 / 25.4,\n\t\t\t\t\"pc\": 6 / 25.4,\n\t\t\t\t\"px\": - 1\n\t\t\t},\n\t\t\t\"cm\": {\n\t\t\t\t\"mm\": 10,\n\t\t\t\t\"cm\": 1,\n\t\t\t\t\"in\": 1 / 2.54,\n\t\t\t\t\"pt\": 72 / 2.54,\n\t\t\t\t\"pc\": 6 / 2.54,\n\t\t\t\t\"px\": - 1\n\t\t\t},\n\t\t\t\"in\": {\n\t\t\t\t\"mm\": 25.4,\n\t\t\t\t\"cm\": 2.54,\n\t\t\t\t\"in\": 1,\n\t\t\t\t\"pt\": 72,\n\t\t\t\t\"pc\": 6,\n\t\t\t\t\"px\": - 1\n\t\t\t},\n\t\t\t\"pt\": {\n\t\t\t\t\"mm\": 25.4 / 72,\n\t\t\t\t\"cm\": 2.54 / 72,\n\t\t\t\t\"in\": 1 / 72,\n\t\t\t\t\"pt\": 1,\n\t\t\t\t\"pc\": 6 / 72,\n\t\t\t\t\"px\": - 1\n\t\t\t},\n\t\t\t\"pc\": {\n\t\t\t\t\"mm\": 25.4 / 6,\n\t\t\t\t\"cm\": 2.54 / 6,\n\t\t\t\t\"in\": 1 / 6,\n\t\t\t\t\"pt\": 72 / 6,\n\t\t\t\t\"pc\": 1,\n\t\t\t\t\"px\": - 1\n\t\t\t},\n\t\t\t\"px\": {\n\t\t\t\t\"px\": 1\n\t\t\t}\n\n\t\t};\n\n\t\tfunction parseFloatWithUnits( string ) {\n\n\t\t\tvar theUnit = \"px\";\n\n\t\t\tif ( typeof string === 'string' || string instanceof String ) {\n\n\t\t\t\tfor ( var i = 0, n = units.length; i < n; i ++ ) {\n\n\t\t\t\t\tvar u = units[ i ];\n\n\t\t\t\t\tif ( string.endsWith( u ) ) {\n\n\t\t\t\t\t\ttheUnit = u;\n\t\t\t\t\t\tstring = string.substring( 0, string.length - u.length );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar scale = undefined;\n\n\t\t\tif ( theUnit === \"px\" && scope.defaultUnit !== \"px\" ) {\n\n\t\t\t\t// Conversion scale from  pixels to inches, then to default units\n\n\t\t\t\tscale = unitConversion[ \"in\" ][ scope.defaultUnit ] / scope.defaultDPI;\n\n\t\t\t} else {\n\n\t\t\t\tscale = unitConversion[ theUnit ][ scope.defaultUnit ];\n\n\t\t\t\tif ( scale < 0 ) {\n\n\t\t\t\t\t// Conversion scale to pixels\n\n\t\t\t\t\tscale = unitConversion[ theUnit ][ \"in\" ] * scope.defaultDPI;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn scale * parseFloat( string );\n\n\t\t}\n\n\t\t// Transforms\n\n\t\tfunction getNodeTransform( node ) {\n\n\t\t\tif ( ! node.hasAttribute( 'transform' ) ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tvar transform = parseNodeTransform( node );\n\n\t\t\tif ( transformStack.length > 0 ) {\n\n\t\t\t\ttransform.premultiply( transformStack[ transformStack.length - 1 ] );\n\n\t\t\t}\n\n\t\t\tcurrentTransform.copy( transform );\n\t\t\ttransformStack.push( transform );\n\n\t\t\treturn transform;\n\n\t\t}\n\n\t\tfunction parseNodeTransform( node ) {\n\n\t\t\tvar transform = new Matrix3();\n\t\t\tvar currentTransform = tempTransform0;\n\t\t\tvar transformsTexts = node.getAttribute( 'transform' ).split( ')' );\n\n\t\t\tfor ( var tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex -- ) {\n\n\t\t\t\tvar transformText = transformsTexts[ tIndex ].trim();\n\n\t\t\t\tif ( transformText === '' ) continue;\n\n\t\t\t\tvar openParPos = transformText.indexOf( '(' );\n\t\t\t\tvar closeParPos = transformText.length;\n\n\t\t\t\tif ( openParPos > 0 && openParPos < closeParPos ) {\n\n\t\t\t\t\tvar transformType = transformText.substr( 0, openParPos );\n\n\t\t\t\t\tvar array = parseFloats( transformText.substr( openParPos + 1, closeParPos - openParPos - 1 ) );\n\n\t\t\t\t\tcurrentTransform.identity();\n\n\t\t\t\t\tswitch ( transformType ) {\n\n\t\t\t\t\t\tcase \"translate\":\n\n\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\tvar tx = array[ 0 ];\n\t\t\t\t\t\t\t\tvar ty = tx;\n\n\t\t\t\t\t\t\t\tif ( array.length >= 2 ) {\n\n\t\t\t\t\t\t\t\t\tty = array[ 1 ];\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tcurrentTransform.translate( tx, ty );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase \"rotate\":\n\n\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\tvar angle = 0;\n\t\t\t\t\t\t\t\tvar cx = 0;\n\t\t\t\t\t\t\t\tvar cy = 0;\n\n\t\t\t\t\t\t\t\t// Angle\n\t\t\t\t\t\t\t\tangle = - array[ 0 ] * Math.PI / 180;\n\n\t\t\t\t\t\t\t\tif ( array.length >= 3 ) {\n\n\t\t\t\t\t\t\t\t\t// Center x, y\n\t\t\t\t\t\t\t\t\tcx = array[ 1 ];\n\t\t\t\t\t\t\t\t\tcy = array[ 2 ];\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Rotate around center (cx, cy)\n\t\t\t\t\t\t\t\ttempTransform1.identity().translate( - cx, - cy );\n\t\t\t\t\t\t\t\ttempTransform2.identity().rotate( angle );\n\t\t\t\t\t\t\t\ttempTransform3.multiplyMatrices( tempTransform2, tempTransform1 );\n\t\t\t\t\t\t\t\ttempTransform1.identity().translate( cx, cy );\n\t\t\t\t\t\t\t\tcurrentTransform.multiplyMatrices( tempTransform1, tempTransform3 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase \"scale\":\n\n\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\tvar scaleX = array[ 0 ];\n\t\t\t\t\t\t\t\tvar scaleY = scaleX;\n\n\t\t\t\t\t\t\t\tif ( array.length >= 2 ) {\n\n\t\t\t\t\t\t\t\t\tscaleY = array[ 1 ];\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tcurrentTransform.scale( scaleX, scaleY );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase \"skewX\":\n\n\t\t\t\t\t\t\tif ( array.length === 1 ) {\n\n\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t1, Math.tan( array[ 0 ] * Math.PI / 180 ), 0,\n\t\t\t\t\t\t\t\t\t0, 1, 0,\n\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase \"skewY\":\n\n\t\t\t\t\t\t\tif ( array.length === 1 ) {\n\n\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t1, 0, 0,\n\t\t\t\t\t\t\t\t\tMath.tan( array[ 0 ] * Math.PI / 180 ), 1, 0,\n\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase \"matrix\":\n\n\t\t\t\t\t\t\tif ( array.length === 6 ) {\n\n\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\tarray[ 0 ], array[ 2 ], array[ 4 ],\n\t\t\t\t\t\t\t\t\tarray[ 1 ], array[ 3 ], array[ 5 ],\n\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\ttransform.premultiply( currentTransform );\n\n\t\t\t}\n\n\t\t\treturn transform;\n\n\t\t}\n\n\t\tfunction transformPath( path, m ) {\n\n\t\t\tfunction transfVec2( v2 ) {\n\n\t\t\t\ttempV3.set( v2.x, v2.y, 1 ).applyMatrix3( m );\n\n\t\t\t\tv2.set( tempV3.x, tempV3.y );\n\n\t\t\t}\n\n\t\t\tvar isRotated = isTransformRotated( m );\n\n\t\t\tvar subPaths = path.subPaths;\n\n\t\t\tfor ( var i = 0, n = subPaths.length; i < n; i ++ ) {\n\n\t\t\t\tvar subPath = subPaths[ i ];\n\t\t\t\tvar curves = subPath.curves;\n\n\t\t\t\tfor ( var j = 0; j < curves.length; j ++ ) {\n\n\t\t\t\t\tvar curve = curves[ j ];\n\n\t\t\t\t\tif ( curve.isLineCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\n\t\t\t\t\t} else if ( curve.isCubicBezierCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v0 );\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\t\t\t\t\t\ttransfVec2( curve.v3 );\n\n\t\t\t\t\t} else if ( curve.isQuadraticBezierCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v0 );\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\n\t\t\t\t\t} else if ( curve.isEllipseCurve ) {\n\n\t\t\t\t\t\tif ( isRotated ) {\n\n\t\t\t\t\t\t\tconsole.warn( \"SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented.\" );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttempV2.set( curve.aX, curve.aY );\n\t\t\t\t\t\ttransfVec2( tempV2 );\n\t\t\t\t\t\tcurve.aX = tempV2.x;\n\t\t\t\t\t\tcurve.aY = tempV2.y;\n\n\t\t\t\t\t\tcurve.xRadius *= getTransformScaleX( m );\n\t\t\t\t\t\tcurve.yRadius *= getTransformScaleY( m );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction isTransformRotated( m ) {\n\n\t\t\treturn m.elements[ 1 ] !== 0 || m.elements[ 3 ] !== 0;\n\n\t\t}\n\n\t\tfunction getTransformScaleX( m ) {\n\n\t\t\tvar te = m.elements;\n\t\t\treturn Math.sqrt( te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] );\n\n\t\t}\n\n\t\tfunction getTransformScaleY( m ) {\n\n\t\t\tvar te = m.elements;\n\t\t\treturn Math.sqrt( te[ 3 ] * te[ 3 ] + te[ 4 ] * te[ 4 ] );\n\n\t\t}\n\n\t\t//\n\n\t\tvar paths = [];\n\t\tvar stylesheets = {};\n\n\t\tvar transformStack = [];\n\n\t\tvar tempTransform0 = new Matrix3();\n\t\tvar tempTransform1 = new Matrix3();\n\t\tvar tempTransform2 = new Matrix3();\n\t\tvar tempTransform3 = new Matrix3();\n\t\tvar tempV2 = new Vector2();\n\t\tvar tempV3 = new Vector3();\n\n\t\tvar currentTransform = new Matrix3();\n\n\t\tvar xml = new DOMParser().parseFromString( text, 'image/svg+xml' ); // application/xml\n\n\t\tparseNode( xml.documentElement, {\n\t\t\tfill: '#000',\n\t\t\tfillOpacity: 1,\n\t\t\tstrokeOpacity: 1,\n\t\t\tstrokeWidth: 1,\n\t\t\tstrokeLineJoin: 'miter',\n\t\t\tstrokeLineCap: 'butt',\n\t\t\tstrokeMiterLimit: 4\n\t\t} );\n\n\t\tvar data = { paths: paths, xml: xml.documentElement };\n\n\t\t// console.log( paths );\n\t\treturn data;\n\n\t}\n\n} );\n\nSVGLoader.getStrokeStyle = function ( width, color, lineJoin, lineCap, miterLimit ) {\n\n\t// Param width: Stroke width\n\t// Param color: As returned by THREE.Color.getStyle()\n\t// Param lineJoin: One of \"round\", \"bevel\", \"miter\" or \"miter-limit\"\n\t// Param lineCap: One of \"round\", \"square\" or \"butt\"\n\t// Param miterLimit: Maximum join length, in multiples of the \"width\" parameter (join is truncated if it exceeds that distance)\n\t// Returns style object\n\n\twidth = width !== undefined ? width : 1;\n\tcolor = color !== undefined ? color : '#000';\n\tlineJoin = lineJoin !== undefined ? lineJoin : 'miter';\n\tlineCap = lineCap !== undefined ? lineCap : 'butt';\n\tmiterLimit = miterLimit !== undefined ? miterLimit : 4;\n\n\treturn {\n\t\tstrokeColor: color,\n\t\tstrokeWidth: width,\n\t\tstrokeLineJoin: lineJoin,\n\t\tstrokeLineCap: lineCap,\n\t\tstrokeMiterLimit: miterLimit\n\t};\n\n};\n\nSVGLoader.pointsToStroke = function ( points, style, arcDivisions, minDistance ) {\n\n\t// Generates a stroke with some witdh around the given path.\n\t// The path can be open or closed (last point equals to first point)\n\t// Param points: Array of Vector2D (the path). Minimum 2 points.\n\t// Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object\n\t// Params arcDivisions: Arc divisions for round joins and endcaps. (Optional)\n\t// Param minDistance: Points closer to this distance will be merged. (Optional)\n\t// Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right)\n\n\tvar vertices = [];\n\tvar normals = [];\n\tvar uvs = [];\n\n\tif ( SVGLoader.pointsToStrokeWithBuffers( points, style, arcDivisions, minDistance, vertices, normals, uvs ) === 0 ) {\n\n\t\treturn null;\n\n\t}\n\n\tvar geometry = new BufferGeometry();\n\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tgeometry.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\tgeometry.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\treturn geometry;\n\n};\n\nSVGLoader.pointsToStrokeWithBuffers = function () {\n\n\tvar tempV2_1 = new Vector2();\n\tvar tempV2_2 = new Vector2();\n\tvar tempV2_3 = new Vector2();\n\tvar tempV2_4 = new Vector2();\n\tvar tempV2_5 = new Vector2();\n\tvar tempV2_6 = new Vector2();\n\tvar tempV2_7 = new Vector2();\n\tvar lastPointL = new Vector2();\n\tvar lastPointR = new Vector2();\n\tvar point0L = new Vector2();\n\tvar point0R = new Vector2();\n\tvar currentPointL = new Vector2();\n\tvar currentPointR = new Vector2();\n\tvar nextPointL = new Vector2();\n\tvar nextPointR = new Vector2();\n\tvar innerPoint = new Vector2();\n\tvar outerPoint = new Vector2();\n\n\treturn function ( points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset ) {\n\n\t\t// This function can be called to update existing arrays or buffers.\n\t\t// Accepts same parameters as pointsToStroke, plus the buffers and optional offset.\n\t\t// Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)\n\t\t// Returns number of written vertices / normals / uvs pairs\n\t\t// if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)\n\t\t// 'normals' and 'uvs' buffers are optional\n\n\t\tarcDivisions = arcDivisions !== undefined ? arcDivisions : 12;\n\t\tminDistance = minDistance !== undefined ? minDistance : 0.001;\n\t\tvertexOffset = vertexOffset !== undefined ? vertexOffset : 0;\n\n\t\t// First ensure there are no duplicated points\n\t\tpoints = removeDuplicatedPoints( points );\n\n\t\tvar numPoints = points.length;\n\n\t\tif ( numPoints < 2 ) return 0;\n\n\t\tvar isClosed = points[ 0 ].equals( points[ numPoints - 1 ] );\n\n\t\tvar currentPoint;\n\t\tvar previousPoint = points[ 0 ];\n\t\tvar nextPoint;\n\n\t\tvar strokeWidth2 = style.strokeWidth / 2;\n\n\t\tvar deltaU = 1 / ( numPoints - 1 );\n\t\tvar u0 = 0;\n\n\t\tvar innerSideModified;\n\t\tvar joinIsOnLeftSide;\n\t\tvar isMiter;\n\t\tvar initialJoinIsOnLeftSide = false;\n\n\t\tvar numVertices = 0;\n\t\tvar currentCoordinate = vertexOffset * 3;\n\t\tvar currentCoordinateUV = vertexOffset * 2;\n\n\t\t// Get initial left and right stroke points\n\t\tgetNormal( points[ 0 ], points[ 1 ], tempV2_1 ).multiplyScalar( strokeWidth2 );\n\t\tlastPointL.copy( points[ 0 ] ).sub( tempV2_1 );\n\t\tlastPointR.copy( points[ 0 ] ).add( tempV2_1 );\n\t\tpoint0L.copy( lastPointL );\n\t\tpoint0R.copy( lastPointR );\n\n\t\tfor ( var iPoint = 1; iPoint < numPoints; iPoint ++ ) {\n\n\t\t\tcurrentPoint = points[ iPoint ];\n\n\t\t\t// Get next point\n\t\t\tif ( iPoint === numPoints - 1 ) {\n\n\t\t\t\tif ( isClosed ) {\n\n\t\t\t\t\t// Skip duplicated initial point\n\t\t\t\t\tnextPoint = points[ 1 ];\n\n\t\t\t\t} else nextPoint = undefined;\n\n\t\t\t} else {\n\n\t\t\t\tnextPoint = points[ iPoint + 1 ];\n\n\t\t\t}\n\n\t\t\t// Normal of previous segment in tempV2_1\n\t\t\tvar normal1 = tempV2_1;\n\t\t\tgetNormal( previousPoint, currentPoint, normal1 );\n\n\t\t\ttempV2_3.copy( normal1 ).multiplyScalar( strokeWidth2 );\n\t\t\tcurrentPointL.copy( currentPoint ).sub( tempV2_3 );\n\t\t\tcurrentPointR.copy( currentPoint ).add( tempV2_3 );\n\n\t\t\tvar u1 = u0 + deltaU;\n\n\t\t\tinnerSideModified = false;\n\n\t\t\tif ( nextPoint !== undefined ) {\n\n\t\t\t\t// Normal of next segment in tempV2_2\n\t\t\t\tgetNormal( currentPoint, nextPoint, tempV2_2 );\n\n\t\t\t\ttempV2_3.copy( tempV2_2 ).multiplyScalar( strokeWidth2 );\n\t\t\t\tnextPointL.copy( currentPoint ).sub( tempV2_3 );\n\t\t\t\tnextPointR.copy( currentPoint ).add( tempV2_3 );\n\n\t\t\t\tjoinIsOnLeftSide = true;\n\t\t\t\ttempV2_3.subVectors( nextPoint, previousPoint );\n\t\t\t\tif ( normal1.dot( tempV2_3 ) < 0 ) {\n\n\t\t\t\t\tjoinIsOnLeftSide = false;\n\n\t\t\t\t}\n\n\t\t\t\tif ( iPoint === 1 ) initialJoinIsOnLeftSide = joinIsOnLeftSide;\n\n\t\t\t\ttempV2_3.subVectors( nextPoint, currentPoint );\n\t\t\t\ttempV2_3.normalize();\n\t\t\t\tvar dot = Math.abs( normal1.dot( tempV2_3 ) );\n\n\t\t\t\t// If path is straight, don't create join\n\t\t\t\tif ( dot !== 0 ) {\n\n\t\t\t\t\t// Compute inner and outer segment intersections\n\t\t\t\t\tvar miterSide = strokeWidth2 / dot;\n\t\t\t\t\ttempV2_3.multiplyScalar( - miterSide );\n\t\t\t\t\ttempV2_4.subVectors( currentPoint, previousPoint );\n\t\t\t\t\ttempV2_5.copy( tempV2_4 ).setLength( miterSide ).add( tempV2_3 );\n\t\t\t\t\tinnerPoint.copy( tempV2_5 ).negate();\n\t\t\t\t\tvar miterLength2 = tempV2_5.length();\n\t\t\t\t\tvar segmentLengthPrev = tempV2_4.length();\n\t\t\t\t\ttempV2_4.divideScalar( segmentLengthPrev );\n\t\t\t\t\ttempV2_6.subVectors( nextPoint, currentPoint );\n\t\t\t\t\tvar segmentLengthNext = tempV2_6.length();\n\t\t\t\t\ttempV2_6.divideScalar( segmentLengthNext );\n\t\t\t\t\t// Check that previous and next segments doesn't overlap with the innerPoint of intersection\n\t\t\t\t\tif ( tempV2_4.dot( innerPoint ) < segmentLengthPrev && tempV2_6.dot( innerPoint ) < segmentLengthNext ) {\n\n\t\t\t\t\t\tinnerSideModified = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\touterPoint.copy( tempV2_5 ).add( currentPoint );\n\t\t\t\t\tinnerPoint.add( currentPoint );\n\n\t\t\t\t\tisMiter = false;\n\n\t\t\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\tnextPointR.copy( innerPoint );\n\t\t\t\t\t\t\tcurrentPointR.copy( innerPoint );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tnextPointL.copy( innerPoint );\n\t\t\t\t\t\t\tcurrentPointL.copy( innerPoint );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// The segment triangles are generated here if there was overlapping\n\n\t\t\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch ( style.strokeLineJoin ) {\n\n\t\t\t\t\t\tcase 'bevel':\n\n\t\t\t\t\t\t\tmakeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'round':\n\n\t\t\t\t\t\t\t// Segment triangles\n\n\t\t\t\t\t\t\tcreateSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );\n\n\t\t\t\t\t\t\t// Join triangles\n\n\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\tmakeCircularSector( currentPoint, currentPointL, nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tmakeCircularSector( currentPoint, nextPointR, currentPointR, u1, 1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'miter':\n\t\t\t\t\t\tcase 'miter-clip':\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tvar miterFraction = ( strokeWidth2 * style.strokeMiterLimit ) / miterLength2;\n\n\t\t\t\t\t\t\tif ( miterFraction < 1 ) {\n\n\t\t\t\t\t\t\t\t// The join miter length exceeds the miter limit\n\n\t\t\t\t\t\t\t\tif ( style.strokeLineJoin !== 'miter-clip' ) {\n\n\t\t\t\t\t\t\t\t\tmakeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// Segment triangles\n\n\t\t\t\t\t\t\t\t\tcreateSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );\n\n\t\t\t\t\t\t\t\t\t// Miter-clip join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\ttempV2_6.subVectors( outerPoint, currentPointL ).multiplyScalar( miterFraction ).add( currentPointL );\n\t\t\t\t\t\t\t\t\t\ttempV2_7.subVectors( outerPoint, nextPointL ).multiplyScalar( miterFraction ).add( nextPointL );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\ttempV2_6.subVectors( outerPoint, currentPointR ).multiplyScalar( miterFraction ).add( currentPointR );\n\t\t\t\t\t\t\t\t\t\ttempV2_7.subVectors( outerPoint, nextPointR ).multiplyScalar( miterFraction ).add( nextPointR );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointR, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Miter join segment triangles\n\n\t\t\t\t\t\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t\t\t\t\t\t// Optimized segment + join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\tnextPointL.copy( outerPoint );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\tnextPointR.copy( outerPoint );\n\n\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// Add extra miter join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointR, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tisMiter = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// The segment triangles are generated here when two consecutive points are collinear\n\n\t\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// The segment triangles are generated here if it is the ending segment\n\n\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t}\n\n\t\t\tif ( ! isClosed && iPoint === numPoints - 1 ) {\n\n\t\t\t\t// Start line endcap\n\t\t\t\taddCapGeometry( points[ 0 ], point0L, point0R, joinIsOnLeftSide, true, u0 );\n\n\t\t\t}\n\n\t\t\t// Increment loop variables\n\n\t\t\tu0 = u1;\n\n\t\t\tpreviousPoint = currentPoint;\n\n\t\t\tlastPointL.copy( nextPointL );\n\t\t\tlastPointR.copy( nextPointR );\n\n\t\t}\n\n\t\tif ( ! isClosed ) {\n\n\t\t\t// Ending line endcap\n\t\t\taddCapGeometry( currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1 );\n\n\t\t} else if ( innerSideModified && vertices ) {\n\n\t\t\t// Modify path first segment vertices to adjust to the segments inner and outer intersections\n\n\t\t\tvar lastOuter = outerPoint;\n\t\t\tvar lastInner = innerPoint;\n\n\t\t\tif ( initialJoinIsOnLeftSide !== joinIsOnLeftSide ) {\n\n\t\t\t\tlastOuter = innerPoint;\n\t\t\t\tlastInner = outerPoint;\n\n\t\t\t}\n\n\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\tif ( isMiter || initialJoinIsOnLeftSide ) {\n\n\t\t\t\t\tlastInner.toArray( vertices, 0 * 3 );\n\t\t\t\t\tlastInner.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\tif ( isMiter ) {\n\n\t\t\t\t\t\tlastOuter.toArray( vertices, 1 * 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( isMiter || ! initialJoinIsOnLeftSide ) {\n\n\t\t\t\t\tlastInner.toArray( vertices, 1 * 3 );\n\t\t\t\t\tlastInner.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\tif ( isMiter ) {\n\n\t\t\t\t\t\tlastOuter.toArray( vertices, 0 * 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn numVertices;\n\n\t\t// -- End of algorithm\n\n\t\t// -- Functions\n\n\t\tfunction getNormal( p1, p2, result ) {\n\n\t\t\tresult.subVectors( p2, p1 );\n\t\t\treturn result.set( - result.y, result.x ).normalize();\n\n\t\t}\n\n\t\tfunction addVertex( position, u, v ) {\n\n\t\t\tif ( vertices ) {\n\n\t\t\t\tvertices[ currentCoordinate ] = position.x;\n\t\t\t\tvertices[ currentCoordinate + 1 ] = position.y;\n\t\t\t\tvertices[ currentCoordinate + 2 ] = 0;\n\n\t\t\t\tif ( normals ) {\n\n\t\t\t\t\tnormals[ currentCoordinate ] = 0;\n\t\t\t\t\tnormals[ currentCoordinate + 1 ] = 0;\n\t\t\t\t\tnormals[ currentCoordinate + 2 ] = 1;\n\n\t\t\t\t}\n\n\t\t\t\tcurrentCoordinate += 3;\n\n\t\t\t\tif ( uvs ) {\n\n\t\t\t\t\tuvs[ currentCoordinateUV ] = u;\n\t\t\t\t\tuvs[ currentCoordinateUV + 1 ] = v;\n\n\t\t\t\t\tcurrentCoordinateUV += 2;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnumVertices += 3;\n\n\t\t}\n\n\t\tfunction makeCircularSector( center, p1, p2, u, v ) {\n\n\t\t\t// param p1, p2: Points in the circle arc.\n\t\t\t// p1 and p2 are in clockwise direction.\n\n\t\t\ttempV2_1.copy( p1 ).sub( center ).normalize();\n\t\t\ttempV2_2.copy( p2 ).sub( center ).normalize();\n\n\t\t\tvar angle = Math.PI;\n\t\t\tvar dot = tempV2_1.dot( tempV2_2 );\n\t\t\tif ( Math.abs( dot ) < 1 ) angle = Math.abs( Math.acos( dot ) );\n\n\t\t\tangle /= arcDivisions;\n\n\t\t\ttempV2_3.copy( p1 );\n\n\t\t\tfor ( var i = 0, il = arcDivisions - 1; i < il; i ++ ) {\n\n\t\t\t\ttempV2_4.copy( tempV2_3 ).rotateAround( center, angle );\n\n\t\t\t\taddVertex( tempV2_3, u, v );\n\t\t\t\taddVertex( tempV2_4, u, v );\n\t\t\t\taddVertex( center, u, 0.5 );\n\n\t\t\t\ttempV2_3.copy( tempV2_4 );\n\n\t\t\t}\n\n\t\t\taddVertex( tempV2_4, u, v );\n\t\t\taddVertex( p2, u, v );\n\t\t\taddVertex( center, u, 0.5 );\n\n\t\t}\n\n\t\tfunction makeSegmentTriangles() {\n\n\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\taddVertex( currentPointL, u1, 1 );\n\t\t\taddVertex( currentPointR, u1, 0 );\n\n\t\t}\n\n\t\tfunction makeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u ) {\n\n\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t// Optimized segment + bevel triangles\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t// Path segments triangles\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t// Bevel join triangle\n\n\t\t\t\t\taddVertex( currentPointL, u, 0 );\n\t\t\t\t\taddVertex( nextPointL, u, 0 );\n\t\t\t\t\taddVertex( innerPoint, u, 0.5 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Path segments triangles\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\t// Bevel join triangle\n\n\t\t\t\t\taddVertex( currentPointR, u, 1 );\n\t\t\t\t\taddVertex( nextPointR, u, 0 );\n\t\t\t\t\taddVertex( innerPoint, u, 0.5 );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// Bevel join triangle. The segment triangles are done in the main loop\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\taddVertex( currentPointL, u, 0 );\n\t\t\t\t\taddVertex( nextPointL, u, 0 );\n\t\t\t\t\taddVertex( currentPoint, u, 0.5 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\taddVertex( currentPointR, u, 1 );\n\t\t\t\t\taddVertex( nextPointR, u, 0 );\n\t\t\t\t\taddVertex( currentPoint, u, 0.5 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction createSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified ) {\n\n\t\t\tif ( innerSideModified ) {\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( nextPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPointR, u0, 1 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( nextPointR, u0, 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction addCapGeometry( center, p1, p2, joinIsOnLeftSide, start, u ) {\n\n\t\t\t// param center: End point of the path\n\t\t\t// param p1, p2: Left and right cap points\n\n\t\t\tswitch ( style.strokeLineCap ) {\n\n\t\t\t\tcase 'round':\n\n\t\t\t\t\tif ( start ) {\n\n\t\t\t\t\t\tmakeCircularSector( center, p2, p1, u, 0.5 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmakeCircularSector( center, p1, p2, u, 0.5 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'square':\n\n\t\t\t\t\tif ( start ) {\n\n\t\t\t\t\t\ttempV2_1.subVectors( p1, center );\n\t\t\t\t\t\ttempV2_2.set( tempV2_1.y, - tempV2_1.x );\n\n\t\t\t\t\t\ttempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );\n\t\t\t\t\t\ttempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );\n\n\t\t\t\t\t\t// Modify already existing vertices\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 0 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 1 * 3 );\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 3 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 0 * 3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttempV2_1.subVectors( p2, center );\n\t\t\t\t\t\ttempV2_2.set( tempV2_1.y, - tempV2_1.x );\n\n\t\t\t\t\t\ttempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );\n\t\t\t\t\t\ttempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );\n\n\t\t\t\t\t\tvar vl = vertices.length;\n\n\t\t\t\t\t\t// Modify already existing vertices\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, vl - 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 2 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 4 * 3 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, vl - 2 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 4 * 3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'butt':\n\t\t\t\tdefault:\n\n\t\t\t\t\t// Nothing to do here\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction removeDuplicatedPoints( points ) {\n\n\t\t\t// Creates a new array if necessary with duplicated points removed.\n\t\t\t// This does not remove duplicated initial and ending points of a closed path.\n\n\t\t\tvar dupPoints = false;\n\t\t\tfor ( var i = 1, n = points.length - 1; i < n; i ++ ) {\n\n\t\t\t\tif ( points[ i ].distanceTo( points[ i + 1 ] ) < minDistance ) {\n\n\t\t\t\t\tdupPoints = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ! dupPoints ) return points;\n\n\t\t\tvar newPoints = [];\n\t\t\tnewPoints.push( points[ 0 ] );\n\n\t\t\tfor ( var i = 1, n = points.length - 1; i < n; i ++ ) {\n\n\t\t\t\tif ( points[ i ].distanceTo( points[ i + 1 ] ) >= minDistance ) {\n\n\t\t\t\t\tnewPoints.push( points[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnewPoints.push( points[ points.length - 1 ] );\n\n\t\t\treturn newPoints;\n\n\t\t}\n\n\t};\n\n}();\n\nexport { SVGLoader };\n"],"sourceRoot":""}