{"version":3,"sources":["webpack://polygonjs-engine/./modules/three/examples/jsm/loaders/EXRLoader.js"],"names":["EXRLoader","manager","call","this","type","prototype","Object","assign","create","constructor","parse","buffer","logBase","Math","pow","getBitsReturn","l","c","lc","getBits","nBits","uInt8Array","inOffset","parseUint8Array","hufTableBuffer","Array","hufUnpackEncTable","inDataView","ni","im","iM","hcode","p","value","zerun","i","nc","hufCanonicalCodeTable","hufLength","code","hufCode","getCharReturn","getChar","getCodeReturn","getCode","po","rlc","outBuffer","outBufferOffset","outBufferEndOffset","cs","Uint8Array","s","Int16","ref","UInt16","wdec14Return","a","b","wdec14","h","ls","hs","ai","as","bs","wav2Decode","j","nx","ox","ny","oy","p2","n","i00","i01","i10","i11","py","ey","oy1","oy2","ox1","ox2","px","ex","p01","p11","p10","hufUncompress","nCompressed","nRaw","initialInOffset","parseUint32","freq","hdec","len","lit","hufClearDecTable","hdecod","pl","plOffset","hufBuildDecTable","encodingTable","decodingTable","no","outOffset","inOffsetEnd","trunc","HUF_DECSIZE","hufDecode","predictor","source","t","length","d","interleaveScalar","out","t1","t2","floor","stop","decodeRunLength","size","byteLength","reader","DataView","getInt8","count","push","getUint8","unRleAC","currAcComp","acBuffer","halfZigBlock","acValue","dctComp","unZigZag","src","dst","decodeFloat16","dctInverse","data","cos","e","f","g","alpha","beta","theta","gamma","row","rowPtr","column","csc709Inverse","y","cb","cr","convertToHalf","idx","encodeFloat16","toLinear","float","sign","abs","uncompressZIP","info","compressed","array","slice","offset","console","error","inflate","Inflate","resize","verify","rawBuffer","decompress","tmpBuffer","uncompressDWA","viewer","width","lines","EXRHeader","channels","dwaHeader","version","parseInt64","unknownUncompressedSize","unknownCompressedSize","acCompressedSize","dcCompressedSize","rleCompressedSize","rleUncompressedSize","rleRawSize","totalAcUncompressedCount","totalDcUncompressedCount","acCompression","compression","channelRules","ruleSize","parseUint16","name","parseNullTerminatedString","parseUint8","index","Int8Array","channelData","cd","channel","decoded","pixelType","pLinear","height","cscSet","rule","Uint16Array","zlibInfo","dcBuffer","rleBuffer","outBufferEnd","rowOffsets","chan","rowPtrs","dataView","numFullBlocksX","numBlocksX","ceil","numBlocksY","leftoverX","leftoverY","currDcComp","dctData","rowBlock","comp","Float32Array","blocky","maxY","maxX","blockx","fill","setUint16","x","halfRow","getUint16","setFloat32","lossyDctDecode","rleOffset","rowOffsetBytes","byte","uintBuffer","endOffset","stringValue","TextDecoder","decode","parseUlong","uLong","getUint32","Uint32","Uint8","int","Number","getBigInt64","parseFloat32","getFloat32","binary","exponent","fraction","NaN","Infinity","floatView","int32View","Int32Array","val","bits","m","Uint16","parseValue","parseFixedLengthString","startOffset","xSampling","ySampling","parseChlist","redX","redY","greenX","greenY","blueX","blueY","whiteX","whiteY","parseChromaticities","parseCompression","xMin","yMin","xMax","yMax","parseBox2i","parseLineOrder","parseV2f","bufferDataView","keepReading","attributeName","attributeValue","uncompress","scanlineBlockSize","size_t","getValue","dataWindowHeight","dataWindow","tmpBufSize","bitmap","pizChannelData","minNonZero","maxNonZero","lut","k","reverseLutFromBitmap","start","nData","applyLut","tmpOffset","cp","end","set","numBlocks","byteArray","line","channelOffsets","R","G","B","A","compressionInfo","scanlineBlockIdx","line_y","true_y","channelID","cOff","header","format","setDataType","load","url","onLoad","onProgress","onError","texture","texData","encoding","minFilter","magFilter","generateMipmaps","flipY"],"mappings":"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","file":"modules_three-polygonjs-engine-EXRLoader.js.js","sourcesContent":["import {DataTextureLoader} from 'three/src/loaders/DataTextureLoader';\nimport {FloatType} from 'three/src/constants';\nimport {HalfFloatType} from 'three/src/constants';\nimport {LinearEncoding} from 'three/src/constants';\nimport {LinearFilter} from 'three/src/constants';\nimport {RGBAFormat} from 'three/src/constants';\nimport {RGBFormat} from 'three/src/constants';\n/**\n * @author Richard M. / https://github.com/richardmonette\n * @author ScieCode / http://github.com/sciecode\n *\n * OpenEXR loader which, currently, supports uncompressed, ZIP(S), RLE and PIZ wavelet compression.\n * Supports reading 16 and 32 bit data format.\n *\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\n * implementation, so I have preserved their copyright notices.\n */\n\nimport { Zlib } from \"../libs/inflate.module.min.js\";\n\n// /*\n// Copyright (c) 2014 - 2017, Syoyo Fujita\n// All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//     * Neither the name of the Syoyo Fujita nor the\n//       names of its contributors may be used to endorse or promote products\n//       derived from this software without specific prior written permission.\n\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// */\n\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\n\n// ///////////////////////////////////////////////////////////////////////////\n// //\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\n// // Digital Ltd. LLC\n// //\n// // All rights reserved.\n// //\n// // Redistribution and use in source and binary forms, with or without\n// // modification, are permitted provided that the following conditions are\n// // met:\n// // *       Redistributions of source code must retain the above copyright\n// // notice, this list of conditions and the following disclaimer.\n// // *       Redistributions in binary form must reproduce the above\n// // copyright notice, this list of conditions and the following disclaimer\n// // in the documentation and/or other materials provided with the\n// // distribution.\n// // *       Neither the name of Industrial Light & Magic nor the names of\n// // its contributors may be used to endorse or promote products derived\n// // from this software without specific prior written permission.\n// //\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// //\n// ///////////////////////////////////////////////////////////////////////////\n\n// // End of OpenEXR license -------------------------------------------------\n\nvar EXRLoader = function ( manager ) {\n\n\tDataTextureLoader.call( this, manager );\n\n\tthis.type = FloatType;\n\n};\n\nEXRLoader.prototype = Object.assign( Object.create( DataTextureLoader.prototype ), {\n\n\tconstructor: EXRLoader,\n\n\tparse: function ( buffer ) {\n\n\t\tconst USHORT_RANGE = ( 1 << 16 );\n\t\tconst BITMAP_SIZE = ( USHORT_RANGE >> 3 );\n\n\t\tconst HUF_ENCBITS = 16; // literal (value) bit length\n\t\tconst HUF_DECBITS = 14; // decoding bit size (>= 8)\n\n\t\tconst HUF_ENCSIZE = ( 1 << HUF_ENCBITS ) + 1; // encoding table size\n\t\tconst HUF_DECSIZE = 1 << HUF_DECBITS; // decoding table size\n\t\tconst HUF_DECMASK = HUF_DECSIZE - 1;\n\n\t\tconst SHORT_ZEROCODE_RUN = 59;\n\t\tconst LONG_ZEROCODE_RUN = 63;\n\t\tconst SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\n\n\t\tconst ULONG_SIZE = 8;\n\t\tconst FLOAT32_SIZE = 4;\n\t\tconst INT32_SIZE = 4;\n\t\tconst INT16_SIZE = 2;\n\t\tconst INT8_SIZE = 1;\n\n\t\tconst STATIC_HUFFMAN = 0;\n\t\tconst DEFLATE = 1;\n\n\t\tconst UNKNOWN = 0;\n\t\tconst LOSSY_DCT = 1;\n\t\tconst RLE = 2;\n\n\t\tconst logBase = Math.pow( 2.7182818, 2.2 );\n\n\t\tfunction reverseLutFromBitmap( bitmap, lut ) {\n\n\t\t\tvar k = 0;\n\n\t\t\tfor ( var i = 0; i < USHORT_RANGE; ++ i ) {\n\n\t\t\t\tif ( ( i == 0 ) || ( bitmap[ i >> 3 ] & ( 1 << ( i & 7 ) ) ) ) {\n\n\t\t\t\t\tlut[ k ++ ] = i;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar n = k - 1;\n\n\t\t\twhile ( k < USHORT_RANGE ) lut[ k ++ ] = 0;\n\n\t\t\treturn n;\n\n\t\t}\n\n\t\tfunction hufClearDecTable( hdec ) {\n\n\t\t\tfor ( var i = 0; i < HUF_DECSIZE; i ++ ) {\n\n\t\t\t\thdec[ i ] = {};\n\t\t\t\thdec[ i ].len = 0;\n\t\t\t\thdec[ i ].lit = 0;\n\t\t\t\thdec[ i ].p = null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst getBitsReturn = { l: 0, c: 0, lc: 0 };\n\n\t\tfunction getBits( nBits, c, lc, uInt8Array, inOffset ) {\n\n\t\t\twhile ( lc < nBits ) {\n\n\t\t\t\tc = ( c << 8 ) | parseUint8Array( uInt8Array, inOffset );\n\t\t\t\tlc += 8;\n\n\t\t\t}\n\n\t\t\tlc -= nBits;\n\n\t\t\tgetBitsReturn.l = ( c >> lc ) & ( ( 1 << nBits ) - 1 );\n\t\t\tgetBitsReturn.c = c;\n\t\t\tgetBitsReturn.lc = lc;\n\n\t\t}\n\n\t\tconst hufTableBuffer = new Array( 59 );\n\n\t\tfunction hufCanonicalCodeTable( hcode ) {\n\n\t\t\tfor ( var i = 0; i <= 58; ++ i ) hufTableBuffer[ i ] = 0;\n\t\t\tfor ( var i = 0; i < HUF_ENCSIZE; ++ i ) hufTableBuffer[ hcode[ i ] ] += 1;\n\n\t\t\tvar c = 0;\n\n\t\t\tfor ( var i = 58; i > 0; -- i ) {\n\n\t\t\t\tvar nc = ( ( c + hufTableBuffer[ i ] ) >> 1 );\n\t\t\t\thufTableBuffer[ i ] = c;\n\t\t\t\tc = nc;\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i < HUF_ENCSIZE; ++ i ) {\n\n\t\t\t\tvar l = hcode[ i ];\n\t\t\t\tif ( l > 0 ) hcode[ i ] = l | ( hufTableBuffer[ l ] ++ << 6 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction hufUnpackEncTable( uInt8Array, inDataView, inOffset, ni, im, iM, hcode ) {\n\n\t\t\tvar p = inOffset;\n\t\t\tvar c = 0;\n\t\t\tvar lc = 0;\n\n\t\t\tfor ( ; im <= iM; im ++ ) {\n\n\t\t\t\tif ( p.value - inOffset.value > ni ) return false;\n\n\t\t\t\tgetBits( 6, c, lc, uInt8Array, p );\n\n\t\t\t\tvar l = getBitsReturn.l;\n\t\t\t\tc = getBitsReturn.c;\n\t\t\t\tlc = getBitsReturn.lc;\n\n\t\t\t\thcode[ im ] = l;\n\n\t\t\t\tif ( l == LONG_ZEROCODE_RUN ) {\n\n\t\t\t\t\tif ( p.value - inOffset.value > ni ) {\n\n\t\t\t\t\t\tthrow 'Something wrong with hufUnpackEncTable';\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgetBits( 8, c, lc, uInt8Array, p );\n\n\t\t\t\t\tvar zerun = getBitsReturn.l + SHORTEST_LONG_RUN;\n\t\t\t\t\tc = getBitsReturn.c;\n\t\t\t\t\tlc = getBitsReturn.lc;\n\n\t\t\t\t\tif ( im + zerun > iM + 1 ) {\n\n\t\t\t\t\t\tthrow 'Something wrong with hufUnpackEncTable';\n\n\t\t\t\t\t}\n\n\t\t\t\t\twhile ( zerun -- ) hcode[ im ++ ] = 0;\n\n\t\t\t\t\tim --;\n\n\t\t\t\t} else if ( l >= SHORT_ZEROCODE_RUN ) {\n\n\t\t\t\t\tvar zerun = l - SHORT_ZEROCODE_RUN + 2;\n\n\t\t\t\t\tif ( im + zerun > iM + 1 ) {\n\n\t\t\t\t\t\tthrow 'Something wrong with hufUnpackEncTable';\n\n\t\t\t\t\t}\n\n\t\t\t\t\twhile ( zerun -- ) hcode[ im ++ ] = 0;\n\n\t\t\t\t\tim --;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\thufCanonicalCodeTable( hcode );\n\n\t\t}\n\n\t\tfunction hufLength( code ) {\n\n\t\t\treturn code & 63;\n\n\t\t}\n\n\t\tfunction hufCode( code ) {\n\n\t\t\treturn code >> 6;\n\n\t\t}\n\n\t\tfunction hufBuildDecTable( hcode, im, iM, hdecod ) {\n\n\t\t\tfor ( ; im <= iM; im ++ ) {\n\n\t\t\t\tvar c = hufCode( hcode[ im ] );\n\t\t\t\tvar l = hufLength( hcode[ im ] );\n\n\t\t\t\tif ( c >> l ) {\n\n\t\t\t\t\tthrow 'Invalid table entry';\n\n\t\t\t\t}\n\n\t\t\t\tif ( l > HUF_DECBITS ) {\n\n\t\t\t\t\tvar pl = hdecod[ ( c >> ( l - HUF_DECBITS ) ) ];\n\n\t\t\t\t\tif ( pl.len ) {\n\n\t\t\t\t\t\tthrow 'Invalid table entry';\n\n\t\t\t\t\t}\n\n\t\t\t\t\tpl.lit ++;\n\n\t\t\t\t\tif ( pl.p ) {\n\n\t\t\t\t\t\tvar p = pl.p;\n\t\t\t\t\t\tpl.p = new Array( pl.lit );\n\n\t\t\t\t\t\tfor ( var i = 0; i < pl.lit - 1; ++ i ) {\n\n\t\t\t\t\t\t\tpl.p[ i ] = p[ i ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpl.p = new Array( 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tpl.p[ pl.lit - 1 ] = im;\n\n\t\t\t\t} else if ( l ) {\n\n\t\t\t\t\tvar plOffset = 0;\n\n\t\t\t\t\tfor ( var i = 1 << ( HUF_DECBITS - l ); i > 0; i -- ) {\n\n\t\t\t\t\t\tvar pl = hdecod[ ( c << ( HUF_DECBITS - l ) ) + plOffset ];\n\n\t\t\t\t\t\tif ( pl.len || pl.p ) {\n\n\t\t\t\t\t\t\tthrow 'Invalid table entry';\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpl.len = l;\n\t\t\t\t\t\tpl.lit = im;\n\n\t\t\t\t\t\tplOffset ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tconst getCharReturn = { c: 0, lc: 0 };\n\n\t\tfunction getChar( c, lc, uInt8Array, inOffset ) {\n\n\t\t\tc = ( c << 8 ) | parseUint8Array( uInt8Array, inOffset );\n\t\t\tlc += 8;\n\n\t\t\tgetCharReturn.c = c;\n\t\t\tgetCharReturn.lc = lc;\n\n\t\t}\n\n\t\tconst getCodeReturn = { c: 0, lc: 0 };\n\n\t\tfunction getCode( po, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset ) {\n\n\t\t\tif ( po == rlc ) {\n\n\t\t\t\tif ( lc < 8 ) {\n\n\t\t\t\t\tgetChar( c, lc, uInt8Array, inOffset );\n\t\t\t\t\tc = getCharReturn.c;\n\t\t\t\t\tlc = getCharReturn.lc;\n\n\t\t\t\t}\n\n\t\t\t\tlc -= 8;\n\n\t\t\t\tvar cs = ( c >> lc );\n\t\t\t\tvar cs = new Uint8Array( [ cs ] )[ 0 ];\n\n\t\t\t\tif ( outBufferOffset.value + cs > outBufferEndOffset ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\tvar s = outBuffer[ outBufferOffset.value - 1 ];\n\n\t\t\t\twhile ( cs -- > 0 ) {\n\n\t\t\t\t\toutBuffer[ outBufferOffset.value ++ ] = s;\n\n\t\t\t\t}\n\n\t\t\t} else if ( outBufferOffset.value < outBufferEndOffset ) {\n\n\t\t\t\toutBuffer[ outBufferOffset.value ++ ] = po;\n\n\t\t\t} else {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\tgetCodeReturn.c = c;\n\t\t\tgetCodeReturn.lc = lc;\n\n\t\t}\n\n\t\tfunction UInt16( value ) {\n\n\t\t\treturn ( value & 0xFFFF );\n\n\t\t}\n\n\t\tfunction Int16( value ) {\n\n\t\t\tvar ref = UInt16( value );\n\t\t\treturn ( ref > 0x7FFF ) ? ref - 0x10000 : ref;\n\n\t\t}\n\n\t\tconst wdec14Return = { a: 0, b: 0 };\n\n\t\tfunction wdec14( l, h ) {\n\n\t\t\tvar ls = Int16( l );\n\t\t\tvar hs = Int16( h );\n\n\t\t\tvar hi = hs;\n\t\t\tvar ai = ls + ( hi & 1 ) + ( hi >> 1 );\n\n\t\t\tvar as = ai;\n\t\t\tvar bs = ai - hi;\n\n\t\t\twdec14Return.a = as;\n\t\t\twdec14Return.b = bs;\n\n\t\t}\n\n\t\tfunction wav2Decode( buffer, j, nx, ox, ny, oy ) {\n\n\t\t\tvar n = ( nx > ny ) ? ny : nx;\n\t\t\tvar p = 1;\n\t\t\tvar p2;\n\n\t\t\twhile ( p <= n ) p <<= 1;\n\n\t\t\tp >>= 1;\n\t\t\tp2 = p;\n\t\t\tp >>= 1;\n\n\t\t\twhile ( p >= 1 ) {\n\n\t\t\t\tvar py = 0;\n\t\t\t\tvar ey = py + oy * ( ny - p2 );\n\t\t\t\tvar oy1 = oy * p;\n\t\t\t\tvar oy2 = oy * p2;\n\t\t\t\tvar ox1 = ox * p;\n\t\t\t\tvar ox2 = ox * p2;\n\t\t\t\tvar i00, i01, i10, i11;\n\n\t\t\t\tfor ( ; py <= ey; py += oy2 ) {\n\n\t\t\t\t\tvar px = py;\n\t\t\t\t\tvar ex = py + ox * ( nx - p2 );\n\n\t\t\t\t\tfor ( ; px <= ex; px += ox2 ) {\n\n\t\t\t\t\t\tvar p01 = px + ox1;\n\t\t\t\t\t\tvar p10 = px + oy1;\n\t\t\t\t\t\tvar p11 = p10 + ox1;\n\n\t\t\t\t\t\twdec14( buffer[ px + j ], buffer[ p10 + j ] );\n\n\t\t\t\t\t\ti00 = wdec14Return.a;\n\t\t\t\t\t\ti10 = wdec14Return.b;\n\n\t\t\t\t\t\twdec14( buffer[ p01 + j ], buffer[ p11 + j ] );\n\n\t\t\t\t\t\ti01 = wdec14Return.a;\n\t\t\t\t\t\ti11 = wdec14Return.b;\n\n\t\t\t\t\t\twdec14( i00, i01 );\n\n\t\t\t\t\t\tbuffer[ px + j ] = wdec14Return.a;\n\t\t\t\t\t\tbuffer[ p01 + j ] = wdec14Return.b;\n\n\t\t\t\t\t\twdec14( i10, i11 );\n\n\t\t\t\t\t\tbuffer[ p10 + j ] = wdec14Return.a;\n\t\t\t\t\t\tbuffer[ p11 + j ] = wdec14Return.b;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( nx & p ) {\n\n\t\t\t\t\t\tvar p10 = px + oy1;\n\n\t\t\t\t\t\twdec14( buffer[ px + j ], buffer[ p10 + j ] );\n\n\t\t\t\t\t\ti00 = wdec14Return.a;\n\t\t\t\t\t\tbuffer[ p10 + j ] = wdec14Return.b;\n\n\t\t\t\t\t\tbuffer[ px + j ] = i00;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( ny & p ) {\n\n\t\t\t\t\tvar px = py;\n\t\t\t\t\tvar ex = py + ox * ( nx - p2 );\n\n\t\t\t\t\tfor ( ; px <= ex; px += ox2 ) {\n\n\t\t\t\t\t\tvar p01 = px + ox1;\n\n\t\t\t\t\t\twdec14( buffer[ px + j ], buffer[ p01 + j ] );\n\n\t\t\t\t\t\ti00 = wdec14Return.a;\n\t\t\t\t\t\tbuffer[ p01 + j ] = wdec14Return.b;\n\n\t\t\t\t\t\tbuffer[ px + j ] = i00;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tp2 = p;\n\t\t\t\tp >>= 1;\n\n\t\t\t}\n\n\t\t\treturn py;\n\n\t\t}\n\n\t\tfunction hufDecode( encodingTable, decodingTable, uInt8Array, inDataView, inOffset, ni, rlc, no, outBuffer, outOffset ) {\n\n\t\t\tvar c = 0;\n\t\t\tvar lc = 0;\n\t\t\tvar outBufferEndOffset = no;\n\t\t\tvar inOffsetEnd = Math.trunc( inOffset.value + ( ni + 7 ) / 8 );\n\n\t\t\twhile ( inOffset.value < inOffsetEnd ) {\n\n\t\t\t\tgetChar( c, lc, uInt8Array, inOffset );\n\n\t\t\t\tc = getCharReturn.c;\n\t\t\t\tlc = getCharReturn.lc;\n\n\t\t\t\twhile ( lc >= HUF_DECBITS ) {\n\n\t\t\t\t\tvar index = ( c >> ( lc - HUF_DECBITS ) ) & HUF_DECMASK;\n\t\t\t\t\tvar pl = decodingTable[ index ];\n\n\t\t\t\t\tif ( pl.len ) {\n\n\t\t\t\t\t\tlc -= pl.len;\n\n\t\t\t\t\t\tgetCode( pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset );\n\n\t\t\t\t\t\tc = getCodeReturn.c;\n\t\t\t\t\t\tlc = getCodeReturn.lc;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( ! pl.p ) {\n\n\t\t\t\t\t\t\tthrow 'hufDecode issues';\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar j;\n\n\t\t\t\t\t\tfor ( j = 0; j < pl.lit; j ++ ) {\n\n\t\t\t\t\t\t\tvar l = hufLength( encodingTable[ pl.p[ j ] ] );\n\n\t\t\t\t\t\t\twhile ( lc < l && inOffset.value < inOffsetEnd ) {\n\n\t\t\t\t\t\t\t\tgetChar( c, lc, uInt8Array, inOffset );\n\n\t\t\t\t\t\t\t\tc = getCharReturn.c;\n\t\t\t\t\t\t\t\tlc = getCharReturn.lc;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( lc >= l ) {\n\n\t\t\t\t\t\t\t\tif ( hufCode( encodingTable[ pl.p[ j ] ] ) == ( ( c >> ( lc - l ) ) & ( ( 1 << l ) - 1 ) ) ) {\n\n\t\t\t\t\t\t\t\t\tlc -= l;\n\n\t\t\t\t\t\t\t\t\tgetCode( pl.p[ j ], rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset );\n\n\t\t\t\t\t\t\t\t\tc = getCodeReturn.c;\n\t\t\t\t\t\t\t\t\tlc = getCodeReturn.lc;\n\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( j == pl.lit ) {\n\n\t\t\t\t\t\t\tthrow 'hufDecode issues';\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar i = ( 8 - ni ) & 7;\n\n\t\t\tc >>= i;\n\t\t\tlc -= i;\n\n\t\t\twhile ( lc > 0 ) {\n\n\t\t\t\tvar pl = decodingTable[ ( c << ( HUF_DECBITS - lc ) ) & HUF_DECMASK ];\n\n\t\t\t\tif ( pl.len ) {\n\n\t\t\t\t\tlc -= pl.len;\n\n\t\t\t\t\tgetCode( pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset );\n\n\t\t\t\t\tc = getCodeReturn.c;\n\t\t\t\t\tlc = getCodeReturn.lc;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow 'hufDecode issues';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tfunction hufUncompress( uInt8Array, inDataView, inOffset, nCompressed, outBuffer, nRaw ) {\n\n\t\t\tvar outOffset = { value: 0 };\n\t\t\tvar initialInOffset = inOffset.value;\n\n\t\t\tvar im = parseUint32( inDataView, inOffset );\n\t\t\tvar iM = parseUint32( inDataView, inOffset );\n\n\t\t\tinOffset.value += 4;\n\n\t\t\tvar nBits = parseUint32( inDataView, inOffset );\n\n\t\t\tinOffset.value += 4;\n\n\t\t\tif ( im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE ) {\n\n\t\t\t\tthrow 'Something wrong with HUF_ENCSIZE';\n\n\t\t\t}\n\n\t\t\tvar freq = new Array( HUF_ENCSIZE );\n\t\t\tvar hdec = new Array( HUF_DECSIZE );\n\n\t\t\thufClearDecTable( hdec );\n\n\t\t\tvar ni = nCompressed - ( inOffset.value - initialInOffset );\n\n\t\t\thufUnpackEncTable( uInt8Array, inDataView, inOffset, ni, im, iM, freq );\n\n\t\t\tif ( nBits > 8 * ( nCompressed - ( inOffset.value - initialInOffset ) ) ) {\n\n\t\t\t\tthrow 'Something wrong with hufUncompress';\n\n\t\t\t}\n\n\t\t\thufBuildDecTable( freq, im, iM, hdec );\n\n\t\t\thufDecode( freq, hdec, uInt8Array, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset );\n\n\t\t}\n\n\t\tfunction applyLut( lut, data, nData ) {\n\n\t\t\tfor ( var i = 0; i < nData; ++ i ) {\n\n\t\t\t\tdata[ i ] = lut[ data[ i ] ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction predictor( source ) {\n\n\t\t\tfor ( var t = 1; t < source.length; t ++ ) {\n\n\t\t\t\tvar d = source[ t - 1 ] + source[ t ] - 128;\n\t\t\t\tsource[ t ] = d;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction interleaveScalar( source, out ) {\n\n\t\t\tvar t1 = 0;\n\t\t\tvar t2 = Math.floor( ( source.length + 1 ) / 2 );\n\t\t\tvar s = 0;\n\t\t\tvar stop = source.length - 1;\n\n\t\t\twhile ( true ) {\n\n\t\t\t\tif ( s > stop ) break;\n\t\t\t\tout[ s ++ ] = source[ t1 ++ ];\n\n\t\t\t\tif ( s > stop ) break;\n\t\t\t\tout[ s ++ ] = source[ t2 ++ ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction decodeRunLength( source ) {\n\n\t\t\tvar size = source.byteLength;\n\t\t\tvar out = new Array();\n\t\t\tvar p = 0;\n\n\t\t\tvar reader = new DataView( source );\n\n\t\t\twhile ( size > 0 ) {\n\n\t\t\t\tvar l = reader.getInt8( p ++ );\n\n\t\t\t\tif ( l < 0 ) {\n\n\t\t\t\t\tvar count = - l;\n\t\t\t\t\tsize -= count + 1;\n\n\t\t\t\t\tfor ( var i = 0; i < count; i ++ ) {\n\n\t\t\t\t\t\tout.push( reader.getUint8( p ++ ) );\n\n\t\t\t\t\t}\n\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar count = l;\n\t\t\t\t\tsize -= 2;\n\n\t\t\t\t\tvar value = reader.getUint8( p ++ );\n\n\t\t\t\t\tfor ( var i = 0; i < count + 1; i ++ ) {\n\n\t\t\t\t\t\tout.push( value );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn out;\n\n\t\t}\n\n\t\tfunction lossyDctDecode( cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer ) {\n\n\t\t\tvar dataView = new DataView( outBuffer.buffer );\n\n\t\t\tvar width = channelData[ cscSet.idx[ 0 ] ].width;\n\t\t\tvar height = channelData[ cscSet.idx[ 0 ] ].height;\n\n\t\t\tvar numComp = 3;\n\n\t\t\tvar numFullBlocksX = Math.floor( width / 8.0 );\n\t\t\tvar numBlocksX = Math.ceil( width / 8.0 );\n\t\t\tvar numBlocksY = Math.ceil( height / 8.0 );\n\t\t\tvar leftoverX = width - ( numBlocksX - 1 ) * 8;\n\t\t\tvar leftoverY = height - ( numBlocksY - 1 ) * 8;\n\n\t\t\tvar currAcComp = { value: 0 };\n\t\t\tvar currDcComp = new Array( numComp );\n\t\t\tvar dctData = new Array( numComp );\n\t\t\tvar halfZigBlock = new Array( numComp );\n\t\t\tvar rowBlock = new Array( numComp );\n\t\t\tvar rowOffsets = new Array( numComp );\n\n\t\t\tfor ( let comp = 0; comp < numComp; ++ comp ) {\n\n\t\t\t\trowOffsets[ comp ] = rowPtrs[ cscSet.idx[ comp ] ];\n\t\t\t\tcurrDcComp[ comp ] = ( comp < 1 ) ? 0 : currDcComp[ comp - 1 ] + numBlocksX * numBlocksY;\n\t\t\t\tdctData[ comp ] = new Float32Array( 64 );\n\t\t\t\thalfZigBlock[ comp ] = new Uint16Array( 64 );\n\t\t\t\trowBlock[ comp ] = new Uint16Array( numBlocksX * 64 );\n\n\t\t\t}\n\n\t\t\tfor ( let blocky = 0; blocky < numBlocksY; ++ blocky ) {\n\n\t\t\t\tvar maxY = 8;\n\n\t\t\t\tif ( blocky == numBlocksY - 1 )\n\t\t\t\t\tmaxY = leftoverY;\n\n\t\t\t\tvar maxX = 8;\n\n\t\t\t\tfor ( let blockx = 0; blockx < numBlocksX; ++ blockx ) {\n\n\t\t\t\t\tif ( blockx == numBlocksX - 1 )\n\t\t\t\t\t\tmaxX = leftoverX;\n\n\t\t\t\t\tfor ( let comp = 0; comp < numComp; ++ comp ) {\n\n\t\t\t\t\t\thalfZigBlock[ comp ].fill( 0 );\n\n\t\t\t\t\t\t// set block DC component\n\t\t\t\t\t\thalfZigBlock[ comp ][ 0 ] = dcBuffer[ currDcComp[ comp ] ++ ];\n\t\t\t\t\t\t// set block AC components\n\t\t\t\t\t\tunRleAC( currAcComp, acBuffer, halfZigBlock[ comp ] );\n\n\t\t\t\t\t\t// UnZigZag block to float\n\t\t\t\t\t\tunZigZag( halfZigBlock[ comp ], dctData[ comp ] );\n\t\t\t\t\t\t// decode float dct\n\t\t\t\t\t\tdctInverse( dctData[ comp ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( numComp == 3 ) {\n\n\t\t\t\t\t\tcsc709Inverse( dctData );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( let comp = 0; comp < numComp; ++ comp ) {\n\n\t\t\t\t\t\tconvertToHalf( dctData[ comp ], rowBlock[ comp ], blockx * 64 );\n\n\t\t\t\t\t}\n\n\t\t\t\t} // blockx\n\n\t\t\t\tlet offset = 0;\n\n\t\t\t\tfor ( let comp = 0; comp < numComp; ++ comp ) {\n\n\t\t\t\t\tlet type = channelData[ cscSet.idx[ comp ] ].type;\n\n\t\t\t\t\tfor ( let y = 8 * blocky; y < 8 * blocky + maxY; ++ y ) {\n\n\t\t\t\t\t\toffset = rowOffsets[ comp ][ y ];\n\n\t\t\t\t\t\tfor ( let blockx = 0; blockx < numFullBlocksX; ++ blockx ) {\n\n\t\t\t\t\t\t\tlet src = blockx * 64 + ( ( y & 0x7 ) * 8 );\n\n\t\t\t\t\t\t\tdataView.setUint16( offset + 0 * INT16_SIZE * type, rowBlock[ comp ][ src + 0 ], true );\n\t\t\t\t\t\t\tdataView.setUint16( offset + 1 * INT16_SIZE * type, rowBlock[ comp ][ src + 1 ], true );\n\t\t\t\t\t\t\tdataView.setUint16( offset + 2 * INT16_SIZE * type, rowBlock[ comp ][ src + 2 ], true );\n\t\t\t\t\t\t\tdataView.setUint16( offset + 3 * INT16_SIZE * type, rowBlock[ comp ][ src + 3 ], true );\n\n\t\t\t\t\t\t\tdataView.setUint16( offset + 4 * INT16_SIZE * type, rowBlock[ comp ][ src + 4 ], true );\n\t\t\t\t\t\t\tdataView.setUint16( offset + 5 * INT16_SIZE * type, rowBlock[ comp ][ src + 5 ], true );\n\t\t\t\t\t\t\tdataView.setUint16( offset + 6 * INT16_SIZE * type, rowBlock[ comp ][ src + 6 ], true );\n\t\t\t\t\t\t\tdataView.setUint16( offset + 7 * INT16_SIZE * type, rowBlock[ comp ][ src + 7 ], true );\n\n\t\t\t\t\t\t\toffset += 8 * INT16_SIZE * type;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// handle partial X blocks\n\t\t\t\t\tif ( numFullBlocksX != numBlocksX ) {\n\n\t\t\t\t\t\tfor ( let y = 8 * blocky; y < 8 * blocky + maxY; ++ y ) {\n\n\t\t\t\t\t\t\tlet offset = rowOffsets[ comp ][ y ] + 8 * numFullBlocksX * INT16_SIZE * type;\n\t\t\t\t\t\t\tlet src = numFullBlocksX * 64 + ( ( y & 0x7 ) * 8 );\n\n\t\t\t\t\t\t\tfor ( let x = 0; x < maxX; ++ x ) {\n\n\t\t\t\t\t\t\t\tdataView.setUint16( offset + x * INT16_SIZE * type, rowBlock[ comp ][ src + x ], true );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t} // comp\n\n\t\t\t} // blocky\n\n\t\t\tvar halfRow = new Uint16Array( width );\n\t\t\tvar dataView = new DataView( outBuffer.buffer );\n\n\t\t\t// convert channels back to float, if needed\n\t\t\tfor ( var comp = 0; comp < numComp; ++ comp ) {\n\n\t\t\t\tchannelData[ cscSet.idx[ comp ] ].decoded = true;\n\t\t\t\tvar type = channelData[ cscSet.idx[ comp ] ].type;\n\n\t\t\t\tif ( channelData[ comp ].type != 2 ) continue;\n\n\t\t\t\tfor ( var y = 0; y < height; ++ y ) {\n\n\t\t\t\t\tlet offset = rowOffsets[ comp ][ y ];\n\n\t\t\t\t\tfor ( var x = 0; x < width; ++ x ) {\n\n\t\t\t\t\t\thalfRow[ x ] = dataView.getUint16( offset + x * INT16_SIZE * type, true );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfor ( var x = 0; x < width; ++ x ) {\n\n\t\t\t\t\t\tdataView.setFloat32( offset + x * INT16_SIZE * type, decodeFloat16( halfRow[ x ] ), true );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction unRleAC( currAcComp, acBuffer, halfZigBlock ) {\n\n\t\t\tvar acValue;\n\t\t\tvar dctComp = 1;\n\n\t\t\twhile ( dctComp < 64 ) {\n\n\t\t\t\tacValue = acBuffer[ currAcComp.value ];\n\n\t\t\t\tif ( acValue == 0xff00 ) {\n\n\t\t\t\t\tdctComp = 64;\n\n\t\t\t\t} else if ( acValue >> 8 == 0xff ) {\n\n\t\t\t\t\tdctComp += acValue & 0xff;\n\n\t\t\t\t} else {\n\n\t\t\t\t\thalfZigBlock[ dctComp ] = acValue;\n\t\t\t\t\tdctComp ++;\n\n\t\t\t\t}\n\n\t\t\t\tcurrAcComp.value ++;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction unZigZag( src, dst ) {\n\n\t\t\tdst[ 0 ] = decodeFloat16( src[ 0 ] );\n\t\t\tdst[ 1 ] = decodeFloat16( src[ 1 ] );\n\t\t\tdst[ 2 ] = decodeFloat16( src[ 5 ] );\n\t\t\tdst[ 3 ] = decodeFloat16( src[ 6 ] );\n\t\t\tdst[ 4 ] = decodeFloat16( src[ 14 ] );\n\t\t\tdst[ 5 ] = decodeFloat16( src[ 15 ] );\n\t\t\tdst[ 6 ] = decodeFloat16( src[ 27 ] );\n\t\t\tdst[ 7 ] = decodeFloat16( src[ 28 ] );\n\t\t\tdst[ 8 ] = decodeFloat16( src[ 2 ] );\n\t\t\tdst[ 9 ] = decodeFloat16( src[ 4 ] );\n\n\t\t\tdst[ 10 ] = decodeFloat16( src[ 7 ] );\n\t\t\tdst[ 11 ] = decodeFloat16( src[ 13 ] );\n\t\t\tdst[ 12 ] = decodeFloat16( src[ 16 ] );\n\t\t\tdst[ 13 ] = decodeFloat16( src[ 26 ] );\n\t\t\tdst[ 14 ] = decodeFloat16( src[ 29 ] );\n\t\t\tdst[ 15 ] = decodeFloat16( src[ 42 ] );\n\t\t\tdst[ 16 ] = decodeFloat16( src[ 3 ] );\n\t\t\tdst[ 17 ] = decodeFloat16( src[ 8 ] );\n\t\t\tdst[ 18 ] = decodeFloat16( src[ 12 ] );\n\t\t\tdst[ 19 ] = decodeFloat16( src[ 17 ] );\n\n\t\t\tdst[ 20 ] = decodeFloat16( src[ 25 ] );\n\t\t\tdst[ 21 ] = decodeFloat16( src[ 30 ] );\n\t\t\tdst[ 22 ] = decodeFloat16( src[ 41 ] );\n\t\t\tdst[ 23 ] = decodeFloat16( src[ 43 ] );\n\t\t\tdst[ 24 ] = decodeFloat16( src[ 9 ] );\n\t\t\tdst[ 25 ] = decodeFloat16( src[ 11 ] );\n\t\t\tdst[ 26 ] = decodeFloat16( src[ 18 ] );\n\t\t\tdst[ 27 ] = decodeFloat16( src[ 24 ] );\n\t\t\tdst[ 28 ] = decodeFloat16( src[ 31 ] );\n\t\t\tdst[ 29 ] = decodeFloat16( src[ 40 ] );\n\n\t\t\tdst[ 30 ] = decodeFloat16( src[ 44 ] );\n\t\t\tdst[ 31 ] = decodeFloat16( src[ 53 ] );\n\t\t\tdst[ 32 ] = decodeFloat16( src[ 10 ] );\n\t\t\tdst[ 33 ] = decodeFloat16( src[ 19 ] );\n\t\t\tdst[ 34 ] = decodeFloat16( src[ 23 ] );\n\t\t\tdst[ 35 ] = decodeFloat16( src[ 32 ] );\n\t\t\tdst[ 36 ] = decodeFloat16( src[ 39 ] );\n\t\t\tdst[ 37 ] = decodeFloat16( src[ 45 ] );\n\t\t\tdst[ 38 ] = decodeFloat16( src[ 52 ] );\n\t\t\tdst[ 39 ] = decodeFloat16( src[ 54 ] );\n\n\t\t\tdst[ 40 ] = decodeFloat16( src[ 20 ] );\n\t\t\tdst[ 41 ] = decodeFloat16( src[ 22 ] );\n\t\t\tdst[ 42 ] = decodeFloat16( src[ 33 ] );\n\t\t\tdst[ 43 ] = decodeFloat16( src[ 38 ] );\n\t\t\tdst[ 44 ] = decodeFloat16( src[ 46 ] );\n\t\t\tdst[ 45 ] = decodeFloat16( src[ 51 ] );\n\t\t\tdst[ 46 ] = decodeFloat16( src[ 55 ] );\n\t\t\tdst[ 47 ] = decodeFloat16( src[ 60 ] );\n\t\t\tdst[ 48 ] = decodeFloat16( src[ 21 ] );\n\t\t\tdst[ 49 ] = decodeFloat16( src[ 34 ] );\n\n\t\t\tdst[ 50 ] = decodeFloat16( src[ 37 ] );\n\t\t\tdst[ 51 ] = decodeFloat16( src[ 47 ] );\n\t\t\tdst[ 52 ] = decodeFloat16( src[ 50 ] );\n\t\t\tdst[ 53 ] = decodeFloat16( src[ 56 ] );\n\t\t\tdst[ 54 ] = decodeFloat16( src[ 59 ] );\n\t\t\tdst[ 55 ] = decodeFloat16( src[ 61 ] );\n\t\t\tdst[ 56 ] = decodeFloat16( src[ 35 ] );\n\t\t\tdst[ 57 ] = decodeFloat16( src[ 36 ] );\n\t\t\tdst[ 58 ] = decodeFloat16( src[ 48 ] );\n\t\t\tdst[ 59 ] = decodeFloat16( src[ 49 ] );\n\n\t\t\tdst[ 60 ] = decodeFloat16( src[ 57 ] );\n\t\t\tdst[ 61 ] = decodeFloat16( src[ 58 ] );\n\t\t\tdst[ 62 ] = decodeFloat16( src[ 62 ] );\n\t\t\tdst[ 63 ] = decodeFloat16( src[ 63 ] );\n\n\t\t}\n\n\t\tfunction dctInverse( data ) {\n\n\t\t\tconst a = 0.5 * Math.cos( 3.14159 / 4.0 );\n\t\t\tconst b = 0.5 * Math.cos( 3.14159 / 16.0 );\n\t\t\tconst c = 0.5 * Math.cos( 3.14159 / 8.0 );\n\t\t\tconst d = 0.5 * Math.cos( 3.0 * 3.14159 / 16.0 );\n\t\t\tconst e = 0.5 * Math.cos( 5.0 * 3.14159 / 16.0 );\n\t\t\tconst f = 0.5 * Math.cos( 3.0 * 3.14159 / 8.0 );\n\t\t\tconst g = 0.5 * Math.cos( 7.0 * 3.14159 / 16.0 );\n\n\t\t\tvar alpha = new Array( 4 );\n\t\t\tvar beta = new Array( 4 );\n\t\t\tvar theta = new Array( 4 );\n\t\t\tvar gamma = new Array( 4 );\n\n\t\t\tfor ( var row = 0; row < 8; ++ row ) {\n\n\t\t\t\tvar rowPtr = row * 8;\n\n\t\t\t\talpha[ 0 ] = c * data[ rowPtr + 2 ];\n\t\t\t\talpha[ 1 ] = f * data[ rowPtr + 2 ];\n\t\t\t\talpha[ 2 ] = c * data[ rowPtr + 6 ];\n\t\t\t\talpha[ 3 ] = f * data[ rowPtr + 6 ];\n\n\t\t\t\tbeta[ 0 ] = b * data[ rowPtr + 1 ] + d * data[ rowPtr + 3 ] + e * data[ rowPtr + 5 ] + g * data[ rowPtr + 7 ];\n\t\t\t\tbeta[ 1 ] = d * data[ rowPtr + 1 ] - g * data[ rowPtr + 3 ] - b * data[ rowPtr + 5 ] - e * data[ rowPtr + 7 ];\n\t\t\t\tbeta[ 2 ] = e * data[ rowPtr + 1 ] - b * data[ rowPtr + 3 ] + g * data[ rowPtr + 5 ] + d * data[ rowPtr + 7 ];\n\t\t\t\tbeta[ 3 ] = g * data[ rowPtr + 1 ] - e * data[ rowPtr + 3 ] + d * data[ rowPtr + 5 ] - b * data[ rowPtr + 7 ];\n\n\t\t\t\ttheta[ 0 ] = a * ( data[ rowPtr + 0 ] + data[ rowPtr + 4 ] );\n\t\t\t\ttheta[ 3 ] = a * ( data[ rowPtr + 0 ] - data[ rowPtr + 4 ] );\n\t\t\t\ttheta[ 1 ] = alpha[ 0 ] + alpha[ 3 ];\n\t\t\t\ttheta[ 2 ] = alpha[ 1 ] - alpha[ 2 ];\n\n\t\t\t\tgamma[ 0 ] = theta[ 0 ] + theta[ 1 ];\n\t\t\t\tgamma[ 1 ] = theta[ 3 ] + theta[ 2 ];\n\t\t\t\tgamma[ 2 ] = theta[ 3 ] - theta[ 2 ];\n\t\t\t\tgamma[ 3 ] = theta[ 0 ] - theta[ 1 ];\n\n\t\t\t\tdata[ rowPtr + 0 ] = gamma[ 0 ] + beta[ 0 ];\n\t\t\t\tdata[ rowPtr + 1 ] = gamma[ 1 ] + beta[ 1 ];\n\t\t\t\tdata[ rowPtr + 2 ] = gamma[ 2 ] + beta[ 2 ];\n\t\t\t\tdata[ rowPtr + 3 ] = gamma[ 3 ] + beta[ 3 ];\n\n\t\t\t\tdata[ rowPtr + 4 ] = gamma[ 3 ] - beta[ 3 ];\n\t\t\t\tdata[ rowPtr + 5 ] = gamma[ 2 ] - beta[ 2 ];\n\t\t\t\tdata[ rowPtr + 6 ] = gamma[ 1 ] - beta[ 1 ];\n\t\t\t\tdata[ rowPtr + 7 ] = gamma[ 0 ] - beta[ 0 ];\n\n\t\t\t}\n\n\t\t\tfor ( var column = 0; column < 8; ++ column ) {\n\n\t\t\t\talpha[ 0 ] = c * data[ 16 + column ];\n\t\t\t\talpha[ 1 ] = f * data[ 16 + column ];\n\t\t\t\talpha[ 2 ] = c * data[ 48 + column ];\n\t\t\t\talpha[ 3 ] = f * data[ 48 + column ];\n\n\t\t\t\tbeta[ 0 ] = b * data[ 8 + column ] + d * data[ 24 + column ] + e * data[ 40 + column ] + g * data[ 56 + column ];\n\t\t\t\tbeta[ 1 ] = d * data[ 8 + column ] - g * data[ 24 + column ] - b * data[ 40 + column ] - e * data[ 56 + column ];\n\t\t\t\tbeta[ 2 ] = e * data[ 8 + column ] - b * data[ 24 + column ] + g * data[ 40 + column ] + d * data[ 56 + column ];\n\t\t\t\tbeta[ 3 ] = g * data[ 8 + column ] - e * data[ 24 + column ] + d * data[ 40 + column ] - b * data[ 56 + column ];\n\n\t\t\t\ttheta[ 0 ] = a * ( data[ column ] + data[ 32 + column ] );\n\t\t\t\ttheta[ 3 ] = a * ( data[ column ] - data[ 32 + column ] );\n\n\t\t\t\ttheta[ 1 ] = alpha[ 0 ] + alpha[ 3 ];\n\t\t\t\ttheta[ 2 ] = alpha[ 1 ] - alpha[ 2 ];\n\n\t\t\t\tgamma[ 0 ] = theta[ 0 ] + theta[ 1 ];\n\t\t\t\tgamma[ 1 ] = theta[ 3 ] + theta[ 2 ];\n\t\t\t\tgamma[ 2 ] = theta[ 3 ] - theta[ 2 ];\n\t\t\t\tgamma[ 3 ] = theta[ 0 ] - theta[ 1 ];\n\n\t\t\t\tdata[ 0 + column ] = gamma[ 0 ] + beta[ 0 ];\n\t\t\t\tdata[ 8 + column ] = gamma[ 1 ] + beta[ 1 ];\n\t\t\t\tdata[ 16 + column ] = gamma[ 2 ] + beta[ 2 ];\n\t\t\t\tdata[ 24 + column ] = gamma[ 3 ] + beta[ 3 ];\n\n\t\t\t\tdata[ 32 + column ] = gamma[ 3 ] - beta[ 3 ];\n\t\t\t\tdata[ 40 + column ] = gamma[ 2 ] - beta[ 2 ];\n\t\t\t\tdata[ 48 + column ] = gamma[ 1 ] - beta[ 1 ];\n\t\t\t\tdata[ 56 + column ] = gamma[ 0 ] - beta[ 0 ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction csc709Inverse( data ) {\n\n\t\t\tfor ( var i = 0; i < 64; ++ i ) {\n\n\t\t\t\tvar y = data[ 0 ][ i ];\n\t\t\t\tvar cb = data[ 1 ][ i ];\n\t\t\t\tvar cr = data[ 2 ][ i ];\n\n\t\t\t\tdata[ 0 ][ i ] = y + 1.5747 * cr;\n\t\t\t\tdata[ 1 ][ i ] = y - 0.1873 * cb - 0.4682 * cr;\n\t\t\t\tdata[ 2 ][ i ] = y + 1.8556 * cb;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction convertToHalf( src, dst, idx ) {\n\n\t\t\tfor ( var i = 0; i < 64; ++ i ) {\n\n\t\t\t\tdst[ idx + i ] = encodeFloat16( toLinear( src[ i ] ) );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction toLinear( float ) {\n\n\t\t\tif ( float <= 1 ) {\n\n\t\t\t\treturn Math.sign( float ) * Math.pow( Math.abs( float ), 2.2 );\n\n\t\t\t} else {\n\n\t\t\t\treturn Math.sign( float ) * Math.pow( logBase, Math.abs( float ) - 1.0 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction uncompressRAW( info ) {\n\n\t\t\treturn new DataView( info.array.buffer, info.offset.value, info.size );\n\n\t\t}\n\n\t\tfunction uncompressRLE( info ) {\n\n\t\t\tvar compressed = info.viewer.buffer.slice( info.offset.value, info.offset.value + info.size );\n\n\t\t\tvar rawBuffer = new Uint8Array( decodeRunLength( compressed ) );\n\t\t\tvar tmpBuffer = new Uint8Array( rawBuffer.length );\n\n\t\t\tpredictor( rawBuffer ); // revert predictor\n\n\t\t\tinterleaveScalar( rawBuffer, tmpBuffer ); // interleave pixels\n\n\t\t\treturn new DataView( tmpBuffer.buffer );\n\n\t\t}\n\n\t\tfunction uncompressZIP( info ) {\n\n\t\t\tvar compressed = info.array.slice( info.offset.value, info.offset.value + info.size );\n\n\t\t\tif ( typeof Zlib === 'undefined' ) {\n\n\t\t\t\tconsole.error( 'THREE.EXRLoader: External library Inflate.min.js required, obtain or import from https://github.com/imaya/zlib.js' );\n\n\t\t\t}\n\n\t\t\tvar inflate = new Zlib.Inflate( compressed, { resize: true, verify: true } ); // eslint-disable-line no-undef\n\n\t\t\tvar rawBuffer = new Uint8Array( inflate.decompress().buffer );\n\t\t\tvar tmpBuffer = new Uint8Array( rawBuffer.length );\n\n\t\t\tpredictor( rawBuffer ); // revert predictor\n\n\t\t\tinterleaveScalar( rawBuffer, tmpBuffer ); // interleave pixels\n\n\t\t\treturn new DataView( tmpBuffer.buffer );\n\n\t\t}\n\n\t\tfunction uncompressPIZ( info ) {\n\n\t\t\tvar inDataView = info.viewer;\n\t\t\tvar inOffset = { value: info.offset.value };\n\n\t\t\tvar tmpBufSize = info.width * scanlineBlockSize * ( EXRHeader.channels.length * info.type );\n\t\t\tvar outBuffer = new Uint16Array( tmpBufSize );\n\t\t\tvar bitmap = new Uint8Array( BITMAP_SIZE );\n\n\t\t\t// Setup channel info\n\t\t\tvar outBufferEnd = 0;\n\t\t\tvar pizChannelData = new Array( info.channels );\n\t\t\tfor ( var i = 0; i < info.channels; i ++ ) {\n\n\t\t\t\tpizChannelData[ i ] = {};\n\t\t\t\tpizChannelData[ i ][ 'start' ] = outBufferEnd;\n\t\t\t\tpizChannelData[ i ][ 'end' ] = pizChannelData[ i ][ 'start' ];\n\t\t\t\tpizChannelData[ i ][ 'nx' ] = info.width;\n\t\t\t\tpizChannelData[ i ][ 'ny' ] = info.lines;\n\t\t\t\tpizChannelData[ i ][ 'size' ] = info.type;\n\n\t\t\t\toutBufferEnd += pizChannelData[ i ].nx * pizChannelData[ i ].ny * pizChannelData[ i ].size;\n\n\t\t\t}\n\n\t\t\t// Read range compression data\n\t\t\tvar minNonZero = parseUint16( inDataView, inOffset );\n\t\t\tvar maxNonZero = parseUint16( inDataView, inOffset );\n\n\t\t\tif ( maxNonZero >= BITMAP_SIZE ) {\n\n\t\t\t\tthrow 'Something is wrong with PIZ_COMPRESSION BITMAP_SIZE';\n\n\t\t\t}\n\n\t\t\tif ( minNonZero <= maxNonZero ) {\n\n\t\t\t\tfor ( var i = 0; i < maxNonZero - minNonZero + 1; i ++ ) {\n\n\t\t\t\t\tbitmap[ i + minNonZero ] = parseUint8( inDataView, inOffset );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Reverse LUT\n\t\t\tvar lut = new Uint16Array( USHORT_RANGE );\n\t\t\treverseLutFromBitmap( bitmap, lut );\n\n\t\t\tvar length = parseUint32( inDataView, inOffset );\n\n\t\t\t// Huffman decoding\n\t\t\thufUncompress( info.array, inDataView, inOffset, length, outBuffer, outBufferEnd );\n\n\t\t\t// Wavelet decoding\n\t\t\tfor ( var i = 0; i < info.channels; ++ i ) {\n\n\t\t\t\tvar cd = pizChannelData[ i ];\n\n\t\t\t\tfor ( var j = 0; j < pizChannelData[ i ].size; ++ j ) {\n\n\t\t\t\t\twav2Decode(\n\t\t\t\t\t\toutBuffer,\n\t\t\t\t\t\tcd.start + j,\n\t\t\t\t\t\tcd.nx,\n\t\t\t\t\t\tcd.size,\n\t\t\t\t\t\tcd.ny,\n\t\t\t\t\t\tcd.nx * cd.size\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Expand the pixel data to their original range\n\t\t\tapplyLut( lut, outBuffer, outBufferEnd );\n\n\t\t\t// Rearrange the pixel data into the format expected by the caller.\n\t\t\tvar tmpOffset = 0;\n\t\t\tvar tmpBuffer = new Uint8Array( outBuffer.buffer.byteLength );\n\t\t\tfor ( var y = 0; y < info.lines; y ++ ) {\n\n\t\t\t\tfor ( var c = 0; c < info.channels; c ++ ) {\n\n\t\t\t\t\tvar cd = pizChannelData[ c ];\n\n\t\t\t\t\tvar n = cd.nx * cd.size;\n\t\t\t\t\tvar cp = new Uint8Array( outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE );\n\n\t\t\t\t\ttmpBuffer.set( cp, tmpOffset );\n\t\t\t\t\ttmpOffset += n * INT16_SIZE;\n\t\t\t\t\tcd.end += n;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new DataView( tmpBuffer.buffer );\n\n\t\t}\n\n\t\tfunction uncompressDWA( info ) {\n\n\t\t\tvar inDataView = info.viewer;\n\t\t\tvar inOffset = { value: info.offset.value };\n\t\t\tvar outBuffer = new Uint8Array( info.width * info.lines * ( EXRHeader.channels.length * info.type * INT16_SIZE ) );\n\n\t\t\t// Read compression header information\n\t\t\tvar dwaHeader = {\n\n\t\t\t\tversion: parseInt64( inDataView, inOffset ),\n\t\t\t\tunknownUncompressedSize: parseInt64( inDataView, inOffset ),\n\t\t\t\tunknownCompressedSize: parseInt64( inDataView, inOffset ),\n\t\t\t\tacCompressedSize: parseInt64( inDataView, inOffset ),\n\t\t\t\tdcCompressedSize: parseInt64( inDataView, inOffset ),\n\t\t\t\trleCompressedSize: parseInt64( inDataView, inOffset ),\n\t\t\t\trleUncompressedSize: parseInt64( inDataView, inOffset ),\n\t\t\t\trleRawSize: parseInt64( inDataView, inOffset ),\n\t\t\t\ttotalAcUncompressedCount: parseInt64( inDataView, inOffset ),\n\t\t\t\ttotalDcUncompressedCount: parseInt64( inDataView, inOffset ),\n\t\t\t\tacCompression: parseInt64( inDataView, inOffset )\n\n\t\t\t};\n\n\t\t\tif ( dwaHeader.version < 2 )\n\t\t\t\tthrow 'EXRLoader.parse: ' + EXRHeader.compression + ' version ' + dwaHeader.version + ' is unsupported';\n\n\t\t\t// Read channel ruleset information\n\t\t\tvar channelRules = new Array();\n\t\t\tvar ruleSize = parseUint16( inDataView, inOffset ) - INT16_SIZE;\n\n\t\t\twhile ( ruleSize > 0 ) {\n\n\t\t\t\tvar name = parseNullTerminatedString( inDataView.buffer, inOffset );\n\t\t\t\tvar value = parseUint8( inDataView, inOffset );\n\t\t\t\tvar compression = ( value >> 2 ) & 3;\n\t\t\t\tvar csc = ( value >> 4 ) - 1;\n\t\t\t\tvar index = new Int8Array( [ csc ] )[ 0 ];\n\t\t\t\tvar type = parseUint8( inDataView, inOffset );\n\n\t\t\t\tchannelRules.push( {\n\t\t\t\t\tname: name,\n\t\t\t\t\tindex: index,\n\t\t\t\t\ttype: type,\n\t\t\t\t\tcompression: compression,\n\t\t\t\t} );\n\n\t\t\t\truleSize -= name.length + 3;\n\n\t\t\t}\n\n\t\t\t// Classify channels\n\t\t\tvar channels = EXRHeader.channels;\n\t\t\tvar channelData = new Array( info.channels );\n\n\t\t\tfor ( var i = 0; i < info.channels; ++ i ) {\n\n\t\t\t\tvar cd = channelData[ i ] = {};\n\t\t\t\tvar channel = channels[ i ];\n\n\t\t\t\tcd.name = channel.name;\n\t\t\t\tcd.compression = UNKNOWN;\n\t\t\t\tcd.decoded = false;\n\t\t\t\tcd.type = channel.pixelType;\n\t\t\t\tcd.pLinear = channel.pLinear;\n\t\t\t\tcd.width = info.width;\n\t\t\t\tcd.height = info.lines;\n\n\t\t\t}\n\n\t\t\tvar cscSet = {\n\t\t\t\tidx: new Array( 3 )\n\t\t\t};\n\n\t\t\tfor ( var offset = 0; offset < info.channels; ++ offset ) {\n\n\t\t\t\tvar cd = channelData[ offset ];\n\n\t\t\t\tfor ( var i = 0; i < channelRules.length; ++ i ) {\n\n\t\t\t\t\tvar rule = channelRules[ i ];\n\n\t\t\t\t\tif ( cd.name == rule.name ) {\n\n\t\t\t\t\t\tcd.compression = rule.compression;\n\n\t\t\t\t\t\tif ( rule.index >= 0 ) {\n\n\t\t\t\t\t\t\tcscSet.idx[ rule.index ] = offset;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcd.offset = offset;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Read DCT - AC component data\n\t\t\tif ( dwaHeader.acCompressedSize > 0 ) {\n\n\t\t\t\tswitch ( dwaHeader.acCompression ) {\n\n\t\t\t\t\tcase STATIC_HUFFMAN:\n\n\t\t\t\t\t\tvar acBuffer = new Uint16Array( dwaHeader.totalAcUncompressedCount );\n\t\t\t\t\t\thufUncompress( info.array, inDataView, inOffset, dwaHeader.acCompressedSize, acBuffer, dwaHeader.totalAcUncompressedCount );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase DEFLATE:\n\n\t\t\t\t\t\tvar compressed = info.array.slice( inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount );\n\t\t\t\t\t\tvar inflate = new Zlib.Inflate( compressed, { resize: true, verify: true } );\n\t\t\t\t\t\tvar acBuffer = new Uint16Array( inflate.decompress().buffer );\n\t\t\t\t\t\tinOffset.value += dwaHeader.totalAcUncompressedCount;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\n\t\t\t}\n\n\t\t\t// Read DCT - DC component data\n\t\t\tif ( dwaHeader.dcCompressedSize > 0 ) {\n\n\t\t\t\tvar zlibInfo = {\n\t\t\t\t\tarray: info.array,\n\t\t\t\t\toffset: inOffset,\n\t\t\t\t\tsize: dwaHeader.dcCompressedSize\n\t\t\t\t};\n\t\t\t\tvar dcBuffer = new Uint16Array( uncompressZIP( zlibInfo ).buffer );\n\t\t\t\tinOffset.value += dwaHeader.dcCompressedSize;\n\n\t\t\t}\n\n\t\t\t// Read RLE compressed data\n\t\t\tif ( dwaHeader.rleRawSize > 0 ) {\n\n\t\t\t\tvar compressed = info.array.slice( inOffset.value, inOffset.value + dwaHeader.rleCompressedSize );\n\t\t\t\tvar inflate = new Zlib.Inflate( compressed, { resize: true, verify: true } );\n\t\t\t\tvar rleBuffer = decodeRunLength( inflate.decompress().buffer );\n\n\t\t\t\tinOffset.value += dwaHeader.rleCompressedSize;\n\n\t\t\t}\n\n\t\t\t// Prepare outbuffer data offset\n\t\t\tvar outBufferEnd = 0;\n\t\t\tvar rowOffsets = new Array( channelData.length );\n\t\t\tfor ( var i = 0; i < rowOffsets.length; ++ i ) {\n\n\t\t\t\trowOffsets[ i ] = new Array();\n\n\t\t\t}\n\n\t\t\tfor ( var y = 0; y < info.lines; ++ y ) {\n\n\t\t\t\tfor ( var chan = 0; chan < channelData.length; ++ chan ) {\n\n\t\t\t\t\trowOffsets[ chan ].push( outBufferEnd );\n\t\t\t\t\toutBufferEnd += channelData[ chan ].width * info.type * INT16_SIZE;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Lossy DCT decode RGB channels\n\t\t\tlossyDctDecode( cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer );\n\n\t\t\t// Decode other channels\n\t\t\tfor ( var i = 0; i < channelData.length; ++ i ) {\n\n\t\t\t\tvar cd = channelData[ i ];\n\n\t\t\t\tif ( cd.decoded ) continue;\n\n\t\t\t\tswitch ( cd.compression ) {\n\n\t\t\t\t\tcase RLE:\n\n\t\t\t\t\t\tvar row = 0;\n\t\t\t\t\t\tvar rleOffset = 0;\n\n\t\t\t\t\t\tfor ( var y = 0; y < info.lines; ++ y ) {\n\n\t\t\t\t\t\t\tvar rowOffsetBytes = rowOffsets[ i ][ row ];\n\n\t\t\t\t\t\t\tfor ( var x = 0; x < cd.width; ++ x ) {\n\n\t\t\t\t\t\t\t\tfor ( var byte = 0; byte < INT16_SIZE * cd.type; ++ byte ) {\n\n\t\t\t\t\t\t\t\t\toutBuffer[ rowOffsetBytes ++ ] = rleBuffer[ rleOffset + byte * cd.width * cd.height ];\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\trleOffset ++;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\trow ++;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase LOSSY_DCT: // skip\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow 'EXRLoader.parse: unsupported channel compression';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new DataView( outBuffer.buffer );\n\n\t\t}\n\n\t\tfunction parseNullTerminatedString( buffer, offset ) {\n\n\t\t\tvar uintBuffer = new Uint8Array( buffer );\n\t\t\tvar endOffset = 0;\n\n\t\t\twhile ( uintBuffer[ offset.value + endOffset ] != 0 ) {\n\n\t\t\t\tendOffset += 1;\n\n\t\t\t}\n\n\t\t\tvar stringValue = new TextDecoder().decode(\n\t\t\t\tuintBuffer.slice( offset.value, offset.value + endOffset )\n\t\t\t);\n\n\t\t\toffset.value = offset.value + endOffset + 1;\n\n\t\t\treturn stringValue;\n\n\t\t}\n\n\t\tfunction parseFixedLengthString( buffer, offset, size ) {\n\n\t\t\tvar stringValue = new TextDecoder().decode(\n\t\t\t\tnew Uint8Array( buffer ).slice( offset.value, offset.value + size )\n\t\t\t);\n\n\t\t\toffset.value = offset.value + size;\n\n\t\t\treturn stringValue;\n\n\t\t}\n\n\t\tfunction parseUlong( dataView, offset ) {\n\n\t\t\tvar uLong = dataView.getUint32( 0, true );\n\n\t\t\toffset.value = offset.value + ULONG_SIZE;\n\n\t\t\treturn uLong;\n\n\t\t}\n\n\t\tfunction parseUint32( dataView, offset ) {\n\n\t\t\tvar Uint32 = dataView.getUint32( offset.value, true );\n\n\t\t\toffset.value = offset.value + INT32_SIZE;\n\n\t\t\treturn Uint32;\n\n\t\t}\n\n\t\tfunction parseUint8Array( uInt8Array, offset ) {\n\n\t\t\tvar Uint8 = uInt8Array[ offset.value ];\n\n\t\t\toffset.value = offset.value + INT8_SIZE;\n\n\t\t\treturn Uint8;\n\n\t\t}\n\n\t\tfunction parseUint8( dataView, offset ) {\n\n\t\t\tvar Uint8 = dataView.getUint8( offset.value );\n\n\t\t\toffset.value = offset.value + INT8_SIZE;\n\n\t\t\treturn Uint8;\n\n\t\t}\n\n\t\tfunction parseInt64( dataView, offset ) {\n\n\t\t\tvar int = Number( dataView.getBigInt64( offset.value, true ) );\n\n\t\t\toffset.value += ULONG_SIZE;\n\n\t\t\treturn int;\n\n\t\t}\n\n\t\tfunction parseFloat32( dataView, offset ) {\n\n\t\t\tvar float = dataView.getFloat32( offset.value, true );\n\n\t\t\toffset.value += FLOAT32_SIZE;\n\n\t\t\treturn float;\n\n\t\t}\n\n\t\t// https://stackoverflow.com/questions/5678432/decompressing-half-precision-floats-in-javascript\n\t\tfunction decodeFloat16( binary ) {\n\n\t\t\tvar exponent = ( binary & 0x7C00 ) >> 10,\n\t\t\t\tfraction = binary & 0x03FF;\n\n\t\t\treturn ( binary >> 15 ? - 1 : 1 ) * (\n\t\t\t\texponent ?\n\t\t\t\t\t(\n\t\t\t\t\t\texponent === 0x1F ?\n\t\t\t\t\t\t\tfraction ? NaN : Infinity :\n\t\t\t\t\t\t\tMath.pow( 2, exponent - 15 ) * ( 1 + fraction / 0x400 )\n\t\t\t\t\t) :\n\t\t\t\t\t6.103515625e-5 * ( fraction / 0x400 )\n\t\t\t);\n\n\t\t}\n\n\t\tvar encodeFloat16 = ( function () {\n\n\t\t\t// Source: http://gamedev.stackexchange.com/questions/17326/conversion-of-a-number-from-single-precision-floating-point-representation-to-a/17410#17410\n\n\t\t\tvar floatView = new Float32Array( 1 );\n\t\t\tvar int32View = new Int32Array( floatView.buffer );\n\n\t\t\t/* This method is faster than the OpenEXR implementation (very often\n\t\t\t * used, eg. in Ogre), with the additional benefit of rounding, inspired\n\t\t\t * by James Tursa?s half-precision code. */\n\t\t\treturn function toHalf( val ) {\n\n\t\t\t\tfloatView[ 0 ] = val;\n\t\t\t\tvar x = int32View[ 0 ];\n\n\t\t\t\tvar bits = ( x >> 16 ) & 0x8000; /* Get the sign */\n\t\t\t\tvar m = ( x >> 12 ) & 0x07ff; /* Keep one extra bit for rounding */\n\t\t\t\tvar e = ( x >> 23 ) & 0xff; /* Using int is faster here */\n\n\t\t\t\t/* If zero, or denormal, or exponent underflows too much for a denormal\n\t\t\t\t * half, return signed zero. */\n\t\t\t\tif ( e < 103 ) return bits;\n\n\t\t\t\t/* If NaN, return NaN. If Inf or exponent overflow, return Inf. */\n\t\t\t\tif ( e > 142 ) {\n\n\t\t\t\t\tbits |= 0x7c00;\n\t\t\t\t\t/* If exponent was 0xff and one mantissa bit was set, it means NaN,\n\t\t\t\t\t\t\t * not Inf, so make sure we set one mantissa bit too. */\n\t\t\t\t\tbits |= ( ( e == 255 ) ? 0 : 1 ) && ( x & 0x007fffff );\n\t\t\t\t\treturn bits;\n\n\t\t\t\t}\n\n\t\t\t\t/* If exponent underflows but not too much, return a denormal */\n\t\t\t\tif ( e < 113 ) {\n\n\t\t\t\t\tm |= 0x0800;\n\t\t\t\t\t/* Extra rounding may overflow and set mantissa to 0 and exponent\n\t\t\t\t\t * to 1, which is OK. */\n\t\t\t\t\tbits |= ( m >> ( 114 - e ) ) + ( ( m >> ( 113 - e ) ) & 1 );\n\t\t\t\t\treturn bits;\n\n\t\t\t\t}\n\n\t\t\t\tbits |= ( ( e - 112 ) << 10 ) | ( m >> 1 );\n\t\t\t\t/* Extra rounding. An overflow will set mantissa to 0 and increment\n\t\t\t\t * the exponent, which is OK. */\n\t\t\t\tbits += m & 1;\n\t\t\t\treturn bits;\n\n\t\t\t};\n\n\t\t} )();\n\n\t\tfunction parseUint16( dataView, offset ) {\n\n\t\t\tvar Uint16 = dataView.getUint16( offset.value, true );\n\n\t\t\toffset.value += INT16_SIZE;\n\n\t\t\treturn Uint16;\n\n\t\t}\n\n\t\tfunction parseFloat16( buffer, offset ) {\n\n\t\t\treturn decodeFloat16( parseUint16( buffer, offset ) );\n\n\t\t}\n\n\t\tfunction parseChlist( dataView, buffer, offset, size ) {\n\n\t\t\tvar startOffset = offset.value;\n\t\t\tvar channels = [];\n\n\t\t\twhile ( offset.value < ( startOffset + size - 1 ) ) {\n\n\t\t\t\tvar name = parseNullTerminatedString( buffer, offset );\n\t\t\t\tvar pixelType = parseUint32( dataView, offset ); // TODO: Cast this to UINT, HALF or FLOAT\n\t\t\t\tvar pLinear = parseUint8( dataView, offset );\n\t\t\t\toffset.value += 3; // reserved, three chars\n\t\t\t\tvar xSampling = parseUint32( dataView, offset );\n\t\t\t\tvar ySampling = parseUint32( dataView, offset );\n\n\t\t\t\tchannels.push( {\n\t\t\t\t\tname: name,\n\t\t\t\t\tpixelType: pixelType,\n\t\t\t\t\tpLinear: pLinear,\n\t\t\t\t\txSampling: xSampling,\n\t\t\t\t\tySampling: ySampling\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\toffset.value += 1;\n\n\t\t\treturn channels;\n\n\t\t}\n\n\t\tfunction parseChromaticities( dataView, offset ) {\n\n\t\t\tvar redX = parseFloat32( dataView, offset );\n\t\t\tvar redY = parseFloat32( dataView, offset );\n\t\t\tvar greenX = parseFloat32( dataView, offset );\n\t\t\tvar greenY = parseFloat32( dataView, offset );\n\t\t\tvar blueX = parseFloat32( dataView, offset );\n\t\t\tvar blueY = parseFloat32( dataView, offset );\n\t\t\tvar whiteX = parseFloat32( dataView, offset );\n\t\t\tvar whiteY = parseFloat32( dataView, offset );\n\n\t\t\treturn { redX: redX, redY: redY, greenX: greenX, greenY: greenY, blueX: blueX, blueY: blueY, whiteX: whiteX, whiteY: whiteY };\n\n\t\t}\n\n\t\tfunction parseCompression( dataView, offset ) {\n\n\t\t\tvar compressionCodes = [\n\t\t\t\t'NO_COMPRESSION',\n\t\t\t\t'RLE_COMPRESSION',\n\t\t\t\t'ZIPS_COMPRESSION',\n\t\t\t\t'ZIP_COMPRESSION',\n\t\t\t\t'PIZ_COMPRESSION',\n\t\t\t\t'PXR24_COMPRESSION',\n\t\t\t\t'B44_COMPRESSION',\n\t\t\t\t'B44A_COMPRESSION',\n\t\t\t\t'DWAA_COMPRESSION',\n\t\t\t\t'DWAB_COMPRESSION'\n\t\t\t];\n\n\t\t\tvar compression = parseUint8( dataView, offset );\n\n\t\t\treturn compressionCodes[ compression ];\n\n\t\t}\n\n\t\tfunction parseBox2i( dataView, offset ) {\n\n\t\t\tvar xMin = parseUint32( dataView, offset );\n\t\t\tvar yMin = parseUint32( dataView, offset );\n\t\t\tvar xMax = parseUint32( dataView, offset );\n\t\t\tvar yMax = parseUint32( dataView, offset );\n\n\t\t\treturn { xMin: xMin, yMin: yMin, xMax: xMax, yMax: yMax };\n\n\t\t}\n\n\t\tfunction parseLineOrder( dataView, offset ) {\n\n\t\t\tvar lineOrders = [\n\t\t\t\t'INCREASING_Y'\n\t\t\t];\n\n\t\t\tvar lineOrder = parseUint8( dataView, offset );\n\n\t\t\treturn lineOrders[ lineOrder ];\n\n\t\t}\n\n\t\tfunction parseV2f( dataView, offset ) {\n\n\t\t\tvar x = parseFloat32( dataView, offset );\n\t\t\tvar y = parseFloat32( dataView, offset );\n\n\t\t\treturn [ x, y ];\n\n\t\t}\n\n\t\tfunction parseValue( dataView, buffer, offset, type, size ) {\n\n\t\t\tif ( type === 'string' || type === 'stringvector' || type === 'iccProfile' ) {\n\n\t\t\t\treturn parseFixedLengthString( buffer, offset, size );\n\n\t\t\t} else if ( type === 'chlist' ) {\n\n\t\t\t\treturn parseChlist( dataView, buffer, offset, size );\n\n\t\t\t} else if ( type === 'chromaticities' ) {\n\n\t\t\t\treturn parseChromaticities( dataView, offset );\n\n\t\t\t} else if ( type === 'compression' ) {\n\n\t\t\t\treturn parseCompression( dataView, offset );\n\n\t\t\t} else if ( type === 'box2i' ) {\n\n\t\t\t\treturn parseBox2i( dataView, offset );\n\n\t\t\t} else if ( type === 'lineOrder' ) {\n\n\t\t\t\treturn parseLineOrder( dataView, offset );\n\n\t\t\t} else if ( type === 'float' ) {\n\n\t\t\t\treturn parseFloat32( dataView, offset );\n\n\t\t\t} else if ( type === 'v2f' ) {\n\n\t\t\t\treturn parseV2f( dataView, offset );\n\n\t\t\t} else if ( type === 'int' ) {\n\n\t\t\t\treturn parseUint32( dataView, offset );\n\n\t\t\t} else {\n\n\t\t\t\tthrow 'Cannot parse value for unsupported type: ' + type;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar bufferDataView = new DataView( buffer );\n\t\tvar uInt8Array = new Uint8Array( buffer );\n\n\t\tvar EXRHeader = {};\n\n\t\tbufferDataView.getUint32( 0, true ); // magic\n\t\tbufferDataView.getUint8( 4, true ); // versionByteZero\n\t\tbufferDataView.getUint8( 5, true ); // fullMask\n\n\t\t// start of header\n\n\t\tvar offset = { value: 8 }; // start at 8, after magic stuff\n\n\t\tvar keepReading = true;\n\n\t\twhile ( keepReading ) {\n\n\t\t\tvar attributeName = parseNullTerminatedString( buffer, offset );\n\n\t\t\tif ( attributeName == 0 ) {\n\n\t\t\t\tkeepReading = false;\n\n\t\t\t} else {\n\n\t\t\t\tvar attributeType = parseNullTerminatedString( buffer, offset );\n\t\t\t\tvar attributeSize = parseUint32( bufferDataView, offset );\n\t\t\t\tvar attributeValue = parseValue( bufferDataView, buffer, offset, attributeType, attributeSize );\n\n\t\t\t\tEXRHeader[ attributeName ] = attributeValue;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// offsets\n\t\tvar dataWindowHeight = EXRHeader.dataWindow.yMax + 1;\n\n\t\tvar uncompress;\n\t\tvar scanlineBlockSize;\n\n\t\tswitch ( EXRHeader.compression ) {\n\n\t\t\tcase 'NO_COMPRESSION':\n\n\t\t\t\tscanlineBlockSize = 1;\n\t\t\t\tuncompress = uncompressRAW;\n\t\t\t\tbreak;\n\n\t\t\tcase 'RLE_COMPRESSION':\n\n\t\t\t\tscanlineBlockSize = 1;\n\t\t\t\tuncompress = uncompressRLE;\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZIPS_COMPRESSION':\n\n\t\t\t\tscanlineBlockSize = 1;\n\t\t\t\tuncompress = uncompressZIP;\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZIP_COMPRESSION':\n\n\t\t\t\tscanlineBlockSize = 16;\n\t\t\t\tuncompress = uncompressZIP;\n\t\t\t\tbreak;\n\n\t\t\tcase 'PIZ_COMPRESSION':\n\n\t\t\t\tscanlineBlockSize = 32;\n\t\t\t\tuncompress = uncompressPIZ;\n\t\t\t\tbreak;\n\n\t\t\tcase 'DWAA_COMPRESSION':\n\n\t\t\t\tscanlineBlockSize = 32;\n\t\t\t\tuncompress = uncompressDWA;\n\t\t\t\tbreak;\n\n\t\t\tcase 'DWAB_COMPRESSION':\n\n\t\t\t\tscanlineBlockSize = 256;\n\t\t\t\tuncompress = uncompressDWA;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tthrow 'EXRLoader.parse: ' + EXRHeader.compression + ' is unsupported';\n\n\t\t}\n\n\t\tvar size_t;\n\t\tvar getValue;\n\n\t\t// mixed pixelType not supported\n\t\tvar pixelType = EXRHeader.channels[ 0 ].pixelType;\n\n\t\tif ( pixelType === 1 ) { // half\n\n\t\t\tswitch ( this.type ) {\n\n\t\t\t\tcase FloatType:\n\n\t\t\t\t\tgetValue = parseFloat16;\n\t\t\t\t\tsize_t = INT16_SIZE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase HalfFloatType:\n\n\t\t\t\t\tgetValue = parseUint16;\n\t\t\t\t\tsize_t = INT16_SIZE;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t} else if ( pixelType === 2 ) { // float\n\n\t\t\tswitch ( this.type ) {\n\n\t\t\t\tcase FloatType:\n\n\t\t\t\t\tgetValue = parseFloat32;\n\t\t\t\t\tsize_t = FLOAT32_SIZE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase HalfFloatType:\n\n\t\t\t\t\tthrow 'EXRLoader.parse: unsupported HalfFloatType texture for FloatType image file.';\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthrow 'EXRLoader.parse: unsupported pixelType ' + pixelType + ' for ' + EXRHeader.compression + '.';\n\n\t\t}\n\n\t\tvar numBlocks = dataWindowHeight / scanlineBlockSize;\n\n\t\tfor ( var i = 0; i < numBlocks; i ++ ) {\n\n\t\t\tparseUlong( bufferDataView, offset ); // scanlineOffset\n\n\t\t}\n\n\t\t// we should be passed the scanline offset table, start reading pixel data\n\n\t\tvar width = EXRHeader.dataWindow.xMax - EXRHeader.dataWindow.xMin + 1;\n\t\tvar height = EXRHeader.dataWindow.yMax - EXRHeader.dataWindow.yMin + 1;\n\t\t// Firefox only supports RGBA (half) float textures\n\t\t// var numChannels = EXRHeader.channels.length;\n\t\tvar numChannels = 4;\n\t\tvar size = width * height * numChannels;\n\n\t\t// Fill initially with 1s for the alpha value if the texture is not RGBA, RGB values will be overwritten\n\t\tswitch ( this.type ) {\n\n\t\t\tcase FloatType:\n\n\t\t\t\tvar byteArray = new Float32Array( size );\n\n\t\t\t\tif ( EXRHeader.channels.length < numChannels ) {\n\n\t\t\t\t\tbyteArray.fill( 1, 0, size );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase HalfFloatType:\n\n\t\t\t\tvar byteArray = new Uint16Array( size );\n\n\t\t\t\tif ( EXRHeader.channels.length < numChannels ) {\n\n\t\t\t\t\tbyteArray.fill( 0x3C00, 0, size ); // Uint16Array holds half float data, 0x3C00 is 1\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tconsole.error( 'THREE.EXRLoader: unsupported type: ', this.type );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tvar channelOffsets = {\n\t\t\tR: 0,\n\t\t\tG: 1,\n\t\t\tB: 2,\n\t\t\tA: 3\n\t\t};\n\n\t\tvar compressionInfo = {\n\n\t\t\tsize: 0,\n\t\t\twidth: width,\n\t\t\tlines: scanlineBlockSize,\n\n\t\t\toffset: offset,\n\t\t\tarray: uInt8Array,\n\t\t\tviewer: bufferDataView,\n\n\t\t\ttype: pixelType,\n\t\t\tchannels: EXRHeader.channels.length,\n\n\t\t};\n\n\t\tvar line;\n\t\tvar size;\n\t\tvar viewer;\n\t\tvar tmpOffset = { value: 0 };\n\n\t\tfor ( var scanlineBlockIdx = 0; scanlineBlockIdx < height / scanlineBlockSize; scanlineBlockIdx ++ ) {\n\n\t\t\tline = parseUint32( bufferDataView, offset ); // line_no\n\t\t\tsize = parseUint32( bufferDataView, offset ); // data_len\n\n\t\t\tcompressionInfo.lines = ( line + scanlineBlockSize > height ) ? height - line : scanlineBlockSize;\n\t\t\tcompressionInfo.offset = offset;\n\t\t\tcompressionInfo.size = size;\n\n\t\t\tviewer = uncompress( compressionInfo );\n\n\t\t\toffset.value += size;\n\n\t\t\tfor ( var line_y = 0; line_y < scanlineBlockSize; line_y ++ ) {\n\n\t\t\t\tvar true_y = line_y + ( scanlineBlockIdx * scanlineBlockSize );\n\n\t\t\t\tif ( true_y >= height ) break;\n\n\t\t\t\tfor ( var channelID = 0; channelID < EXRHeader.channels.length; channelID ++ ) {\n\n\t\t\t\t\tvar cOff = channelOffsets[ EXRHeader.channels[ channelID ].name ];\n\n\t\t\t\t\tfor ( var x = 0; x < width; x ++ ) {\n\n\t\t\t\t\t\tvar idx = ( line_y * ( EXRHeader.channels.length * width ) ) + ( channelID * width ) + x;\n\t\t\t\t\t\ttmpOffset.value = idx * size_t;\n\n\t\t\t\t\t\tvar val = getValue( viewer, tmpOffset );\n\n\t\t\t\t\t\tbyteArray[ ( ( ( height - 1 - true_y ) * ( width * numChannels ) ) + ( x * numChannels ) ) + cOff ] = val;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn {\n\t\t\theader: EXRHeader,\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tdata: byteArray,\n\t\t\tformat: numChannels === 4 ? RGBAFormat : RGBFormat,\n\t\t\ttype: this.type\n\t\t};\n\n\t},\n\n\tsetDataType: function ( value ) {\n\n\t\tthis.type = value;\n\t\treturn this;\n\n\t},\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tfunction onLoadCallback( texture, texData ) {\n\n\t\t\tswitch ( texture.type ) {\n\n\t\t\t\tcase FloatType:\n\n\t\t\t\t\ttexture.encoding = LinearEncoding;\n\t\t\t\t\ttexture.minFilter = LinearFilter;\n\t\t\t\t\ttexture.magFilter = LinearFilter;\n\t\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\t\ttexture.flipY = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase HalfFloatType:\n\n\t\t\t\t\ttexture.encoding = LinearEncoding;\n\t\t\t\t\ttexture.minFilter = LinearFilter;\n\t\t\t\t\ttexture.magFilter = LinearFilter;\n\t\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\t\ttexture.flipY = false;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t}\n\n\t\treturn DataTextureLoader.prototype.load.call( this, url, onLoadCallback, onProgress, onError );\n\n\t}\n\n} );\n\nexport { EXRLoader };\n"],"sourceRoot":""}