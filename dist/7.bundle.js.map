{"version":3,"sources":["webpack://POLY/./modules/three/examples/jsm/loaders/SVGLoader.js"],"names":["tempV2_1","tempV2_2","tempV2_3","tempV2_4","tempV2_5","tempV2_6","tempV2_7","lastPointL","lastPointR","point0L","point0R","currentPointL","currentPointR","nextPointL","nextPointR","innerPoint","outerPoint","SVGLoader","manager","call","this","defaultDPI","defaultUnit","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","text","parse","parseArcCommand","rx","ry","x_axis_rotation","large_arc_flag","sweep_flag","start","end","Math","PI","abs","dx2","x","dy2","y","x1p","cos","sin","y1p","rxs","rys","x1ps","y1ps","cr","s","sqrt","dq","pq","q","max","cxp","cyp","cx","cy","theta","svgAngle","delta","currentPath","absellipse","ux","uy","vx","vy","dot","len","ang","acos","min","parseStyle","node","style","addStyle","svgName","jsName","adjustFunction","undefined","v","hasAttribute","getAttribute","clamp","parseFloatWithUnits","positive","getReflection","a","b","parseFloats","string","array","split","i","length","number","indexOf","lastIndexOf","splice","units","unitConversion","theUnit","String","n","u","endsWith","substring","scale","parseFloat","getTransformScaleX","m","te","elements","getTransformScaleY","paths","transformStack","tempTransform0","tempTransform1","tempTransform2","tempTransform3","tempV2","tempV3","currentTransform","xml","DOMParser","parseFromString","parseNode","nodeType","transform","transformsTexts","tIndex","transformText","trim","openParPos","closeParPos","transformType","substr","identity","tx","ty","translate","angle","rotate","multiplyMatrices","scaleX","scaleY","set","tan","premultiply","parseNodeTransform","copy","push","getNodeTransform","nodeName","point","control","firstPoint","isFirstPoint","doSetFirstPoint","commands","match","l","command","type","charAt","data","numbers","j","jl","moveTo","lineTo","bezierCurveTo","quadraticCurveTo","clone","autoClose","curves","currentPoint","console","warn","parsePathNode","w","h","parseRectNode","iterator","index","replace","parsePolygonNode","parsePolylineNode","r","subpath","absarc","subPaths","parseCircleNode","parseEllipseNode","x1","y1","x2","y2","parseLineNode","log","fill","color","setStyle","transfVec2","v2","applyMatrix3","isRotated","isTransformRotated","curve","isLineCurve","v1","isCubicBezierCurve","v0","v3","isQuadraticBezierCurve","isEllipseCurve","aX","aY","xRadius","yRadius","transformPath","userData","nodes","childNodes","pop","documentElement","fillOpacity","strokeOpacity","strokeWidth","strokeLineJoin","strokeLineCap","strokeMiterLimit","getStrokeStyle","width","lineJoin","lineCap","miterLimit","strokeColor","pointsToStroke","points","arcDivisions","minDistance","vertices","normals","uvs","pointsToStrokeWithBuffers","geometry","setAttribute","vertexOffset","numPoints","dupPoints","distanceTo","newPoints","removeDuplicatedPoints","nextPoint","innerSideModified","joinIsOnLeftSide","isMiter","isClosed","equals","previousPoint","strokeWidth2","deltaU","u0","initialJoinIsOnLeftSide","numVertices","currentCoordinate","currentCoordinateUV","getNormal","multiplyScalar","sub","add","iPoint","normal1","u1","subVectors","normalize","miterSide","setLength","negate","miterLength2","segmentLengthPrev","divideScalar","segmentLengthNext","makeSegmentTriangles","makeSegmentWithBevelJoin","createSegmentTrianglesWithMiddleSection","makeCircularSector","miterFraction","addVertex","addCapGeometry","lastOuter","lastInner","toArray","p1","p2","result","position","center","il","rotateAround","addVectors","vl"],"mappings":"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","file":"7.bundle.js","sourcesContent":["import {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {FileLoader} from 'three/src/loaders/FileLoader';\nimport {Float32BufferAttribute} from 'three/src/core/BufferAttribute';\nimport {Loader} from 'three/src/loaders/Loader';\nimport {Matrix3} from 'three/src/math/Matrix3';\nimport {Path} from 'three/src/extras/core/Path';\nimport {ShapePath} from 'three/src/extras/core/ShapePath';\nimport {Vector2} from 'three/src/math/Vector2';\nimport {Vector3} from 'three/src/math/Vector3';\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author zz85 / http://joshuakoo.com/\n * @author yomboprime / https://yombo.org\n */\n\n\nvar SVGLoader = function ( manager ) {\n\n\tLoader.call( this, manager );\n\n\t// Default dots per inch\n\tthis.defaultDPI = 90;\n\n\t// Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px'\n\tthis.defaultUnit = \"px\";\n\n};\n\nSVGLoader.prototype = Object.assign( Object.create( Loader.prototype ), {\n\n\tconstructor: SVGLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tonLoad( scope.parse( text ) );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tparse: function ( text ) {\n\n\t\tvar scope = this;\n\n\t\tfunction parseNode( node, style ) {\n\n\t\t\tif ( node.nodeType !== 1 ) return;\n\n\t\t\tvar transform = getNodeTransform( node );\n\n\t\t\tvar path = null;\n\n\t\t\tswitch ( node.nodeName ) {\n\n\t\t\t\tcase 'svg':\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'g':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'path':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tif ( node.hasAttribute( 'd' ) ) path = parsePathNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rect':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseRectNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'polygon':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parsePolygonNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'polyline':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parsePolylineNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'circle':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseCircleNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ellipse':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseEllipseNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'line':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseLineNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.log( node );\n\n\t\t\t}\n\n\t\t\tif ( path ) {\n\n\t\t\t\tif ( style.fill !== undefined && style.fill !== 'none' ) {\n\n\t\t\t\t\tpath.color.setStyle( style.fill );\n\n\t\t\t\t}\n\n\t\t\t\ttransformPath( path, currentTransform );\n\n\t\t\t\tpaths.push( path );\n\n\t\t\t\tpath.userData = { node: node, style: style };\n\n\t\t\t}\n\n\t\t\tvar nodes = node.childNodes;\n\n\t\t\tfor ( var i = 0; i < nodes.length; i ++ ) {\n\n\t\t\t\tparseNode( nodes[ i ], style );\n\n\t\t\t}\n\n\t\t\tif ( transform ) {\n\n\t\t\t\ttransformStack.pop();\n\n\t\t\t\tif ( transformStack.length > 0 ) {\n\n\t\t\t\t\tcurrentTransform.copy( transformStack[ transformStack.length - 1 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcurrentTransform.identity();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parsePathNode( node ) {\n\n\t\t\tvar path = new ShapePath();\n\n\t\t\tvar point = new Vector2();\n\t\t\tvar control = new Vector2();\n\n\t\t\tvar firstPoint = new Vector2();\n\t\t\tvar isFirstPoint = true;\n\t\t\tvar doSetFirstPoint = false;\n\n\t\t\tvar d = node.getAttribute( 'd' );\n\n\t\t\t// console.log( d );\n\n\t\t\tvar commands = d.match( /[a-df-z][^a-df-z]*/ig );\n\n\t\t\tfor ( var i = 0, l = commands.length; i < l; i ++ ) {\n\n\t\t\t\tvar command = commands[ i ];\n\n\t\t\t\tvar type = command.charAt( 0 );\n\t\t\t\tvar data = command.substr( 1 ).trim();\n\n\t\t\t\tif ( isFirstPoint === true ) {\n\n\t\t\t\t\tdoSetFirstPoint = true;\n\t\t\t\t\tisFirstPoint = false;\n\n\t\t\t\t}\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase 'M':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\n\t\t\t\t\t\t\tif ( j === 0 ) {\n\n\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'H':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'V':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.y = numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'L':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'C':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 6 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 4 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 5 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 3 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 4 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 5 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'S':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\n\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Q':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'T':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tvar rx = getReflection( point.x, control.x );\n\t\t\t\t\t\t\tvar ry = getReflection( point.y, control.y );\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\trx,\n\t\t\t\t\t\t\t\try,\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = rx;\n\t\t\t\t\t\t\tcontrol.y = ry;\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'A':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 7 ) {\n\n\t\t\t\t\t\t\tvar start = point.clone();\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 5 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 6 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tparseArcCommand(\n\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'm':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\n\t\t\t\t\t\t\tif ( j === 0 ) {\n\n\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'h':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.y += numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'l':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 6 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 4 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 5 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 2 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 3 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 4 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 5 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 's':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\n\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'q':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tvar rx = getReflection( point.x, control.x );\n\t\t\t\t\t\t\tvar ry = getReflection( point.y, control.y );\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\trx,\n\t\t\t\t\t\t\t\try,\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = rx;\n\t\t\t\t\t\t\tcontrol.y = ry;\n\t\t\t\t\t\t\tpoint.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = point.y + numbers[ j + 1 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'a':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 7 ) {\n\n\t\t\t\t\t\t\tvar start = point.clone();\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 5 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 6 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tparseArcCommand(\n\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Z':\n\t\t\t\t\tcase 'z':\n\t\t\t\t\t\tpath.currentPath.autoClose = true;\n\n\t\t\t\t\t\tif ( path.currentPath.curves.length > 0 ) {\n\n\t\t\t\t\t\t\t// Reset point to beginning of Path\n\t\t\t\t\t\t\tpoint.copy( firstPoint );\n\t\t\t\t\t\t\tpath.currentPath.currentPoint.copy( point );\n\t\t\t\t\t\t\tisFirstPoint = true;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( command );\n\n\t\t\t\t}\n\n\t\t\t\t// console.log( type, parseFloats( data ), parseFloats( data ).length  )\n\n\t\t\t\tdoSetFirstPoint = false;\n\n\t\t\t}\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\t/**\n\t\t * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n\t\t * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\n\t\t * From\n\t\t * rx ry x-axis-rotation large-arc-flag sweep-flag x y\n\t\t * To\n\t\t * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation\n\t\t */\n\n\t\tfunction parseArcCommand( path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end ) {\n\n\t\t\tx_axis_rotation = x_axis_rotation * Math.PI / 180;\n\n\t\t\t// Ensure radii are positive\n\t\t\trx = Math.abs( rx );\n\t\t\try = Math.abs( ry );\n\n\t\t\t// Compute (x1′, y1′)\n\t\t\tvar dx2 = ( start.x - end.x ) / 2.0;\n\t\t\tvar dy2 = ( start.y - end.y ) / 2.0;\n\t\t\tvar x1p = Math.cos( x_axis_rotation ) * dx2 + Math.sin( x_axis_rotation ) * dy2;\n\t\t\tvar y1p = - Math.sin( x_axis_rotation ) * dx2 + Math.cos( x_axis_rotation ) * dy2;\n\n\t\t\t// Compute (cx′, cy′)\n\t\t\tvar rxs = rx * rx;\n\t\t\tvar rys = ry * ry;\n\t\t\tvar x1ps = x1p * x1p;\n\t\t\tvar y1ps = y1p * y1p;\n\n\t\t\t// Ensure radii are large enough\n\t\t\tvar cr = x1ps / rxs + y1ps / rys;\n\n\t\t\tif ( cr > 1 ) {\n\n\t\t\t\t// scale up rx,ry equally so cr == 1\n\t\t\t\tvar s = Math.sqrt( cr );\n\t\t\t\trx = s * rx;\n\t\t\t\try = s * ry;\n\t\t\t\trxs = rx * rx;\n\t\t\t\trys = ry * ry;\n\n\t\t\t}\n\n\t\t\tvar dq = ( rxs * y1ps + rys * x1ps );\n\t\t\tvar pq = ( rxs * rys - dq ) / dq;\n\t\t\tvar q = Math.sqrt( Math.max( 0, pq ) );\n\t\t\tif ( large_arc_flag === sweep_flag ) q = - q;\n\t\t\tvar cxp = q * rx * y1p / ry;\n\t\t\tvar cyp = - q * ry * x1p / rx;\n\n\t\t\t// Step 3: Compute (cx, cy) from (cx′, cy′)\n\t\t\tvar cx = Math.cos( x_axis_rotation ) * cxp - Math.sin( x_axis_rotation ) * cyp + ( start.x + end.x ) / 2;\n\t\t\tvar cy = Math.sin( x_axis_rotation ) * cxp + Math.cos( x_axis_rotation ) * cyp + ( start.y + end.y ) / 2;\n\n\t\t\t// Step 4: Compute θ1 and Δθ\n\t\t\tvar theta = svgAngle( 1, 0, ( x1p - cxp ) / rx, ( y1p - cyp ) / ry );\n\t\t\tvar delta = svgAngle( ( x1p - cxp ) / rx, ( y1p - cyp ) / ry, ( - x1p - cxp ) / rx, ( - y1p - cyp ) / ry ) % ( Math.PI * 2 );\n\n\t\t\tpath.currentPath.absellipse( cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation );\n\n\t\t}\n\n\t\tfunction svgAngle( ux, uy, vx, vy ) {\n\n\t\t\tvar dot = ux * vx + uy * vy;\n\t\t\tvar len = Math.sqrt( ux * ux + uy * uy ) * Math.sqrt( vx * vx + vy * vy );\n\t\t\tvar ang = Math.acos( Math.max( - 1, Math.min( 1, dot / len ) ) ); // floating point precision, slightly over values appear\n\t\t\tif ( ( ux * vy - uy * vx ) < 0 ) ang = - ang;\n\t\t\treturn ang;\n\n\t\t}\n\n\t\t/*\n\t\t* According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute\n\t\t* rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough\n\t\t*/\n\t\tfunction parseRectNode( node ) {\n\n\t\t\tvar x = parseFloatWithUnits( node.getAttribute( 'x' ) || 0 );\n\t\t\tvar y = parseFloatWithUnits( node.getAttribute( 'y' ) || 0 );\n\t\t\tvar rx = parseFloatWithUnits( node.getAttribute( 'rx' ) || 0 );\n\t\t\tvar ry = parseFloatWithUnits( node.getAttribute( 'ry' ) || 0 );\n\t\t\tvar w = parseFloatWithUnits( node.getAttribute( 'width' ) );\n\t\t\tvar h = parseFloatWithUnits( node.getAttribute( 'height' ) );\n\n\t\t\tvar path = new ShapePath();\n\t\t\tpath.moveTo( x + 2 * rx, y );\n\t\t\tpath.lineTo( x + w - 2 * rx, y );\n\t\t\tif ( rx !== 0 || ry !== 0 ) path.bezierCurveTo( x + w, y, x + w, y, x + w, y + 2 * ry );\n\t\t\tpath.lineTo( x + w, y + h - 2 * ry );\n\t\t\tif ( rx !== 0 || ry !== 0 ) path.bezierCurveTo( x + w, y + h, x + w, y + h, x + w - 2 * rx, y + h );\n\t\t\tpath.lineTo( x + 2 * rx, y + h );\n\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo( x, y + h, x, y + h, x, y + h - 2 * ry );\n\n\t\t\t}\n\n\t\t\tpath.lineTo( x, y + 2 * ry );\n\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo( x, y, x, y, x + 2 * rx, y );\n\n\t\t\t}\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parsePolygonNode( node ) {\n\n\t\t\tfunction iterator( match, a, b ) {\n\n\t\t\t\tvar x = parseFloatWithUnits( a );\n\t\t\t\tvar y = parseFloatWithUnits( b );\n\n\t\t\t\tif ( index === 0 ) {\n\n\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t}\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\tvar regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n\n\t\t\tvar path = new ShapePath();\n\n\t\t\tvar index = 0;\n\n\t\t\tnode.getAttribute( 'points' ).replace( regex, iterator );\n\n\t\t\tpath.currentPath.autoClose = true;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parsePolylineNode( node ) {\n\n\t\t\tfunction iterator( match, a, b ) {\n\n\t\t\t\tvar x = parseFloatWithUnits( a );\n\t\t\t\tvar y = parseFloatWithUnits( b );\n\n\t\t\t\tif ( index === 0 ) {\n\n\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t}\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\tvar regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n\n\t\t\tvar path = new ShapePath();\n\n\t\t\tvar index = 0;\n\n\t\t\tnode.getAttribute( 'points' ).replace( regex, iterator );\n\n\t\t\tpath.currentPath.autoClose = false;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseCircleNode( node ) {\n\n\t\t\tvar x = parseFloatWithUnits( node.getAttribute( 'cx' ) );\n\t\t\tvar y = parseFloatWithUnits( node.getAttribute( 'cy' ) );\n\t\t\tvar r = parseFloatWithUnits( node.getAttribute( 'r' ) );\n\n\t\t\tvar subpath = new Path();\n\t\t\tsubpath.absarc( x, y, r, 0, Math.PI * 2 );\n\n\t\t\tvar path = new ShapePath();\n\t\t\tpath.subPaths.push( subpath );\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseEllipseNode( node ) {\n\n\t\t\tvar x = parseFloatWithUnits( node.getAttribute( 'cx' ) );\n\t\t\tvar y = parseFloatWithUnits( node.getAttribute( 'cy' ) );\n\t\t\tvar rx = parseFloatWithUnits( node.getAttribute( 'rx' ) );\n\t\t\tvar ry = parseFloatWithUnits( node.getAttribute( 'ry' ) );\n\n\t\t\tvar subpath = new Path();\n\t\t\tsubpath.absellipse( x, y, rx, ry, 0, Math.PI * 2 );\n\n\t\t\tvar path = new ShapePath();\n\t\t\tpath.subPaths.push( subpath );\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseLineNode( node ) {\n\n\t\t\tvar x1 = parseFloatWithUnits( node.getAttribute( 'x1' ) );\n\t\t\tvar y1 = parseFloatWithUnits( node.getAttribute( 'y1' ) );\n\t\t\tvar x2 = parseFloatWithUnits( node.getAttribute( 'x2' ) );\n\t\t\tvar y2 = parseFloatWithUnits( node.getAttribute( 'y2' ) );\n\n\t\t\tvar path = new ShapePath();\n\t\t\tpath.moveTo( x1, y1 );\n\t\t\tpath.lineTo( x2, y2 );\n\t\t\tpath.currentPath.autoClose = false;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\t//\n\n\t\tfunction parseStyle( node, style ) {\n\n\t\t\tstyle = Object.assign( {}, style ); // clone style\n\n\t\t\tfunction addStyle( svgName, jsName, adjustFunction ) {\n\n\t\t\t\tif ( adjustFunction === undefined ) adjustFunction = function copy( v ) {\n\n\t\t\t\t\treturn v;\n\n\t\t\t\t};\n\n\t\t\t\tif ( node.hasAttribute( svgName ) ) style[ jsName ] = adjustFunction( node.getAttribute( svgName ) );\n\t\t\t\tif ( node.style && node.style[ svgName ] !== '' ) style[ jsName ] = adjustFunction( node.style[ svgName ] );\n\n\t\t\t}\n\n\t\t\tfunction clamp( v ) {\n\n\t\t\t\treturn Math.max( 0, Math.min( 1, parseFloatWithUnits( v ) ) );\n\n\t\t\t}\n\n\t\t\tfunction positive( v ) {\n\n\t\t\t\treturn Math.max( 0, parseFloatWithUnits( v ) );\n\n\t\t\t}\n\n\t\t\taddStyle( 'fill', 'fill' );\n\t\t\taddStyle( 'fill-opacity', 'fillOpacity', clamp );\n\t\t\taddStyle( 'stroke', 'stroke' );\n\t\t\taddStyle( 'stroke-opacity', 'strokeOpacity', clamp );\n\t\t\taddStyle( 'stroke-width', 'strokeWidth', positive );\n\t\t\taddStyle( 'stroke-linejoin', 'strokeLineJoin' );\n\t\t\taddStyle( 'stroke-linecap', 'strokeLineCap' );\n\t\t\taddStyle( 'stroke-miterlimit', 'strokeMiterLimit', positive );\n\n\t\t\treturn style;\n\n\t\t}\n\n\t\t// http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\n\n\t\tfunction getReflection( a, b ) {\n\n\t\t\treturn a - ( b - a );\n\n\t\t}\n\n\t\tfunction parseFloats( string ) {\n\n\t\t\tvar array = string.split( /[\\s,]+|(?=\\s?[+\\-])/ );\n\n\t\t\tfor ( var i = 0; i < array.length; i ++ ) {\n\n\t\t\t\tvar number = array[ i ];\n\n\t\t\t\t// Handle values like 48.6037.7.8\n\t\t\t\t// TODO Find a regex for this\n\n\t\t\t\tif ( number.indexOf( '.' ) !== number.lastIndexOf( '.' ) ) {\n\n\t\t\t\t\tvar split = number.split( '.' );\n\n\t\t\t\t\tfor ( var s = 2; s < split.length; s ++ ) {\n\n\t\t\t\t\t\tarray.splice( i + s - 1, 0, '0.' + split[ s ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tarray[ i ] = parseFloatWithUnits( number );\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\n\t\t}\n\n\t\t// Units\n\n\t\tvar units = [ 'mm', 'cm', 'in', 'pt', 'pc', 'px' ];\n\n\t\t// Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)\n\t\tvar unitConversion = {\n\n\t\t\t\"mm\": {\n\t\t\t\t\"mm\": 1,\n\t\t\t\t\"cm\": 0.1,\n\t\t\t\t\"in\": 1 / 25.4,\n\t\t\t\t\"pt\": 72 / 25.4,\n\t\t\t\t\"pc\": 6 / 25.4,\n\t\t\t\t\"px\": - 1\n\t\t\t},\n\t\t\t\"cm\": {\n\t\t\t\t\"mm\": 10,\n\t\t\t\t\"cm\": 1,\n\t\t\t\t\"in\": 1 / 2.54,\n\t\t\t\t\"pt\": 72 / 2.54,\n\t\t\t\t\"pc\": 6 / 2.54,\n\t\t\t\t\"px\": - 1\n\t\t\t},\n\t\t\t\"in\": {\n\t\t\t\t\"mm\": 25.4,\n\t\t\t\t\"cm\": 2.54,\n\t\t\t\t\"in\": 1,\n\t\t\t\t\"pt\": 72,\n\t\t\t\t\"pc\": 6,\n\t\t\t\t\"px\": - 1\n\t\t\t},\n\t\t\t\"pt\": {\n\t\t\t\t\"mm\": 25.4 / 72,\n\t\t\t\t\"cm\": 2.54 / 72,\n\t\t\t\t\"in\": 1 / 72,\n\t\t\t\t\"pt\": 1,\n\t\t\t\t\"pc\": 6 / 72,\n\t\t\t\t\"px\": - 1\n\t\t\t},\n\t\t\t\"pc\": {\n\t\t\t\t\"mm\": 25.4 / 6,\n\t\t\t\t\"cm\": 2.54 / 6,\n\t\t\t\t\"in\": 1 / 6,\n\t\t\t\t\"pt\": 72 / 6,\n\t\t\t\t\"pc\": 1,\n\t\t\t\t\"px\": - 1\n\t\t\t},\n\t\t\t\"px\": {\n\t\t\t\t\"px\": 1\n\t\t\t}\n\n\t\t};\n\n\t\tfunction parseFloatWithUnits( string ) {\n\n\t\t\tvar theUnit = \"px\";\n\n\t\t\tif ( typeof string === 'string' || string instanceof String ) {\n\n\t\t\t\tfor ( var i = 0, n = units.length; i < n; i ++ ) {\n\n\t\t\t\t\tvar u = units[ i ];\n\n\t\t\t\t\tif ( string.endsWith( u ) ) {\n\n\t\t\t\t\t\ttheUnit = u;\n\t\t\t\t\t\tstring = string.substring( 0, string.length - u.length );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar scale = undefined;\n\n\t\t\tif ( theUnit === \"px\" && scope.defaultUnit !== \"px\" ) {\n\n\t\t\t\t// Conversion scale from  pixels to inches, then to default units\n\n\t\t\t\tscale = unitConversion[ \"in\" ][ scope.defaultUnit ] / scope.defaultDPI;\n\n\t\t\t} else {\n\n\t\t\t\tscale = unitConversion[ theUnit ][ scope.defaultUnit ];\n\n\t\t\t\tif ( scale < 0 ) {\n\n\t\t\t\t\t// Conversion scale to pixels\n\n\t\t\t\t\tscale = unitConversion[ theUnit ][ \"in\" ] * scope.defaultDPI;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn scale * parseFloat( string );\n\n\t\t}\n\n\t\t// Transforms\n\n\t\tfunction getNodeTransform( node ) {\n\n\t\t\tif ( ! node.hasAttribute( 'transform' ) ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tvar transform = parseNodeTransform( node );\n\n\t\t\tif ( transformStack.length > 0 ) {\n\n\t\t\t\ttransform.premultiply( transformStack[ transformStack.length - 1 ] );\n\n\t\t\t}\n\n\t\t\tcurrentTransform.copy( transform );\n\t\t\ttransformStack.push( transform );\n\n\t\t\treturn transform;\n\n\t\t}\n\n\t\tfunction parseNodeTransform( node ) {\n\n\t\t\tvar transform = new Matrix3();\n\t\t\tvar currentTransform = tempTransform0;\n\t\t\tvar transformsTexts = node.getAttribute( 'transform' ).split( ')' );\n\n\t\t\tfor ( var tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex -- ) {\n\n\t\t\t\tvar transformText = transformsTexts[ tIndex ].trim();\n\n\t\t\t\tif ( transformText === '' ) continue;\n\n\t\t\t\tvar openParPos = transformText.indexOf( '(' );\n\t\t\t\tvar closeParPos = transformText.length;\n\n\t\t\t\tif ( openParPos > 0 && openParPos < closeParPos ) {\n\n\t\t\t\t\tvar transformType = transformText.substr( 0, openParPos );\n\n\t\t\t\t\tvar array = parseFloats( transformText.substr( openParPos + 1, closeParPos - openParPos - 1 ) );\n\n\t\t\t\t\tcurrentTransform.identity();\n\n\t\t\t\t\tswitch ( transformType ) {\n\n\t\t\t\t\t\tcase \"translate\":\n\n\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\tvar tx = array[ 0 ];\n\t\t\t\t\t\t\t\tvar ty = tx;\n\n\t\t\t\t\t\t\t\tif ( array.length >= 2 ) {\n\n\t\t\t\t\t\t\t\t\tty = array[ 1 ];\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tcurrentTransform.translate( tx, ty );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase \"rotate\":\n\n\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\tvar angle = 0;\n\t\t\t\t\t\t\t\tvar cx = 0;\n\t\t\t\t\t\t\t\tvar cy = 0;\n\n\t\t\t\t\t\t\t\t// Angle\n\t\t\t\t\t\t\t\tangle = - array[ 0 ] * Math.PI / 180;\n\n\t\t\t\t\t\t\t\tif ( array.length >= 3 ) {\n\n\t\t\t\t\t\t\t\t\t// Center x, y\n\t\t\t\t\t\t\t\t\tcx = array[ 1 ];\n\t\t\t\t\t\t\t\t\tcy = array[ 2 ];\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Rotate around center (cx, cy)\n\t\t\t\t\t\t\t\ttempTransform1.identity().translate( - cx, - cy );\n\t\t\t\t\t\t\t\ttempTransform2.identity().rotate( angle );\n\t\t\t\t\t\t\t\ttempTransform3.multiplyMatrices( tempTransform2, tempTransform1 );\n\t\t\t\t\t\t\t\ttempTransform1.identity().translate( cx, cy );\n\t\t\t\t\t\t\t\tcurrentTransform.multiplyMatrices( tempTransform1, tempTransform3 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase \"scale\":\n\n\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\tvar scaleX = array[ 0 ];\n\t\t\t\t\t\t\t\tvar scaleY = scaleX;\n\n\t\t\t\t\t\t\t\tif ( array.length >= 2 ) {\n\n\t\t\t\t\t\t\t\t\tscaleY = array[ 1 ];\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tcurrentTransform.scale( scaleX, scaleY );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase \"skewX\":\n\n\t\t\t\t\t\t\tif ( array.length === 1 ) {\n\n\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t1, Math.tan( array[ 0 ] * Math.PI / 180 ), 0,\n\t\t\t\t\t\t\t\t\t0, 1, 0,\n\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase \"skewY\":\n\n\t\t\t\t\t\t\tif ( array.length === 1 ) {\n\n\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t1, 0, 0,\n\t\t\t\t\t\t\t\t\tMath.tan( array[ 0 ] * Math.PI / 180 ), 1, 0,\n\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase \"matrix\":\n\n\t\t\t\t\t\t\tif ( array.length === 6 ) {\n\n\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\tarray[ 0 ], array[ 2 ], array[ 4 ],\n\t\t\t\t\t\t\t\t\tarray[ 1 ], array[ 3 ], array[ 5 ],\n\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\ttransform.premultiply( currentTransform );\n\n\t\t\t}\n\n\t\t\treturn transform;\n\n\t\t}\n\n\t\tfunction transformPath( path, m ) {\n\n\t\t\tfunction transfVec2( v2 ) {\n\n\t\t\t\ttempV3.set( v2.x, v2.y, 1 ).applyMatrix3( m );\n\n\t\t\t\tv2.set( tempV3.x, tempV3.y );\n\n\t\t\t}\n\n\t\t\tvar isRotated = isTransformRotated( m );\n\n\t\t\tvar subPaths = path.subPaths;\n\n\t\t\tfor ( var i = 0, n = subPaths.length; i < n; i ++ ) {\n\n\t\t\t\tvar subPath = subPaths[ i ];\n\t\t\t\tvar curves = subPath.curves;\n\n\t\t\t\tfor ( var j = 0; j < curves.length; j ++ ) {\n\n\t\t\t\t\tvar curve = curves[ j ];\n\n\t\t\t\t\tif ( curve.isLineCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\n\t\t\t\t\t} else if ( curve.isCubicBezierCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v0 );\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\t\t\t\t\t\ttransfVec2( curve.v3 );\n\n\t\t\t\t\t} else if ( curve.isQuadraticBezierCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v0 );\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\n\t\t\t\t\t} else if ( curve.isEllipseCurve ) {\n\n\t\t\t\t\t\tif ( isRotated ) {\n\n\t\t\t\t\t\t\tconsole.warn( \"SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented.\" );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttempV2.set( curve.aX, curve.aY );\n\t\t\t\t\t\ttransfVec2( tempV2 );\n\t\t\t\t\t\tcurve.aX = tempV2.x;\n\t\t\t\t\t\tcurve.aY = tempV2.y;\n\n\t\t\t\t\t\tcurve.xRadius *= getTransformScaleX( m );\n\t\t\t\t\t\tcurve.yRadius *= getTransformScaleY( m );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction isTransformRotated( m ) {\n\n\t\t\treturn m.elements[ 1 ] !== 0 || m.elements[ 3 ] !== 0;\n\n\t\t}\n\n\t\tfunction getTransformScaleX( m ) {\n\n\t\t\tvar te = m.elements;\n\t\t\treturn Math.sqrt( te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] );\n\n\t\t}\n\n\t\tfunction getTransformScaleY( m ) {\n\n\t\t\tvar te = m.elements;\n\t\t\treturn Math.sqrt( te[ 3 ] * te[ 3 ] + te[ 4 ] * te[ 4 ] );\n\n\t\t}\n\n\t\t//\n\n\t\tvar paths = [];\n\n\t\tvar transformStack = [];\n\n\t\tvar tempTransform0 = new Matrix3();\n\t\tvar tempTransform1 = new Matrix3();\n\t\tvar tempTransform2 = new Matrix3();\n\t\tvar tempTransform3 = new Matrix3();\n\t\tvar tempV2 = new Vector2();\n\t\tvar tempV3 = new Vector3();\n\n\t\tvar currentTransform = new Matrix3();\n\n\t\tvar xml = new DOMParser().parseFromString( text, 'image/svg+xml' ); // application/xml\n\n\t\tparseNode( xml.documentElement, {\n\t\t\tfill: '#000',\n\t\t\tfillOpacity: 1,\n\t\t\tstrokeOpacity: 1,\n\t\t\tstrokeWidth: 1,\n\t\t\tstrokeLineJoin: 'miter',\n\t\t\tstrokeLineCap: 'butt',\n\t\t\tstrokeMiterLimit: 4\n\t\t} );\n\n\t\tvar data = { paths: paths, xml: xml.documentElement };\n\n\t\t// console.log( paths );\n\t\treturn data;\n\n\t}\n\n} );\n\nSVGLoader.getStrokeStyle = function ( width, color, lineJoin, lineCap, miterLimit ) {\n\n\t// Param width: Stroke width\n\t// Param color: As returned by THREE.Color.getStyle()\n\t// Param lineJoin: One of \"round\", \"bevel\", \"miter\" or \"miter-limit\"\n\t// Param lineCap: One of \"round\", \"square\" or \"butt\"\n\t// Param miterLimit: Maximum join length, in multiples of the \"width\" parameter (join is truncated if it exceeds that distance)\n\t// Returns style object\n\n\twidth = width !== undefined ? width : 1;\n\tcolor = color !== undefined ? color : '#000';\n\tlineJoin = lineJoin !== undefined ? lineJoin : 'miter';\n\tlineCap = lineCap !== undefined ? lineCap : 'butt';\n\tmiterLimit = miterLimit !== undefined ? miterLimit : 4;\n\n\treturn {\n\t\tstrokeColor: color,\n\t\tstrokeWidth: width,\n\t\tstrokeLineJoin: lineJoin,\n\t\tstrokeLineCap: lineCap,\n\t\tstrokeMiterLimit: miterLimit\n\t};\n\n};\n\nSVGLoader.pointsToStroke = function ( points, style, arcDivisions, minDistance ) {\n\n\t// Generates a stroke with some witdh around the given path.\n\t// The path can be open or closed (last point equals to first point)\n\t// Param points: Array of Vector2D (the path). Minimum 2 points.\n\t// Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object\n\t// Params arcDivisions: Arc divisions for round joins and endcaps. (Optional)\n\t// Param minDistance: Points closer to this distance will be merged. (Optional)\n\t// Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right)\n\n\tvar vertices = [];\n\tvar normals = [];\n\tvar uvs = [];\n\n\tif ( SVGLoader.pointsToStrokeWithBuffers( points, style, arcDivisions, minDistance, vertices, normals, uvs ) === 0 ) {\n\n\t\treturn null;\n\n\t}\n\n\tvar geometry = new BufferGeometry();\n\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tgeometry.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\tgeometry.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\treturn geometry;\n\n};\n\nSVGLoader.pointsToStrokeWithBuffers = function () {\n\n\tvar tempV2_1 = new Vector2();\n\tvar tempV2_2 = new Vector2();\n\tvar tempV2_3 = new Vector2();\n\tvar tempV2_4 = new Vector2();\n\tvar tempV2_5 = new Vector2();\n\tvar tempV2_6 = new Vector2();\n\tvar tempV2_7 = new Vector2();\n\tvar lastPointL = new Vector2();\n\tvar lastPointR = new Vector2();\n\tvar point0L = new Vector2();\n\tvar point0R = new Vector2();\n\tvar currentPointL = new Vector2();\n\tvar currentPointR = new Vector2();\n\tvar nextPointL = new Vector2();\n\tvar nextPointR = new Vector2();\n\tvar innerPoint = new Vector2();\n\tvar outerPoint = new Vector2();\n\n\treturn function ( points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset ) {\n\n\t\t// This function can be called to update existing arrays or buffers.\n\t\t// Accepts same parameters as pointsToStroke, plus the buffers and optional offset.\n\t\t// Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)\n\t\t// Returns number of written vertices / normals / uvs pairs\n\t\t// if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)\n\t\t// 'normals' and 'uvs' buffers are optional\n\n\t\tarcDivisions = arcDivisions !== undefined ? arcDivisions : 12;\n\t\tminDistance = minDistance !== undefined ? minDistance : 0.001;\n\t\tvertexOffset = vertexOffset !== undefined ? vertexOffset : 0;\n\n\t\t// First ensure there are no duplicated points\n\t\tpoints = removeDuplicatedPoints( points );\n\n\t\tvar numPoints = points.length;\n\n\t\tif ( numPoints < 2 ) return 0;\n\n\t\tvar isClosed = points[ 0 ].equals( points[ numPoints - 1 ] );\n\n\t\tvar currentPoint;\n\t\tvar previousPoint = points[ 0 ];\n\t\tvar nextPoint;\n\n\t\tvar strokeWidth2 = style.strokeWidth / 2;\n\n\t\tvar deltaU = 1 / ( numPoints - 1 );\n\t\tvar u0 = 0;\n\n\t\tvar innerSideModified;\n\t\tvar joinIsOnLeftSide;\n\t\tvar isMiter;\n\t\tvar initialJoinIsOnLeftSide = false;\n\n\t\tvar numVertices = 0;\n\t\tvar currentCoordinate = vertexOffset * 3;\n\t\tvar currentCoordinateUV = vertexOffset * 2;\n\n\t\t// Get initial left and right stroke points\n\t\tgetNormal( points[ 0 ], points[ 1 ], tempV2_1 ).multiplyScalar( strokeWidth2 );\n\t\tlastPointL.copy( points[ 0 ] ).sub( tempV2_1 );\n\t\tlastPointR.copy( points[ 0 ] ).add( tempV2_1 );\n\t\tpoint0L.copy( lastPointL );\n\t\tpoint0R.copy( lastPointR );\n\n\t\tfor ( var iPoint = 1; iPoint < numPoints; iPoint ++ ) {\n\n\t\t\tcurrentPoint = points[ iPoint ];\n\n\t\t\t// Get next point\n\t\t\tif ( iPoint === numPoints - 1 ) {\n\n\t\t\t\tif ( isClosed ) {\n\n\t\t\t\t\t// Skip duplicated initial point\n\t\t\t\t\tnextPoint = points[ 1 ];\n\n\t\t\t\t} else nextPoint = undefined;\n\n\t\t\t} else {\n\n\t\t\t\tnextPoint = points[ iPoint + 1 ];\n\n\t\t\t}\n\n\t\t\t// Normal of previous segment in tempV2_1\n\t\t\tvar normal1 = tempV2_1;\n\t\t\tgetNormal( previousPoint, currentPoint, normal1 );\n\n\t\t\ttempV2_3.copy( normal1 ).multiplyScalar( strokeWidth2 );\n\t\t\tcurrentPointL.copy( currentPoint ).sub( tempV2_3 );\n\t\t\tcurrentPointR.copy( currentPoint ).add( tempV2_3 );\n\n\t\t\tvar u1 = u0 + deltaU;\n\n\t\t\tinnerSideModified = false;\n\n\t\t\tif ( nextPoint !== undefined ) {\n\n\t\t\t\t// Normal of next segment in tempV2_2\n\t\t\t\tgetNormal( currentPoint, nextPoint, tempV2_2 );\n\n\t\t\t\ttempV2_3.copy( tempV2_2 ).multiplyScalar( strokeWidth2 );\n\t\t\t\tnextPointL.copy( currentPoint ).sub( tempV2_3 );\n\t\t\t\tnextPointR.copy( currentPoint ).add( tempV2_3 );\n\n\t\t\t\tjoinIsOnLeftSide = true;\n\t\t\t\ttempV2_3.subVectors( nextPoint, previousPoint );\n\t\t\t\tif ( normal1.dot( tempV2_3 ) < 0 ) {\n\n\t\t\t\t\tjoinIsOnLeftSide = false;\n\n\t\t\t\t}\n\t\t\t\tif ( iPoint === 1 ) initialJoinIsOnLeftSide = joinIsOnLeftSide;\n\n\t\t\t\ttempV2_3.subVectors( nextPoint, currentPoint );\n\t\t\t\ttempV2_3.normalize();\n\t\t\t\tvar dot = Math.abs( normal1.dot( tempV2_3 ) );\n\n\t\t\t\t// If path is straight, don't create join\n\t\t\t\tif ( dot !== 0 ) {\n\n\t\t\t\t\t// Compute inner and outer segment intersections\n\t\t\t\t\tvar miterSide = strokeWidth2 / dot;\n\t\t\t\t\ttempV2_3.multiplyScalar( - miterSide );\n\t\t\t\t\ttempV2_4.subVectors( currentPoint, previousPoint );\n\t\t\t\t\ttempV2_5.copy( tempV2_4 ).setLength( miterSide ).add( tempV2_3 );\n\t\t\t\t\tinnerPoint.copy( tempV2_5 ).negate();\n\t\t\t\t\tvar miterLength2 = tempV2_5.length();\n\t\t\t\t\tvar segmentLengthPrev = tempV2_4.length();\n\t\t\t\t\ttempV2_4.divideScalar( segmentLengthPrev );\n\t\t\t\t\ttempV2_6.subVectors( nextPoint, currentPoint );\n\t\t\t\t\tvar segmentLengthNext = tempV2_6.length();\n\t\t\t\t\ttempV2_6.divideScalar( segmentLengthNext );\n\t\t\t\t\t// Check that previous and next segments doesn't overlap with the innerPoint of intersection\n\t\t\t\t\tif ( tempV2_4.dot( innerPoint ) < segmentLengthPrev && tempV2_6.dot( innerPoint ) < segmentLengthNext ) {\n\n\t\t\t\t\t\tinnerSideModified = true;\n\n\t\t\t\t\t}\n\t\t\t\t\touterPoint.copy( tempV2_5 ).add( currentPoint );\n\t\t\t\t\tinnerPoint.add( currentPoint );\n\n\t\t\t\t\tisMiter = false;\n\n\t\t\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\tnextPointR.copy( innerPoint );\n\t\t\t\t\t\t\tcurrentPointR.copy( innerPoint );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tnextPointL.copy( innerPoint );\n\t\t\t\t\t\t\tcurrentPointL.copy( innerPoint );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// The segment triangles are generated here if there was overlapping\n\n\t\t\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch ( style.strokeLineJoin ) {\n\n\t\t\t\t\t\tcase 'bevel':\n\n\t\t\t\t\t\t\tmakeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'round':\n\n\t\t\t\t\t\t\t// Segment triangles\n\n\t\t\t\t\t\t\tcreateSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );\n\n\t\t\t\t\t\t\t// Join triangles\n\n\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\tmakeCircularSector( currentPoint, currentPointL, nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tmakeCircularSector( currentPoint, nextPointR, currentPointR, u1, 1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'miter':\n\t\t\t\t\t\tcase 'miter-clip':\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tvar miterFraction = ( strokeWidth2 * style.strokeMiterLimit ) / miterLength2;\n\n\t\t\t\t\t\t\tif ( miterFraction < 1 ) {\n\n\t\t\t\t\t\t\t\t// The join miter length exceeds the miter limit\n\n\t\t\t\t\t\t\t\tif ( style.strokeLineJoin !== 'miter-clip' ) {\n\n\t\t\t\t\t\t\t\t\tmakeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// Segment triangles\n\n\t\t\t\t\t\t\t\t\tcreateSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );\n\n\t\t\t\t\t\t\t\t\t// Miter-clip join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\ttempV2_6.subVectors( outerPoint, currentPointL ).multiplyScalar( miterFraction ).add( currentPointL );\n\t\t\t\t\t\t\t\t\t\ttempV2_7.subVectors( outerPoint, nextPointL ).multiplyScalar( miterFraction ).add( nextPointL );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\ttempV2_6.subVectors( outerPoint, currentPointR ).multiplyScalar( miterFraction ).add( currentPointR );\n\t\t\t\t\t\t\t\t\t\ttempV2_7.subVectors( outerPoint, nextPointR ).multiplyScalar( miterFraction ).add( nextPointR );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointR, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Miter join segment triangles\n\n\t\t\t\t\t\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t\t\t\t\t\t// Optimized segment + join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\tnextPointL.copy( outerPoint );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\tnextPointR.copy( outerPoint );\n\n\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// Add extra miter join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointR, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tisMiter = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// The segment triangles are generated here when two consecutive points are collinear\n\n\t\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// The segment triangles are generated here if it is the ending segment\n\n\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t}\n\n\t\t\tif ( ! isClosed && iPoint === numPoints - 1 ) {\n\n\t\t\t\t// Start line endcap\n\t\t\t\taddCapGeometry( points[ 0 ], point0L, point0R, joinIsOnLeftSide, true, u0 );\n\n\t\t\t}\n\n\t\t\t// Increment loop variables\n\n\t\t\tu0 = u1;\n\n\t\t\tpreviousPoint = currentPoint;\n\n\t\t\tlastPointL.copy( nextPointL );\n\t\t\tlastPointR.copy( nextPointR );\n\n\t\t}\n\n\t\tif ( ! isClosed ) {\n\n\t\t\t// Ending line endcap\n\t\t\taddCapGeometry( currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1 );\n\n\t\t} else if ( innerSideModified && vertices ) {\n\n\t\t\t// Modify path first segment vertices to adjust to the segments inner and outer intersections\n\n\t\t\tvar lastOuter = outerPoint;\n\t\t\tvar lastInner = innerPoint;\n\n\t\t\tif ( initialJoinIsOnLeftSide !== joinIsOnLeftSide ) {\n\n\t\t\t\tlastOuter = innerPoint;\n\t\t\t\tlastInner = outerPoint;\n\n\t\t\t}\n\n\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\tif ( isMiter || initialJoinIsOnLeftSide ) {\n\n\t\t\t\t\tlastInner.toArray( vertices, 0 * 3 );\n\t\t\t\t\tlastInner.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\tif ( isMiter ) {\n\n\t\t\t\t\t\tlastOuter.toArray( vertices, 1 * 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( isMiter || ! initialJoinIsOnLeftSide ) {\n\n\t\t\t\t\tlastInner.toArray( vertices, 1 * 3 );\n\t\t\t\t\tlastInner.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\tif ( isMiter ) {\n\n\t\t\t\t\t\tlastOuter.toArray( vertices, 0 * 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn numVertices;\n\n\t\t// -- End of algorithm\n\n\t\t// -- Functions\n\n\t\tfunction getNormal( p1, p2, result ) {\n\n\t\t\tresult.subVectors( p2, p1 );\n\t\t\treturn result.set( - result.y, result.x ).normalize();\n\n\t\t}\n\n\t\tfunction addVertex( position, u, v ) {\n\n\t\t\tif ( vertices ) {\n\n\t\t\t\tvertices[ currentCoordinate ] = position.x;\n\t\t\t\tvertices[ currentCoordinate + 1 ] = position.y;\n\t\t\t\tvertices[ currentCoordinate + 2 ] = 0;\n\n\t\t\t\tif ( normals ) {\n\n\t\t\t\t\tnormals[ currentCoordinate ] = 0;\n\t\t\t\t\tnormals[ currentCoordinate + 1 ] = 0;\n\t\t\t\t\tnormals[ currentCoordinate + 2 ] = 1;\n\n\t\t\t\t}\n\n\t\t\t\tcurrentCoordinate += 3;\n\n\t\t\t\tif ( uvs ) {\n\n\t\t\t\t\tuvs[ currentCoordinateUV ] = u;\n\t\t\t\t\tuvs[ currentCoordinateUV + 1 ] = v;\n\n\t\t\t\t\tcurrentCoordinateUV += 2;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnumVertices += 3;\n\n\t\t}\n\n\t\tfunction makeCircularSector( center, p1, p2, u, v ) {\n\n\t\t\t// param p1, p2: Points in the circle arc.\n\t\t\t// p1 and p2 are in clockwise direction.\n\n\t\t\ttempV2_1.copy( p1 ).sub( center ).normalize();\n\t\t\ttempV2_2.copy( p2 ).sub( center ).normalize();\n\n\t\t\tvar angle = Math.PI;\n\t\t\tvar dot = tempV2_1.dot( tempV2_2 );\n\t\t\tif ( Math.abs( dot ) < 1 ) angle = Math.abs( Math.acos( dot ) );\n\n\t\t\tangle /= arcDivisions;\n\n\t\t\ttempV2_3.copy( p1 );\n\n\t\t\tfor ( var i = 0, il = arcDivisions - 1; i < il; i ++ ) {\n\n\t\t\t\ttempV2_4.copy( tempV2_3 ).rotateAround( center, angle );\n\n\t\t\t\taddVertex( tempV2_3, u, v );\n\t\t\t\taddVertex( tempV2_4, u, v );\n\t\t\t\taddVertex( center, u, 0.5 );\n\n\t\t\t\ttempV2_3.copy( tempV2_4 );\n\n\t\t\t}\n\n\t\t\taddVertex( tempV2_4, u, v );\n\t\t\taddVertex( p2, u, v );\n\t\t\taddVertex( center, u, 0.5 );\n\n\t\t}\n\n\t\tfunction makeSegmentTriangles() {\n\n\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\taddVertex( currentPointL, u1, 1 );\n\t\t\taddVertex( currentPointR, u1, 0 );\n\n\t\t}\n\n\t\tfunction makeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u ) {\n\n\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t// Optimized segment + bevel triangles\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t// Path segments triangles\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t// Bevel join triangle\n\n\t\t\t\t\taddVertex( currentPointL, u, 0 );\n\t\t\t\t\taddVertex( nextPointL, u, 0 );\n\t\t\t\t\taddVertex( innerPoint, u, 0.5 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Path segments triangles\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\t// Bevel join triangle\n\n\t\t\t\t\taddVertex( currentPointR, u, 1 );\n\t\t\t\t\taddVertex( nextPointR, u, 0 );\n\t\t\t\t\taddVertex( innerPoint, u, 0.5 );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// Bevel join triangle. The segment triangles are done in the main loop\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\taddVertex( currentPointL, u, 0 );\n\t\t\t\t\taddVertex( nextPointL, u, 0 );\n\t\t\t\t\taddVertex( currentPoint, u, 0.5 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\taddVertex( currentPointR, u, 1 );\n\t\t\t\t\taddVertex( nextPointR, u, 0 );\n\t\t\t\t\taddVertex( currentPoint, u, 0.5 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction createSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified ) {\n\n\t\t\tif ( innerSideModified ) {\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( nextPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPointR, u0, 1 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( nextPointR, u0, 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction addCapGeometry( center, p1, p2, joinIsOnLeftSide, start, u ) {\n\n\t\t\t// param center: End point of the path\n\t\t\t// param p1, p2: Left and right cap points\n\n\t\t\tswitch ( style.strokeLineCap ) {\n\n\t\t\t\tcase 'round':\n\n\t\t\t\t\tif ( start ) {\n\n\t\t\t\t\t\tmakeCircularSector( center, p2, p1, u, 0.5 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmakeCircularSector( center, p1, p2, u, 0.5 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'square':\n\n\t\t\t\t\tif ( start ) {\n\n\t\t\t\t\t\ttempV2_1.subVectors( p1, center );\n\t\t\t\t\t\ttempV2_2.set( tempV2_1.y, - tempV2_1.x );\n\n\t\t\t\t\t\ttempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );\n\t\t\t\t\t\ttempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );\n\n\t\t\t\t\t\t// Modify already existing vertices\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 0 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 1 * 3 );\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 3 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 0 * 3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttempV2_1.subVectors( p2, center );\n\t\t\t\t\t\ttempV2_2.set( tempV2_1.y, - tempV2_1.x );\n\n\t\t\t\t\t\ttempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );\n\t\t\t\t\t\ttempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );\n\n\t\t\t\t\t\tvar vl = vertices.length;\n\n\t\t\t\t\t\t// Modify already existing vertices\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, vl - 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 2 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 4 * 3 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, vl - 2 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 4 * 3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'butt':\n\t\t\t\tdefault:\n\n\t\t\t\t\t// Nothing to do here\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction removeDuplicatedPoints( points ) {\n\n\t\t\t// Creates a new array if necessary with duplicated points removed.\n\t\t\t// This does not remove duplicated initial and ending points of a closed path.\n\n\t\t\tvar dupPoints = false;\n\t\t\tfor ( var i = 1, n = points.length - 1; i < n; i ++ ) {\n\n\t\t\t\tif ( points[ i ].distanceTo( points[ i + 1 ] ) < minDistance ) {\n\n\t\t\t\t\tdupPoints = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ! dupPoints ) return points;\n\n\t\t\tvar newPoints = [];\n\t\t\tnewPoints.push( points[ 0 ] );\n\n\t\t\tfor ( var i = 1, n = points.length - 1; i < n; i ++ ) {\n\n\t\t\t\tif ( points[ i ].distanceTo( points[ i + 1 ] ) >= minDistance ) {\n\n\t\t\t\t\tnewPoints.push( points[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnewPoints.push( points[ points.length - 1 ] );\n\n\t\t\treturn newPoints;\n\n\t\t}\n\n\t};\n\n}();\n\nexport { SVGLoader };\n"],"sourceRoot":""}