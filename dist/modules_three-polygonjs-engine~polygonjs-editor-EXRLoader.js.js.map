{"version":3,"sources":["webpack:///./modules/three/examples/jsm/loaders/EXRLoader.js"],"names":["EXRLoader","manager","call","this","type","prototype","Object","assign","create","constructor","parse","buffer","getBitsReturn","l","c","lc","getBits","nBits","uInt8Array","inOffset","parseUint8Array","hufTableBuffer","Array","hufUnpackEncTable","inDataView","ni","im","iM","hcode","p","value","zerun","i","nc","hufCanonicalCodeTable","hufLength","code","hufCode","getCharReturn","getChar","getCodeReturn","getCode","po","rlc","outBuffer","outBufferOffset","outBufferEndOffset","cs","Uint8Array","s","Int16","ref","UInt16","wdec14Return","a","b","wdec14","h","ls","hs","ai","as","bs","wav2Decode","j","nx","ox","ny","oy","p2","n","i00","i01","i10","i11","py","ey","oy1","oy2","ox1","ox2","px","ex","p01","p11","p10","hufUncompress","nCompressed","outOffset","nRaw","initialInOffset","parseUint32","freq","hdec","len","lit","hufClearDecTable","hdecod","pl","plOffset","hufBuildDecTable","encodingTable","decodingTable","no","inOffsetEnd","Math","trunc","HUF_DECSIZE","hufDecode","predictor","source","t","length","d","interleaveScalar","out","t1","t2","floor","stop","uncompressZIP","info","compressed","array","slice","offset","size","console","error","inflate","Inflate","resize","verify","rawBuffer","decompress","tmpBuffer","DataView","parseNullTerminatedString","uintBuffer","endOffset","stringValue","TextDecoder","decode","parseUlong","dataView","uLong","getUint32","Uint32","Uint8","parseUint8","getUint8","parseFloat32","float","getFloat32","parseUint16","Uint16","getUint16","parseValue","parseFixedLengthString","startOffset","channels","name","pixelType","pLinear","xSampling","ySampling","push","parseChlist","redX","redY","greenX","greenY","blueX","blueY","whiteX","whiteY","parseChromaticities","parseCompression","xMin","yMin","xMax","yMax","parseBox2i","parseLineOrder","parseV2f","bufferDataView","EXRHeader","keepReading","attributeName","attributeValue","uncompress","scanlineBlockSize","size_t","getValue","dataWindowHeight","dataWindow","compression","viewer","byteLength","reader","getInt8","count","decodeRunLength","tmpBufSize","width","Uint16Array","bitmap","minNonZero","maxNonZero","lut","k","reverseLutFromBitmap","pizChannelData","outBufferEnd","lines","fooOffset","data","nData","applyLut","tmpOffset","y","cd","cp","end","set","binary","fraction","exponent","NaN","Infinity","pow","numBlocks","height","byteArray","Float32Array","fill","channelOffsets","R","G","B","A","compressionInfo","scanlineBlockIdx","line_y","true_y","channelID","cOff","x","idx","val","header","format","setDataType","load","url","onLoad","onProgress","onError","texture","texData","encoding","minFilter","magFilter","generateMipmaps","flipY"],"mappings":"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","file":"modules_three-polygonjs-engine~polygonjs-editor-EXRLoader.js.js","sourcesContent":["import {DataTextureLoader} from 'three/src/loaders/DataTextureLoader';\nimport {FloatType} from 'three/src/constants';\nimport {HalfFloatType} from 'three/src/constants';\nimport {LinearEncoding} from 'three/src/constants';\nimport {LinearFilter} from 'three/src/constants';\nimport {RGBAFormat} from 'three/src/constants';\nimport {RGBFormat} from 'three/src/constants';\n/**\n * @author Richard M. / https://github.com/richardmonette\n * @author ScieCode / http://github.com/sciecode\n *\n * OpenEXR loader which, currently, supports uncompressed, ZIP(S), RLE and PIZ wavelet compression.\n * Supports reading 16 and 32 bit data format, except for PIZ compression which only reads 16-bit data.\n *\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\n * implementation, so I have preserved their copyright notices.\n */\n\nimport { Zlib } from \"../libs/inflate.module.min.js\";\n\n// /*\n// Copyright (c) 2014 - 2017, Syoyo Fujita\n// All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//     * Neither the name of the Syoyo Fujita nor the\n//       names of its contributors may be used to endorse or promote products\n//       derived from this software without specific prior written permission.\n\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// */\n\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\n\n// ///////////////////////////////////////////////////////////////////////////\n// //\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\n// // Digital Ltd. LLC\n// //\n// // All rights reserved.\n// //\n// // Redistribution and use in source and binary forms, with or without\n// // modification, are permitted provided that the following conditions are\n// // met:\n// // *       Redistributions of source code must retain the above copyright\n// // notice, this list of conditions and the following disclaimer.\n// // *       Redistributions in binary form must reproduce the above\n// // copyright notice, this list of conditions and the following disclaimer\n// // in the documentation and/or other materials provided with the\n// // distribution.\n// // *       Neither the name of Industrial Light & Magic nor the names of\n// // its contributors may be used to endorse or promote products derived\n// // from this software without specific prior written permission.\n// //\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// //\n// ///////////////////////////////////////////////////////////////////////////\n\n// // End of OpenEXR license -------------------------------------------------\n\nvar EXRLoader = function ( manager ) {\n\n\tDataTextureLoader.call( this, manager );\n\n\tthis.type = FloatType;\n\n};\n\nEXRLoader.prototype = Object.assign( Object.create( DataTextureLoader.prototype ), {\n\n\tconstructor: EXRLoader,\n\n\tparse: function ( buffer ) {\n\n\t\tconst USHORT_RANGE = ( 1 << 16 );\n\t\tconst BITMAP_SIZE = ( USHORT_RANGE >> 3 );\n\n\t\tconst HUF_ENCBITS = 16; // literal (value) bit length\n\t\tconst HUF_DECBITS = 14; // decoding bit size (>= 8)\n\n\t\tconst HUF_ENCSIZE = ( 1 << HUF_ENCBITS ) + 1; // encoding table size\n\t\tconst HUF_DECSIZE = 1 << HUF_DECBITS; // decoding table size\n\t\tconst HUF_DECMASK = HUF_DECSIZE - 1;\n\n\t\tconst SHORT_ZEROCODE_RUN = 59;\n\t\tconst LONG_ZEROCODE_RUN = 63;\n\t\tconst SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN;\n\n\t\tconst BYTES_PER_HALF = 2;\n\n\t\tconst ULONG_SIZE = 8;\n\t\tconst FLOAT32_SIZE = 4;\n\t\tconst INT32_SIZE = 4;\n\t\tconst INT16_SIZE = 2;\n\t\tconst INT8_SIZE = 1;\n\n\t\tfunction reverseLutFromBitmap( bitmap, lut ) {\n\n\t\t\tvar k = 0;\n\n\t\t\tfor ( var i = 0; i < USHORT_RANGE; ++ i ) {\n\n\t\t\t\tif ( ( i == 0 ) || ( bitmap[ i >> 3 ] & ( 1 << ( i & 7 ) ) ) ) {\n\n\t\t\t\t\tlut[ k ++ ] = i;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar n = k - 1;\n\n\t\t\twhile ( k < USHORT_RANGE ) lut[ k ++ ] = 0;\n\n\t\t\treturn n;\n\n\t\t}\n\n\t\tfunction hufClearDecTable( hdec ) {\n\n\t\t\tfor ( var i = 0; i < HUF_DECSIZE; i ++ ) {\n\n\t\t\t\thdec[ i ] = {};\n\t\t\t\thdec[ i ].len = 0;\n\t\t\t\thdec[ i ].lit = 0;\n\t\t\t\thdec[ i ].p = null;\n\n\t\t\t}\n\n\t\t}\n\n\t\tconst getBitsReturn = { l: 0, c: 0, lc: 0 };\n\n\t\tfunction getBits( nBits, c, lc, uInt8Array, inOffset ) {\n\n\t\t\twhile ( lc < nBits ) {\n\n\t\t\t\tc = ( c << 8 ) | parseUint8Array( uInt8Array, inOffset );\n\t\t\t\tlc += 8;\n\n\t\t\t}\n\n\t\t\tlc -= nBits;\n\n\t\t\tgetBitsReturn.l = ( c >> lc ) & ( ( 1 << nBits ) - 1 );\n\t\t\tgetBitsReturn.c = c;\n\t\t\tgetBitsReturn.lc = lc;\n\n\t\t}\n\n\t\tconst hufTableBuffer = new Array( 59 );\n\n\t\tfunction hufCanonicalCodeTable( hcode ) {\n\n\t\t\tfor ( var i = 0; i <= 58; ++ i ) hufTableBuffer[ i ] = 0;\n\t\t\tfor ( var i = 0; i < HUF_ENCSIZE; ++ i ) hufTableBuffer[ hcode[ i ] ] += 1;\n\n\t\t\tvar c = 0;\n\n\t\t\tfor ( var i = 58; i > 0; -- i ) {\n\n\t\t\t\tvar nc = ( ( c + hufTableBuffer[ i ] ) >> 1 );\n\t\t\t\thufTableBuffer[ i ] = c;\n\t\t\t\tc = nc;\n\n\t\t\t}\n\n\t\t\tfor ( var i = 0; i < HUF_ENCSIZE; ++ i ) {\n\n\t\t\t\tvar l = hcode[ i ];\n\t\t\t\tif ( l > 0 ) hcode[ i ] = l | ( hufTableBuffer[ l ] ++ << 6 );\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction hufUnpackEncTable( uInt8Array, inDataView, inOffset, ni, im, iM, hcode ) {\n\n\t\t\tvar p = inOffset;\n\t\t\tvar c = 0;\n\t\t\tvar lc = 0;\n\n\t\t\tfor ( ; im <= iM; im ++ ) {\n\n\t\t\t\tif ( p.value - inOffset.value > ni ) return false;\n\n\t\t\t\tgetBits( 6, c, lc, uInt8Array, p );\n\n\t\t\t\tvar l = getBitsReturn.l;\n\t\t\t\tc = getBitsReturn.c;\n\t\t\t\tlc = getBitsReturn.lc;\n\n\t\t\t\thcode[ im ] = l;\n\n\t\t\t\tif ( l == LONG_ZEROCODE_RUN ) {\n\n\t\t\t\t\tif ( p.value - inOffset.value > ni ) {\n\n\t\t\t\t\t\tthrow 'Something wrong with hufUnpackEncTable';\n\n\t\t\t\t\t}\n\n\t\t\t\t\tgetBits( 8, c, lc, uInt8Array, p );\n\n\t\t\t\t\tvar zerun = getBitsReturn.l + SHORTEST_LONG_RUN;\n\t\t\t\t\tc = getBitsReturn.c;\n\t\t\t\t\tlc = getBitsReturn.lc;\n\n\t\t\t\t\tif ( im + zerun > iM + 1 ) {\n\n\t\t\t\t\t\tthrow 'Something wrong with hufUnpackEncTable';\n\n\t\t\t\t\t}\n\n\t\t\t\t\twhile ( zerun -- ) hcode[ im ++ ] = 0;\n\n\t\t\t\t\tim --;\n\n\t\t\t\t} else if ( l >= SHORT_ZEROCODE_RUN ) {\n\n\t\t\t\t\tvar zerun = l - SHORT_ZEROCODE_RUN + 2;\n\n\t\t\t\t\tif ( im + zerun > iM + 1 ) {\n\n\t\t\t\t\t\tthrow 'Something wrong with hufUnpackEncTable';\n\n\t\t\t\t\t}\n\n\t\t\t\t\twhile ( zerun -- ) hcode[ im ++ ] = 0;\n\n\t\t\t\t\tim --;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\thufCanonicalCodeTable( hcode );\n\n\t\t}\n\n\t\tfunction hufLength( code ) {\n\n\t\t\treturn code & 63;\n\n\t\t}\n\n\t\tfunction hufCode( code ) {\n\n\t\t\treturn code >> 6;\n\n\t\t}\n\n\t\tfunction hufBuildDecTable( hcode, im, iM, hdecod ) {\n\n\t\t\tfor ( ; im <= iM; im ++ ) {\n\n\t\t\t\tvar c = hufCode( hcode[ im ] );\n\t\t\t\tvar l = hufLength( hcode[ im ] );\n\n\t\t\t\tif ( c >> l ) {\n\n\t\t\t\t\tthrow 'Invalid table entry';\n\n\t\t\t\t}\n\n\t\t\t\tif ( l > HUF_DECBITS ) {\n\n\t\t\t\t\tvar pl = hdecod[ ( c >> ( l - HUF_DECBITS ) ) ];\n\n\t\t\t\t\tif ( pl.len ) {\n\n\t\t\t\t\t\tthrow 'Invalid table entry';\n\n\t\t\t\t\t}\n\n\t\t\t\t\tpl.lit ++;\n\n\t\t\t\t\tif ( pl.p ) {\n\n\t\t\t\t\t\tvar p = pl.p;\n\t\t\t\t\t\tpl.p = new Array( pl.lit );\n\n\t\t\t\t\t\tfor ( var i = 0; i < pl.lit - 1; ++ i ) {\n\n\t\t\t\t\t\t\tpl.p[ i ] = p[ i ];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tpl.p = new Array( 1 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tpl.p[ pl.lit - 1 ] = im;\n\n\t\t\t\t} else if ( l ) {\n\n\t\t\t\t\tvar plOffset = 0;\n\n\t\t\t\t\tfor ( var i = 1 << ( HUF_DECBITS - l ); i > 0; i -- ) {\n\n\t\t\t\t\t\tvar pl = hdecod[ ( c << ( HUF_DECBITS - l ) ) + plOffset ];\n\n\t\t\t\t\t\tif ( pl.len || pl.p ) {\n\n\t\t\t\t\t\t\tthrow 'Invalid table entry';\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpl.len = l;\n\t\t\t\t\t\tpl.lit = im;\n\n\t\t\t\t\t\tplOffset ++;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tconst getCharReturn = { c: 0, lc: 0 };\n\n\t\tfunction getChar( c, lc, uInt8Array, inOffset ) {\n\n\t\t\tc = ( c << 8 ) | parseUint8Array( uInt8Array, inOffset );\n\t\t\tlc += 8;\n\n\t\t\tgetCharReturn.c = c;\n\t\t\tgetCharReturn.lc = lc;\n\n\t\t}\n\n\t\tconst getCodeReturn = { c: 0, lc: 0 };\n\n\t\tfunction getCode( po, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset ) {\n\n\t\t\tif ( po == rlc ) {\n\n\t\t\t\tif ( lc < 8 ) {\n\n\t\t\t\t\tgetChar( c, lc, uInt8Array, inOffset );\n\t\t\t\t\tc = getCharReturn.c;\n\t\t\t\t\tlc = getCharReturn.lc;\n\n\t\t\t\t}\n\n\t\t\t\tlc -= 8;\n\n\t\t\t\tvar cs = ( c >> lc );\n\t\t\t\tvar cs = new Uint8Array( [ cs ] )[ 0 ];\n\n\t\t\t\tif ( outBufferOffset.value + cs > outBufferEndOffset ) {\n\n\t\t\t\t\treturn false;\n\n\t\t\t\t}\n\n\t\t\t\tvar s = outBuffer[ outBufferOffset.value - 1 ];\n\n\t\t\t\twhile ( cs -- > 0 ) {\n\n\t\t\t\t\toutBuffer[ outBufferOffset.value ++ ] = s;\n\n\t\t\t\t}\n\n\t\t\t} else if ( outBufferOffset.value < outBufferEndOffset ) {\n\n\t\t\t\toutBuffer[ outBufferOffset.value ++ ] = po;\n\n\t\t\t} else {\n\n\t\t\t\treturn false;\n\n\t\t\t}\n\n\t\t\tgetCodeReturn.c = c;\n\t\t\tgetCodeReturn.lc = lc;\n\n\t\t}\n\n\t\tfunction UInt16( value ) {\n\n\t\t\treturn ( value & 0xFFFF );\n\n\t\t}\n\n\t\tfunction Int16( value ) {\n\n\t\t\tvar ref = UInt16( value );\n\t\t\treturn ( ref > 0x7FFF ) ? ref - 0x10000 : ref;\n\n\t\t}\n\n\t\tconst wdec14Return = { a: 0, b: 0 };\n\n\t\tfunction wdec14( l, h ) {\n\n\t\t\tvar ls = Int16( l );\n\t\t\tvar hs = Int16( h );\n\n\t\t\tvar hi = hs;\n\t\t\tvar ai = ls + ( hi & 1 ) + ( hi >> 1 );\n\n\t\t\tvar as = ai;\n\t\t\tvar bs = ai - hi;\n\n\t\t\twdec14Return.a = as;\n\t\t\twdec14Return.b = bs;\n\n\t\t}\n\n\t\tfunction wav2Decode( j, buffer, nx, ox, ny, oy ) {\n\n\t\t\tvar n = ( nx > ny ) ? ny : nx;\n\t\t\tvar p = 1;\n\t\t\tvar p2;\n\n\t\t\twhile ( p <= n ) p <<= 1;\n\n\t\t\tp >>= 1;\n\t\t\tp2 = p;\n\t\t\tp >>= 1;\n\n\t\t\twhile ( p >= 1 ) {\n\n\t\t\t\tvar py = 0;\n\t\t\t\tvar ey = py + oy * ( ny - p2 );\n\t\t\t\tvar oy1 = oy * p;\n\t\t\t\tvar oy2 = oy * p2;\n\t\t\t\tvar ox1 = ox * p;\n\t\t\t\tvar ox2 = ox * p2;\n\t\t\t\tvar i00, i01, i10, i11;\n\n\t\t\t\tfor ( ; py <= ey; py += oy2 ) {\n\n\t\t\t\t\tvar px = py;\n\t\t\t\t\tvar ex = py + ox * ( nx - p2 );\n\n\t\t\t\t\tfor ( ; px <= ex; px += ox2 ) {\n\n\t\t\t\t\t\tvar p01 = px + ox1;\n\t\t\t\t\t\tvar p10 = px + oy1;\n\t\t\t\t\t\tvar p11 = p10 + ox1;\n\n\t\t\t\t\t\twdec14( buffer[ px + j ], buffer[ p10 + j ] );\n\n\t\t\t\t\t\ti00 = wdec14Return.a;\n\t\t\t\t\t\ti10 = wdec14Return.b;\n\n\t\t\t\t\t\twdec14( buffer[ p01 + j ], buffer[ p11 + j ] );\n\n\t\t\t\t\t\ti01 = wdec14Return.a;\n\t\t\t\t\t\ti11 = wdec14Return.b;\n\n\t\t\t\t\t\twdec14( i00, i01 );\n\n\t\t\t\t\t\tbuffer[ px + j ] = wdec14Return.a;\n\t\t\t\t\t\tbuffer[ p01 + j ] = wdec14Return.b;\n\n\t\t\t\t\t\twdec14( i10, i11 );\n\n\t\t\t\t\t\tbuffer[ p10 + j ] = wdec14Return.a;\n\t\t\t\t\t\tbuffer[ p11 + j ] = wdec14Return.b;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( nx & p ) {\n\n\t\t\t\t\t\tvar p10 = px + oy1;\n\n\t\t\t\t\t\twdec14( buffer[ px + j ], buffer[ p10 + j ] );\n\n\t\t\t\t\t\ti00 = wdec14Return.a;\n\t\t\t\t\t\tbuffer[ p10 + j ] = wdec14Return.b;\n\n\t\t\t\t\t\tbuffer[ px + j ] = i00;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif ( ny & p ) {\n\n\t\t\t\t\tvar px = py;\n\t\t\t\t\tvar ex = py + ox * ( nx - p2 );\n\n\t\t\t\t\tfor ( ; px <= ex; px += ox2 ) {\n\n\t\t\t\t\t\tvar p01 = px + ox1;\n\n\t\t\t\t\t\twdec14( buffer[ px + j ], buffer[ p01 + j ] );\n\n\t\t\t\t\t\ti00 = wdec14Return.a;\n\t\t\t\t\t\tbuffer[ p01 + j ] = wdec14Return.b;\n\n\t\t\t\t\t\tbuffer[ px + j ] = i00;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tp2 = p;\n\t\t\t\tp >>= 1;\n\n\t\t\t}\n\n\t\t\treturn py;\n\n\t\t}\n\n\t\tfunction hufDecode( encodingTable, decodingTable, uInt8Array, inDataView, inOffset, ni, rlc, no, outBuffer, outOffset ) {\n\n\t\t\tvar c = 0;\n\t\t\tvar lc = 0;\n\t\t\tvar outBufferEndOffset = no;\n\t\t\tvar inOffsetEnd = Math.trunc( inOffset.value + ( ni + 7 ) / 8 );\n\n\t\t\twhile ( inOffset.value < inOffsetEnd ) {\n\n\t\t\t\tgetChar( c, lc, uInt8Array, inOffset );\n\n\t\t\t\tc = getCharReturn.c;\n\t\t\t\tlc = getCharReturn.lc;\n\n\t\t\t\twhile ( lc >= HUF_DECBITS ) {\n\n\t\t\t\t\tvar index = ( c >> ( lc - HUF_DECBITS ) ) & HUF_DECMASK;\n\t\t\t\t\tvar pl = decodingTable[ index ];\n\n\t\t\t\t\tif ( pl.len ) {\n\n\t\t\t\t\t\tlc -= pl.len;\n\n\t\t\t\t\t\tgetCode( pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset );\n\n\t\t\t\t\t\tc = getCodeReturn.c;\n\t\t\t\t\t\tlc = getCodeReturn.lc;\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tif ( ! pl.p ) {\n\n\t\t\t\t\t\t\tthrow 'hufDecode issues';\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar j;\n\n\t\t\t\t\t\tfor ( j = 0; j < pl.lit; j ++ ) {\n\n\t\t\t\t\t\t\tvar l = hufLength( encodingTable[ pl.p[ j ] ] );\n\n\t\t\t\t\t\t\twhile ( lc < l && inOffset.value < inOffsetEnd ) {\n\n\t\t\t\t\t\t\t\tgetChar( c, lc, uInt8Array, inOffset );\n\n\t\t\t\t\t\t\t\tc = getCharReturn.c;\n\t\t\t\t\t\t\t\tlc = getCharReturn.lc;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( lc >= l ) {\n\n\t\t\t\t\t\t\t\tif ( hufCode( encodingTable[ pl.p[ j ] ] ) == ( ( c >> ( lc - l ) ) & ( ( 1 << l ) - 1 ) ) ) {\n\n\t\t\t\t\t\t\t\t\tlc -= l;\n\n\t\t\t\t\t\t\t\t\tgetCode( pl.p[ j ], rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset );\n\n\t\t\t\t\t\t\t\t\tc = getCodeReturn.c;\n\t\t\t\t\t\t\t\t\tlc = getCodeReturn.lc;\n\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( j == pl.lit ) {\n\n\t\t\t\t\t\t\tthrow 'hufDecode issues';\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar i = ( 8 - ni ) & 7;\n\n\t\t\tc >>= i;\n\t\t\tlc -= i;\n\n\t\t\twhile ( lc > 0 ) {\n\n\t\t\t\tvar pl = decodingTable[ ( c << ( HUF_DECBITS - lc ) ) & HUF_DECMASK ];\n\n\t\t\t\tif ( pl.len ) {\n\n\t\t\t\t\tlc -= pl.len;\n\n\t\t\t\t\tgetCode( pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset );\n\n\t\t\t\t\tc = getCodeReturn.c;\n\t\t\t\t\tlc = getCodeReturn.lc;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrow 'hufDecode issues';\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn true;\n\n\t\t}\n\n\t\tfunction hufUncompress( uInt8Array, inDataView, inOffset, nCompressed, outBuffer, outOffset, nRaw ) {\n\n\t\t\tvar initialInOffset = inOffset.value;\n\n\t\t\tvar im = parseUint32( inDataView, inOffset );\n\t\t\tvar iM = parseUint32( inDataView, inOffset );\n\n\t\t\tinOffset.value += 4;\n\n\t\t\tvar nBits = parseUint32( inDataView, inOffset );\n\n\t\t\tinOffset.value += 4;\n\n\t\t\tif ( im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE ) {\n\n\t\t\t\tthrow 'Something wrong with HUF_ENCSIZE';\n\n\t\t\t}\n\n\t\t\tvar freq = new Array( HUF_ENCSIZE );\n\t\t\tvar hdec = new Array( HUF_DECSIZE );\n\n\t\t\thufClearDecTable( hdec );\n\n\t\t\tvar ni = nCompressed - ( inOffset.value - initialInOffset );\n\n\t\t\thufUnpackEncTable( uInt8Array, inDataView, inOffset, ni, im, iM, freq );\n\n\t\t\tif ( nBits > 8 * ( nCompressed - ( inOffset.value - initialInOffset ) ) ) {\n\n\t\t\t\tthrow 'Something wrong with hufUncompress';\n\n\t\t\t}\n\n\t\t\thufBuildDecTable( freq, im, iM, hdec );\n\n\t\t\thufDecode( freq, hdec, uInt8Array, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset );\n\n\t\t}\n\n\t\tfunction applyLut( lut, data, nData ) {\n\n\t\t\tfor ( var i = 0; i < nData; ++ i ) {\n\n\t\t\t\tdata[ i ] = lut[ data[ i ] ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction predictor( source ) {\n\n\t\t\tfor ( var t = 1; t < source.length; t ++ ) {\n\n\t\t\t\tvar d = source[ t - 1 ] + source[ t ] - 128;\n\t\t\t\tsource[ t ] = d;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction interleaveScalar( source, out ) {\n\n\t\t\tvar t1 = 0;\n\t\t\tvar t2 = Math.floor( ( source.length + 1 ) / 2 );\n\t\t\tvar s = 0;\n\t\t\tvar stop = source.length - 1;\n\n\t\t\twhile ( true ) {\n\n\t\t\t\tif ( s > stop ) break;\n\t\t\t\tout[ s ++ ] = source[ t1 ++ ];\n\n\t\t\t\tif ( s > stop ) break;\n\t\t\t\tout[ s ++ ] = source[ t2 ++ ];\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction decodeRunLength( source ) {\n\n\t\t\tvar size = source.byteLength;\n\t\t\tvar out = new Array();\n\t\t\tvar p = 0;\n\n\t\t\tvar reader = new DataView( source );\n\n\t\t\twhile ( size > 0 ) {\n\n\t\t\t\tvar l = reader.getInt8( p ++ );\n\n\t\t\t\tif ( l < 0 ) {\n\n\t\t\t\t\tvar count = - l;\n\t\t\t\t\tsize -= count + 1;\n\n\t\t\t\t\tfor ( var i = 0; i < count; i ++ ) {\n\n\t\t\t\t\t\tout.push( reader.getUint8( p ++ ) );\n\n\t\t\t\t\t}\n\n\n\t\t\t\t} else {\n\n\t\t\t\t\tvar count = l;\n\t\t\t\t\tsize -= 2;\n\n\t\t\t\t\tvar value = reader.getUint8( p ++ );\n\n\t\t\t\t\tfor ( var i = 0; i < count + 1; i ++ ) {\n\n\t\t\t\t\t\tout.push( value );\n\n\t\t\t\t\t}\n\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn out;\n\n\t\t}\n\n\t\tfunction uncompressRaw( info ) {\n\n\t\t\treturn new DataView( info.array.buffer, info.offset.value, info.size );\n\n\t\t}\n\n\t\tfunction uncompressRLE( info ) {\n\n\t\t\tvar compressed = info.viewer.buffer.slice( info.offset.value, info.offset.value + info.size );\n\n\t\t\tvar rawBuffer = new Uint8Array( decodeRunLength( compressed ) );\n\t\t\tvar tmpBuffer = new Uint8Array( rawBuffer.length );\n\n\t\t\tpredictor( rawBuffer ); // revert predictor\n\n\t\t\tinterleaveScalar( rawBuffer, tmpBuffer ); // interleave pixels\n\n\t\t\treturn new DataView( tmpBuffer.buffer );\n\n\t\t}\n\n\t\tfunction uncompressZIP( info ) {\n\n\t\t\tvar compressed = info.array.slice( info.offset.value, info.offset.value + info.size );\n\n\t\t\tif ( typeof Zlib === 'undefined' ) {\n\n\t\t\t\tconsole.error( 'THREE.EXRLoader: External library Inflate.min.js required, obtain or import from https://github.com/imaya/zlib.js' );\n\n\t\t\t}\n\n\t\t\tvar inflate = new Zlib.Inflate( compressed, { resize: true, verify: true } ); // eslint-disable-line no-undef\n\n\t\t\tvar rawBuffer = new Uint8Array( inflate.decompress().buffer );\n\t\t\tvar tmpBuffer = new Uint8Array( rawBuffer.length );\n\n\t\t\tpredictor( rawBuffer ); // revert predictor\n\n\t\t\tinterleaveScalar( rawBuffer, tmpBuffer ); // interleave pixels\n\n\t\t\treturn new DataView( tmpBuffer.buffer );\n\n\t\t}\n\n\t\tfunction uncompressPIZ( info ) {\n\n\t\t\tvar inDataView = info.viewer;\n\t\t\tvar inOffset = { value: info.offset.value };\n\n\t\t\tvar tmpBufSize = info.width * scanlineBlockSize * ( EXRHeader.channels.length * BYTES_PER_HALF );\n\t\t\tvar outBuffer = new Uint16Array( tmpBufSize );\n\t\t\tvar outOffset = { value: 0 };\n\n\t\t\tvar bitmap = new Uint8Array( BITMAP_SIZE );\n\n\t\t\tvar minNonZero = parseUint16( inDataView, inOffset );\n\t\t\tvar maxNonZero = parseUint16( inDataView, inOffset );\n\n\t\t\tif ( maxNonZero >= BITMAP_SIZE ) {\n\n\t\t\t\tthrow 'Something is wrong with PIZ_COMPRESSION BITMAP_SIZE';\n\n\t\t\t}\n\n\t\t\tif ( minNonZero <= maxNonZero ) {\n\n\t\t\t\tfor ( var i = 0; i < maxNonZero - minNonZero + 1; i ++ ) {\n\n\t\t\t\t\tbitmap[ i + minNonZero ] = parseUint8( inDataView, inOffset );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tvar lut = new Uint16Array( USHORT_RANGE );\n\t\t\treverseLutFromBitmap( bitmap, lut );\n\n\t\t\tvar length = parseUint32( inDataView, inOffset );\n\n\t\t\thufUncompress( info.array, inDataView, inOffset, length, outBuffer, outOffset, tmpBufSize );\n\n\t\t\tvar pizChannelData = new Array( info.channels );\n\n\t\t\tvar outBufferEnd = 0;\n\n\t\t\tfor ( var i = 0; i < info.channels; i ++ ) {\n\n\t\t\t\tpizChannelData[ i ] = {};\n\t\t\t\tpizChannelData[ i ][ 'start' ] = outBufferEnd;\n\t\t\t\tpizChannelData[ i ][ 'end' ] = pizChannelData[ i ][ 'start' ];\n\t\t\t\tpizChannelData[ i ][ 'nx' ] = info.width;\n\t\t\t\tpizChannelData[ i ][ 'ny' ] = info.lines;\n\t\t\t\tpizChannelData[ i ][ 'size' ] = 1;\n\n\t\t\t\toutBufferEnd += pizChannelData[ i ].nx * pizChannelData[ i ].ny * pizChannelData[ i ].size;\n\n\t\t\t}\n\n\t\t\tvar fooOffset = 0;\n\n\t\t\tfor ( var i = 0; i < info.channels; i ++ ) {\n\n\t\t\t\tfor ( var j = 0; j < pizChannelData[ i ].size; ++ j ) {\n\n\t\t\t\t\tfooOffset += wav2Decode(\n\t\t\t\t\t\tj + fooOffset,\n\t\t\t\t\t\toutBuffer,\n\t\t\t\t\t\tpizChannelData[ i ].nx,\n\t\t\t\t\t\tpizChannelData[ i ].size,\n\t\t\t\t\t\tpizChannelData[ i ].ny,\n\t\t\t\t\t\tpizChannelData[ i ].nx * pizChannelData[ i ].size\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tapplyLut( lut, outBuffer, outBufferEnd );\n\n\t\t\tvar tmpBuffer = new Uint8Array( outBuffer.buffer.byteLength );\n\t\t\tvar tmpOffset = 0;\n\t\t\tvar n = info.width * 2;\n\n\t\t\tfor ( var y = 0; y < info.lines; y ++ ) {\n\n\t\t\t\tfor ( var c = 0; c < info.channels; c ++ ) {\n\n\t\t\t\t\tvar cd = pizChannelData[ c ];\n\t\t\t\t\tvar cp = new Uint8Array( outBuffer.buffer, cd.end * 2 + y * n, n );\n\n\t\t\t\t\ttmpBuffer.set( cp, tmpOffset );\n\t\t\t\t\ttmpOffset += n;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn new DataView( tmpBuffer.buffer );\n\n\t\t}\n\n\t\tfunction parseNullTerminatedString( buffer, offset ) {\n\n\t\t\tvar uintBuffer = new Uint8Array( buffer );\n\t\t\tvar endOffset = 0;\n\n\t\t\twhile ( uintBuffer[ offset.value + endOffset ] != 0 ) {\n\n\t\t\t\tendOffset += 1;\n\n\t\t\t}\n\n\t\t\tvar stringValue = new TextDecoder().decode(\n\t\t\t\tuintBuffer.slice( offset.value, offset.value + endOffset )\n\t\t\t);\n\n\t\t\toffset.value = offset.value + endOffset + 1;\n\n\t\t\treturn stringValue;\n\n\t\t}\n\n\t\tfunction parseFixedLengthString( buffer, offset, size ) {\n\n\t\t\tvar stringValue = new TextDecoder().decode(\n\t\t\t\tnew Uint8Array( buffer ).slice( offset.value, offset.value + size )\n\t\t\t);\n\n\t\t\toffset.value = offset.value + size;\n\n\t\t\treturn stringValue;\n\n\t\t}\n\n\t\tfunction parseUlong( dataView, offset ) {\n\n\t\t\tvar uLong = dataView.getUint32( 0, true );\n\n\t\t\toffset.value = offset.value + ULONG_SIZE;\n\n\t\t\treturn uLong;\n\n\t\t}\n\n\t\tfunction parseUint32( dataView, offset ) {\n\n\t\t\tvar Uint32 = dataView.getUint32( offset.value, true );\n\n\t\t\toffset.value = offset.value + INT32_SIZE;\n\n\t\t\treturn Uint32;\n\n\t\t}\n\n\t\tfunction parseUint8Array( uInt8Array, offset ) {\n\n\t\t\tvar Uint8 = uInt8Array[ offset.value ];\n\n\t\t\toffset.value = offset.value + INT8_SIZE;\n\n\t\t\treturn Uint8;\n\n\t\t}\n\n\t\tfunction parseUint8( dataView, offset ) {\n\n\t\t\tvar Uint8 = dataView.getUint8( offset.value );\n\n\t\t\toffset.value = offset.value + INT8_SIZE;\n\n\t\t\treturn Uint8;\n\n\t\t}\n\n\t\tfunction parseFloat32( dataView, offset ) {\n\n\t\t\tvar float = dataView.getFloat32( offset.value, true );\n\n\t\t\toffset.value += FLOAT32_SIZE;\n\n\t\t\treturn float;\n\n\t\t}\n\n\t\t// https://stackoverflow.com/questions/5678432/decompressing-half-precision-floats-in-javascript\n\t\tfunction decodeFloat16( binary ) {\n\n\t\t\tvar exponent = ( binary & 0x7C00 ) >> 10,\n\t\t\t\tfraction = binary & 0x03FF;\n\n\t\t\treturn ( binary >> 15 ? - 1 : 1 ) * (\n\t\t\t\texponent ?\n\t\t\t\t\t(\n\t\t\t\t\t\texponent === 0x1F ?\n\t\t\t\t\t\t\tfraction ? NaN : Infinity :\n\t\t\t\t\t\t\tMath.pow( 2, exponent - 15 ) * ( 1 + fraction / 0x400 )\n\t\t\t\t\t) :\n\t\t\t\t\t6.103515625e-5 * ( fraction / 0x400 )\n\t\t\t);\n\n\t\t}\n\n\t\tfunction parseUint16( dataView, offset ) {\n\n\t\t\tvar Uint16 = dataView.getUint16( offset.value, true );\n\n\t\t\toffset.value += INT16_SIZE;\n\n\t\t\treturn Uint16;\n\n\t\t}\n\n\t\tfunction parseFloat16( buffer, offset ) {\n\n\t\t\treturn decodeFloat16( parseUint16( buffer, offset ) );\n\n\t\t}\n\n\t\tfunction parseChlist( dataView, buffer, offset, size ) {\n\n\t\t\tvar startOffset = offset.value;\n\t\t\tvar channels = [];\n\n\t\t\twhile ( offset.value < ( startOffset + size - 1 ) ) {\n\n\t\t\t\tvar name = parseNullTerminatedString( buffer, offset );\n\t\t\t\tvar pixelType = parseUint32( dataView, offset ); // TODO: Cast this to UINT, HALF or FLOAT\n\t\t\t\tvar pLinear = parseUint8( dataView, offset );\n\t\t\t\toffset.value += 3; // reserved, three chars\n\t\t\t\tvar xSampling = parseUint32( dataView, offset );\n\t\t\t\tvar ySampling = parseUint32( dataView, offset );\n\n\t\t\t\tchannels.push( {\n\t\t\t\t\tname: name,\n\t\t\t\t\tpixelType: pixelType,\n\t\t\t\t\tpLinear: pLinear,\n\t\t\t\t\txSampling: xSampling,\n\t\t\t\t\tySampling: ySampling\n\t\t\t\t} );\n\n\t\t\t}\n\n\t\t\toffset.value += 1;\n\n\t\t\treturn channels;\n\n\t\t}\n\n\t\tfunction parseChromaticities( dataView, offset ) {\n\n\t\t\tvar redX = parseFloat32( dataView, offset );\n\t\t\tvar redY = parseFloat32( dataView, offset );\n\t\t\tvar greenX = parseFloat32( dataView, offset );\n\t\t\tvar greenY = parseFloat32( dataView, offset );\n\t\t\tvar blueX = parseFloat32( dataView, offset );\n\t\t\tvar blueY = parseFloat32( dataView, offset );\n\t\t\tvar whiteX = parseFloat32( dataView, offset );\n\t\t\tvar whiteY = parseFloat32( dataView, offset );\n\n\t\t\treturn { redX: redX, redY: redY, greenX: greenX, greenY: greenY, blueX: blueX, blueY: blueY, whiteX: whiteX, whiteY: whiteY };\n\n\t\t}\n\n\t\tfunction parseCompression( dataView, offset ) {\n\n\t\t\tvar compressionCodes = [\n\t\t\t\t'NO_COMPRESSION',\n\t\t\t\t'RLE_COMPRESSION',\n\t\t\t\t'ZIPS_COMPRESSION',\n\t\t\t\t'ZIP_COMPRESSION',\n\t\t\t\t'PIZ_COMPRESSION',\n\t\t\t\t'PXR24_COMPRESSION',\n\t\t\t\t'B44_COMPRESSION',\n\t\t\t\t'B44A_COMPRESSION',\n\t\t\t\t'DWAA_COMPRESSION',\n\t\t\t\t'DWAB_COMPRESSION'\n\t\t\t];\n\n\t\t\tvar compression = parseUint8( dataView, offset );\n\n\t\t\treturn compressionCodes[ compression ];\n\n\t\t}\n\n\t\tfunction parseBox2i( dataView, offset ) {\n\n\t\t\tvar xMin = parseUint32( dataView, offset );\n\t\t\tvar yMin = parseUint32( dataView, offset );\n\t\t\tvar xMax = parseUint32( dataView, offset );\n\t\t\tvar yMax = parseUint32( dataView, offset );\n\n\t\t\treturn { xMin: xMin, yMin: yMin, xMax: xMax, yMax: yMax };\n\n\t\t}\n\n\t\tfunction parseLineOrder( dataView, offset ) {\n\n\t\t\tvar lineOrders = [\n\t\t\t\t'INCREASING_Y'\n\t\t\t];\n\n\t\t\tvar lineOrder = parseUint8( dataView, offset );\n\n\t\t\treturn lineOrders[ lineOrder ];\n\n\t\t}\n\n\t\tfunction parseV2f( dataView, offset ) {\n\n\t\t\tvar x = parseFloat32( dataView, offset );\n\t\t\tvar y = parseFloat32( dataView, offset );\n\n\t\t\treturn [ x, y ];\n\n\t\t}\n\n\t\tfunction parseValue( dataView, buffer, offset, type, size ) {\n\n\t\t\tif ( type === 'string' || type === 'stringvector' || type === 'iccProfile' ) {\n\n\t\t\t\treturn parseFixedLengthString( buffer, offset, size );\n\n\t\t\t} else if ( type === 'chlist' ) {\n\n\t\t\t\treturn parseChlist( dataView, buffer, offset, size );\n\n\t\t\t} else if ( type === 'chromaticities' ) {\n\n\t\t\t\treturn parseChromaticities( dataView, offset );\n\n\t\t\t} else if ( type === 'compression' ) {\n\n\t\t\t\treturn parseCompression( dataView, offset );\n\n\t\t\t} else if ( type === 'box2i' ) {\n\n\t\t\t\treturn parseBox2i( dataView, offset );\n\n\t\t\t} else if ( type === 'lineOrder' ) {\n\n\t\t\t\treturn parseLineOrder( dataView, offset );\n\n\t\t\t} else if ( type === 'float' ) {\n\n\t\t\t\treturn parseFloat32( dataView, offset );\n\n\t\t\t} else if ( type === 'v2f' ) {\n\n\t\t\t\treturn parseV2f( dataView, offset );\n\n\t\t\t} else if ( type === 'int' ) {\n\n\t\t\t\treturn parseUint32( dataView, offset );\n\n\t\t\t} else {\n\n\t\t\t\tthrow 'Cannot parse value for unsupported type: ' + type;\n\n\t\t\t}\n\n\t\t}\n\n\t\tvar bufferDataView = new DataView( buffer );\n\t\tvar uInt8Array = new Uint8Array( buffer );\n\n\t\tvar EXRHeader = {};\n\n\t\tbufferDataView.getUint32( 0, true ); // magic\n\t\tbufferDataView.getUint8( 4, true ); // versionByteZero\n\t\tbufferDataView.getUint8( 5, true ); // fullMask\n\n\t\t// start of header\n\n\t\tvar offset = { value: 8 }; // start at 8, after magic stuff\n\n\t\tvar keepReading = true;\n\n\t\twhile ( keepReading ) {\n\n\t\t\tvar attributeName = parseNullTerminatedString( buffer, offset );\n\n\t\t\tif ( attributeName == 0 ) {\n\n\t\t\t\tkeepReading = false;\n\n\t\t\t} else {\n\n\t\t\t\tvar attributeType = parseNullTerminatedString( buffer, offset );\n\t\t\t\tvar attributeSize = parseUint32( bufferDataView, offset );\n\t\t\t\tvar attributeValue = parseValue( bufferDataView, buffer, offset, attributeType, attributeSize );\n\n\t\t\t\tEXRHeader[ attributeName ] = attributeValue;\n\n\t\t\t}\n\n\t\t}\n\n\t\t// offsets\n\t\tvar dataWindowHeight = EXRHeader.dataWindow.yMax + 1;\n\n\t\tvar uncompress;\n\t\tvar scanlineBlockSize;\n\n\t\tswitch ( EXRHeader.compression ) {\n\n\t\t\tcase 'NO_COMPRESSION':\n\n\t\t\t\tscanlineBlockSize = 1;\n\t\t\t\tuncompress = uncompressRaw;\n\t\t\t\tbreak;\n\n\t\t\tcase 'RLE_COMPRESSION':\n\n\t\t\t\tscanlineBlockSize = 1;\n\t\t\t\tuncompress = uncompressRLE;\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZIPS_COMPRESSION':\n\n\t\t\t\tscanlineBlockSize = 1;\n\t\t\t\tuncompress = uncompressZIP;\n\t\t\t\tbreak;\n\n\t\t\tcase 'ZIP_COMPRESSION':\n\n\t\t\t\tscanlineBlockSize = 16;\n\t\t\t\tuncompress = uncompressZIP;\n\t\t\t\tbreak;\n\n\t\t\tcase 'PIZ_COMPRESSION':\n\n\t\t\t\tscanlineBlockSize = 32;\n\t\t\t\tuncompress = uncompressPIZ;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tthrow 'EXRLoader.parse: ' + EXRHeader.compression + ' is unsupported';\n\n\t\t}\n\n\t\tvar size_t;\n\t\tvar getValue;\n\n\t\t// mixed pixelType not supported\n\t\tvar pixelType = EXRHeader.channels[ 0 ].pixelType;\n\n\t\tif ( pixelType === 1 ) { // half\n\n\t\t\tswitch ( this.type ) {\n\n\t\t\t\tcase FloatType:\n\n\t\t\t\t\tgetValue = parseFloat16;\n\t\t\t\t\tsize_t = INT16_SIZE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase HalfFloatType:\n\n\t\t\t\t\tgetValue = parseUint16;\n\t\t\t\t\tsize_t = INT16_SIZE;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t} else if ( pixelType === 2 ) { // float\n\n\t\t\tswitch ( this.type ) {\n\n\t\t\t\tcase FloatType:\n\n\t\t\t\t\tgetValue = parseFloat32;\n\t\t\t\t\tsize_t = FLOAT32_SIZE;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase HalfFloatType:\n\n\t\t\t\t\tthrow 'EXRLoader.parse: unsupported HalfFloatType texture for FloatType image file.';\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tthrow 'EXRLoader.parse: unsupported pixelType ' + pixelType + ' for ' + EXRHeader.compression + '.';\n\n\t\t}\n\n\t\tvar numBlocks = dataWindowHeight / scanlineBlockSize;\n\n\t\tfor ( var i = 0; i < numBlocks; i ++ ) {\n\n\t\t\tparseUlong( bufferDataView, offset ); // scanlineOffset\n\n\t\t}\n\n\t\t// we should be passed the scanline offset table, start reading pixel data\n\n\t\tvar width = EXRHeader.dataWindow.xMax - EXRHeader.dataWindow.xMin + 1;\n\t\tvar height = EXRHeader.dataWindow.yMax - EXRHeader.dataWindow.yMin + 1;\n\t\t// Firefox only supports RGBA (half) float textures\n\t\t// var numChannels = EXRHeader.channels.length;\n\t\tvar numChannels = 4;\n\t\tvar size = width * height * numChannels;\n\n\t\t// Fill initially with 1s for the alpha value if the texture is not RGBA, RGB values will be overwritten\n\t\tswitch ( this.type ) {\n\n\t\t\tcase FloatType:\n\n\t\t\t\tvar byteArray = new Float32Array( size );\n\n\t\t\t\tif ( EXRHeader.channels.length < numChannels ) {\n\n\t\t\t\t\tbyteArray.fill( 1, 0, size );\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tcase HalfFloatType:\n\n\t\t\t\tvar byteArray = new Uint16Array( size );\n\n\t\t\t\tif ( EXRHeader.channels.length < numChannels ) {\n\n\t\t\t\t\tbyteArray.fill( 0x3C00, 0, size ); // Uint16Array holds half float data, 0x3C00 is 1\n\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\n\t\t\t\tconsole.error( 'THREE.EXRLoader: unsupported type: ', this.type );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tvar channelOffsets = {\n\t\t\tR: 0,\n\t\t\tG: 1,\n\t\t\tB: 2,\n\t\t\tA: 3\n\t\t};\n\n\t\tvar compressionInfo = {\n\n\t\t\tarray: uInt8Array,\n\t\t\tviewer: bufferDataView,\n\t\t\toffset: offset,\n\t\t\tchannels: EXRHeader.channels.length,\n\t\t\twidth: width,\n\t\t\tlines: scanlineBlockSize,\n\t\t\tsize: 0\n\n\t\t};\n\n\t\tif ( EXRHeader.compression === 'NO_COMPRESSION' ||\n\t\t\tEXRHeader.compression === 'ZIP_COMPRESSION' ||\n\t\t\tEXRHeader.compression === 'ZIPS_COMPRESSION' ||\n\t\t\tEXRHeader.compression === 'RLE_COMPRESSION' ||\n\t\t\tEXRHeader.compression === 'PIZ_COMPRESSION' ) {\n\n\t\t\tvar size;\n\t\t\tvar viewer;\n\t\t\tvar tmpOffset = { value: 0 };\n\n\t\t\tfor ( var scanlineBlockIdx = 0; scanlineBlockIdx < height / scanlineBlockSize; scanlineBlockIdx ++ ) {\n\n\t\t\t\tparseUint32( bufferDataView, offset ); // line_no\n\t\t\t\tsize = parseUint32( bufferDataView, offset ); // data_len\n\n\t\t\t\tcompressionInfo.offset = offset;\n\t\t\t\tcompressionInfo.size = size;\n\n\t\t\t\tviewer = uncompress( compressionInfo );\n\n\t\t\t\toffset.value += size;\n\n\t\t\t\tfor ( var line_y = 0; line_y < scanlineBlockSize; line_y ++ ) {\n\n\t\t\t\t\tvar true_y = line_y + ( scanlineBlockIdx * scanlineBlockSize );\n\n\t\t\t\t\tif ( true_y >= height ) break;\n\n\t\t\t\t\tfor ( var channelID = 0; channelID < EXRHeader.channels.length; channelID ++ ) {\n\n\t\t\t\t\t\tvar cOff = channelOffsets[ EXRHeader.channels[ channelID ].name ];\n\n\t\t\t\t\t\tfor ( var x = 0; x < width; x ++ ) {\n\n\t\t\t\t\t\t\tvar idx = ( line_y * ( EXRHeader.channels.length * width ) ) + ( channelID * width ) + x;\n\t\t\t\t\t\t\ttmpOffset.value = idx * size_t;\n\n\t\t\t\t\t\t\tvar val = getValue( viewer, tmpOffset );\n\n\t\t\t\t\t\t\tbyteArray[ ( ( ( height - 1 - true_y ) * ( width * numChannels ) ) + ( x * numChannels ) ) + cOff ] = val;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn {\n\t\t\theader: EXRHeader,\n\t\t\twidth: width,\n\t\t\theight: height,\n\t\t\tdata: byteArray,\n\t\t\tformat: numChannels === 4 ? RGBAFormat : RGBFormat,\n\t\t\ttype: this.type\n\t\t};\n\n\t},\n\n\tsetDataType: function ( value ) {\n\n\t\tthis.type = value;\n\t\treturn this;\n\n\t},\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tfunction onLoadCallback( texture, texData ) {\n\n\t\t\tswitch ( texture.type ) {\n\n\t\t\t\tcase FloatType:\n\n\t\t\t\t\ttexture.encoding = LinearEncoding;\n\t\t\t\t\ttexture.minFilter = LinearFilter;\n\t\t\t\t\ttexture.magFilter = LinearFilter;\n\t\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\t\ttexture.flipY = false;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase HalfFloatType:\n\n\t\t\t\t\ttexture.encoding = LinearEncoding;\n\t\t\t\t\ttexture.minFilter = LinearFilter;\n\t\t\t\t\ttexture.magFilter = LinearFilter;\n\t\t\t\t\ttexture.generateMipmaps = false;\n\t\t\t\t\ttexture.flipY = false;\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t\tif ( onLoad ) onLoad( texture, texData );\n\n\t\t}\n\n\t\treturn DataTextureLoader.prototype.load.call( this, url, onLoadCallback, onProgress, onError );\n\n\t}\n\n} );\n\nexport { EXRLoader };\n"],"sourceRoot":""}