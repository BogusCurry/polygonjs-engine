{"version":3,"sources":["webpack:///./modules/three/examples/jsm/loaders/SVGLoader.js"],"names":["tempV2_1","tempV2_2","tempV2_3","tempV2_4","tempV2_5","tempV2_6","tempV2_7","lastPointL","lastPointR","point0L","point0R","currentPointL","currentPointR","nextPointL","nextPointR","innerPoint","outerPoint","SVGLoader","manager","call","this","prototype","Object","assign","create","constructor","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","text","parse","parseArcCommand","rx","ry","x_axis_rotation","large_arc_flag","sweep_flag","start","end","Math","PI","abs","dx2","x","dy2","y","x1p","cos","sin","y1p","rxs","rys","x1ps","y1ps","cr","s","sqrt","dq","pq","q","max","cxp","cyp","cx","cy","theta","svgAngle","delta","currentPath","absellipse","ux","uy","vx","vy","dot","len","ang","acos","min","parseStyle","node","style","addStyle","svgName","jsName","adjustFunction","undefined","v","hasAttribute","getAttribute","clamp","parseFloat","positive","getReflection","a","b","parseFloats","string","array","split","i","length","number","indexOf","lastIndexOf","splice","getTransformScaleX","m","te","elements","getTransformScaleY","console","log","paths","transformStack","tempTransform0","tempTransform1","tempTransform2","tempTransform3","tempV2","tempV3","currentTransform","time","xml","DOMParser","parseFromString","timeEnd","parseNode","nodeType","transform","transformsTexts","tIndex","transformText","trim","openParPos","closeParPos","transformType","substr","identity","tx","ty","translate","angle","rotate","multiplyMatrices","scaleX","scaleY","scale","set","tan","premultiply","parseNodeTransform","copy","push","getNodeTransform","nodeName","point","control","firstPoint","isFirstPoint","doSetFirstPoint","commands","match","l","command","type","charAt","data","numbers","j","jl","moveTo","lineTo","bezierCurveTo","quadraticCurveTo","clone","autoClose","curves","currentPoint","warn","parsePathNode","w","h","parseRectNode","iterator","index","replace","parsePolygonNode","parsePolylineNode","r","subpath","absarc","subPaths","parseCircleNode","parseEllipseNode","x1","y1","x2","y2","parseLineNode","fill","color","setStyle","transfVec2","v2","applyMatrix3","isRotated","isTransformRotated","n","curve","isLineCurve","v1","isCubicBezierCurve","v0","v3","isQuadraticBezierCurve","isEllipseCurve","aX","aY","xRadius","yRadius","transformPath","userData","nodes","childNodes","pop","documentElement","fillOpacity","strokeOpacity","strokeWidth","strokeLineJoin","strokeLineCap","strokeMiterLimit","getStrokeStyle","width","lineJoin","lineCap","miterLimit","strokeColor","pointsToStroke","points","arcDivisions","minDistance","vertices","normals","uvs","pointsToStrokeWithBuffers","geometry","setAttribute","vertexOffset","numPoints","dupPoints","distanceTo","newPoints","removeDuplicatedPoints","nextPoint","innerSideModified","joinIsOnLeftSide","isMiter","isClosed","equals","previousPoint","strokeWidth2","deltaU","u0","initialJoinIsOnLeftSide","numVertices","currentCoordinate","currentCoordinateUV","getNormal","multiplyScalar","sub","add","iPoint","normal1","u1","subVectors","normalize","miterSide","setLength","negate","miterLength2","segmentLengthPrev","divideScalar","segmentLengthNext","makeSegmentTriangles","makeSegmentWithBevelJoin","createSegmentTrianglesWithMiddleSection","makeCircularSector","miterFraction","addVertex","addCapGeometry","lastOuter","lastInner","toArray","p1","p2","result","position","u","center","il","rotateAround","addVectors","vl"],"mappings":"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","file":"modules_three-polygonjs-engine-SVGLoader.js.js","sourcesContent":["import {BufferGeometry} from 'three/src/core/BufferGeometry';\nimport {Color} from 'three/src/math/Color';\nimport {FileLoader} from 'three/src/loaders/FileLoader';\nimport {Float32BufferAttribute} from 'three/src/core/BufferAttribute';\nimport {Loader} from 'three/src/loaders/Loader';\nimport {Matrix3} from 'three/src/math/Matrix3';\nimport {Path} from 'three/src/extras/core/Path';\nimport {ShapePath} from 'three/src/extras/core/ShapePath';\nimport {Vector2} from 'three/src/math/Vector2';\nimport {Vector3} from 'three/src/math/Vector3';\n/**\n * @author mrdoob / http://mrdoob.com/\n * @author zz85 / http://joshuakoo.com/\n * @author yomboprime / https://yombo.org\n */\n\n\nvar SVGLoader = function ( manager ) {\n\n\tLoader.call( this, manager );\n\n};\n\nSVGLoader.prototype = Object.assign( Object.create( Loader.prototype ), {\n\n\tconstructor: SVGLoader,\n\n\tload: function ( url, onLoad, onProgress, onError ) {\n\n\t\tvar scope = this;\n\n\t\tvar loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\tonLoad( scope.parse( text ) );\n\n\t\t}, onProgress, onError );\n\n\t},\n\n\tparse: function ( text ) {\n\n\t\tfunction parseNode( node, style ) {\n\n\t\t\tif ( node.nodeType !== 1 ) return;\n\n\t\t\tvar transform = getNodeTransform( node );\n\n\t\t\tvar path = null;\n\n\t\t\tswitch ( node.nodeName ) {\n\n\t\t\t\tcase 'svg':\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'g':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'path':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tif ( node.hasAttribute( 'd' ) ) path = parsePathNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rect':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseRectNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'polygon':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parsePolygonNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'polyline':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parsePolylineNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'circle':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseCircleNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ellipse':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseEllipseNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'line':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseLineNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.log( node );\n\n\t\t\t}\n\n\t\t\tif ( path ) {\n\n\t\t\t\tif ( style.fill !== undefined && style.fill !== 'none' ) {\n\n\t\t\t\t\tpath.color.setStyle( style.fill );\n\n\t\t\t\t}\n\n\t\t\t\ttransformPath( path, currentTransform );\n\n\t\t\t\tpaths.push( path );\n\n\t\t\t\tpath.userData = { node: node, style: style };\n\n\t\t\t}\n\n\t\t\tvar nodes = node.childNodes;\n\n\t\t\tfor ( var i = 0; i < nodes.length; i ++ ) {\n\n\t\t\t\tparseNode( nodes[ i ], style );\n\n\t\t\t}\n\n\t\t\tif ( transform ) {\n\n\t\t\t\ttransformStack.pop();\n\n\t\t\t\tif ( transformStack.length > 0 ) {\n\n\t\t\t\t\tcurrentTransform.copy( transformStack[ transformStack.length - 1 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcurrentTransform.identity();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parsePathNode( node ) {\n\n\t\t\tvar path = new ShapePath();\n\n\t\t\tvar point = new Vector2();\n\t\t\tvar control = new Vector2();\n\n\t\t\tvar firstPoint = new Vector2();\n\t\t\tvar isFirstPoint = true;\n\t\t\tvar doSetFirstPoint = false;\n\n\t\t\tvar d = node.getAttribute( 'd' );\n\n\t\t\t// console.log( d );\n\n\t\t\tvar commands = d.match( /[a-df-z][^a-df-z]*/ig );\n\n\t\t\tfor ( var i = 0, l = commands.length; i < l; i ++ ) {\n\n\t\t\t\tvar command = commands[ i ];\n\n\t\t\t\tvar type = command.charAt( 0 );\n\t\t\t\tvar data = command.substr( 1 ).trim();\n\n\t\t\t\tif ( isFirstPoint === true ) {\n\n\t\t\t\t\tdoSetFirstPoint = true;\n\t\t\t\t\tisFirstPoint = false;\n\n\t\t\t\t}\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase 'M':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\n\t\t\t\t\t\t\tif ( j === 0 ) {\n\n\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'H':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'V':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.y = numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'L':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'C':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 6 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 4 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 5 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 3 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 4 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 5 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'S':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\n\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Q':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'T':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tvar rx = getReflection( point.x, control.x );\n\t\t\t\t\t\t\tvar ry = getReflection( point.y, control.y );\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\trx,\n\t\t\t\t\t\t\t\try,\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = rx;\n\t\t\t\t\t\t\tcontrol.y = ry;\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'A':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 7 ) {\n\n\t\t\t\t\t\t\tvar start = point.clone();\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 5 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 6 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tparseArcCommand(\n\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'm':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\n\t\t\t\t\t\t\tif ( j === 0 ) {\n\n\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'h':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.y += numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'l':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 6 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 4 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 5 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 2 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 3 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 4 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 5 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 's':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\n\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'q':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tvar rx = getReflection( point.x, control.x );\n\t\t\t\t\t\t\tvar ry = getReflection( point.y, control.y );\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\trx,\n\t\t\t\t\t\t\t\try,\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = rx;\n\t\t\t\t\t\t\tcontrol.y = ry;\n\t\t\t\t\t\t\tpoint.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = point.y + numbers[ j + 1 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'a':\n\t\t\t\t\t\tvar numbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( var j = 0, jl = numbers.length; j < jl; j += 7 ) {\n\n\t\t\t\t\t\t\tvar start = point.clone();\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 5 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 6 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tparseArcCommand(\n\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Z':\n\t\t\t\t\tcase 'z':\n\t\t\t\t\t\tpath.currentPath.autoClose = true;\n\n\t\t\t\t\t\tif ( path.currentPath.curves.length > 0 ) {\n\n\t\t\t\t\t\t\t// Reset point to beginning of Path\n\t\t\t\t\t\t\tpoint.copy( firstPoint );\n\t\t\t\t\t\t\tpath.currentPath.currentPoint.copy( point );\n\t\t\t\t\t\t\tisFirstPoint = true;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( command );\n\n\t\t\t\t}\n\n\t\t\t\t// console.log( type, parseFloats( data ), parseFloats( data ).length  )\n\n\t\t\t\tdoSetFirstPoint = false;\n\n\t\t\t}\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\t/**\n\t\t * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n\t\t * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\n\t\t * From\n\t\t * rx ry x-axis-rotation large-arc-flag sweep-flag x y\n\t\t * To\n\t\t * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation\n\t\t */\n\n\t\tfunction parseArcCommand( path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end ) {\n\n\t\t\tx_axis_rotation = x_axis_rotation * Math.PI / 180;\n\n\t\t\t// Ensure radii are positive\n\t\t\trx = Math.abs( rx );\n\t\t\try = Math.abs( ry );\n\n\t\t\t// Compute (x1′, y1′)\n\t\t\tvar dx2 = ( start.x - end.x ) / 2.0;\n\t\t\tvar dy2 = ( start.y - end.y ) / 2.0;\n\t\t\tvar x1p = Math.cos( x_axis_rotation ) * dx2 + Math.sin( x_axis_rotation ) * dy2;\n\t\t\tvar y1p = - Math.sin( x_axis_rotation ) * dx2 + Math.cos( x_axis_rotation ) * dy2;\n\n\t\t\t// Compute (cx′, cy′)\n\t\t\tvar rxs = rx * rx;\n\t\t\tvar rys = ry * ry;\n\t\t\tvar x1ps = x1p * x1p;\n\t\t\tvar y1ps = y1p * y1p;\n\n\t\t\t// Ensure radii are large enough\n\t\t\tvar cr = x1ps / rxs + y1ps / rys;\n\n\t\t\tif ( cr > 1 ) {\n\n\t\t\t\t// scale up rx,ry equally so cr == 1\n\t\t\t\tvar s = Math.sqrt( cr );\n\t\t\t\trx = s * rx;\n\t\t\t\try = s * ry;\n\t\t\t\trxs = rx * rx;\n\t\t\t\trys = ry * ry;\n\n\t\t\t}\n\n\t\t\tvar dq = ( rxs * y1ps + rys * x1ps );\n\t\t\tvar pq = ( rxs * rys - dq ) / dq;\n\t\t\tvar q = Math.sqrt( Math.max( 0, pq ) );\n\t\t\tif ( large_arc_flag === sweep_flag ) q = - q;\n\t\t\tvar cxp = q * rx * y1p / ry;\n\t\t\tvar cyp = - q * ry * x1p / rx;\n\n\t\t\t// Step 3: Compute (cx, cy) from (cx′, cy′)\n\t\t\tvar cx = Math.cos( x_axis_rotation ) * cxp - Math.sin( x_axis_rotation ) * cyp + ( start.x + end.x ) / 2;\n\t\t\tvar cy = Math.sin( x_axis_rotation ) * cxp + Math.cos( x_axis_rotation ) * cyp + ( start.y + end.y ) / 2;\n\n\t\t\t// Step 4: Compute θ1 and Δθ\n\t\t\tvar theta = svgAngle( 1, 0, ( x1p - cxp ) / rx, ( y1p - cyp ) / ry );\n\t\t\tvar delta = svgAngle( ( x1p - cxp ) / rx, ( y1p - cyp ) / ry, ( - x1p - cxp ) / rx, ( - y1p - cyp ) / ry ) % ( Math.PI * 2 );\n\n\t\t\tpath.currentPath.absellipse( cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation );\n\n\t\t}\n\n\t\tfunction svgAngle( ux, uy, vx, vy ) {\n\n\t\t\tvar dot = ux * vx + uy * vy;\n\t\t\tvar len = Math.sqrt( ux * ux + uy * uy ) * Math.sqrt( vx * vx + vy * vy );\n\t\t\tvar ang = Math.acos( Math.max( - 1, Math.min( 1, dot / len ) ) ); // floating point precision, slightly over values appear\n\t\t\tif ( ( ux * vy - uy * vx ) < 0 ) ang = - ang;\n\t\t\treturn ang;\n\n\t\t}\n\n\t\t/*\n\t\t* According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute\n\t\t* rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough\n\t\t*/\n\t\tfunction parseRectNode( node ) {\n\n\t\t\tvar x = parseFloat( node.getAttribute( 'x' ) || 0 );\n\t\t\tvar y = parseFloat( node.getAttribute( 'y' ) || 0 );\n\t\t\tvar rx = parseFloat( node.getAttribute( 'rx' ) || 0 );\n\t\t\tvar ry = parseFloat( node.getAttribute( 'ry' ) || 0 );\n\t\t\tvar w = parseFloat( node.getAttribute( 'width' ) );\n\t\t\tvar h = parseFloat( node.getAttribute( 'height' ) );\n\n\t\t\tvar path = new ShapePath();\n\t\t\tpath.moveTo( x + 2 * rx, y );\n\t\t\tpath.lineTo( x + w - 2 * rx, y );\n\t\t\tif ( rx !== 0 || ry !== 0 ) path.bezierCurveTo( x + w, y, x + w, y, x + w, y + 2 * ry );\n\t\t\tpath.lineTo( x + w, y + h - 2 * ry );\n\t\t\tif ( rx !== 0 || ry !== 0 ) path.bezierCurveTo( x + w, y + h, x + w, y + h, x + w - 2 * rx, y + h );\n\t\t\tpath.lineTo( x + 2 * rx, y + h );\n\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo( x, y + h, x, y + h, x, y + h - 2 * ry );\n\n\t\t\t}\n\n\t\t\tpath.lineTo( x, y + 2 * ry );\n\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo( x, y, x, y, x + 2 * rx, y );\n\n\t\t\t}\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parsePolygonNode( node ) {\n\n\t\t\tfunction iterator( match, a, b ) {\n\n\t\t\t\tvar x = parseFloat( a );\n\t\t\t\tvar y = parseFloat( b );\n\n\t\t\t\tif ( index === 0 ) {\n\n\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t}\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\tvar regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n\n\t\t\tvar path = new ShapePath();\n\n\t\t\tvar index = 0;\n\n\t\t\tnode.getAttribute( 'points' ).replace( regex, iterator );\n\n\t\t\tpath.currentPath.autoClose = true;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parsePolylineNode( node ) {\n\n\t\t\tfunction iterator( match, a, b ) {\n\n\t\t\t\tvar x = parseFloat( a );\n\t\t\t\tvar y = parseFloat( b );\n\n\t\t\t\tif ( index === 0 ) {\n\n\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t}\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\tvar regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n\n\t\t\tvar path = new ShapePath();\n\n\t\t\tvar index = 0;\n\n\t\t\tnode.getAttribute( 'points' ).replace( regex, iterator );\n\n\t\t\tpath.currentPath.autoClose = false;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseCircleNode( node ) {\n\n\t\t\tvar x = parseFloat( node.getAttribute( 'cx' ) );\n\t\t\tvar y = parseFloat( node.getAttribute( 'cy' ) );\n\t\t\tvar r = parseFloat( node.getAttribute( 'r' ) );\n\n\t\t\tvar subpath = new Path();\n\t\t\tsubpath.absarc( x, y, r, 0, Math.PI * 2 );\n\n\t\t\tvar path = new ShapePath();\n\t\t\tpath.subPaths.push( subpath );\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseEllipseNode( node ) {\n\n\t\t\tvar x = parseFloat( node.getAttribute( 'cx' ) );\n\t\t\tvar y = parseFloat( node.getAttribute( 'cy' ) );\n\t\t\tvar rx = parseFloat( node.getAttribute( 'rx' ) );\n\t\t\tvar ry = parseFloat( node.getAttribute( 'ry' ) );\n\n\t\t\tvar subpath = new Path();\n\t\t\tsubpath.absellipse( x, y, rx, ry, 0, Math.PI * 2 );\n\n\t\t\tvar path = new ShapePath();\n\t\t\tpath.subPaths.push( subpath );\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseLineNode( node ) {\n\n\t\t\tvar x1 = parseFloat( node.getAttribute( 'x1' ) );\n\t\t\tvar y1 = parseFloat( node.getAttribute( 'y1' ) );\n\t\t\tvar x2 = parseFloat( node.getAttribute( 'x2' ) );\n\t\t\tvar y2 = parseFloat( node.getAttribute( 'y2' ) );\n\n\t\t\tvar path = new ShapePath();\n\t\t\tpath.moveTo( x1, y1 );\n\t\t\tpath.lineTo( x2, y2 );\n\t\t\tpath.currentPath.autoClose = false;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\t//\n\n\t\tfunction parseStyle( node, style ) {\n\n\t\t\tstyle = Object.assign( {}, style ); // clone style\n\n\t\t\tfunction addStyle( svgName, jsName, adjustFunction ) {\n\n\t\t\t\tif ( adjustFunction === undefined ) adjustFunction = function copy( v ) {\n\n\t\t\t\t\treturn v;\n\n\t\t\t\t};\n\n\t\t\t\tif ( node.hasAttribute( svgName ) ) style[ jsName ] = adjustFunction( node.getAttribute( svgName ) );\n\t\t\t\tif ( node.style && node.style[ svgName ] !== '' ) style[ jsName ] = adjustFunction( node.style[ svgName ] );\n\n\t\t\t}\n\n\t\t\tfunction clamp( v ) {\n\n\t\t\t\treturn Math.max( 0, Math.min( 1, parseFloat( v ) ) );\n\n\t\t\t}\n\n\t\t\tfunction positive( v ) {\n\n\t\t\t\treturn Math.max( 0, parseFloat( v ) );\n\n\t\t\t}\n\n\t\t\taddStyle( 'fill', 'fill' );\n\t\t\taddStyle( 'fill-opacity', 'fillOpacity', clamp );\n\t\t\taddStyle( 'stroke', 'stroke' );\n\t\t\taddStyle( 'stroke-opacity', 'strokeOpacity', clamp );\n\t\t\taddStyle( 'stroke-width', 'strokeWidth', positive );\n\t\t\taddStyle( 'stroke-linejoin', 'strokeLineJoin' );\n\t\t\taddStyle( 'stroke-linecap', 'strokeLineCap' );\n\t\t\taddStyle( 'stroke-miterlimit', 'strokeMiterLimit', positive );\n\n\t\t\treturn style;\n\n\t\t}\n\n\t\t// http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\n\n\t\tfunction getReflection( a, b ) {\n\n\t\t\treturn a - ( b - a );\n\n\t\t}\n\n\t\tfunction parseFloats( string ) {\n\n\t\t\tvar array = string.split( /[\\s,]+|(?=\\s?[+\\-])/ );\n\n\t\t\tfor ( var i = 0; i < array.length; i ++ ) {\n\n\t\t\t\tvar number = array[ i ];\n\n\t\t\t\t// Handle values like 48.6037.7.8\n\t\t\t\t// TODO Find a regex for this\n\n\t\t\t\tif ( number.indexOf( '.' ) !== number.lastIndexOf( '.' ) ) {\n\n\t\t\t\t\tvar split = number.split( '.' );\n\n\t\t\t\t\tfor ( var s = 2; s < split.length; s ++ ) {\n\n\t\t\t\t\t\tarray.splice( i + s - 1, 0, '0.' + split[ s ] );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tarray[ i ] = parseFloat( number );\n\n\t\t\t}\n\n\t\t\treturn array;\n\n\n\t\t}\n\n\t\tfunction getNodeTransform( node ) {\n\n\t\t\tif ( ! node.hasAttribute( 'transform' ) ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tvar transform = parseNodeTransform( node );\n\n\t\t\tif ( transformStack.length > 0 ) {\n\n\t\t\t\ttransform.premultiply( transformStack[ transformStack.length - 1 ] );\n\n\t\t\t}\n\n\t\t\tcurrentTransform.copy( transform );\n\t\t\ttransformStack.push( transform );\n\n\t\t\treturn transform;\n\n\t\t}\n\n\t\tfunction parseNodeTransform( node ) {\n\n\t\t\tvar transform = new Matrix3();\n\t\t\tvar currentTransform = tempTransform0;\n\t\t\tvar transformsTexts = node.getAttribute( 'transform' ).split( ')' );\n\n\t\t\tfor ( var tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex -- ) {\n\n\t\t\t\tvar transformText = transformsTexts[ tIndex ].trim();\n\n\t\t\t\tif ( transformText === '' ) continue;\n\n\t\t\t\tvar openParPos = transformText.indexOf( '(' );\n\t\t\t\tvar closeParPos = transformText.length;\n\n\t\t\t\tif ( openParPos > 0 && openParPos < closeParPos ) {\n\n\t\t\t\t\tvar transformType = transformText.substr( 0, openParPos );\n\n\t\t\t\t\tvar array = parseFloats( transformText.substr( openParPos + 1, closeParPos - openParPos - 1 ) );\n\n\t\t\t\t\tcurrentTransform.identity();\n\n\t\t\t\t\tswitch ( transformType ) {\n\n\t\t\t\t\t\tcase \"translate\":\n\n\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\tvar tx = array[ 0 ];\n\t\t\t\t\t\t\t\tvar ty = tx;\n\n\t\t\t\t\t\t\t\tif ( array.length >= 2 ) {\n\n\t\t\t\t\t\t\t\t\tty = array[ 1 ];\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tcurrentTransform.translate( tx, ty );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase \"rotate\":\n\n\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\tvar angle = 0;\n\t\t\t\t\t\t\t\tvar cx = 0;\n\t\t\t\t\t\t\t\tvar cy = 0;\n\n\t\t\t\t\t\t\t\t// Angle\n\t\t\t\t\t\t\t\tangle = - array[ 0 ] * Math.PI / 180;\n\n\t\t\t\t\t\t\t\tif ( array.length >= 3 ) {\n\n\t\t\t\t\t\t\t\t\t// Center x, y\n\t\t\t\t\t\t\t\t\tcx = array[ 1 ];\n\t\t\t\t\t\t\t\t\tcy = array[ 2 ];\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Rotate around center (cx, cy)\n\t\t\t\t\t\t\t\ttempTransform1.identity().translate( - cx, - cy );\n\t\t\t\t\t\t\t\ttempTransform2.identity().rotate( angle );\n\t\t\t\t\t\t\t\ttempTransform3.multiplyMatrices( tempTransform2, tempTransform1 );\n\t\t\t\t\t\t\t\ttempTransform1.identity().translate( cx, cy );\n\t\t\t\t\t\t\t\tcurrentTransform.multiplyMatrices( tempTransform1, tempTransform3 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase \"scale\":\n\n\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\tvar scaleX = array[ 0 ];\n\t\t\t\t\t\t\t\tvar scaleY = scaleX;\n\n\t\t\t\t\t\t\t\tif ( array.length >= 2 ) {\n\n\t\t\t\t\t\t\t\t\tscaleY = array[ 1 ];\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tcurrentTransform.scale( scaleX, scaleY );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase \"skewX\":\n\n\t\t\t\t\t\t\tif ( array.length === 1 ) {\n\n\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t1, Math.tan( array[ 0 ] * Math.PI / 180 ), 0,\n\t\t\t\t\t\t\t\t\t0, 1, 0,\n\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase \"skewY\":\n\n\t\t\t\t\t\t\tif ( array.length === 1 ) {\n\n\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t1, 0, 0,\n\t\t\t\t\t\t\t\t\tMath.tan( array[ 0 ] * Math.PI / 180 ), 1, 0,\n\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase \"matrix\":\n\n\t\t\t\t\t\t\tif ( array.length === 6 ) {\n\n\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\tarray[ 0 ], array[ 2 ], array[ 4 ],\n\t\t\t\t\t\t\t\t\tarray[ 1 ], array[ 3 ], array[ 5 ],\n\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\ttransform.premultiply( currentTransform );\n\n\t\t\t}\n\n\t\t\treturn transform;\n\n\t\t}\n\n\t\tfunction transformPath( path, m ) {\n\n\t\t\tfunction transfVec2( v2 ) {\n\n\t\t\t\ttempV3.set( v2.x, v2.y, 1 ).applyMatrix3( m );\n\n\t\t\t\tv2.set( tempV3.x, tempV3.y );\n\n\t\t\t}\n\n\t\t\tvar isRotated = isTransformRotated( m );\n\n\t\t\tvar subPaths = path.subPaths;\n\n\t\t\tfor ( var i = 0, n = subPaths.length; i < n; i ++ ) {\n\n\t\t\t\tvar subPath = subPaths[ i ];\n\t\t\t\tvar curves = subPath.curves;\n\n\t\t\t\tfor ( var j = 0; j < curves.length; j ++ ) {\n\n\t\t\t\t\tvar curve = curves[ j ];\n\n\t\t\t\t\tif ( curve.isLineCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\n\t\t\t\t\t} else if ( curve.isCubicBezierCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v0 );\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\t\t\t\t\t\ttransfVec2( curve.v3 );\n\n\t\t\t\t\t} else if ( curve.isQuadraticBezierCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v0 );\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\n\t\t\t\t\t} else if ( curve.isEllipseCurve ) {\n\n\t\t\t\t\t\tif ( isRotated ) {\n\n\t\t\t\t\t\t\tconsole.warn( \"SVGLoader: Elliptic arc or ellipse rotation or skewing is not implemented.\" );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttempV2.set( curve.aX, curve.aY );\n\t\t\t\t\t\ttransfVec2( tempV2 );\n\t\t\t\t\t\tcurve.aX = tempV2.x;\n\t\t\t\t\t\tcurve.aY = tempV2.y;\n\n\t\t\t\t\t\tcurve.xRadius *= getTransformScaleX( m );\n\t\t\t\t\t\tcurve.yRadius *= getTransformScaleY( m );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction isTransformRotated( m ) {\n\n\t\t\treturn m.elements[ 1 ] !== 0 || m.elements[ 3 ] !== 0;\n\n\t\t}\n\n\t\tfunction getTransformScaleX( m ) {\n\n\t\t\tvar te = m.elements;\n\t\t\treturn Math.sqrt( te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] );\n\n\t\t}\n\n\t\tfunction getTransformScaleY( m ) {\n\n\t\t\tvar te = m.elements;\n\t\t\treturn Math.sqrt( te[ 3 ] * te[ 3 ] + te[ 4 ] * te[ 4 ] );\n\n\t\t}\n\n\t\t//\n\n\t\tconsole.log( 'THREE.SVGLoader' );\n\n\t\tvar paths = [];\n\n\t\tvar transformStack = [];\n\n\t\tvar tempTransform0 = new Matrix3();\n\t\tvar tempTransform1 = new Matrix3();\n\t\tvar tempTransform2 = new Matrix3();\n\t\tvar tempTransform3 = new Matrix3();\n\t\tvar tempV2 = new Vector2();\n\t\tvar tempV3 = new Vector3();\n\n\t\tvar currentTransform = new Matrix3();\n\n\t\tconsole.time( 'THREE.SVGLoader: DOMParser' );\n\n\t\tvar xml = new DOMParser().parseFromString( text, 'image/svg+xml' ); // application/xml\n\n\t\tconsole.timeEnd( 'THREE.SVGLoader: DOMParser' );\n\n\t\tconsole.time( 'THREE.SVGLoader: Parse' );\n\n\t\tparseNode( xml.documentElement, {\n\t\t\tfill: '#000',\n\t\t\tfillOpacity: 1,\n\t\t\tstrokeOpacity: 1,\n\t\t\tstrokeWidth: 1,\n\t\t\tstrokeLineJoin: 'miter',\n\t\t\tstrokeLineCap: 'butt',\n\t\t\tstrokeMiterLimit: 4\n\t\t} );\n\n\t\tvar data = { paths: paths, xml: xml.documentElement };\n\n\t\t// console.log( paths );\n\n\n\t\tconsole.timeEnd( 'THREE.SVGLoader: Parse' );\n\n\t\treturn data;\n\n\t}\n\n} );\n\nSVGLoader.getStrokeStyle = function ( width, color, lineJoin, lineCap, miterLimit ) {\n\n\t// Param width: Stroke width\n\t// Param color: As returned by Color.getStyle()\n\t// Param lineJoin: One of \"round\", \"bevel\", \"miter\" or \"miter-limit\"\n\t// Param lineCap: One of \"round\", \"square\" or \"butt\"\n\t// Param miterLimit: Maximum join length, in multiples of the \"width\" parameter (join is truncated if it exceeds that distance)\n\t// Returns style object\n\n\twidth = width !== undefined ? width : 1;\n\tcolor = color !== undefined ? color : '#000';\n\tlineJoin = lineJoin !== undefined ? lineJoin : 'miter';\n\tlineCap = lineCap !== undefined ? lineCap : 'butt';\n\tmiterLimit = miterLimit !== undefined ? miterLimit : 4;\n\n\treturn {\n\t\tstrokeColor: color,\n\t\tstrokeWidth: width,\n\t\tstrokeLineJoin: lineJoin,\n\t\tstrokeLineCap: lineCap,\n\t\tstrokeMiterLimit: miterLimit\n\t};\n\n};\n\nSVGLoader.pointsToStroke = function ( points, style, arcDivisions, minDistance ) {\n\n\t// Generates a stroke with some witdh around the given path.\n\t// The path can be open or closed (last point equals to first point)\n\t// Param points: Array of Vector2D (the path). Minimum 2 points.\n\t// Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object\n\t// Params arcDivisions: Arc divisions for round joins and endcaps. (Optional)\n\t// Param minDistance: Points closer to this distance will be merged. (Optional)\n\t// Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right)\n\n\tvar vertices = [];\n\tvar normals = [];\n\tvar uvs = [];\n\n\tif ( SVGLoader.pointsToStrokeWithBuffers( points, style, arcDivisions, minDistance, vertices, normals, uvs ) === 0 ) {\n\n\t\treturn null;\n\n\t}\n\n\tvar geometry = new BufferGeometry();\n\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\tgeometry.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\tgeometry.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\treturn geometry;\n\n};\n\nSVGLoader.pointsToStrokeWithBuffers = function () {\n\n\tvar tempV2_1 = new Vector2();\n\tvar tempV2_2 = new Vector2();\n\tvar tempV2_3 = new Vector2();\n\tvar tempV2_4 = new Vector2();\n\tvar tempV2_5 = new Vector2();\n\tvar tempV2_6 = new Vector2();\n\tvar tempV2_7 = new Vector2();\n\tvar lastPointL = new Vector2();\n\tvar lastPointR = new Vector2();\n\tvar point0L = new Vector2();\n\tvar point0R = new Vector2();\n\tvar currentPointL = new Vector2();\n\tvar currentPointR = new Vector2();\n\tvar nextPointL = new Vector2();\n\tvar nextPointR = new Vector2();\n\tvar innerPoint = new Vector2();\n\tvar outerPoint = new Vector2();\n\n\treturn function ( points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset ) {\n\n\t\t// This function can be called to update existing arrays or buffers.\n\t\t// Accepts same parameters as pointsToStroke, plus the buffers and optional offset.\n\t\t// Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)\n\t\t// Returns number of written vertices / normals / uvs pairs\n\t\t// if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)\n\t\t// 'normals' and 'uvs' buffers are optional\n\n\t\tarcDivisions = arcDivisions !== undefined ? arcDivisions : 12;\n\t\tminDistance = minDistance !== undefined ? minDistance : 0.001;\n\t\tvertexOffset = vertexOffset !== undefined ? vertexOffset : 0;\n\n\t\t// First ensure there are no duplicated points\n\t\tpoints = removeDuplicatedPoints( points );\n\n\t\tvar numPoints = points.length;\n\n\t\tif ( numPoints < 2 ) return 0;\n\n\t\tvar isClosed = points[ 0 ].equals( points[ numPoints - 1 ] );\n\n\t\tvar currentPoint;\n\t\tvar previousPoint = points[ 0 ];\n\t\tvar nextPoint;\n\n\t\tvar strokeWidth2 = style.strokeWidth / 2;\n\n\t\tvar deltaU = 1 / ( numPoints - 1 );\n\t\tvar u0 = 0;\n\n\t\tvar innerSideModified;\n\t\tvar joinIsOnLeftSide;\n\t\tvar isMiter;\n\t\tvar initialJoinIsOnLeftSide = false;\n\n\t\tvar numVertices = 0;\n\t\tvar currentCoordinate = vertexOffset * 3;\n\t\tvar currentCoordinateUV = vertexOffset * 2;\n\n\t\t// Get initial left and right stroke points\n\t\tgetNormal( points[ 0 ], points[ 1 ], tempV2_1 ).multiplyScalar( strokeWidth2 );\n\t\tlastPointL.copy( points[ 0 ] ).sub( tempV2_1 );\n\t\tlastPointR.copy( points[ 0 ] ).add( tempV2_1 );\n\t\tpoint0L.copy( lastPointL );\n\t\tpoint0R.copy( lastPointR );\n\n\t\tfor ( var iPoint = 1; iPoint < numPoints; iPoint ++ ) {\n\n\t\t\tcurrentPoint = points[ iPoint ];\n\n\t\t\t// Get next point\n\t\t\tif ( iPoint === numPoints - 1 ) {\n\n\t\t\t\tif ( isClosed ) {\n\n\t\t\t\t\t// Skip duplicated initial point\n\t\t\t\t\tnextPoint = points[ 1 ];\n\n\t\t\t\t} else nextPoint = undefined;\n\n\t\t\t} else {\n\n\t\t\t\tnextPoint = points[ iPoint + 1 ];\n\n\t\t\t}\n\n\t\t\t// Normal of previous segment in tempV2_1\n\t\t\tvar normal1 = tempV2_1;\n\t\t\tgetNormal( previousPoint, currentPoint, normal1 );\n\n\t\t\ttempV2_3.copy( normal1 ).multiplyScalar( strokeWidth2 );\n\t\t\tcurrentPointL.copy( currentPoint ).sub( tempV2_3 );\n\t\t\tcurrentPointR.copy( currentPoint ).add( tempV2_3 );\n\n\t\t\tvar u1 = u0 + deltaU;\n\n\t\t\tinnerSideModified = false;\n\n\t\t\tif ( nextPoint !== undefined ) {\n\n\t\t\t\t// Normal of next segment in tempV2_2\n\t\t\t\tgetNormal( currentPoint, nextPoint, tempV2_2 );\n\n\t\t\t\ttempV2_3.copy( tempV2_2 ).multiplyScalar( strokeWidth2 );\n\t\t\t\tnextPointL.copy( currentPoint ).sub( tempV2_3 );\n\t\t\t\tnextPointR.copy( currentPoint ).add( tempV2_3 );\n\n\t\t\t\tjoinIsOnLeftSide = true;\n\t\t\t\ttempV2_3.subVectors( nextPoint, previousPoint );\n\t\t\t\tif ( normal1.dot( tempV2_3 ) < 0 ) {\n\n\t\t\t\t\tjoinIsOnLeftSide = false;\n\n\t\t\t\t}\n\t\t\t\tif ( iPoint === 1 ) initialJoinIsOnLeftSide = joinIsOnLeftSide;\n\n\t\t\t\ttempV2_3.subVectors( nextPoint, currentPoint );\n\t\t\t\ttempV2_3.normalize();\n\t\t\t\tvar dot = Math.abs( normal1.dot( tempV2_3 ) );\n\n\t\t\t\t// If path is straight, don't create join\n\t\t\t\tif ( dot !== 0 ) {\n\n\t\t\t\t\t// Compute inner and outer segment intersections\n\t\t\t\t\tvar miterSide = strokeWidth2 / dot;\n\t\t\t\t\ttempV2_3.multiplyScalar( - miterSide );\n\t\t\t\t\ttempV2_4.subVectors( currentPoint, previousPoint );\n\t\t\t\t\ttempV2_5.copy( tempV2_4 ).setLength( miterSide ).add( tempV2_3 );\n\t\t\t\t\tinnerPoint.copy( tempV2_5 ).negate();\n\t\t\t\t\tvar miterLength2 = tempV2_5.length();\n\t\t\t\t\tvar segmentLengthPrev = tempV2_4.length();\n\t\t\t\t\ttempV2_4.divideScalar( segmentLengthPrev );\n\t\t\t\t\ttempV2_6.subVectors( nextPoint, currentPoint );\n\t\t\t\t\tvar segmentLengthNext = tempV2_6.length();\n\t\t\t\t\ttempV2_6.divideScalar( segmentLengthNext );\n\t\t\t\t\t// Check that previous and next segments doesn't overlap with the innerPoint of intersection\n\t\t\t\t\tif ( tempV2_4.dot( innerPoint ) < segmentLengthPrev && tempV2_6.dot( innerPoint ) < segmentLengthNext ) {\n\n\t\t\t\t\t\tinnerSideModified = true;\n\n\t\t\t\t\t}\n\t\t\t\t\touterPoint.copy( tempV2_5 ).add( currentPoint );\n\t\t\t\t\tinnerPoint.add( currentPoint );\n\n\t\t\t\t\tisMiter = false;\n\n\t\t\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\tnextPointR.copy( innerPoint );\n\t\t\t\t\t\t\tcurrentPointR.copy( innerPoint );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tnextPointL.copy( innerPoint );\n\t\t\t\t\t\t\tcurrentPointL.copy( innerPoint );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// The segment triangles are generated here if there was overlapping\n\n\t\t\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch ( style.strokeLineJoin ) {\n\n\t\t\t\t\t\tcase 'bevel':\n\n\t\t\t\t\t\t\tmakeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'round':\n\n\t\t\t\t\t\t\t// Segment triangles\n\n\t\t\t\t\t\t\tcreateSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );\n\n\t\t\t\t\t\t\t// Join triangles\n\n\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\tmakeCircularSector( currentPoint, currentPointL, nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tmakeCircularSector( currentPoint, nextPointR, currentPointR, u1, 1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'miter':\n\t\t\t\t\t\tcase 'miter-clip':\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tvar miterFraction = ( strokeWidth2 * style.strokeMiterLimit ) / miterLength2;\n\n\t\t\t\t\t\t\tif ( miterFraction < 1 ) {\n\n\t\t\t\t\t\t\t\t// The join miter length exceeds the miter limit\n\n\t\t\t\t\t\t\t\tif ( style.strokeLineJoin !== 'miter-clip' ) {\n\n\t\t\t\t\t\t\t\t\tmakeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// Segment triangles\n\n\t\t\t\t\t\t\t\t\tcreateSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );\n\n\t\t\t\t\t\t\t\t\t// Miter-clip join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\ttempV2_6.subVectors( outerPoint, currentPointL ).multiplyScalar( miterFraction ).add( currentPointL );\n\t\t\t\t\t\t\t\t\t\ttempV2_7.subVectors( outerPoint, nextPointL ).multiplyScalar( miterFraction ).add( nextPointL );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\ttempV2_6.subVectors( outerPoint, currentPointR ).multiplyScalar( miterFraction ).add( currentPointR );\n\t\t\t\t\t\t\t\t\t\ttempV2_7.subVectors( outerPoint, nextPointR ).multiplyScalar( miterFraction ).add( nextPointR );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointR, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Miter join segment triangles\n\n\t\t\t\t\t\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t\t\t\t\t\t// Optimized segment + join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\tnextPointL.copy( outerPoint );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\tnextPointR.copy( outerPoint );\n\n\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// Add extra miter join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointR, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tisMiter = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// The segment triangles are generated here when two consecutive points are collinear\n\n\t\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// The segment triangles are generated here if it is the ending segment\n\n\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t}\n\n\t\t\tif ( ! isClosed && iPoint === numPoints - 1 ) {\n\n\t\t\t\t// Start line endcap\n\t\t\t\taddCapGeometry( points[ 0 ], point0L, point0R, joinIsOnLeftSide, true, u0 );\n\n\t\t\t}\n\n\t\t\t// Increment loop variables\n\n\t\t\tu0 = u1;\n\n\t\t\tpreviousPoint = currentPoint;\n\n\t\t\tlastPointL.copy( nextPointL );\n\t\t\tlastPointR.copy( nextPointR );\n\n\t\t}\n\n\t\tif ( ! isClosed ) {\n\n\t\t\t// Ending line endcap\n\t\t\taddCapGeometry( currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1 );\n\n\t\t} else if ( innerSideModified && vertices ) {\n\n\t\t\t// Modify path first segment vertices to adjust to the segments inner and outer intersections\n\n\t\t\tvar lastOuter = outerPoint;\n\t\t\tvar lastInner = innerPoint;\n\n\t\t\tif ( initialJoinIsOnLeftSide !== joinIsOnLeftSide ) {\n\n\t\t\t\tlastOuter = innerPoint;\n\t\t\t\tlastInner = outerPoint;\n\n\t\t\t}\n\n\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\tif ( isMiter || initialJoinIsOnLeftSide ) {\n\n\t\t\t\t\tlastInner.toArray( vertices, 0 * 3 );\n\t\t\t\t\tlastInner.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\tif ( isMiter ) {\n\n\t\t\t\t\t\tlastOuter.toArray( vertices, 1 * 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( isMiter || ! initialJoinIsOnLeftSide ) {\n\n\t\t\t\t\tlastInner.toArray( vertices, 1 * 3 );\n\t\t\t\t\tlastInner.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\tif ( isMiter ) {\n\n\t\t\t\t\t\tlastOuter.toArray( vertices, 0 * 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn numVertices;\n\n\t\t// -- End of algorithm\n\n\t\t// -- Functions\n\n\t\tfunction getNormal( p1, p2, result ) {\n\n\t\t\tresult.subVectors( p2, p1 );\n\t\t\treturn result.set( - result.y, result.x ).normalize();\n\n\t\t}\n\n\t\tfunction addVertex( position, u, v ) {\n\n\t\t\tif ( vertices ) {\n\n\t\t\t\tvertices[ currentCoordinate ] = position.x;\n\t\t\t\tvertices[ currentCoordinate + 1 ] = position.y;\n\t\t\t\tvertices[ currentCoordinate + 2 ] = 0;\n\n\t\t\t\tif ( normals ) {\n\n\t\t\t\t\tnormals[ currentCoordinate ] = 0;\n\t\t\t\t\tnormals[ currentCoordinate + 1 ] = 0;\n\t\t\t\t\tnormals[ currentCoordinate + 2 ] = 1;\n\n\t\t\t\t}\n\n\t\t\t\tcurrentCoordinate += 3;\n\n\t\t\t\tif ( uvs ) {\n\n\t\t\t\t\tuvs[ currentCoordinateUV ] = u;\n\t\t\t\t\tuvs[ currentCoordinateUV + 1 ] = v;\n\n\t\t\t\t\tcurrentCoordinateUV += 2;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnumVertices += 3;\n\n\t\t}\n\n\t\tfunction makeCircularSector( center, p1, p2, u, v ) {\n\n\t\t\t// param p1, p2: Points in the circle arc.\n\t\t\t// p1 and p2 are in clockwise direction.\n\n\t\t\ttempV2_1.copy( p1 ).sub( center ).normalize();\n\t\t\ttempV2_2.copy( p2 ).sub( center ).normalize();\n\n\t\t\tvar angle = Math.PI;\n\t\t\tvar dot = tempV2_1.dot( tempV2_2 );\n\t\t\tif ( Math.abs( dot ) < 1 ) angle = Math.abs( Math.acos( dot ) );\n\n\t\t\tangle /= arcDivisions;\n\n\t\t\ttempV2_3.copy( p1 );\n\n\t\t\tfor ( var i = 0, il = arcDivisions - 1; i < il; i ++ ) {\n\n\t\t\t\ttempV2_4.copy( tempV2_3 ).rotateAround( center, angle );\n\n\t\t\t\taddVertex( tempV2_3, u, v );\n\t\t\t\taddVertex( tempV2_4, u, v );\n\t\t\t\taddVertex( center, u, 0.5 );\n\n\t\t\t\ttempV2_3.copy( tempV2_4 );\n\n\t\t\t}\n\n\t\t\taddVertex( tempV2_4, u, v );\n\t\t\taddVertex( p2, u, v );\n\t\t\taddVertex( center, u, 0.5 );\n\n\t\t}\n\n\t\tfunction makeSegmentTriangles() {\n\n\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\taddVertex( currentPointL, u1, 1 );\n\t\t\taddVertex( currentPointR, u1, 0 );\n\n\t\t}\n\n\t\tfunction makeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u ) {\n\n\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t// Optimized segment + bevel triangles\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t// Path segments triangles\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t// Bevel join triangle\n\n\t\t\t\t\taddVertex( currentPointL, u, 0 );\n\t\t\t\t\taddVertex( nextPointL, u, 0 );\n\t\t\t\t\taddVertex( innerPoint, u, 0.5 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Path segments triangles\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\t// Bevel join triangle\n\n\t\t\t\t\taddVertex( currentPointR, u, 1 );\n\t\t\t\t\taddVertex( nextPointR, u, 0 );\n\t\t\t\t\taddVertex( innerPoint, u, 0.5 );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// Bevel join triangle. The segment triangles are done in the main loop\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\taddVertex( currentPointL, u, 0 );\n\t\t\t\t\taddVertex( nextPointL, u, 0 );\n\t\t\t\t\taddVertex( currentPoint, u, 0.5 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\taddVertex( currentPointR, u, 1 );\n\t\t\t\t\taddVertex( nextPointR, u, 0 );\n\t\t\t\t\taddVertex( currentPoint, u, 0.5 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction createSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified ) {\n\n\t\t\tif ( innerSideModified ) {\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( nextPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPointR, u0, 1 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( nextPointR, u0, 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction addCapGeometry( center, p1, p2, joinIsOnLeftSide, start, u ) {\n\n\t\t\t// param center: End point of the path\n\t\t\t// param p1, p2: Left and right cap points\n\n\t\t\tswitch ( style.strokeLineCap ) {\n\n\t\t\t\tcase 'round':\n\n\t\t\t\t\tif ( start ) {\n\n\t\t\t\t\t\tmakeCircularSector( center, p2, p1, u, 0.5 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmakeCircularSector( center, p1, p2, u, 0.5 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'square':\n\n\t\t\t\t\tif ( start ) {\n\n\t\t\t\t\t\ttempV2_1.subVectors( p1, center );\n\t\t\t\t\t\ttempV2_2.set( tempV2_1.y, - tempV2_1.x );\n\n\t\t\t\t\t\ttempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );\n\t\t\t\t\t\ttempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );\n\n\t\t\t\t\t\t// Modify already existing vertices\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 0 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 1 * 3 );\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 3 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 0 * 3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttempV2_1.subVectors( p2, center );\n\t\t\t\t\t\ttempV2_2.set( tempV2_1.y, - tempV2_1.x );\n\n\t\t\t\t\t\ttempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );\n\t\t\t\t\t\ttempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );\n\n\t\t\t\t\t\tvar vl = vertices.length;\n\n\t\t\t\t\t\t// Modify already existing vertices\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, vl - 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 2 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 4 * 3 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, vl - 2 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 4 * 3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'butt':\n\t\t\t\tdefault:\n\n\t\t\t\t\t// Nothing to do here\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction removeDuplicatedPoints( points ) {\n\n\t\t\t// Creates a new array if necessary with duplicated points removed.\n\t\t\t// This does not remove duplicated initial and ending points of a closed path.\n\n\t\t\tvar dupPoints = false;\n\t\t\tfor ( var i = 1, n = points.length - 1; i < n; i ++ ) {\n\n\t\t\t\tif ( points[ i ].distanceTo( points[ i + 1 ] ) < minDistance ) {\n\n\t\t\t\t\tdupPoints = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ! dupPoints ) return points;\n\n\t\t\tvar newPoints = [];\n\t\t\tnewPoints.push( points[ 0 ] );\n\n\t\t\tfor ( var i = 1, n = points.length - 1; i < n; i ++ ) {\n\n\t\t\t\tif ( points[ i ].distanceTo( points[ i + 1 ] ) >= minDistance ) {\n\n\t\t\t\t\tnewPoints.push( points[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnewPoints.push( points[ points.length - 1 ] );\n\n\t\t\treturn newPoints;\n\n\t\t}\n\n\t};\n\n}();\n\nexport { SVGLoader };\n"],"sourceRoot":""}