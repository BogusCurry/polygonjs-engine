{"version":3,"sources":["webpack://POLY/./src/engine/nodes/gl/utils/GLDefinition.ts","webpack://POLY/./src/core/ThreeToGl.ts","webpack://POLY/./src/engine/nodes/gl/utils/SpareParamsController.ts","webpack://POLY/./src/engine/nodes/gl/_Base.ts","webpack://POLY/./src/engine/nodes/utils/flags/Base.ts","webpack://POLY/./src/engine/nodes/utils/flags/Bypass.ts","webpack://POLY/./src/engine/nodes/utils/flags/Display.ts","webpack://POLY/./src/engine/nodes/utils/FlagsController.ts","webpack://POLY/./src/engine/containers/Texture.ts","webpack://POLY/./src/engine/nodes/cop/_Base.ts","webpack://POLY/./src/engine/nodes/gl/utils/ConnectionsController.ts","webpack://POLY/./src/core/loader/Texture.ts","webpack://POLY/./src/engine/nodes/cop/File.ts","webpack://POLY/./src/engine/poly/registers/Category.ts","webpack://POLY/./src/engine/nodes/gl/Attribute.ts","webpack://POLY/./src/engine/nodes/gl/utils/GLDefinitionCollection.ts","webpack://POLY/./src/engine/nodes/utils/code/configs/ParamConfig.ts","webpack://POLY/./src/engine/nodes/utils/code/controllers/ParamConfigsController.ts","webpack://POLY/./src/engine/nodes/gl/Globals.ts"],"names":["GLDefinitionType","TypedGLDefinition","_definition_type","_data_type","_node","_name","this","AttributeGLDefinition","super","ATTRIBUTE","data_type","name","FunctionGLDefinition","FUNCTION","UniformGLDefinition","UNIFORM","VaryingGLDefinition","VARYING","ThreeToGl","value","ensure_float","values","toArray","map","v","length","join","vec","num","vector3","x","y","z","w","node","_allow_inputs_created_from_params","params","set_post_create_params_hook","create_inputs_from_params","bind","connections","param_name","names","add_input","_inputless_param_names","includes","has","param","get","parent_param","connection_type","type","connection","push","io","inputs","set_named_input_connection_points","raw_input_serialized_by_param_name","Map","default_value_serialized_by_param_name","current_param_names","spare_names","params_update_options","set","raw_input_serialized","default_value_serialized","names_to_delete","connection_point","named_input_connection_points","param_type","init_value","last_param_init_value","default_value_from_name","gl_input_default_value","array","Array","i","to_add","options","spare","scene","loading_controller","is_loading","update_params","spare_param","raw_input","spare_params_controller","NodeContext","GL","init_inputs","ui_data","set_layout_horizontal","outputs","set_named_output_connection_points","initialize_node","node_sibbling","console","warn","material_node","assembler_controller","set_compilation_required_and_dirty","parent","input_index","get_input_index","input_connection","input_node","node_src","output_connection_point","named_output_connection_points","output_index","output_name","gl_var_name","full_path","any","shaders_collection_controller","_param_configs_controller","reset","list","ParamlessTypedGlNode","params_config","BaseFlag","_state","_hooks","hook","new_state","on_update","run_hooks","emit","NodeEvent","FLAG_BYPASS_UPDATED","set_dirty","FLAG_DISPLAY_UPDATED","FlagsController","Display","Base","display","Bypass","bypass","FlagsControllerD","FlagsControllerB","FlagsControllerDB","content","set_content","_content","log","texture","clone","needsUpdate","image","width","height","DEFAULT_INPUT_NAMES","data","Uint16Array","EMPTY_DATA_TEXTURE","DataTexture","container_controller","flags","COP","set_has_one_output","set_container","BaseCopNodeClass","GlConnectionsController","_input_name_function","index","_output_name_function","_expected_input_types_function","first_input_connection_type","FLOAT","_expected_output_types_function","_update_signature_if_required_bound","update_signature_if_required","_initialized","func","add_on_set_input_hook","add_on_scene_load_hook","add_post_dirty_hook","dirty_trigger","lifecycle","creation_completed","_connections_match_inputs","update_connection_types","remove_dirty_state","make_successors_update_signatures","successor","graph_all_successors","gl_node","gl_connections_controller","expected_input_types","expected_output_types","named_input_connections","named_outputs","create_spare_parameters","current_input_types","c","current_output_types","input_connections","first_connection","connection_type_from_connection","Extension","_param","url","found_node","substring","node_path","find_node","request_container","states","error","load_url","texture_as_env","set_texture_for_mapping","graph_predecessors","graph_disconnect_predecessors","add_graph_input","Promise","resolve","reject","ext","_ext","VIDEO_EXTENSIONS","_load_as_video","loader_for_ext","then","loader","load","undefined","toLowerCase","EXR","EXRLoader","HDR","RGBELoader","setDataType","BASIS","BasisTextureLoader","setTranscoderPath","renderer","Poly","instance","renderers_controller","wait_for_renderer","detectSupport","TextureLoader","video","document","createElement","setAttribute","onloadedmetadata","pause","VideoTexture","source","VIDEO_SOURCE_TYPE_BY_EXT","_default_video_source_type","appendChild","img","canvas","context","getContext","drawImage","getImageData","elements","split","PARAM_DEFAULT","PARAM_ENV_DEFAULT","ogg","ogv","mp4","MAPPINGS","UVMapping","CubeReflectionMapping","CubeRefractionMapping","EquirectangularReflectionMapping","EquirectangularRefractionMapping","SphericalReflectionMapping","CubeUVReflectionMapping","CubeUVRefractionMapping","WRAPPINGS","ClampToEdgeWrapping","RepeatWrapping","MirroredRepeatWrapping","MAG_FILTERS","LinearFilter","NearestFilter","MIN_FILTERS","NearestMipMapNearestFilter","NearestMipMapLinearFilter","LinearMipMapNearestFilter","LinearMipMapLinearFilter","ATTRIB_MAPPING_KEYS","ATTRIB_MAPPING","mapping","wrapS","wrapT","minFilter","magFilter","STRING","desktop_browse","file_type","reload","BUTTON","callback","PARAM_CALLBACK_reload","INTEGER","menu","entries","m","Object","keys","wrap_s","wrap_t","mag_filter","min_filter","_is_static_image_url","pv","cook_for_image","cook_for_video","_load_texture","_update_texture_params","set_texture","clear_texture","_param_url_changed","_add_video_spare_params_if_required","_previous_param_url","_set_video_current_time","cook_controller","end_cook","texture_attrib","param_value","float","param_callback_reload","p","set_successors_dirty","_video","currentTime","constructor","has_param","VIDEO_TIME_PARAM_NAME","duration","add_param","ParamType","cook","range","range_locked","PARAMS_UPDATED","_remove_spare_params","_texture_loader","load_texture_from_url_or_op","e","DEFAULT_NODE_PATH","UV","ENV_MAP","CATEGORY_OBJ","LIGHT","MANAGER","GEOMETRY","CAMERA","MISC","CATEGORY_COP","INPUT","ADVANCED","CATEGORY_EVENT","CATEGORY_GL","COLOR","CONVERSION","DYNAMICS","GLOBALS","LOGIC","MATH","QUAT","TRIGO","UTIL","INSTANCE","CATEGORY_MAT","MESH","POINTS","LINE","VOLUME","CATEGORY_SOP","ANIMATION","MODIFIER","PRIMITIVES","RENDER","ConnectionPointTypesAvailableForAttribute","VEC2","VEC3","VEC4","AttributeGlParamsConfig","ParamsConfig","AttributeGlNode","_on_create_set_name_if_none_bound","_on_create_set_name_if_none","_set_mat_to_recompile_if_is_exporting","add_on_create_hook","set_expected_input_types_function","set_expected_output_types_function","allow_attribute_exports","BOOLEAN","INPUT_NAME","OUTPUT_NAME","assembler","set_node_lines_attribute","named_input","named_input_connection_point","named_output_connection_points_by_name","input_name","used_output_names","export_when_connected","is_exporting","_set_mat_to_recompile","TypedGLDefinitionCollection","_definitions","_errored","_error_message","definitions_by_name","definition","existing","uniq_definitions","_type","_default_value","_uniform_name","uniform_name","default_value","_uniform","_create_uniform","uniform_by_type","callback_bound","_callback","OPERATOR_PATH","node_selection","uniform","Vector3","FOLDER","RAMP","SEPARATOR","VECTOR2","Vector2","VECTOR3","VECTOR4","Vector4","unreachable","compute","has_value_changed","is_video_texture","set_uniform_value_from_texture","set_uniform_value_from_ramp","ramp_texture","new_value","param_constructor","ParamConstructorByType","_cached_param_value","has_changed","are_values_equal","clone_value","result","_param_configs","param_config","GlobalsGlParamsConfig","GlobalsGlNode","add_globals_params","set_node_lines_globals"],"mappings":"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","file":"Gl~Mat.bundle.js","sourcesContent":["import {BaseGlNodeType} from '../_Base';\nimport {TypedGLDefinitionCollection} from './GLDefinitionCollection';\nimport {ConnectionPointType} from '../../utils/connections/ConnectionPointType';\n\nexport enum GLDefinitionType {\n\tATTRIBUTE = 'attribute',\n\tFUNCTION = 'function',\n\tUNIFORM = 'uniform',\n\tVARYING = 'varying',\n}\n\nexport abstract class TypedGLDefinition<T extends GLDefinitionType> {\n\t// constructor(protected _node: BaseGlNodeType, protected _name: string) {}\n\tconstructor(\n\t\tprotected _definition_type: T,\n\t\tprotected _data_type: ConnectionPointType,\n\t\tprotected _node: BaseGlNodeType,\n\t\tprotected _name: string\n\t) {\n\t\t// super(_node, _name);\n\t}\n\n\tget definition_type() {\n\t\treturn this._definition_type;\n\t}\n\tget data_type() {\n\t\treturn this._data_type;\n\t}\n\tget node() {\n\t\treturn this._node;\n\t}\n\tget name() {\n\t\treturn this._name;\n\t}\n\t// get id() {\n\t// \treturn this._data_type;\n\t// }\n\n\tabstract get line(): string;\n\tcollection_instance() {\n\t\treturn new TypedGLDefinitionCollection<T>();\n\t}\n}\n\nexport class AttributeGLDefinition extends TypedGLDefinition<GLDefinitionType.ATTRIBUTE> {\n\tconstructor(protected _node: BaseGlNodeType, protected _data_type: ConnectionPointType, protected _name: string) {\n\t\tsuper(GLDefinitionType.ATTRIBUTE, _data_type, _node, _name);\n\t}\n\tget line() {\n\t\treturn `attribute ${this.data_type} ${this.name}`;\n\t}\n}\n\nexport class FunctionGLDefinition extends TypedGLDefinition<GLDefinitionType.FUNCTION> {\n\tconstructor(protected _node: BaseGlNodeType, protected _data_type: ConnectionPointType, protected _name: string) {\n\t\tsuper(GLDefinitionType.FUNCTION, _data_type, _node, _name);\n\t}\n\tget line() {\n\t\treturn this.name;\n\t}\n}\n\nexport class UniformGLDefinition extends TypedGLDefinition<GLDefinitionType.UNIFORM> {\n\tconstructor(protected _node: BaseGlNodeType, protected _data_type: ConnectionPointType, protected _name: string) {\n\t\tsuper(GLDefinitionType.UNIFORM, _data_type, _node, _name);\n\t}\n\tget line() {\n\t\treturn `uniform ${this.data_type} ${this.name}`;\n\t}\n}\n\nexport class VaryingGLDefinition extends TypedGLDefinition<GLDefinitionType.VARYING> {\n\tconstructor(protected _node: BaseGlNodeType, protected _data_type: ConnectionPointType, protected _name: string) {\n\t\tsuper(GLDefinitionType.VARYING, _data_type, _node, _name);\n\t}\n\tget line() {\n\t\treturn `varying ${this.data_type} ${this.name}`;\n\t}\n}\nexport type BaseGLDefinition = TypedGLDefinition<GLDefinitionType>;\n","import {CoreString} from './String';\nimport {Vector3} from 'three/src/math/Vector3';\nimport {Vector2} from 'three/src/math/Vector2';\nimport lodash_isNumber from 'lodash/isNumber';\nimport lodash_isBoolean from 'lodash/isBoolean';\nimport lodash_isString from 'lodash/isString';\n\nexport class ThreeToGl {\n\tstatic any(value: any) {\n\t\tif (lodash_isString(value)) {\n\t\t\treturn value;\n\t\t}\n\t\tif (lodash_isBoolean(value)) {\n\t\t\treturn `${value}`;\n\t\t}\n\n\t\tif (lodash_isNumber(value)) {\n\t\t\treturn `${CoreString.ensure_float(value)}`;\n\t\t} else {\n\t\t\tconst values = value.toArray().map((v: number) => {\n\t\t\t\treturn `${CoreString.ensure_float(v)}`;\n\t\t\t});\n\t\t\tconst gl_type = `vec${values.length}`;\n\t\t\treturn `${gl_type}(${values.join(', ')})`;\n\t\t}\n\t}\n\n\tstatic vector3(vec: Vector3 | string): string {\n\t\tif (lodash_isString(vec)) {\n\t\t\treturn vec;\n\t\t}\n\t\tconst values = vec.toArray().map((v) => {\n\t\t\treturn `${CoreString.ensure_float(v)}`;\n\t\t});\n\t\treturn `vec3(${values.join(', ')})`;\n\t}\n\tstatic vector2(vec: Vector2 | string): string {\n\t\tif (lodash_isString(vec)) {\n\t\t\treturn vec;\n\t\t}\n\t\tconst values = vec.toArray().map((v) => {\n\t\t\treturn `${CoreString.ensure_float(v)}`;\n\t\t});\n\t\treturn `vec2(${values.join(', ')})`;\n\t}\n\n\tstatic vector3_float(vec: Vector3 | string, num: number | string): string {\n\t\tif (!lodash_isString(num)) {\n\t\t\tnum = CoreString.ensure_float(num);\n\t\t}\n\t\treturn `vec4(${this.vector3(vec)}, ${num})`;\n\t}\n\n\tstatic float4(x: number | string, y: number | string, z: number | string, w: number | string) {\n\t\tif (!lodash_isString(x)) {\n\t\t\tx = CoreString.ensure_float(x);\n\t\t}\n\t\tif (!lodash_isString(y)) {\n\t\t\ty = CoreString.ensure_float(y);\n\t\t}\n\t\tif (!lodash_isString(z)) {\n\t\t\tz = CoreString.ensure_float(z);\n\t\t}\n\t\tif (!lodash_isString(w)) {\n\t\t\tw = CoreString.ensure_float(w);\n\t\t}\n\t\treturn `vec4(${x}, ${y}, ${z}, ${w})`;\n\t}\n\tstatic float3(x: number | string, y: number | string, z: number | string) {\n\t\tif (!lodash_isString(x)) {\n\t\t\tx = CoreString.ensure_float(x);\n\t\t}\n\t\tif (!lodash_isString(y)) {\n\t\t\ty = CoreString.ensure_float(y);\n\t\t}\n\t\tif (!lodash_isString(z)) {\n\t\t\tz = CoreString.ensure_float(z);\n\t\t}\n\t\treturn `vec3(${x}, ${y}, ${z})`;\n\t}\n\tstatic float2(x: number | string, y: number | string) {\n\t\tif (!lodash_isString(x)) {\n\t\t\tx = CoreString.ensure_float(x);\n\t\t}\n\t\tif (!lodash_isString(y)) {\n\t\t\ty = CoreString.ensure_float(y);\n\t\t}\n\t\treturn `vec2(${x}, ${y})`;\n\t}\n\tstatic float(x: number | string) {\n\t\tif (!lodash_isString(x)) {\n\t\t\tx = CoreString.ensure_float(x);\n\t\t}\n\t\treturn `${x}`;\n\t}\n\tstatic int(x: number | string) {\n\t\treturn `${x}`;\n\t}\n\tstatic bool(x: number | string) {\n\t\treturn `${x}`;\n\t}\n}\n","import {ParamTypeToConnectionPointTypeMap} from '../../utils/connections/ConnectionPointType';\nimport {BaseGlNodeType} from '../_Base';\nimport {BaseNamedConnectionPointType, TypedNamedConnectionPoint} from '../../utils/connections/NamedConnectionPoint';\n// import {ParamValue} from '../../../params/types/ParamValue';\nimport {ParamType} from '../../../poly/ParamType';\n// import {ParamValueToDefaultConverter} from '../../utils/params/ParamValueToDefaultConverter';\n// import {NodeEvent} from '../../../poly/NodeEvent';\nimport {ParamsUpdateOptions} from '../../utils/params/ParamsController';\n// import {ParamInitValueSerializedTypeMap} from '../../../params/types/ParamInitValueSerializedTypeMap';\nimport {ParamInitValueSerialized} from '../../../params/types/ParamInitValueSerialized';\nimport lodash_clone from 'lodash/clone';\nimport lodash_isArray from 'lodash/isArray';\nimport lodash_isNumber from 'lodash/isNumber';\n\nexport class GlNodeSpareParamsController {\n\tprivate _allow_inputs_created_from_params: boolean = true;\n\tprivate _inputless_param_names: string[] | undefined;\n\tconstructor(private node: BaseGlNodeType) {}\n\n\tdisallow_inputs_created_from_params() {\n\t\tthis._allow_inputs_created_from_params = false;\n\t}\n\n\tinitialize_node() {\n\t\tthis.node.params.set_post_create_params_hook(this.create_inputs_from_params.bind(this));\n\t}\n\n\tcreate_inputs_from_params() {\n\t\tif (!this._allow_inputs_created_from_params) {\n\t\t\treturn;\n\t\t}\n\t\tconst connections: BaseNamedConnectionPointType[] = [];\n\t\tfor (let param_name of this.node.params.names) {\n\t\t\tlet add_input = true;\n\t\t\tif (\n\t\t\t\tthis._inputless_param_names &&\n\t\t\t\tthis._inputless_param_names.length > 0 &&\n\t\t\t\tthis._inputless_param_names.includes(param_name)\n\t\t\t) {\n\t\t\t\tadd_input = false;\n\t\t\t}\n\t\t\tif (add_input) {\n\t\t\t\tif (this.node.params.has(param_name)) {\n\t\t\t\t\tconst param = this.node.params.get(param_name);\n\t\t\t\t\tif (param && !param.parent_param) {\n\t\t\t\t\t\tconst connection_type = ParamTypeToConnectionPointTypeMap[param.type];\n\t\t\t\t\t\tif (connection_type) {\n\t\t\t\t\t\t\tconst connection = new TypedNamedConnectionPoint(param.name, connection_type);\n\t\t\t\t\t\t\tconnections.push(connection);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.node.io.inputs.set_named_input_connection_points(connections);\n\t}\n\n\tset_inputless_param_names(names: string[]) {\n\t\treturn (this._inputless_param_names = names);\n\t}\n\n\tcreate_spare_parameters() {\n\t\tconst raw_input_serialized_by_param_name: Map<string, ParamInitValueSerialized> = new Map();\n\t\tconst default_value_serialized_by_param_name: Map<string, ParamInitValueSerialized> = new Map();\n\t\tconst current_param_names: string[] = this.node.params.spare_names;\n\t\tconst params_update_options: ParamsUpdateOptions = {};\n\n\t\tfor (let param_name of current_param_names) {\n\t\t\tif (this.node.params.has(param_name)) {\n\t\t\t\tconst param = this.node.params.get(param_name);\n\t\t\t\tif (param) {\n\t\t\t\t\traw_input_serialized_by_param_name.set(param_name, param.raw_input_serialized);\n\t\t\t\t\tdefault_value_serialized_by_param_name.set(param_name, param.default_value_serialized);\n\t\t\t\t\tparams_update_options.names_to_delete = params_update_options.names_to_delete || [];\n\t\t\t\t\tparams_update_options.names_to_delete.push(param_name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (let connection_point of this.node.io.inputs.named_input_connection_points) {\n\t\t\tconst param_name = connection_point.name;\n\t\t\tconst param_type: ParamType = connection_point.param_type;\n\t\t\tlet init_value = connection_point.init_value;\n\t\t\t// let raw_input: ParamInitValueSerialized= null\n\n\t\t\t// const raw_input = raw_input_serialized_by_param_name.get(param_name);\n\t\t\tconst last_param_init_value = default_value_serialized_by_param_name.get(param_name);\n\t\t\t// if (last_param_raw_input != null && last_param_init_value != null) {\n\t\t\t// init_value = ParamValueToDefaultConverter.from_value(param_type, last_param_raw_input);\n\t\t\t// if (init_value == null) {\n\t\t\tconst default_value_from_name = this.node.gl_input_default_value(param_name);\n\n\t\t\t// TODO: this should really store the largest set value\n\t\t\t// (as in the ones with the most components)\n\t\t\t// so that for an Add Gl Node, if I set a vec4 to [1,2,3,4]\n\t\t\t// and then set an input type, which will transform the param to a float\n\t\t\t// it will have a value of 1.\n\t\t\t// But if I then set it to a vec4 again, it will remember [1,2,3,4]\n\t\t\tif (default_value_from_name != null) {\n\t\t\t\tinit_value = default_value_from_name;\n\t\t\t} else {\n\t\t\t\tif (last_param_init_value != null) {\n\t\t\t\t\tinit_value = last_param_init_value;\n\t\t\t\t} else {\n\t\t\t\t\tinit_value = connection_point.init_value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (lodash_isArray(connection_point.init_value) && lodash_isNumber(init_value)) {\n\t\t\t\tconst array = new Array(connection_point.init_value.length) as Number2;\n\t\t\t\tfor (let i = 0; i < array.length; i++) {\n\t\t\t\t\tarray[i] = init_value;\n\t\t\t\t}\n\t\t\t\tinit_value = array;\n\t\t\t}\n\n\t\t\tif (init_value != null) {\n\t\t\t\tparams_update_options.to_add = params_update_options.to_add || [];\n\t\t\t\tparams_update_options.to_add.push({\n\t\t\t\t\tname: param_name,\n\t\t\t\t\ttype: param_type,\n\t\t\t\t\tinit_value: lodash_clone(init_value as any),\n\t\t\t\t\toptions: {\n\t\t\t\t\t\tspare: true,\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\tif (!this.node.scene.loading_controller.is_loading) {\n\t\t\tthis.node.params.update_params(params_update_options);\n\n\t\t\tfor (let spare_param of this.node.params.spare) {\n\t\t\t\tif (!spare_param.parent_param) {\n\t\t\t\t\tconst raw_input = raw_input_serialized_by_param_name.get(spare_param.name);\n\t\t\t\t\tif (raw_input) {\n\t\t\t\t\t\tspare_param.set(raw_input as any);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n","import {TypedNode} from '../_Base';\nimport {ThreeToGl} from '../../../core/ThreeToGl';\nimport {BaseGlShaderAssembler} from './code/assemblers/_Base';\nimport {AssemblerControllerNode} from './code/Controller';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {ParamConfigsController} from '../utils/code/controllers/ParamConfigsController';\nimport {ShadersCollectionController} from './code/utils/ShadersCollectionController';\nimport {ParamInitValueSerialized} from '../../params/types/ParamInitValueSerialized';\nimport {GlNodeSpareParamsController} from './utils/SpareParamsController';\nimport {GlConnectionsController} from './utils/ConnectionsController';\n\nexport class TypedGlNode<K extends NodeParamsConfig> extends TypedNode<'GL', BaseGlNodeType, K> {\n\tstatic node_context(): NodeContext {\n\t\treturn NodeContext.GL;\n\t}\n\tprotected _param_configs_controller: ParamConfigsController | undefined;\n\tprotected _assembler: BaseGlShaderAssembler | undefined;\n\n\treadonly spare_params_controller: GlNodeSpareParamsController = new GlNodeSpareParamsController(this);\n\tpublic readonly gl_connections_controller: GlConnectionsController | undefined;\n\n\tinitialize_base_node() {\n\t\t// this.io.inputs.set_depends_on_inputs(false);\n\t\tthis.io.connections.init_inputs();\n\t\tthis.ui_data.set_layout_horizontal();\n\t\tthis.io.outputs.set_named_output_connection_points([]);\n\n\t\tthis.spare_params_controller.initialize_node();\n\t}\n\tnode_sibbling(name: string): BaseGlNodeType | null {\n\t\treturn super.node_sibbling(name) as BaseGlNodeType | null;\n\t}\n\tcook() {\n\t\tconsole.warn('gl nodes should never cook');\n\t}\n\n\tprotected _set_mat_to_recompile() {\n\t\tthis.material_node?.assembler_controller.set_compilation_required_and_dirty(this);\n\t}\n\tget material_node(): AssemblerControllerNode | undefined {\n\t\tif (this.parent) {\n\t\t\tif (this.parent.type == this.type) {\n\t\t\t\treturn (this.parent as BaseGlNodeType)?.material_node;\n\t\t\t} else {\n\t\t\t\treturn this.parent as AssemblerControllerNode;\n\t\t\t}\n\t\t}\n\t}\n\n\t//\n\t//\n\t// VARIABLES\n\t//\n\t//\n\tgl_var_name(name: string) {\n\t\treturn `v_POLY_${this.name}_${name}`;\n\t}\n\n\tvariable_for_input(name: string): string {\n\t\tconst input_index = this.io.inputs.get_input_index(name);\n\t\tconst connection = this.io.connections.input_connection(input_index);\n\t\tif (connection) {\n\t\t\tconst input_node = (<unknown>connection.node_src) as BaseGlNodeType;\n\t\t\tconst output_connection_point =\n\t\t\t\tinput_node.io.outputs.named_output_connection_points[connection.output_index];\n\t\t\tif (output_connection_point) {\n\t\t\t\tconst output_name = output_connection_point.name;\n\t\t\t\treturn input_node.gl_var_name(output_name);\n\t\t\t} else {\n\t\t\t\tconsole.warn(`no output called '${name}' for gl node ${input_node.full_path()}`);\n\t\t\t\tthrow 'variable_for_input ERROR';\n\t\t\t}\n\t\t} else {\n\t\t\treturn ThreeToGl.any(this.params.get(name)?.value);\n\t\t}\n\t}\n\n\t//\n\t//\n\t// ADDED LINES\n\t//\n\t//\n\tset_lines(shaders_collection_controller: ShadersCollectionController) {}\n\n\treset_code() {\n\t\tthis._param_configs_controller?.reset();\n\t\t// this.reset_lines();\n\t}\n\n\t//\n\t//\n\t// PARAM CONFIGS\n\t//\n\t//\n\tpublic set_param_configs() {}\n\tparam_configs() {\n\t\treturn this._param_configs_controller?.list;\n\t}\n\t// private reset_param_configs() {\n\t// \tthis._param_configs = [];\n\t// }\n\t// add_param_config<T extends ParamType>(\n\t// \ttype: T,\n\t// \tname: string,\n\t// \tdefault_value: ParamInitValuesTypeMap[T],\n\t// \tuniform_name: string\n\t// ) {\n\t// \tconst param_config = new ParamConfig(type, name, default_value, uniform_name);\n\t// \tthis._param_configs.push(param_config);\n\t// }\n\t// param_configs() {\n\t// \treturn this._param_configs;\n\t// }\n\t//\n\t//\n\t// INPUT\n\t//\n\t//\n\tgl_input_default_value(name: string): ParamInitValueSerialized {\n\t\treturn null;\n\t}\n\n\t//\n\t//\n\t// MISC\n\t//\n\t//\n\n\t//\n\t//\n\t// NEEDED?\n\t//\n\t//\n\t// set_assembler(assembler: BaseGlShaderAssembler) {\n\t// \tthis._assembler = assembler;\n\t// }\n\t// get assembler(): BaseGlShaderAssembler | undefined {\n\t// \treturn this._assembler;\n\t// }\n\n\t// shader_configs() {\n\t// \treturn this.assembler?.shader_configs || [];\n\t// }\n\t// shader_config(name: string) {\n\t// \treturn this.assembler?.shader_config(name);\n\t// }\n\t// shader_names() {\n\t// \treturn this.assembler?.shader_names || [];\n\t// }\n}\n\nexport type BaseGlNodeType = TypedGlNode<NodeParamsConfig>;\nexport class BaseGlNodeClass extends TypedGlNode<NodeParamsConfig> {}\n\nclass ParamlessParamsConfig extends NodeParamsConfig {}\nconst ParamsConfig = new ParamlessParamsConfig();\nexport class ParamlessTypedGlNode extends TypedGlNode<ParamlessParamsConfig> {\n\tparams_config = ParamsConfig;\n}\n","import {BaseNodeType} from '../../_Base';\n\ntype FlagHookCallback = () => void;\n\nexport class BaseFlag {\n\t// protected _available_states: [boolean, boolean] = [];\n\tprotected _state: boolean = true;\n\tprotected _hooks: FlagHookCallback[] | null = null;\n\tconstructor(protected node: BaseNodeType) {}\n\n\t// set_available_states(states: T[]) {}\n\tadd_hook(hook: FlagHookCallback) {\n\t\tthis._hooks = this._hooks || [];\n\t\tthis._hooks.push(hook);\n\t}\n\tprotected on_update() {}\n\tset(new_state: boolean) {\n\t\tif (this._state != new_state) {\n\t\t\tthis._state = new_state;\n\t\t\tthis.on_update();\n\t\t\tthis.run_hooks();\n\t\t}\n\t}\n\tget active() {\n\t\treturn this._state;\n\t}\n\ttoggle() {\n\t\tthis.set(!this._state);\n\t}\n\trun_hooks() {\n\t\tif (this._hooks) {\n\t\t\tfor (let hook of this._hooks) {\n\t\t\t\thook();\n\t\t\t}\n\t\t}\n\t}\n}\n","import {BaseFlag} from './Base';\nimport {NodeEvent} from '../../../poly/NodeEvent';\n\n// export interface BypassOptions {\n// \thas_bypass_flag?: boolean;\n// }\n\nexport class BypassFlag extends BaseFlag {\n\tprotected _state: boolean = false;\n\ton_update() {\n\t\tthis.node.emit(NodeEvent.FLAG_BYPASS_UPDATED);\n\t\tthis.node.set_dirty();\n\t}\n}\n\n// export function Bypass<TBase extends Constructor>(Base: TBase) {\n// \treturn class Mixin extends Base {\n// \t\tprotected self: BaseNode = (<unknown>this) as BaseNode;\n// \t\t_has_bypass_flag: boolean = true;\n// \t\t_bypass_flag: boolean = false;\n\n// \t\t_init_bypass_flag(options: BypassOptions = {}) {\n// \t\t\tif (options['has_bypass_flag'] == null) {\n// \t\t\t\toptions['has_bypass_flag'] = true;\n// \t\t\t}\n\n// \t\t\tthis._has_bypass_flag = options['has_bypass_flag'];\n// \t\t\tthis._bypass_flag = false;\n// \t\t}\n\n// \t\thas_bypass_flag(): boolean {\n// \t\t\treturn this._has_bypass_flag;\n// \t\t}\n\n// \t\tis_bypassed(): boolean {\n// \t\t\treturn this._bypass_flag;\n// \t\t}\n\n// \t\tset_bypass_flag(state: boolean) {\n// \t\t\tif (state == null) {\n// \t\t\t\tstate = true;\n// \t\t\t}\n// \t\t\tif (state !== this._bypass_flag) {\n// \t\t\t\tthis._bypass_flag = state;\n// \t\t\t\tthis.self.emit('bypass_flag_update');\n// \t\t\t\tthis.self.set_dirty();\n// \t\t\t\t// this.post_set_bypass_flag()\n// \t\t\t}\n// \t\t}\n\n// \t\t// post_process_container_request_as_bypassed(input_node: BaseNode){}\n// \t\t// post_set_bypass_flag(){}\n\n// \t\ttoggle_bypass_flag() {\n// \t\t\tthis.set_bypass_flag(!this.is_bypassed());\n// \t\t}\n// \t};\n// }\n","import {BaseFlag} from './Base';\nimport {NodeEvent} from '../../../poly/NodeEvent';\n\nexport class DisplayFlag extends BaseFlag {\n\ton_update() {\n\t\tthis.node.emit(NodeEvent.FLAG_DISPLAY_UPDATED);\n\t\t// this.node.set_dirty();\n\t}\n}\n","import {BaseNodeType} from '../_Base';\n\nimport {BypassFlag} from './flags/Bypass';\nimport {DisplayFlag} from './flags/Display';\n\nexport class FlagsController {\n\tpublic readonly bypass: DisplayFlag | undefined;\n\tpublic readonly display: BypassFlag | undefined;\n\tconstructor(protected node: BaseNodeType) {}\n\thas_display(): boolean {\n\t\treturn false;\n\t}\n\thas_bypass(): boolean {\n\t\treturn false;\n\t}\n}\n\nfunction Display<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\tprotected node!: BaseNodeType;\n\t\tpublic display: DisplayFlag = new DisplayFlag(this.node);\n\t\thas_display(): boolean {\n\t\t\treturn true;\n\t\t}\n\t};\n}\nfunction Bypass<TBase extends Constructor>(Base: TBase) {\n\treturn class Mixin extends Base {\n\t\tprotected node!: BaseNodeType;\n\t\tpublic readonly bypass: BypassFlag = new BypassFlag(this.node);\n\t\thas_bypass(): boolean {\n\t\t\treturn true;\n\t\t}\n\t};\n}\n\nexport class FlagsControllerD extends Display(FlagsController) {}\nexport class FlagsControllerB extends Bypass(FlagsController) {}\nexport class FlagsControllerDB extends Bypass(Display(FlagsController)) {}\n","import {TypedContainer} from './_Base';\nimport {ContainableMap} from './utils/ContainableMap';\n\nexport class TextureContainer extends TypedContainer<ContainableMap['TEXTURE']> {\n\t// _content: Texture;\n\tset_content(content: ContainableMap['TEXTURE']) {\n\t\tsuper.set_content(content);\n\t}\n\n\t// set_texture(texture: Texture){\n\t// \tif (this._content != null) {\n\t// \t\tthis._content.dispose();\n\t// \t}\n\t// \tthis.set_content(texture);\n\t// }\n\ttexture(): ContainableMap['TEXTURE'] {\n\t\treturn this._content;\n\t}\n\tcore_content(): ContainableMap['TEXTURE'] {\n\t\treturn this._content;\n\t}\n\tcore_content_cloned(): ContainableMap['TEXTURE'] | undefined {\n\t\tconsole.log('clone', this._content);\n\t\tconst texture = this._content?.clone();\n\t\tif (texture) {\n\t\t\ttexture.needsUpdate = true;\n\t\t}\n\t\treturn texture;\n\t}\n\n\tobject() {\n\t\treturn this.texture();\n\t}\n\n\tinfos() {\n\t\tif (this._content != null) {\n\t\t\treturn [this._content];\n\t\t}\n\t}\n\tresolution(): [number, number] {\n\t\tif (this._content) {\n\t\t\tif (this._content.image) {\n\t\t\t\treturn [this._content.image.width, this._content.image.height];\n\t\t\t}\n\t\t}\n\t\treturn [-1, -1];\n\t}\n}\n","import {TypedNode} from '../_Base';\nimport {TextureContainer} from '../../containers/Texture';\nimport {Texture} from 'three/src/textures/Texture';\nimport {TypedContainerController} from '../utils/ContainerController';\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {NodeContext} from '../../poly/NodeContext';\nimport {PolyScene} from '../../scene/PolyScene';\nimport {FlagsControllerB} from '../utils/FlagsController';\nimport {DataTexture} from 'three/src/textures/DataTexture';\nimport {LuminanceFormat, HalfFloatType} from 'three/src/constants';\n\nconst INPUT_COP_NAME = 'input texture';\nconst DEFAULT_INPUT_NAMES = [INPUT_COP_NAME, INPUT_COP_NAME, INPUT_COP_NAME, INPUT_COP_NAME];\n\nvar size = 32;\nvar data = new Uint16Array(size);\nfor (var i = 0; i < size; i++) {\n\tdata[i] = 0x70e2; // Half float 10000\n}\nconst EMPTY_DATA_TEXTURE = new DataTexture(data, size, 1, LuminanceFormat, HalfFloatType);\n\nexport class TypedCopNode<K extends NodeParamsConfig> extends TypedNode<'TEXTURE', BaseCopNodeType, K> {\n\tcontainer_controller: TypedContainerController<TextureContainer> = new TypedContainerController<TextureContainer>(\n\t\tthis,\n\t\tTextureContainer\n\t);\n\tpublic readonly flags: FlagsControllerB = new FlagsControllerB(this);\n\t// private _typed_array = new Uint8ClampedArray(512 * 512 * 4);\n\t// protected _texture: Texture = new DataTexture(this._typed_array, 512, 512, RGBFormat);\n\t// get texture() {\n\t// \treturn this._data_texture;\n\t// }\n\n\tstatic node_context(): NodeContext {\n\t\treturn NodeContext.COP;\n\t}\n\tstatic displayed_input_names(): string[] {\n\t\treturn DEFAULT_INPUT_NAMES;\n\t}\n\n\tconstructor(scene: PolyScene) {\n\t\tsuper(scene, 'BaseCopNode');\n\t}\n\n\tinitialize_base_node() {\n\t\t// this.flags.add_bypass();\n\n\t\t// this.flags.add_display();\n\t\t// if (this.flags.display) {\n\t\t// \tthis.flags.display.set(false);\n\t\t// }\n\t\tthis.io.outputs.set_has_one_output();\n\t\t// this.container_controller.init(CONTAINER_CLASS);\n\t}\n\tnode_sibbling(name: string): BaseCopNodeType | null {\n\t\treturn super.node_sibbling(name) as BaseCopNodeType | null;\n\t}\n\n\tset_texture(texture: Texture) {\n\t\t// this._copy_texture(texture);\n\t\ttexture.name = this.full_path();\n\t\tthis.set_container(texture);\n\t}\n\tclear_texture() {\n\t\tthis.set_container(EMPTY_DATA_TEXTURE);\n\t}\n\n\t// private _copy_texture(texture: Texture) {\n\t// \tconsole.log('_copy_texture', texture);\n\t// \tif (texture instanceof DataTexture) {\n\t// \t\tthis._data_texture.image = texture.image;\n\t// \t} else {\n\t// \t\tconst canvas = document.createElement('canvas');\n\t// \t\t// document.body.appendChild(canvas);\n\t// \t\tconst width = texture.image.width;\n\t// \t\tconst height = texture.image.height;\n\t// \t\tcanvas.width = width;\n\t// \t\tcanvas.height = height;\n\t// \t\tconst context = canvas.getContext('2d') as CanvasRenderingContext2D;\n\t// \t\tcontext.drawImage(texture.image, 0, 0);\n\t// \t\tconst image_data = context.getImageData(0, 0, width, height);\n\t// \t\tconsole.log(this._typed_array.length, image_data.data.length, image_data);\n\t// \t\tthis._data_texture.image = image_data;\n\t// \t}\n\t// \tthis._data_texture.format = texture.format;\n\t// \t// this._data_texture.mapping = texture.mapping;\n\t// \t// this._data_texture.wrapS = texture.wrapS;\n\t// \t// this._data_texture.wrapT = texture.wrapT;\n\t// \t// this._data_texture.minFilter = texture.minFilter;\n\t// \t// this._data_texture.magFilter = texture.magFilter;\n\t// \tthis._data_texture.needsUpdate = true;\n\t// \tconsole.log('updated data tex', this._data_texture);\n\n\t// \t// if (!this._texture || this._texture.uuid != texture.uuid) {\n\t// \t// \tif (!this._texture) {\n\t// \t// \t\tconsole.log('assign');\n\t// \t// \t\tthis._texture = texture.clone();\n\t// \t// \t\t// this._texture.name = this.full_path();\n\t// \t// \t} else {\n\t// \t// \t\tconsole.log('copy');\n\t// \t// \t\tconst keys = Object.keys(texture) as Array<keyof Texture>;\n\t// \t// \t\tconst protected_keys = ['uuid', 'name', 'node'];\n\t// \t// \t\tfor (let key of keys) {\n\t// \t// \t\t\tif (!protected_keys.includes(key)) {\n\t// \t// \t\t\t\tthis._texture[key] = texture[key] as never; // but why is 'never' needed?!\n\t// \t// \t\t\t}\n\t// \t// \t\t}\n\t// \t// \t}\n\t// \t// }\n\t// }\n}\n\nexport type BaseCopNodeType = TypedCopNode<any>;\nexport class BaseCopNodeClass extends TypedCopNode<any> {}\n","import {ConnectionPointType} from '../../utils/connections/ConnectionPointType';\nimport {BaseGlNodeType} from '../_Base';\nimport {CoreGraphNode} from '../../../../core/graph/CoreGraphNode';\nimport {TypedNamedConnectionPoint} from '../../utils/connections/NamedConnectionPoint';\nimport {NodeConnection} from '../../utils/connections/NodeConnection';\n\ntype IONameFunction = (index: number) => string;\ntype ExpectedConnectionTypesFunction = () => ConnectionPointType[];\n\nexport class GlConnectionsController {\n\tprivate _input_name_function: IONameFunction = (index: number) => {\n\t\treturn `in${index}`;\n\t};\n\tprivate _output_name_function: IONameFunction = (index: number) => {\n\t\treturn index == 0 ? 'val' : `val${index}`;\n\t};\n\t// private _default_input_type: ConnectionPointType = ConnectionPointType.FLOAT;\n\tprivate _expected_input_types_function: ExpectedConnectionTypesFunction = () => {\n\t\tconst type = this.first_input_connection_type() || ConnectionPointType.FLOAT;\n\t\treturn [type, type];\n\t};\n\tprivate _expected_output_types_function: ExpectedConnectionTypesFunction = () => {\n\t\treturn [this._expected_input_types_function()[0]];\n\t};\n\n\tconstructor(private node: BaseGlNodeType) {}\n\n\tset_input_name_function(func: IONameFunction) {\n\t\tthis._input_name_function = func;\n\t}\n\tset_output_name_function(func: IONameFunction) {\n\t\tthis._output_name_function = func;\n\t}\n\t// set_default_input_type(type: ConnectionPointType) {\n\t// \tthis._default_input_type = type;\n\t// }\n\tset_expected_input_types_function(func: ExpectedConnectionTypesFunction) {\n\t\tthis._expected_input_types_function = func;\n\t}\n\tset_expected_output_types_function(func: ExpectedConnectionTypesFunction) {\n\t\tthis._expected_output_types_function = func;\n\t}\n\n\toutput_name(index: number) {\n\t\treturn this._output_name_function(index);\n\t}\n\n\tprivate _update_signature_if_required_bound = this.update_signature_if_required.bind(this);\n\tprivate _initialized: boolean = false;\n\tinitialize_node() {\n\t\tif (this._initialized) {\n\t\t\tconsole.warn('already initialized', this.node);\n\t\t\treturn;\n\t\t}\n\t\tthis._initialized = true;\n\n\t\tthis.node.io.inputs.add_on_set_input_hook(\n\t\t\t'_update_signature_if_required',\n\t\t\tthis._update_signature_if_required_bound\n\t\t);\n\t\tthis.node.params.add_on_scene_load_hook(\n\t\t\t'_update_signature_if_required',\n\t\t\tthis._update_signature_if_required_bound\n\t\t);\n\t\tthis.node.params.set_post_create_params_hook(this._update_signature_if_required_bound);\n\t\tthis.node.add_post_dirty_hook('_update_signature_if_required', this._update_signature_if_required_bound);\n\t}\n\n\tupdate_signature_if_required(dirty_trigger?: CoreGraphNode) {\n\t\tif (!this.node.lifecycle.creation_completed || !this._connections_match_inputs()) {\n\t\t\tthis.update_connection_types();\n\t\t\tthis.node.remove_dirty_state();\n\t\t\tthis.make_successors_update_signatures();\n\t\t}\n\t}\n\t// used when a node changes its signature, adn the output nodes need to adapt their own signatures\n\tprivate make_successors_update_signatures() {\n\t\tfor (let successor of this.node.graph_all_successors()) {\n\t\t\tconst gl_node = successor as BaseGlNodeType;\n\t\t\tif (gl_node.gl_connections_controller) {\n\t\t\t\tgl_node.gl_connections_controller.update_signature_if_required(this.node);\n\t\t\t}\n\t\t}\n\t\t// this.node.io.connections\n\t\t// \t.output_connections()\n\t\t// \t.map((c) => c.node_dest)\n\t\t// \t.forEach((o) => {\n\t\t// \t\to.set_dirty(this.node);\n\t\t// \t});\n\t}\n\n\tupdate_connection_types() {\n\t\tconst set_dirty = false;\n\t\tconst expected_input_types = this._expected_input_types_function();\n\t\tconst expected_output_types = this._expected_output_types_function();\n\n\t\tconst named_input_connections = expected_input_types.map((type: ConnectionPointType, i: number) => {\n\t\t\treturn new TypedNamedConnectionPoint(this._input_name_function(i), type);\n\t\t});\n\t\tconst named_outputs = expected_output_types.map((type: ConnectionPointType, i: number) => {\n\t\t\treturn new TypedNamedConnectionPoint(this._output_name_function(i), type);\n\t\t});\n\n\t\tthis.node.io.inputs.set_named_input_connection_points(named_input_connections);\n\t\tthis.node.io.outputs.set_named_output_connection_points(named_outputs, set_dirty);\n\t\tthis.node.spare_params_controller.create_spare_parameters();\n\t}\n\n\tprotected _connections_match_inputs(): boolean {\n\t\tconst current_input_types = this.node.io.inputs.named_input_connection_points.map((c) => c.type);\n\t\tconst current_output_types = this.node.io.outputs.named_output_connection_points.map((c) => c.type);\n\t\tconst expected_input_types = this._expected_input_types_function();\n\t\tconst expected_output_types = this._expected_output_types_function();\n\n\t\tif (expected_input_types.length != current_input_types.length) {\n\t\t\treturn false;\n\t\t}\n\t\tif (expected_output_types.length != current_output_types.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (let i = 0; i < current_input_types.length; i++) {\n\t\t\tif (current_input_types[i] != expected_input_types[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tfor (let i = 0; i < current_output_types.length; i++) {\n\t\t\tif (current_output_types[i] != expected_output_types[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t// protected input_connection_type() {\n\t// \treturn this.first_input_connection_type();\n\t// }\n\t// protected output_connection_type() {\n\t// \treturn this.first_input_connection_type();\n\t// }\n\n\tfirst_input_connection_type(): ConnectionPointType | undefined {\n\t\tconst connections = this.node.io.connections.input_connections();\n\t\tif (connections) {\n\t\t\tconst first_connection = connections[0];\n\t\t\tif (first_connection) {\n\t\t\t\treturn this.connection_type_from_connection(first_connection);\n\t\t\t}\n\t\t}\n\t}\n\tconnection_type_from_connection(connection: NodeConnection): ConnectionPointType {\n\t\tconst node_src = connection.node_src;\n\t\tconst output_index = connection.output_index;\n\t\tconst node_src_output_connection = node_src.io.outputs.named_output_connection_points[output_index];\n\t\treturn node_src_output_connection.type;\n\t}\n}\n","import {VideoTexture} from 'three/src/textures/VideoTexture';\nimport {TextureLoader} from 'three/src/loaders/TextureLoader';\nimport {Texture} from 'three/src/textures/Texture';\n// import {RepeatWrapping} from 'three/src/constants';\n// import {Float32BufferAttribute} from 'three/src/core/BufferAttribute';\n// import lodash_isArray from 'lodash/isArray';\n// import {CoreScriptLoader} from '/Script';\n// import {CoreGeometry} from '../geometry/Geometry';\nimport {UnsignedByteType} from 'three/src/constants';\nimport {CoreWalker} from '../Walker';\n\nimport {BaseNodeType} from '../../engine/nodes/_Base';\nimport {BaseParamType} from '../../engine/params/_Base';\nimport {BaseCopNodeClass} from '../../engine/nodes/cop/_Base';\nimport {TextureContainer} from '../../engine/containers/Texture';\nimport {Poly} from '../../engine/Poly';\n// import {BufferGeometry} from 'three/src/core/BufferGeometry';\n\ninterface VideoSourceTypeByExt {\n\togg: string;\n\togv: string;\n\tmp4: string;\n}\n// interface ImageScriptUrlByExt {\n// \texr: string;\n// \tbasis: string;\n// }\ninterface ThreeLoaderByExt {\n\texr: string;\n\tbasis: string;\n\thdr: string;\n}\n\nenum Extension {\n\tEXR = 'exr',\n\tBASIS = 'basis',\n\tHDR = 'hdr',\n}\n\nexport class CoreTextureLoader {\n\tstatic PARAM_DEFAULT = '/examples/textures/uv.jpg';\n\tstatic PARAM_ENV_DEFAULT = '/examples/textures/piz_compressed.exr';\n\n\tstatic VIDEO_EXTENSIONS = ['mp4', 'webm', 'ogv'];\n\tstatic VIDEO_SOURCE_TYPE_BY_EXT: VideoSourceTypeByExt = {\n\t\togg: 'video/ogg; codecs=\"theora, vorbis\"',\n\t\togv: 'video/ogg; codecs=\"theora, vorbis\"',\n\t\tmp4: 'video/mp4; codecs=\"avc1.42E01E, mp4a.40.2\"',\n\t};\n\t// static SCRIPT_URL_BY_EXT: ImageScriptUrlByExt = {\n\t// \texr: 'EXRLoader',\n\t// \tbasis: 'BasisTextureLoader',\n\t// };\n\t// static THREE_LOADER_BY_EXT: ThreeLoaderByExt = {\n\t// \texr: 'EXRLoader',\n\t// \tbasis: 'BasisTextureLoader',\n\t// };\n\t// @load_texture: (url, callback)->\n\t// \tif url\n\t// \t\tloader = this._texture_loader(url)\n\n\t// \t\tloader.load(\n\t// \t\t\turl,\n\t// \t\t\tcallback,\n\t// \t\t\tnull,\n\t// \t\t\t(error)=>\n\t// \t\t\t\tthis.set_error(\"could not load texture #{url}\")\n\t// \t\t\t\t#this._on_error(error)\n\t// \t\t\t)\n\t// \telse\n\t// \t\tthis.set_error(\"not url given to Mat/Base._load_texture\")\n\t// _on_error: (error)->\n\t// \tconsole.log(\"ERROR\")\n\t// \tconsole.log(error)\n\t// \tthis.set_error_message()\n\n\tconstructor(private _node: BaseNodeType, private _param: BaseParamType) {}\n\n\tasync load_texture_from_url_or_op(url: string): Promise<Texture | VideoTexture | null> {\n\t\tlet texture: Texture | null = null;\n\t\tlet found_node;\n\n\t\tif (url.substring(0, 3) == 'op:') {\n\t\t\tconst node_path = url.substring(3);\n\t\t\tfound_node = CoreWalker.find_node(this._node, node_path);\n\t\t\tif (found_node) {\n\t\t\t\tif (found_node instanceof BaseCopNodeClass) {\n\t\t\t\t\tconst container: TextureContainer = await found_node.request_container();\n\t\t\t\t\ttexture = container.texture();\n\t\t\t\t} else {\n\t\t\t\t\tthis._node.states.error.set(`found node is not a texture node`);\n\t\t\t\t}\n\n\t\t\t\t// this._assign_texture(attrib, texture)\n\t\t\t} else {\n\t\t\t\tthis._node.states.error.set(`no node found in path '${node_path}'`);\n\t\t\t}\n\t\t} else {\n\t\t\ttexture = await this.load_url(url);\n\t\t\tif (texture) {\n\t\t\t\t// param.mark_as_referencing_asset(url)\n\t\t\t\tif (this._param.options.texture_as_env()) {\n\t\t\t\t\t// texture = await CoreTextureLoader.set_texture_for_env(texture, this._node);\n\t\t\t\t} else {\n\t\t\t\t\ttexture = CoreTextureLoader.set_texture_for_mapping(texture);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._node.states.error.set(`could not load texture ${url}`);\n\t\t\t}\n\t\t}\n\n\t\t// NOTE: if this._param gets its value from an expression like `ch('/CONTROL/photo_url')`\n\t\t// then found_node will be null, so the graph should not be changed\n\t\tif (found_node && this._param.graph_predecessors()[0] != found_node) {\n\t\t\tthis._param.graph_disconnect_predecessors();\n\t\t\tthis._param.add_graph_input(found_node);\n\t\t}\n\n\t\t// this._assign_texture(attrib, texture)\n\t\treturn texture;\n\t}\n\n\tasync load_url(url: string): Promise<Texture> {\n\t\treturn new Promise(async (resolve, reject) => {\n\t\t\t// url = this._resolve_url(url)\n\t\t\tconst ext = CoreTextureLoader._ext(url);\n\n\t\t\tif (CoreTextureLoader.VIDEO_EXTENSIONS.includes(ext)) {\n\t\t\t\tconst texture: VideoTexture = await this._load_as_video(url);\n\t\t\t\treturn texture;\n\t\t\t} else {\n\t\t\t\tthis.loader_for_ext(ext).then((loader) => {\n\t\t\t\t\tloader.load(url, resolve, undefined, (error: any) => {\n\t\t\t\t\t\tconsole.warn('error', error);\n\t\t\t\t\t\treject();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\n\tasync loader_for_ext(ext: string) {\n\t\tconst ext_lowercase = ext.toLowerCase() as keyof ThreeLoaderByExt;\n\t\t// const script_name = CoreTextureLoader.SCRIPT_URL_BY_EXT[ext_lowercase];\n\t\t// var loader;\n\n\t\tswitch (ext_lowercase) {\n\t\t\tcase Extension.EXR: {\n\t\t\t\tconst {EXRLoader} = await import('../../../modules/three/examples/jsm/loaders/EXRLoader');\n\t\t\t\treturn new EXRLoader();\n\t\t\t}\n\t\t\tcase Extension.HDR: {\n\t\t\t\tconst {RGBELoader} = await import('../../../modules/three/examples/jsm/loaders/RGBELoader');\n\t\t\t\tconst loader = new RGBELoader();\n\t\t\t\tloader.setDataType(UnsignedByteType); // FloatType,HalfFloatType\n\t\t\t\t// loader.setPath('/examples/textures/equirectangular/');\n\t\t\t\treturn loader;\n\t\t\t}\n\t\t\tcase Extension.BASIS: {\n\t\t\t\tconst {BasisTextureLoader} = await import(\n\t\t\t\t\t'../../../modules/three/examples/jsm/loaders/BasisTextureLoader'\n\t\t\t\t);\n\t\t\t\tconst loader = new BasisTextureLoader();\n\t\t\t\tloader.setTranscoderPath('/three/js/libs/basis/');\n\t\t\t\tconst renderer = await Poly.instance().renderers_controller.wait_for_renderer();\n\t\t\t\tif (renderer) {\n\t\t\t\t\tloader.detectSupport(renderer);\n\t\t\t\t} else {\n\t\t\t\t\tconsole.warn('texture loader found no renderer for basis texture loader');\n\t\t\t\t}\n\t\t\t\treturn loader;\n\t\t\t}\n\t\t}\n\n\t\t// if (script_name) {\n\t\t// const imported_classes = await CoreScriptLoader.load_module_three_loader(script_name)\n\t\t// const imported_classes = await CoreScriptLoader.three_module(`loaders/${script_name}`);\n\t\t// const imported_classes = await import(`modules/three/examples/jsm/loaders/${script_name}`);\n\t\t// const loader_class_name = CoreTextureLoader.THREE_LOADER_BY_EXT[ext_lowercase];\n\t\t// const loader_class = imported_classes[loader_class_name];\n\t\t// if (loader_class) {\n\t\t// \tloader = new loader_class();\n\t\t// \tif (ext == 'basis') {\n\t\t// \t\tloader.setTranscoderPath('/three/js/libs/basis/');\n\t\t// \t\tconst renderer = POLY.renderers_controller.first_renderer();\n\t\t// \t\tloader.detectSupport(renderer);\n\t\t// \t}\n\t\t// }\n\t\t// }\n\t\treturn new TextureLoader();\n\n\t\t// const constructor = (() => { switch (ext) {\n\t\t// \tcase 'exr': return EXRLoader;\n\t\t// \tdefault: return TextureLoader;\n\t\t// } })();\n\t\t// return new constructor();\n\t}\n\n\t_load_as_video(url: string): Promise<VideoTexture> {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tconst video = document.createElement('video');\n\t\t\t// document.body.appendChild(video)\n\t\t\t// video.id = 'video'\n\t\t\t// console.log(\"video\", video)\n\t\t\tvideo.setAttribute('crossOrigin', 'anonymous');\n\t\t\tvideo.setAttribute('autoplay', `${true}`); // to ensure it loads\n\t\t\tvideo.setAttribute('loop', `${true}`);\n\n\t\t\t// wait for onloadedmetadata to ensure that we have a duration\n\t\t\tvideo.onloadedmetadata = function () {\n\t\t\t\tvideo.pause();\n\t\t\t\tconst texture = new VideoTexture(video);\n\t\t\t\tresolve(texture);\n\t\t\t};\n\t\t\t// video.setAttribute('controls', true)\n\t\t\t// video.style=\"display:none\"\n\t\t\tconst source = document.createElement('source');\n\t\t\tconst ext = CoreTextureLoader._ext(url) as keyof VideoSourceTypeByExt;\n\t\t\tlet type: string = CoreTextureLoader.VIDEO_SOURCE_TYPE_BY_EXT[ext];\n\t\t\ttype = type || CoreTextureLoader._default_video_source_type(url);\n\t\t\tsource.setAttribute('type', type);\n\t\t\tsource.setAttribute('src', url);\n\n\t\t\tvideo.appendChild(source);\n\t\t});\n\t}\n\tstatic _default_video_source_type(url: string) {\n\t\tconst ext = this._ext(url);\n\t\treturn `video/${ext}`;\n\t}\n\n\tstatic pixel_data(texture: Texture) {\n\t\tconst img = texture.image;\n\t\tconst canvas = document.createElement('canvas');\n\t\tcanvas.width = img.width;\n\t\tcanvas.height = img.height;\n\t\tconst context = canvas.getContext('2d');\n\t\tif (context) {\n\t\t\tcontext.drawImage(img, 0, 0, img.width, img.height);\n\t\t\treturn context.getImageData(0, 0, img.width, img.height);\n\t\t}\n\t}\n\n\t// TODO: typescript: check what type the pixel_data is\n\t// static pixel_data_to_attribute(pixel_data: Pixel, geometry: BufferGeometry, attrib_name_with_component:string, convert_method: (x:number, y:number, z:number, w:number)=>number) {\n\t// \tconst {data} = pixel_data;\n\t// \tconst geometry_wrapper = new CoreGeometry(geometry);\n\t// \t// TODO: add error if no uvs\n\t// \tconst values = [];\n\t// \tconst points = geometry_wrapper.points();\n\t// \tfor (let point of points) {\n\t// \t\tconst uv = point.attrib_value('uv');\n\t// \t\tconst x = Math.floor((pixel_data.width - 1) * uv.x);\n\t// \t\tconst y = Math.floor((pixel_data.height - 1) * (1 - uv.y));\n\t// \t\tconst i = y * pixel_data.width + x;\n\t// \t\t// const val = data[4*i] / 255.0;\n\t// \t\tif (convert_method) {\n\t// \t\t\tconst val = convert_method(data[4 * i + 0], data[4 * i + 1], data[4 * i + 2], data[4 * i + 3]);\n\t// \t\t\tvalues.push(val);\n\t// \t\t} else {\n\t// \t\t\tvalues.push([data[4 * i + 0], data[4 * i + 1], data[4 * i + 2]]);\n\t// \t\t}\n\t// \t}\n\n\t// \tconst attrib_name_elements = attrib_name_with_component.split('.');\n\t// \tlet attrib_name = attrib_name_elements[0];\n\t// \tlet component_offset = null;\n\t// \tif (attrib_name_elements.length > 1) {\n\t// \t\tconst component = attrib_name_elements[1] as keyof Vector4Like\n\t// \t\tcomponent_offset = {x: 0, y: 1, z: 2, w: 3}[component];\n\t// \t}\n\n\t// \tlet attrib = geometry.attributes[attrib_name];\n\t// \tif (attrib) {\n\t// \t\tconst array = attrib.array;\n\t// \t\tlet index = 0;\n\t// \t\tlet is_array = null;\n\t// \t\tfor (let value of values) {\n\t// \t\t\tif (is_array || lodash_isArray(value)) {\n\t// \t\t\t\tis_array = true;\n\t// \t\t\t\tlet component_index = 0;\n\t// \t\t\t\tfor (let value_c of value) {\n\t// \t\t\t\t\tarray[attrib.itemSize * index + component_index] = value_c;\n\t// \t\t\t\t\tcomponent_index++;\n\t// \t\t\t\t}\n\t// \t\t\t} else {\n\t// \t\t\t\tarray[attrib.itemSize * index + component_offset] = value;\n\t// \t\t\t}\n\t// \t\t\tindex++;\n\t// \t\t}\n\t// \t} else {\n\t// \t\tattrib = geometry.setAttribute(attrib_name, new Float32BufferAttribute(values, 1));\n\t// \t}\n\t// \tattrib.needsUpdate = true;\n\t// }\n\n\tstatic _ext(url: string) {\n\t\tconst elements = url.split('.');\n\t\treturn elements[elements.length - 1].toLowerCase();\n\t}\n\t// static private _resolve_url(url: string):string{\n\t// \tif(url[0] == '/'){\n\t// \t\tconst root_url = POLY.env_is_production() ? 'https://polygonjs.com' : 'http://localhost:5000'\n\t// \t\turl = `${root_url}${url}`\n\t// \t}\n\t// \treturn url\n\t// }\n\n\tstatic set_texture_for_mapping(texture: Texture) {\n\t\t// let val = texture['wrapS']\n\t\t// Object.defineProperty(texture, 'wrapS', {\n\t\t// \tget () {\n\t\t// \t\treturn val // Simply return the cached value\n\t\t// \t},\n\t\t// \tset (newVal) {\n\t\t// \t\tval = newVal // Save the newVal\n\t\t// \t\tconsole.warn(\"set\", newVal)\n\t\t// \t}\n\t\t// })\n\n\t\t// texture.wrapS = RepeatWrapping\n\t\t// texture.wrapT = RepeatWrapping\n\t\t// console.log(\"set_texture_for_mapping\", RepeatWrapping, texture, texture.wrapS)\n\t\treturn texture;\n\t}\n\n\t// static async set_texture_for_env(texture: Texture, registerer: BaseNode) {\n\t// \tif (registerer._registered_env_map) {\n\t// \t\tPOLY.renderers_controller.deregister_env_map(registerer._registered_env_map);\n\t// \t}\n\t// \tregisterer._registered_env_map = await POLY.renderers_controller.register_env_map(texture);\n\t// \treturn registerer._registered_env_map;\n\t// }\n}\n","import {VideoTexture} from 'three/src/textures/VideoTexture';\nimport {\n\tUVMapping,\n\tCubeReflectionMapping,\n\tCubeRefractionMapping,\n\tEquirectangularReflectionMapping,\n\tEquirectangularRefractionMapping,\n\tSphericalReflectionMapping,\n\tCubeUVReflectionMapping,\n\tCubeUVRefractionMapping,\n\tClampToEdgeWrapping,\n\tRepeatWrapping,\n\tMirroredRepeatWrapping,\n\tLinearFilter,\n\tNearestFilter,\n\tNearestMipMapNearestFilter,\n\tNearestMipMapLinearFilter,\n\tLinearMipMapNearestFilter,\n\tLinearMipMapLinearFilter,\n\t// UnsignedByteType,\n\t// ByteType,\n\t// ShortType,\n\t// UnsignedShortType,\n\t// IntType,\n\t// UnsignedIntType,\n\t// FloatType,\n\t// HalfFloatType,\n\t// UnsignedShort4444Type,\n\t// UnsignedShort5551Type,\n\t// UnsignedShort565Type,\n\t// UnsignedInt248Type,\n\t// AlphaFormat,\n\t// RGBFormat,\n\t// RGBAFormat,\n\t// LuminanceFormat,\n\t// LuminanceAlphaFormat,\n\t// RGBEFormat,\n\t// DepthFormat,\n\t// DepthStencilFormat,\n\t// LinearEncoding,\n\t// sRGBEncoding,\n\t// GammaEncoding,\n\t// RGBEEncoding,\n\t// LogLuvEncoding,\n\t// RGBM7Encoding,\n\t// RGBM16Encoding,\n\t// RGBDEncoding,\n\t// BasicDepthPacking,\n\t// RGBADepthPacking,\n} from 'three/src/constants';\nimport {Texture} from 'three/src/textures/Texture';\n// const THREE = {\n// \tTexture,\n// \tUVMapping,\n// \tVideoTexture,\n// \tCubeReflectionMapping,\n// \tCubeRefractionMapping,\n// \tEquirectangularReflectionMapping,\n// \tEquirectangularRefractionMapping,\n// \tSphericalReflectionMapping,\n// \tCubeUVReflectionMapping,\n// \tCubeUVRefractionMapping,\n// \tClampToEdgeWrapping,\n// \tRepeatWrapping,\n// \tMirroredRepeatWrapping,\n// \tLinearFilter,\n// \tNearestFilter,\n// \tNearestMipMapNearestFilter,\n// \tNearestMipMapLinearFilter,\n// \tLinearMipMapNearestFilter,\n// \tLinearMipMapLinearFilter,\n// \tUnsignedByteType,\n// \tByteType,\n// \tShortType,\n// \tUnsignedShortType,\n// \tIntType,\n// \tUnsignedIntType,\n// \tFloatType,\n// \tHalfFloatType,\n// \tUnsignedShort4444Type,\n// \tUnsignedShort5551Type,\n// \tUnsignedShort565Type,\n// \tUnsignedInt248Type,\n// \tAlphaFormat,\n// \tRGBFormat,\n// \tRGBAFormat,\n// \tLuminanceFormat,\n// \tLuminanceAlphaFormat,\n// \tRGBEFormat,\n// \tDepthFormat,\n// \tDepthStencilFormat,\n// \tLinearEncoding,\n// \tsRGBEncoding,\n// \tGammaEncoding,\n// \tRGBEEncoding,\n// \tLogLuvEncoding,\n// \tRGBM7Encoding,\n// \tRGBM16Encoding,\n// \tRGBDEncoding,\n// \tBasicDepthPacking,\n// \tRGBADepthPacking,\n// };\n// import lodash_last from 'lodash/last';\n// import NodeBase from '../_Base'\n\nimport {TypedCopNode} from './_Base';\n// import {BaseParam} from '../../../Engine/Param/_Base'\nimport {CoreTextureLoader} from '../../../core/loader/Texture';\nimport {ParamType} from '../../poly/ParamType';\nimport {NodeEvent} from '../../poly/NodeEvent';\n\n// this used to be named file_in, but I can't recall the decision of not calling it simply 'file'\n// so renaming it back to file for now\n\nconst MAPPINGS = [\n\t{UVMapping},\n\t{CubeReflectionMapping},\n\t{CubeRefractionMapping},\n\t{EquirectangularReflectionMapping},\n\t{EquirectangularRefractionMapping},\n\t{SphericalReflectionMapping},\n\t{CubeUVReflectionMapping},\n\t{CubeUVRefractionMapping},\n];\n\nconst WRAPPINGS: Dictionary<number>[] = [{ClampToEdgeWrapping}, {RepeatWrapping}, {MirroredRepeatWrapping}];\n\nconst MAG_FILTERS: Dictionary<number>[] = [{LinearFilter}, {NearestFilter}];\nconst MIN_FILTERS: Dictionary<number>[] = [\n\t{NearestFilter},\n\t{NearestMipMapNearestFilter},\n\t{NearestMipMapLinearFilter},\n\t{LinearFilter},\n\t{LinearMipMapNearestFilter},\n\t{LinearMipMapLinearFilter},\n];\n\n// const TYPES = [\n// \t\"UnsignedByteType\",\n// \t\"ByteType\",\n// \t\"ShortType\",\n// \t\"UnsignedShortType\",\n// \t\"IntType\",\n// \t\"UnsignedIntType\",\n// \t\"FloatType\",\n// \t\"HalfFloatType\",\n// \t\"UnsignedShort4444Type\",\n// \t\"UnsignedShort5551Type\",\n// \t\"UnsignedShort565Type\",\n// \t\"UnsignedInt248Type\"\n// ];\n\n// const FORMATS = [\n// \t\"AlphaFormat\",\n// \t\"RGBFormat\",\n// \t\"RGBAFormat\",\n// \t\"LuminanceFormat\",\n// \t\"LuminanceAlphaFormat\",\n// \t\"RGBEFormat\",\n// \t\"DepthFormat\",\n// \t\"DepthStencilFormat\"\n// ];\n\n// const ENCODINGS = [\n// \t\"LinearEncoding\",\n// \t\"sRGBEncoding\",\n// \t\"GammaEncoding\",\n// \t\"RGBEEncoding\",\n// \t\"LogLuvEncoding\",\n// \t\"RGBM7Encoding\",\n// \t\"RGBM16Encoding\",\n// \t\"RGBDEncoding\",\n// \t\"BasicDepthPacking\",\n// \t\"RGBADepthPacking\"\n// ];\n\ninterface AttribMapping {\n\tmapping: string;\n\twrapS: string;\n\twrapT: string;\n\tminFilter: string;\n\tmagFilter: string;\n}\nconst ATTRIB_MAPPING_KEYS: Array<keyof AttribMapping> = ['mapping', 'wrapS', 'wrapT', 'minFilter', 'magFilter'];\nconst ATTRIB_MAPPING: AttribMapping = {\n\tmapping: 'mapping',\n\twrapS: 'wrap_s',\n\twrapT: 'wrap_t',\n\tminFilter: 'min_filter',\n\tmagFilter: 'mag_filter',\n\t// type: 'type',\n\t// encoding: 'encoding'\n\t// format: 'format',\n};\n\nimport {BaseNodeType} from '../_Base';\nimport {BaseParamType} from '../../params/_Base';\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nclass FileCopParamsConfig extends NodeParamsConfig {\n\t// video_time = ParamConfig.FLOAT(1);\n\turl = ParamConfig.STRING(CoreTextureLoader.PARAM_DEFAULT, {\n\t\tdesktop_browse: {file_type: 'texture'},\n\t});\n\treload = ParamConfig.BUTTON(null, {\n\t\tcallback: (node: BaseNodeType, param: BaseParamType) => {\n\t\t\tFileCopNode.PARAM_CALLBACK_reload(node as FileCopNode, param);\n\t\t},\n\t});\n\tmapping = ParamConfig.INTEGER(UVMapping, {\n\t\tmenu: {\n\t\t\tentries: MAPPINGS.map((m) => {\n\t\t\t\treturn {\n\t\t\t\t\tname: Object.keys(m)[0],\n\t\t\t\t\tvalue: Object.values(m)[0] as number,\n\t\t\t\t};\n\t\t\t}),\n\t\t},\n\t});\n\twrap_s = ParamConfig.INTEGER(Object.values(WRAPPINGS[0])[0], {\n\t\tmenu: {\n\t\t\t// type: 'radio',\n\t\t\tentries: WRAPPINGS.map((m) => {\n\t\t\t\treturn {\n\t\t\t\t\tname: Object.keys(m)[0],\n\t\t\t\t\tvalue: Object.values(m)[0] as number,\n\t\t\t\t};\n\t\t\t}),\n\t\t},\n\t});\n\twrap_t = ParamConfig.INTEGER(Object.values(WRAPPINGS[0])[0], {\n\t\tmenu: {\n\t\t\t// type: 'radio',\n\t\t\tentries: WRAPPINGS.map((m) => {\n\t\t\t\treturn {\n\t\t\t\t\tname: Object.keys(m)[0],\n\t\t\t\t\tvalue: Object.values(m)[0] as number,\n\t\t\t\t};\n\t\t\t}),\n\t\t},\n\t});\n\tmag_filter = ParamConfig.INTEGER(Object.values(MAG_FILTERS[0])[0], {\n\t\tmenu: {\n\t\t\t// type: 'radio',\n\t\t\tentries: MAG_FILTERS.map((m) => {\n\t\t\t\treturn {\n\t\t\t\t\tname: Object.keys(m)[0],\n\t\t\t\t\tvalue: Object.values(m)[0] as number,\n\t\t\t\t};\n\t\t\t}),\n\t\t},\n\t});\n\tmin_filter = ParamConfig.INTEGER(Object.values(MIN_FILTERS[0])[0], {\n\t\tmenu: {\n\t\t\t// type: 'radio',\n\t\t\tentries: MIN_FILTERS.map((m) => {\n\t\t\t\treturn {\n\t\t\t\t\tname: Object.keys(m)[0],\n\t\t\t\t\tvalue: Object.values(m)[0] as number,\n\t\t\t\t};\n\t\t\t}),\n\t\t},\n\t});\n}\n\nconst ParamsConfig = new FileCopParamsConfig();\n\nexport class FileCopNode extends TypedCopNode<FileCopParamsConfig> {\n\tparams_config = ParamsConfig;\n\t// @ParamF('video_time') _param_video_time: number;\n\t// @ParamS('url') _param_url: string;\n\tprivate _previous_param_url: string | undefined;\n\tprivate _video: HTMLVideoElement | undefined;\n\n\tstatic type() {\n\t\treturn 'file';\n\t}\n\n\t// _param_video_time_param: BaseParam\n\tprivate _texture_loader: CoreTextureLoader | undefined;\n\n\tstatic readonly VIDEO_TIME_PARAM_NAME = 'video_time';\n\tstatic readonly DEFAULT_NODE_PATH = {\n\t\tUV: '/COP/file_uv',\n\t\tENV_MAP: '/COP/env_map',\n\t};\n\n\t// initialize_node() {\n\t// \t// this.io.inputs.set_count_to_zero();\n\t// }\n\n\t// create_params() {\n\t// \t// this.add_param(ParamType.STRING, 'url', CoreTextureLoader.PARAM_DEFAULT, {\n\t// \t// \tdesktop_browse: {file_type: 'texture'},\n\t// \t// });\n\t// \t// this.add_param(ParamType.BUTTON, 'reload', null, {\n\t// \t// \tcallback: this._reload.bind(this),\n\t// \t// });\n\t// \t// this.add_param(ParamType.FLOAT, 'video_time', 0, {range: [0, 10]})\n\t// \t// this.add_param(ParamType.INTEGER, 'mapping', UVMapping as number, {\n\t// \t// \tmenu: {\n\t// \t// \t\tentries: MAPPINGS.map((m) => {\n\t// \t// \t\t\treturn {\n\t// \t// \t\t\t\tname: Object.keys(m)[0],\n\t// \t// \t\t\t\tvalue: Object.values(m)[0] as number,\n\t// \t// \t\t\t};\n\t// \t// \t\t}),\n\t// \t// \t},\n\t// \t// });\n\t// \t// for (let wrap_name of ['wrap_s', 'wrap_t']) {\n\t// \t// \tconst wrap = Object.values(WRAPPINGS[0])[0] as number;\n\t// \t// \tthis.add_param(ParamType.INTEGER, wrap_name, wrap, {\n\t// \t// \t\tmenu: {\n\t// \t// \t\t\t// type: 'radio',\n\t// \t// \t\t\tentries: WRAPPINGS.map((m) => {\n\t// \t// \t\t\t\treturn {\n\t// \t// \t\t\t\t\tname: Object.keys(m)[0],\n\t// \t// \t\t\t\t\tvalue: Object.values(m)[0] as number,\n\t// \t// \t\t\t\t};\n\t// \t// \t\t\t}),\n\t// \t// \t\t},\n\t// \t// \t});\n\t// \t// }\n\t// \t// const mag_filter = Object.values(MAG_FILTERS[0])[0] as number;\n\t// \t// this.add_param(ParamType.INTEGER, 'mag_filter', mag_filter, {\n\t// \t// \tmenu: {\n\t// \t// \t\t// type: 'radio',\n\t// \t// \t\tentries: MAG_FILTERS.map((m) => {\n\t// \t// \t\t\treturn {\n\t// \t// \t\t\t\tname: Object.keys(m)[0],\n\t// \t// \t\t\t\tvalue: Object.values(m)[0] as number,\n\t// \t// \t\t\t};\n\t// \t// \t\t}),\n\t// \t// \t},\n\t// \t// });\n\t// \t// const min_filter: number = Object.values(MIN_FILTERS[0])[0] as number;\n\t// \t// this.add_param(ParamType.INTEGER, 'min_filter', min_filter, {\n\t// \t// \tmenu: {\n\t// \t// \t\t// type: 'radio',\n\t// \t// \t\tentries: MIN_FILTERS.map((m) => {\n\t// \t// \t\t\treturn {\n\t// \t// \t\t\t\tname: Object.keys(m)[0],\n\t// \t// \t\t\t\tvalue: Object.values(m)[0] as number,\n\t// \t// \t\t\t};\n\t// \t// \t\t}),\n\t// \t// \t},\n\t// \t// });\n\t// \t// TODO: to be added when I have some level of control\n\t// \t// for now, the type attribute overrides what piz_compressed.exr creates\n\t// \t// which in turns fucks up with the env_map\n\t// \t// advanced\n\t// \t// this.add_param(ParamType.TOGGLE, 'advanced', 0)\n\t// \t// this.add_param(ParamType.INTEGER, 'type', THREE[TYPES[0]], {\n\t// \t// \tmenu: { type: 'radio', entries: TYPES.map(m=>{ return { name: m, value: THREE[m] } })},\n\t// \t// \tvisible_if: {advanced: 1}\n\t// \t// })\n\t// \t// this.add_param(ParamType.INTEGER, 'format', THREE[FORMATS[0]], {\n\t// \t// \tmenu: { type: 'radio', entries: FORMATS.map(m=>{ return { name: m, value: THREE[m] } })},\n\t// \t// \tvisible_if: {advanced: 1}\n\t// \t// })\n\t// \t// this.add_param(ParamType.INTEGER, 'encoding', THREE[ENCODINGS[0]], {\n\t// \t// \tmenu: { type: 'radio', entries: ENCODINGS.map(m=>{ return { name: m, value: THREE[m] } })},\n\t// \t// \tvisible_if: {advanced: 1}\n\t// \t// })\n\t// }\n\n\tasync cook() {\n\t\tif (this._is_static_image_url(this.pv.url)) {\n\t\t\tawait this.cook_for_image();\n\t\t} else {\n\t\t\tawait this.cook_for_video();\n\t\t}\n\t}\n\n\tprivate _is_static_image_url(url: string) {\n\t\treturn true;\n\t}\n\n\tprivate async cook_for_image() {\n\t\tconst texture = await this._load_texture(this.pv.url);\n\n\t\tif (texture) {\n\t\t\tthis._update_texture_params(texture);\n\t\t\tthis.set_texture(texture);\n\t\t} else {\n\t\t\tthis.clear_texture();\n\t\t}\n\t}\n\n\tprivate async cook_for_video() {\n\t\tif (this._param_url_changed()) {\n\t\t\tconst texture = await this._load_texture(this.pv.url);\n\t\t\t// if (texture) {\n\t\t\t// \tthis._texture = texture;\n\t\t\t// }\n\n\t\t\tif (texture) {\n\t\t\t\tthis._add_video_spare_params_if_required(texture);\n\t\t\t}\n\t\t\tthis._previous_param_url = this.pv.url;\n\n\t\t\tthis._set_video_current_time();\n\n\t\t\tif (texture) {\n\t\t\t\tthis._update_texture_params(texture);\n\t\t\t\tthis.set_texture(texture);\n\t\t\t} else {\n\t\t\t\tthis.cook_controller.end_cook();\n\t\t\t}\n\t\t} else {\n\t\t\t// this._set_video_current_time();\n\t\t\t// this._update_texture_params();\n\t\t\t// if (texture?.needsUpdate) {\n\t\t\t// \tthis.set_texture(texture);\n\t\t\t// } else {\n\t\t\t// \tthis.cook_controller.end_cook();\n\t\t\t// }\n\t\t}\n\t}\n\n\tresolved_url() {\n\t\treturn this.pv.url;\n\t}\n\n\tprivate _update_texture_params(texture: Texture) {\n\t\t// const keys = Object.keys(ATTRIB_MAPPING) as keyof AttribMapping\n\t\tfor (let texture_attrib of ATTRIB_MAPPING_KEYS) {\n\t\t\tconst param_name = ATTRIB_MAPPING[texture_attrib];\n\t\t\tconst param_value = this.params.float(param_name);\n\t\t\t// const texture_attrib = ATTRIB_MAPPING[attrib];\n\n\t\t\tif (param_value != null && texture) {\n\t\t\t\tif (texture[texture_attrib] != param_value) {\n\t\t\t\t\ttexture[texture_attrib] = param_value;\n\t\t\t\t\ttexture.needsUpdate = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstatic PARAM_CALLBACK_reload(node: FileCopNode, param: BaseParamType) {\n\t\tnode.param_callback_reload();\n\t}\n\tprivate param_callback_reload() {\n\t\tthis._previous_param_url = undefined;\n\n\t\t// set the param dirty is preferable, in case this is used to refresh a local asset\n\t\tthis.p.url.set_successors_dirty();\n\t\t// this.set_dirty()\n\t}\n\n\tprivate _set_video_current_time() {\n\t\tif (this._video) {\n\t\t\tif (this.params.has('video_time')) {\n\t\t\t\tthis._video.currentTime = this.params.float('video_time');\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate _add_video_spare_params_if_required(texture: Texture | VideoTexture | null) {\n\t\tif (texture) {\n\t\t\tconst is_video = texture.constructor == VideoTexture;\n\t\t\tif (is_video) {\n\t\t\t\tthis._video = texture.image;\n\t\t\t\tif (this._video) {\n\t\t\t\t\tif (!this.params.has_param(FileCopNode.VIDEO_TIME_PARAM_NAME)) {\n\t\t\t\t\t\tconst duration = this._video.duration;\n\n\t\t\t\t\t\tthis.add_param(ParamType.FLOAT, FileCopNode.VIDEO_TIME_PARAM_NAME, '$T', {\n\t\t\t\t\t\t\tspare: true,\n\t\t\t\t\t\t\tcook: true,\n\t\t\t\t\t\t\trange: [0, duration],\n\t\t\t\t\t\t\trange_locked: [true, true],\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tthis.emit(NodeEvent.PARAMS_UPDATED);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._remove_spare_params();\n\t\t\t}\n\t\t} else {\n\t\t\tthis._remove_spare_params();\n\t\t}\n\t}\n\n\tprivate _remove_spare_params() {\n\t\tif (this.params.has_param(FileCopNode.VIDEO_TIME_PARAM_NAME)) {\n\t\t\tthis.params.update_params({names_to_delete: [FileCopNode.VIDEO_TIME_PARAM_NAME]});\n\t\t\t// this.emit(NodeEvent.PARAMS_UPDATED);\n\t\t}\n\t}\n\n\tprivate _param_url_changed(): boolean {\n\t\treturn this._previous_param_url != this.pv.url;\n\t}\n\n\tprivate async _load_texture(url: string) {\n\t\tlet texture: Texture | VideoTexture | null = null;\n\t\tconst param = this.params.get('url');\n\t\tif (url && param) {\n\t\t\tthis._texture_loader = this._texture_loader || new CoreTextureLoader(this, param);\n\t\t\t// const ext = lodash_last(url.split('.')).toLowerCase()\n\t\t\ttry {\n\t\t\t\ttexture = await this._texture_loader.load_texture_from_url_or_op(url);\n\t\t\t} catch (e) {\n\t\t\t\t//console.log('FAIL');\n\t\t\t}\n\t\t\t// if(texture){\n\t\t\t// \tcallback(texture)\n\t\t\t// } else {\n\t\t\tif (!texture) {\n\t\t\t\tthis.states.error.set(`could not load texture '${url}'`);\n\t\t\t}\n\t\t\t// }).catch(error=>{\n\t\t\t// \tthis.self.set_error(`could not load texture ${url} (${error})`);\n\t\t\t// })\n\t\t} else {\n\t\t\tthis.states.error.set('not url given to Mat/Base._load_texture');\n\t\t}\n\t\treturn texture;\n\t}\n}\n","export const CATEGORY_OBJ = {\n\tLIGHT: 'lights',\n\tMANAGER: 'managers',\n\tGEOMETRY: 'geometries',\n\tCAMERA: 'cameras',\n\tMISC: 'misc',\n};\nexport const CATEGORY_COP = {\n\tINPUT: 'inputs',\n\tADVANCED: 'advanced',\n\tMISC: 'misc',\n};\nexport const CATEGORY_EVENT = {\n\tCAMERA: 'cameras',\n\tMISC: 'misc',\n};\nexport const CATEGORY_GL = {\n\tCOLOR: 'color',\n\tCONVERSION: 'conversion',\n\tDYNAMICS: 'dynamics',\n\tGEOMETRY: 'geometry',\n\tGLOBALS: 'globals',\n\tLOGIC: 'logic',\n\tMATH: 'math',\n\tQUAT: 'quat',\n\tTRIGO: 'trigo',\n\tUTIL: 'util',\n\tINSTANCE: 'instance',\n};\nexport const CATEGORY_MAT = {\n\tADVANCED: 'advanced',\n\tMESH: 'meshes',\n\tPOINTS: 'points',\n\tLINE: 'lines',\n\tVOLUME: 'volumes',\n\tINSTANCE: 'instances',\n};\nexport const CATEGORY_SOP = {\n\tADVANCED: 'advanced',\n\tANIMATION: 'animation',\n\tATTRIBUTE: 'attributes',\n\tDYNAMICS: 'dynamics',\n\tINPUT: 'inputs',\n\tMISC: 'misc',\n\tMODIFIER: 'modifiers',\n\tPRIMITIVES: 'primitives',\n\tRENDER: 'render',\n};\nexport const CATEGORY_POST = {\n\tPASS: 'passes',\n};\n","import lodash_trim from 'lodash/trim';\n\nimport {TypedGlNode, BaseGlNodeType} from './_Base';\n// import {BaseNodeGlMathFunctionArg1} from './_BaseMathFunctionArg1';\nimport {ConnectionPointType} from '../utils/connections/ConnectionPointType';\nimport {BaseNamedConnectionPointType} from '../utils/connections/NamedConnectionPoint';\nimport {ParamType} from '../../poly/ParamType';\nimport {ShadersCollectionController} from './code/utils/ShadersCollectionController';\nimport {GlConnectionsController} from './utils/ConnectionsController';\n\nexport const ConnectionPointTypesAvailableForAttribute = [\n\tConnectionPointType.FLOAT,\n\tConnectionPointType.VEC2,\n\tConnectionPointType.VEC3,\n\tConnectionPointType.VEC4,\n];\n\nimport {NodeParamsConfig, ParamConfig} from '../utils/params/ParamsConfig';\nclass AttributeGlParamsConfig extends NodeParamsConfig {\n\tname = ParamConfig.STRING('');\n\ttype = ParamConfig.INTEGER(0, {\n\t\tmenu: {\n\t\t\tentries: ConnectionPointTypesAvailableForAttribute.map((name, i) => {\n\t\t\t\treturn {name: name, value: i};\n\t\t\t}),\n\t\t},\n\t});\n}\nconst ParamsConfig = new AttributeGlParamsConfig();\n\nexport class AttributeGlNode extends TypedGlNode<AttributeGlParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'attribute';\n\t}\n\tstatic readonly INPUT_NAME = 'export';\n\tstatic readonly OUTPUT_NAME = 'val';\n\n\tprivate _on_create_set_name_if_none_bound = this._on_create_set_name_if_none.bind(this);\n\t// private _update_signature_if_required_bound = this._update_signature_if_required.bind(this);\n\tpublic readonly gl_connections_controller: GlConnectionsController = new GlConnectionsController(this);\n\tinitialize_node() {\n\t\tthis.add_post_dirty_hook('_set_mat_to_recompile', this._set_mat_to_recompile_if_is_exporting.bind(this));\n\t\tthis.lifecycle.add_on_create_hook(this._on_create_set_name_if_none_bound);\n\t\tthis.gl_connections_controller.initialize_node();\n\n\t\tthis.gl_connections_controller.set_expected_input_types_function(() => []);\n\t\tthis.gl_connections_controller.set_expected_output_types_function(() => [\n\t\t\tConnectionPointTypesAvailableForAttribute[this.pv.type],\n\t\t]);\n\t\t// this.params.add_on_scene_load_hook('_update_signature_if_required', this._update_signature_if_required_bound);\n\t\t// this.params.set_post_create_params_hook(this._update_signature_if_required_bound);\n\t\t// this.add_post_dirty_hook('_update_signature_if_required', this._update_signature_if_required_bound);\n\t}\n\tcreate_params() {\n\t\tif (this.material_node?.assembler_controller.allow_attribute_exports()) {\n\t\t\tthis.add_param(ParamType.BOOLEAN, 'export_when_connected', 0);\n\t\t}\n\t}\n\t// inputless_params_names(): string[] {\n\t// \treturn ['type'];\n\t// }\n\n\tget input_name() {\n\t\treturn AttributeGlNode.INPUT_NAME;\n\t}\n\tget output_name() {\n\t\treturn AttributeGlNode.OUTPUT_NAME;\n\t}\n\n\t// private create_inputs_from_params() {\n\t// \tif (this.material_node.allow_attribute_exports) {\n\t// \t\t// this.set_named_inputs([new TypedConnectionFloat(AttributeGlNode.input_name())]);\n\t// \t\tthis.io.inputs.set_named_input_connection_points([\n\t// \t\t\tnew TypedNamedConnectionPoint(INPUT_NAME, ConnectionPointTypes[this.pv.type]),\n\t// \t\t]);\n\t// \t\t// this._init_graph_node_inputs();\n\t// \t}\n\t// }\n\n\tset_lines(shaders_collection_controller: ShadersCollectionController) {\n\t\t// if (lines_controller.shader_name) {\n\t\tthis.material_node?.assembler_controller.assembler.set_node_lines_attribute(\n\t\t\tthis,\n\t\t\tshaders_collection_controller\n\t\t);\n\t\t// }\n\t}\n\n\t// update_output_type(constructor) {\n\t// \tconst named_output = new constructor(Attribute.output_name());\n\t// \tthis.set_named_outputs([named_output]);\n\t// }\n\t// update_input_type(constructor) {\n\t// \tconst named_input = new constructor(Attribute.input_name());\n\t// \tthis.set_named_inputs([named_input]);\n\t// \tthis._init_graph_node_inputs();\n\t// }\n\n\tget attribute_name(): string {\n\t\treturn lodash_trim(this.pv.name);\n\t}\n\tgl_type(): ConnectionPointType {\n\t\treturn this.io.outputs.named_output_connection_points[0].type;\n\t}\n\t//\n\t//\n\t// Utility methods for SOP/ParticlesSystemGPU and Assembler/Particles\n\t//\n\t//\n\tconnected_input_node(): BaseGlNodeType | null {\n\t\t// if (this.io.inputs.has_named_inputs) {\n\t\treturn this.io.inputs.named_input(AttributeGlNode.INPUT_NAME);\n\t\t// }\n\t}\n\tconnected_input_connection_point(): BaseNamedConnectionPointType | undefined {\n\t\treturn this.io.inputs.named_input_connection_point(AttributeGlNode.INPUT_NAME);\n\t}\n\t// connected_input(): NamedConnection {\n\t// \tconst connection_point = this.connected_input_connection_point();\n\t// \tif (connection_point) {\n\t// \t\treturn this.io.inputs.named_inputs().filter((ni) => ni.name() == Attribute.input_name())[0];\n\t// \t}\n\t// }\n\toutput_connection_point(): BaseNamedConnectionPointType | undefined {\n\t\t// if (this.io.inputs.has_named_inputs) {\n\t\treturn this.io.outputs.named_output_connection_points_by_name(this.input_name);\n\t\t// }\n\t}\n\t// connected_output(): NamedConnection {\n\t// \tconst output = this.named_output(0);\n\t// \tif (output) {\n\t// \t\treturn output; //this.named_inputs().filter(ni=>ni.name() == Attribute.input_name())[0]\n\t// \t}\n\t// }\n\tget is_importing(): boolean {\n\t\treturn this.io.outputs.used_output_names().length > 0; // TODO: typescript - ensure that we can check that the connected outputs are part of the nodes retrived by the node traverser\n\t}\n\tget is_exporting(): boolean {\n\t\tif (this.pv.export_when_connected) {\n\t\t\tconst input_node = this.io.inputs.named_input(AttributeGlNode.INPUT_NAME);\n\t\t\treturn input_node != null;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\tprivate _set_mat_to_recompile_if_is_exporting() {\n\t\tif (this.is_exporting) {\n\t\t\tthis._set_mat_to_recompile();\n\t\t}\n\t}\n\t//\n\t//\n\t// HOOKS\n\t//\n\t//\n\tprivate _on_create_set_name_if_none() {\n\t\tif (this.pv.name == '') {\n\t\t\tthis.p.name.set(this.name);\n\t\t}\n\t}\n\n\t//\n\t//\n\t// SIGNATURE\n\t//\n\t//\n\t// private _update_signature_if_required(dirty_trigger?: CoreGraphNode) {\n\t// \tif (!this.lifecycle.creation_completed || dirty_trigger == this.p.type) {\n\t// \t\tthis.update_input_and_output_types();\n\t// \t\tthis.remove_dirty_state();\n\t// \t\tthis.make_output_nodes_dirty();\n\t// \t}\n\t// \tthis.material_node?.assembler_controller.set_compilation_required_and_dirty(this);\n\t// }\n\t// private update_input_and_output_types() {\n\t// \tconst set_dirty = false;\n\t// \tthis.io.outputs.set_named_output_connection_points(\n\t// \t\t[new TypedNamedConnectionPoint(this.output_name, ConnectionPointTypesAvailableForAttribute[this.pv.type])],\n\t// \t\tset_dirty\n\t// \t);\n\t// \tif (this.material_node?.assembler_controller.allow_attribute_exports()) {\n\t// \t\tthis.io.inputs.set_named_input_connection_points([\n\t// \t\t\tnew TypedNamedConnectionPoint(this.input_name, ConnectionPointTypesAvailableForAttribute[this.pv.type]),\n\t// \t\t]);\n\t// \t}\n\t// }\n}\n","import {TypedGLDefinition, GLDefinitionType} from './GLDefinition';\n\nexport class TypedGLDefinitionCollection<T extends GLDefinitionType> {\n\t_errored: boolean = false;\n\t_error_message: string | undefined;\n\n\tconstructor(private _definitions: TypedGLDefinition<T>[] = []) {}\n\n\tget errored() {\n\t\treturn this._errored;\n\t}\n\tget error_message() {\n\t\treturn this._error_message;\n\t}\n\n\tuniq(): TypedGLDefinition<T>[] {\n\t\tconst definitions_by_name: Map<string, TypedGLDefinition<T>> = new Map();\n\t\tconst names: string[] = [];\n\n\t\tfor (let definition of this._definitions) {\n\t\t\tif (!this._errored) {\n\t\t\t\tconst name = definition.name;\n\t\t\t\tconst existing = definitions_by_name.get(name);\n\t\t\t\tif (existing) {\n\t\t\t\t\tif (existing.data_type != definition.data_type) {\n\t\t\t\t\t\tthis._errored = true;\n\t\t\t\t\t\tthis._error_message = `attempt to create ${definition.name} with types ${definition.data_type}`;\n\t\t\t\t\t\tconsole.warn('emitting error message', this._error_message);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tdefinitions_by_name.set(name, definition);\n\t\t\t\t\tnames.push(name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tconst uniq_definitions: TypedGLDefinition<T>[] = [];\n\t\tfor (let name of names) {\n\t\t\tconst definition = definitions_by_name.get(name);\n\t\t\tif (definition) {\n\t\t\t\tuniq_definitions.push(definition);\n\t\t\t}\n\t\t}\n\t\t// sorting may make dependencies be declared after the function calling them\n\t\t// const sorted_definitions = lodash_sortBy(uniq_definitions, (d)=>d.name())\n\t\treturn uniq_definitions;\n\t}\n}\n","import {VideoTexture} from 'three/src/textures/VideoTexture';\nimport {Vector4} from 'three/src/math/Vector4';\nimport {Vector3} from 'three/src/math/Vector3';\nimport {Vector2} from 'three/src/math/Vector2';\n\nimport {ParamType} from '../../../../poly/ParamType';\nimport {ParamInitValuesTypeMap} from '../../../../params/types/ParamInitValuesTypeMap';\nimport {ParamValuesTypeMap} from '../../../../params/types/ParamValuesTypeMap';\nimport {ParamConstructorByType} from '../../../../params/types/ParamConstructorByType';\n\nimport {BaseNodeType} from '../../../_Base';\nimport {TypedParam, BaseParamType} from '../../../../params/_Base';\nimport {NodeContext} from '../../../../poly/NodeContext';\nimport {TypeAssert} from '../../../../poly/Assert';\nimport {IUniform} from 'three/src/renderers/shaders/UniformsLib';\n// import { RampValue } from '../../../../params/ramp/RampValue';\nimport {RampParam} from '../../../../params/Ramp';\nimport {OperatorPathParam} from '../../../../params/OperatorPath';\n// import {ParamValueComparer} from '../../params/ParamValueComparer';\n// import {ParamValueCloner} from '../../params/ParamValueCloner';\n// import {CoreTextureLoader} from '../../../../../Core/Loader/Texture'\n\nexport class ParamConfig<T extends ParamType> {\n\tprivate _uniform: IUniform | undefined;\n\tprivate _cached_param_value: ParamValuesTypeMap[T] | undefined;\n\t// private _texture_loader: CoreTextureLoader\n\n\tconstructor(\n\t\tprivate _type: T,\n\t\tprivate _name: string,\n\t\tprivate _default_value: ParamInitValuesTypeMap[T],\n\t\tprivate _uniform_name: string\n\t) {}\n\n\tstatic from_param<K extends ParamType>(param: TypedParam<K>, uniform_name: string): ParamConfig<K> {\n\t\treturn new ParamConfig<K>(param.type, param.name, param.default_value, uniform_name);\n\t}\n\n\tget type() {\n\t\treturn this._type;\n\t}\n\tget name() {\n\t\treturn this._name;\n\t}\n\tget default_value() {\n\t\treturn this._default_value;\n\t}\n\tget uniform_name() {\n\t\treturn this._uniform_name;\n\t}\n\n\tget uniform() {\n\t\treturn (this._uniform = this._uniform || this._create_uniform());\n\t}\n\n\tprivate _create_uniform() {\n\t\treturn ParamConfig.uniform_by_type(this._type);\n\t}\n\n\tget param_options() {\n\t\tconst callback_bound = this._callback.bind(this);\n\t\tswitch (this._type) {\n\t\t\tcase ParamType.OPERATOR_PATH:\n\t\t\t\treturn {callback: callback_bound, node_selection: {context: NodeContext.COP}};\n\t\t\tdefault:\n\t\t\t\treturn {callback: callback_bound};\n\t\t}\n\t}\n\n\tprivate _callback(node: BaseNodeType, param: BaseParamType) {\n\t\tthis.uniform.value = param.value;\n\t}\n\n\t// TODO: refactor that to use the default values map?\n\tstatic uniform_by_type(type: ParamType): IUniform {\n\t\tswitch (type) {\n\t\t\tcase ParamType.BOOLEAN:\n\t\t\t\treturn {value: 0};\n\t\t\tcase ParamType.BUTTON:\n\t\t\t\treturn {value: 0};\n\t\t\tcase ParamType.COLOR:\n\t\t\t\treturn {value: new Vector3(0, 0, 0)};\n\t\t\tcase ParamType.FLOAT:\n\t\t\t\treturn {value: 0};\n\t\t\tcase ParamType.FOLDER:\n\t\t\t\treturn {value: 0};\n\t\t\tcase ParamType.INTEGER:\n\t\t\t\treturn {value: 0};\n\t\t\tcase ParamType.OPERATOR_PATH:\n\t\t\t\treturn {value: 0};\n\t\t\t// case ParamType.STRING: return {type: 't', value: null} // new Texture()}\n\t\t\tcase ParamType.RAMP:\n\t\t\t\treturn {value: null}; // new Texture()}\n\t\t\tcase ParamType.SEPARATOR:\n\t\t\t\treturn {value: 0};\n\t\t\tcase ParamType.STRING:\n\t\t\t\treturn {value: null};\n\t\t\tcase ParamType.VECTOR2:\n\t\t\t\treturn {value: new Vector2(0, 0)};\n\t\t\tcase ParamType.VECTOR3:\n\t\t\t\treturn {value: new Vector3(0, 0, 0)};\n\t\t\tcase ParamType.VECTOR4:\n\t\t\t\treturn {value: new Vector4(0, 0, 0, 0)};\n\t\t}\n\t\tTypeAssert.unreachable(type);\n\t}\n\n\tasync set_uniform_value(node: BaseNodeType) {\n\t\t// return new Promise( async (resolve, reject)=>{\n\t\tconst uniform = this.uniform;\n\t\t// the cache cannot be trusted...\n\t\tconst param = node.params.get(this._name) as TypedParam<T>;\n\t\tif (param) {\n\t\t\tawait param.compute(); //node[node.param_cache_name(this._name)]\n\t\t\tconst value = param.value;\n\n\t\t\tif ((value != null && this.has_value_changed(value)) || this.is_video_texture()) {\n\t\t\t\t// this._update_cached_value(value);\n\t\t\t\t// console.log(this._name, value)\n\n\t\t\t\tswitch (this._type) {\n\t\t\t\t\tcase ParamType.OPERATOR_PATH: {\n\t\t\t\t\t\tawait this.set_uniform_value_from_texture((<unknown>param) as OperatorPathParam, uniform);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcase ParamType.RAMP: {\n\t\t\t\t\t\tthis.set_uniform_value_from_ramp((<unknown>param) as RampParam, uniform);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\tuniform.value = param.value;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// resolve()\n\t\t\t} // else {\n\t\t\t//\tresolve()\n\t\t\t//}\n\t\t\t// })\n\t\t}\n\t}\n\n\tasync set_uniform_value_from_texture(param: OperatorPathParam, uniform: IUniform) {\n\t\t// this._texture_loader = this._texture_loader || new CoreTextureLoader(node, node.param(this.name()))\n\n\t\t// // param.graph_disconnect_predecessors()\n\t\t// const texture = await this._texture_loader.load_texture_from_url_or_op( url );\n\t\t// uniform.value = texture\n\t\tconst found_node = param.found_node();\n\t\tif (found_node) {\n\t\t\tconst container = await found_node.request_container();\n\t\t\tconst texture = container.texture();\n\t\t\tuniform.value = texture;\n\t\t} else {\n\t\t\tuniform.value = null;\n\t\t}\n\t}\n\n\tset_uniform_value_from_ramp(param: RampParam, uniform: IUniform) {\n\t\tuniform.value = param.ramp_texture();\n\t}\n\n\thas_value_changed(new_value: ParamValuesTypeMap[T]): boolean {\n\t\tconst param_constructor = ParamConstructorByType[this._type];\n\t\tif (this._cached_param_value) {\n\t\t\tconst has_changed = !param_constructor.are_values_equal(new_value, this._cached_param_value);\n\t\t\tif (has_changed) {\n\t\t\t\tthis._cached_param_value = param_constructor.clone_value(new_value);\n\t\t\t}\n\t\t\treturn has_changed;\n\t\t} else {\n\t\t\tthis._cached_param_value = param_constructor.clone_value(new_value);\n\t\t\treturn false;\n\t\t}\n\n\t\t// let has_changed = false;\n\t\t// if (this._type == ParamType.RAMP) {\n\t\t// \thas_changed = new_value.uuid() != this._cached_param_value;\n\t\t// \t// if(has_changed){ this._cached_param_value = new_value.uuid() }\n\t\t// } else {\n\t\t// \tif (this._cached_param_value != null) {\n\t\t// \t\tif (lodash_isString(new_value) || lodash_isNumber(new_value)) {\n\t\t// \t\t\t// console.log(\"new f\", new_value, this._cached_param_value)\n\t\t// \t\t\thas_changed = this._cached_param_value != new_value;\n\t\t// \t\t} else {\n\t\t// \t\t\tif (new_value != null) {\n\t\t// \t\t\t\t// console.log(\"new v\", new_value, this._cached_param_value)\n\t\t// \t\t\t\thas_changed = new_value.toArray().join('.') != this._cached_param_value.toArray().join('.');\n\t\t// \t\t\t} else {\n\t\t// \t\t\t\thas_changed = this._cached_param_value != new_value;\n\t\t// \t\t\t}\n\t\t// \t\t}\n\t\t// \t} else {\n\t\t// \t\thas_changed = true;\n\t\t// \t}\n\t\t// \t// this._cached_param_value = new_value\n\t\t// }\n\t\t// return has_changed;\n\t}\n\t// private _update_cached_value(new_value) {\n\t// \t// console.log(\"_update_cached_value\", this._name, new_value)\n\t// \tif (this._type == 'ramp') {\n\t// \t\tthis._cached_param_value = new_value.uuid();\n\t// \t} else {\n\t// \t\tif (lodash_isString(new_value) || lodash_isNumber(new_value)) {\n\t// \t\t\tthis._cached_param_value = new_value;\n\t// \t\t} else {\n\t// \t\t\t// make sure to copy the value, not assign to it\n\t// \t\t\t// otherwise we won't detect changes (since the objects would be the same)\n\t// \t\t\tthis._cached_param_value = this._cached_param_value || new_value.clone();\n\t// \t\t\tthis._cached_param_value.copy(new_value);\n\t// \t\t}\n\t// \t}\n\t// }\n\n\tis_video_texture(): boolean {\n\t\tlet result = false;\n\t\tconst uniform = this.uniform;\n\t\tif (uniform) {\n\t\t\tconst value = uniform.value;\n\t\t\tif (value) {\n\t\t\t\tresult = value.constructor == VideoTexture;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n}\n","import {ParamConfig} from '../configs/ParamConfig';\nimport {ParamType} from '../../../../poly/ParamType';\nimport {ParamInitValuesTypeMap} from '../../../../params/types/ParamInitValuesTypeMap';\n\nexport class ParamConfigsController {\n\tprivate _param_configs: ParamConfig<ParamType>[] = [];\n\n\treset() {\n\t\tthis._param_configs = [];\n\t}\n\n\tpush(param_config: ParamConfig<ParamType>) {\n\t\tthis._param_configs.push(param_config);\n\t}\n\tcreate_and_push<T extends ParamType>(\n\t\ttype: T,\n\t\tname: string,\n\t\tdefault_value: ParamInitValuesTypeMap[T],\n\t\tuniform_name: string\n\t) {\n\t\tconst param_config = new ParamConfig(type, name, default_value, uniform_name);\n\t\tthis._param_configs.push(param_config);\n\t}\n\n\tget list(): Readonly<ParamConfig<ParamType>[]> {\n\t\treturn this._param_configs;\n\t}\n}\n","import {TypedGlNode} from './_Base';\n// import {ParamType} from '../../../Engine/Param/_Module';\n// import {Connection} from './GlData';\n// import {Definition} from './Definition/_Module';\n// import {ShaderName} from './Assembler/Util/CodeBuilder';\n\n// list of globals\n// https://www.khronos.org/opengl/wiki/Built-in_Variable_(GLSL)\n// gl_PointCoord\n\nimport {NodeParamsConfig} from '../utils/params/ParamsConfig';\nimport {ShadersCollectionController} from './code/utils/ShadersCollectionController';\nclass GlobalsGlParamsConfig extends NodeParamsConfig {}\nconst ParamsConfig = new GlobalsGlParamsConfig();\n\nexport class GlobalsGlNode extends TypedGlNode<GlobalsGlParamsConfig> {\n\tparams_config = ParamsConfig;\n\tstatic type() {\n\t\treturn 'globals';\n\t}\n\n\tcreate_params() {\n\t\tthis.material_node?.assembler_controller.add_globals_params(this);\n\t}\n\n\tset_lines(shaders_collection_controller: ShadersCollectionController) {\n\t\t// if (lines_controller.shader_name) {\n\t\tthis.material_node?.assembler_controller?.assembler.set_node_lines_globals(this, shaders_collection_controller);\n\t\t// }\n\t\t// const vertex_definitions = []\n\t\t// const fragment_definitions = []\n\t\t// const definitions = []\n\t\t// // const vertex_body_lines = []\n\t\t// const fragment_body_lines = []\n\t\t// const body_lines = []\n\n\t\t// const shader_config = this.shader_config(this._shader_name)\n\t\t// const dependencies = shader_config.dependencies()\n\n\t\t// const definitions_by_shader_name = {}\n\t\t// definitions_by_shader_name[this._shader_name] = []\n\t\t// for(let dependency of dependencies){ definitions_by_shader_name[dependency] = [] }\n\n\t\t// const body_lines_by_shader_name = {}\n\t\t// body_lines_by_shader_name[this._shader_name] = []\n\t\t// for(let dependency of dependencies){ body_lines_by_shader_name[dependency] = [] }\n\n\t\t// let definition\n\t\t// let body_line\n\t\t// for(let output_name of this.used_output_names()){\n\t\t// \tconst var_name = this.gl_var_name(output_name)\n\n\t\t// \tswitch (output_name){\n\t\t// \t\tcase 'frame':\n\t\t// \t\t\tdefinition = new Definition.Uniform(this, 'float', output_name)\n\t\t// \t\t\t// vertex_definitions.push(definition)\n\t\t// \t\t\t// fragment_definitions.push(definition)\n\t\t// \t\t\tdefinitions_by_shader_name[this._shader_name].push(definition)\n\n\t\t// \t\t\tbody_line = `float ${var_name} = ${output_name}`\n\t\t// \t\t\tfor(let dependency of dependencies){\n\t\t// \t\t\t\tdefinitions_by_shader_name[dependency].push(definition)\n\t\t// \t\t\t\tbody_lines_by_shader_name[dependency].push(body_line)\n\t\t// \t\t\t}\n\n\t\t// \t\t\t// vertex_body_lines.push(`float ${var_name} = ${output_name}`)\n\t\t// \t\t\tbody_lines.push(body_line)\n\t\t// \t\t\tbreak;\n\t\t// \t\tcase 'gl_FragCoord':\n\t\t// \t\t\tif( this._shader_name == ShaderName.FRAGMENT ){\n\t\t// \t\t\t\tfragment_body_lines.push(`vec4 ${var_name} = gl_FragCoord`)\n\t\t// \t\t\t}\n\t\t// \t\t\tbreak;\n\t\t// \t\tcase 'gl_PointCoord':\n\t\t// \t\t\tif( this._shader_name == ShaderName.FRAGMENT ){\n\t\t// \t\t\t\tif(this.parent().is_point_material()){\n\t\t// \t\t\t\t\tfragment_body_lines.push(`vec2 ${var_name} = gl_PointCoord`)\n\t\t// \t\t\t\t}\n\t\t// \t\t\t}\n\t\t// \t\t\tbreak;\n\t\t// \t\tdefault:\n\t\t// \t\t\tconst named_output = this.named_output_by_name(output_name)\n\t\t// \t\t\tconst gl_type = named_output.gl_type()\n\t\t// \t\t\tdefinition = new Definition.Varying(this, gl_type, var_name)\n\t\t// \t\t\tdefinitions_by_shader_name[this._shader_name].push(definition)\n\n\t\t// \t\t\tbody_line = `${var_name} = vec3(${output_name})`\n\t\t// \t\t\tfor(let dependency of dependencies){\n\t\t// \t\t\t\tdefinitions_by_shader_name[dependency].push(definition)\n\t\t// \t\t\t\tbody_lines_by_shader_name[dependency].push(body_line)\n\t\t// \t\t\t}\n\t\t// \t\t\tif(dependencies.length == 0){\n\t\t// \t\t\t\tbody_lines.push(body_line)\n\t\t// \t\t\t}\n\t\t// \t}\n\t\t// }\n\t\t// // this.set_vertex_definitions(vertex_definitions)\n\t\t// // this.set_fragment_definitions(fragment_definitions)\n\t\t// for(let shader_name of Object.keys(definitions_by_shader_name)){\n\t\t// \tthis.set_definitions(definitions_by_shader_name[shader_name], shader_name)\n\t\t// }\n\t\t// for(let shader_name of Object.keys(body_lines_by_shader_name)){\n\t\t// \tthis.add_body_lines(body_lines_by_shader_name[shader_name], shader_name)\n\t\t// }\n\t\t// // this.add_definitions(definitions)\n\t\t// // this.set_vertex_body_lines(vertex_body_lines)\n\t\t// // this.set_fragment_body_lines(fragment_body_lines)\n\n\t\t// this.add_body_lines(body_lines)\n\t}\n}\n"],"sourceRoot":""}